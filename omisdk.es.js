var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var CallEventType = /* @__PURE__ */ ((CallEventType2) => {
  CallEventType2["CALL_INCOMING"] = "call_incoming";
  CallEventType2["CALL_OUTGOING"] = "call_outgoing";
  CallEventType2["CALL_HANGUP"] = "call_hangup";
  CallEventType2["CALL_ANSWERED"] = "call_answered";
  CallEventType2["CALL_REJECTED"] = "call_rejected";
  CallEventType2["CALL_HOLD"] = "call_hold";
  CallEventType2["CALL_UNHOLD"] = "call_unhold";
  CallEventType2["CALL_MUTE"] = "call_mute";
  CallEventType2["CALL_UNMUTE"] = "call_unmute";
  CallEventType2["CALL_TRANSFER"] = "call_transfer";
  CallEventType2["CALL_CONNECTED"] = "call_connected";
  CallEventType2["CALL_CLOSE_CONVERSATION"] = "call_close_conversation";
  CallEventType2["CALL_REFUSE_TRANSFER"] = "call_refuse_transfer";
  CallEventType2["CALL_ACCEPT_TRANSFER"] = "call_accept_transfer";
  CallEventType2["CALL_TRANSFER_FAILED"] = "call_transfer_failed";
  CallEventType2["CALL_TRANSFER_RINGING"] = "call_transfer_ringing";
  CallEventType2["CALL_TRANSFER_ANSWER"] = "call_transfer_answer";
  CallEventType2["CALL_TRANSFER_ACCEPTED"] = "call_transfer_accepted";
  CallEventType2["CALL_TERMINATED_OR_IVR_MISSED"] = "call_terminated_or_ivr_missed";
  CallEventType2["CALL_CROSS_PLATFORM"] = "call_cross_platform";
  return CallEventType2;
})(CallEventType || {});
var AppEventType$1 = /* @__PURE__ */ ((AppEventType2) => {
  AppEventType2["READY"] = "ready";
  AppEventType2["DISPLAY_CHANGED"] = "display_changed";
  AppEventType2["BUBBLE_HIDDEN"] = "bubble_hidden";
  AppEventType2["BUBBLE_SHOWN"] = "bubble_shown";
  AppEventType2["LOGGED_IN"] = "logged_in";
  AppEventType2["LOGGED_OUT"] = "logged_out";
  AppEventType2["TOKEN_EXPIRED"] = "token_expired";
  AppEventType2["ERROR"] = "error";
  AppEventType2["NETWORK_ERROR"] = "network_error";
  AppEventType2["DISCONNECTED"] = "disconnected";
  AppEventType2["CONNECTED"] = "connected";
  AppEventType2["PERMISSION_DENIED"] = "permission_denied";
  AppEventType2["DISCONNECTED_WEB_SOCKET"] = "disconnected_web_socket";
  AppEventType2["CONNECTED_WEB_SOCKET"] = "connected_web_socket";
  AppEventType2["AUTO_CONNECT"] = "auto_connect";
  AppEventType2["NOT_AUTO_CONNECT"] = "not_auto_connect";
  return AppEventType2;
})(AppEventType$1 || {});
var TransferType = /* @__PURE__ */ ((TransferType2) => {
  TransferType2["BLIND_TRANSFER"] = "BLIND_TRANSFER";
  TransferType2["ATTENDED_TRANSFER"] = "ATTENDED_TRANSFER";
  return TransferType2;
})(TransferType || {});
var PlatformType = /* @__PURE__ */ ((PlatformType2) => {
  PlatformType2["WEB"] = "WEB";
  PlatformType2["MOBILE"] = "MOBILE";
  PlatformType2["DESKTOP"] = "DESKTOP";
  PlatformType2["TABLET"] = "TABLET";
  PlatformType2["PWA"] = "PWA";
  return PlatformType2;
})(PlatformType || {});
function createElement(tag, attributes = {}, children = []) {
  const element = document.createElement(tag);
  Object.entries(attributes).forEach(([key, value2]) => {
    element.setAttribute(key, value2);
  });
  children.forEach((child) => {
    if (typeof child === "string") {
      element.appendChild(document.createTextNode(child));
    } else {
      element.appendChild(child);
    }
  });
  return element;
}
function getElementById(id) {
  return document.getElementById(id);
}
function createStyleElement(css, id) {
  const style2 = document.createElement("style");
  style2.textContent = css;
  if (id) {
    style2.id = id;
  }
  return style2;
}
function addStyleToDocument(css, id) {
  const style2 = createStyleElement(css, id);
  document.head.appendChild(style2);
  return style2;
}
function removeElement(element) {
  if (element && element.parentNode) {
    element.parentNode.removeChild(element);
  }
}
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  return LogLevel2;
})(LogLevel || {});
const DEFAULT_CONFIG = {
  enabled: false,
  level: "info",
  prefix: "[OmiSDK]"
};
let Logger$3 = class Logger {
  /**
   * Creates a new Logger instance
   * @param config Logger configuration
   */
  constructor(config = {}) {
    __publicField(this, "config");
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Updates the logger configuration
   * @param config New configuration
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * Logs a debug message
   * @param message Message to log
   * @param args Additional arguments
   */
  debug(message2, ...args) {
    this.log("debug", message2, ...args);
  }
  /**
   * Logs an info message
   * @param message Message to log
   * @param args Additional arguments
   */
  info(message2, ...args) {
    this.log("info", message2, ...args);
  }
  /**
   * Logs a warning message
   * @param message Message to log
   * @param args Additional arguments
   */
  warn(message2, ...args) {
    this.log("warn", message2, ...args);
  }
  /**
   * Logs an error message
   * @param message Message to log
   * @param args Additional arguments
   */
  error(message2, ...args) {
    this.log("error", message2, ...args);
  }
  /**
   * Internal log method
   * @param level Log level
   * @param message Message to log
   * @param args Additional arguments
   */
  log(level, message2, ...args) {
    if (!this.config.enabled) return;
    const logLevels = Object.values(LogLevel);
    const configLevelIndex = logLevels.indexOf(this.config.level);
    const messageLevelIndex = logLevels.indexOf(level);
    if (messageLevelIndex < configLevelIndex) return;
    const formattedMessage = `${this.config.prefix} ${message2}`;
    switch (level) {
      case "debug":
        console.debug(formattedMessage, ...args);
        break;
      case "info":
        console.info(formattedMessage, ...args);
        break;
      case "warn":
        console.warn(formattedMessage, ...args);
        break;
      case "error":
        console.error(formattedMessage, ...args);
        break;
    }
  }
};
const DEFAULT_THEME = {
  primaryColor: "#3498db",
  secondaryColor: "#2ecc71",
  textColor: "#333333",
  backgroundColor: "#ffffff",
  fontFamily: "Arial, sans-serif",
  borderRadius: "4px",
  customClasses: {}
};
function generateThemeCSS(theme, namespace) {
  const mergedTheme = { ...DEFAULT_THEME, ...theme };
  return `
    .${namespace} {
      --primary-color: ${mergedTheme.primaryColor};
      --secondary-color: ${mergedTheme.secondaryColor};
      --text-color: ${mergedTheme.textColor};
      --background-color: ${mergedTheme.backgroundColor};
      --font-family: ${mergedTheme.fontFamily};
      --border-radius: ${mergedTheme.borderRadius};
      
      font-family: var(--font-family);
      color: var(--text-color);
      background-color: var(--background-color);
    }
    
    .${namespace} .btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      padding: 8px 16px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    
    .${namespace} .btn:hover {
      background-color: var(--secondary-color);
    }
    
    .${namespace} .container {
      border-radius: var(--border-radius);
      border: 1px solid #e0e0e0;
      padding: 16px;
      margin: 8px 0;
    }
    
    .${namespace} .header {
      font-weight: bold;
      margin-bottom: 8px;
    }
    
    ${Object.entries(mergedTheme.customClasses || {}).map(([className, css]) => `.${namespace} .${className} { ${css} }`).join("\n")}
  `;
}
function applyTheme(theme, namespace) {
  const css = generateThemeCSS(theme, namespace);
  const styleId = `${namespace}-theme`;
  const existingStyle = document.getElementById(styleId);
  if (existingStyle) {
    existingStyle.remove();
  }
  return addStyleToDocument(css, styleId);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names2 = [], events, name2;
    if (this._eventsCount === 0) return names2;
    for (name2 in events = this._events) {
      if (has2.call(events, name2)) names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i2 = 0; i2 < length; i2++) {
        if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
const eventEmitter = new EventEmitter$1();
const client_socket = {
  on: (event, fn) => eventEmitter.on(event, fn),
  once: (event, fn) => eventEmitter.once(event, fn),
  off: (event, fn) => eventEmitter.off(event, fn),
  emit: (event, payload) => eventEmitter.emit(event, payload)
};
Object.freeze(client_socket);
class SimpleEventEmitter {
  constructor() {
    __publicField(this, "events", /* @__PURE__ */ new Map());
  }
  /**
   * Subscribe to an event
   * @param eventName Event name
   * @param callback Callback function
   */
  on(eventName, callback) {
    client_socket.on(eventName, callback);
  }
  /**
   * Unsubscribe from an event
   * @param eventName Event name
   * @param callback Callback function
   */
  off(eventName, callback) {
    if (!this.events.has(eventName)) {
      return;
    }
    const callbacks = this.events.get(eventName);
    const index = callbacks.indexOf(callback);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
    if (callbacks.length === 0) {
      this.events.delete(eventName);
    }
  }
  /**
   * Emit an event
   * @param eventName Event name
   * @param data Event data
   */
  emit(eventName, data) {
    client_socket.emit(eventName, data);
  }
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l2 = Symbol.for("react.element"), n2 = Symbol.for("react.portal"), p2 = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u2 = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z && a2[z] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C2 = Object.assign, D = {};
  function E(a2, b, e2) {
    this.props = a2;
    this.context = b;
    this.refs = D;
    this.updater = e2 || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a2, b) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b, "setState");
  };
  E.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a2, b, e2) {
    this.props = a2;
    this.context = b;
    this.refs = D;
    this.updater = e2 || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C2(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a2, b, e2) {
    var d, c2 = {}, k = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c2[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c2.children = e2;
    else if (1 < g) {
      for (var f = Array(g), m2 = 0; m2 < g; m2++) f[m2] = arguments[m2 + 2];
      c2.children = f;
    }
    if (a2 && a2.defaultProps) for (d in g = a2.defaultProps, g) void 0 === c2[d] && (c2[d] = g[d]);
    return { $$typeof: l2, type: a2, key: k, ref: h, props: c2, _owner: K.current };
  }
  function N(a2, b) {
    return { $$typeof: l2, type: a2.type, key: b, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l2;
  }
  function escape2(a2) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b[a3];
    });
  }
  var P = /\/+/g;
  function Q(a2, b) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape2("" + a2.key) : b.toString(36);
  }
  function R(a2, b, e2, d, c2) {
    var k = typeof a2;
    if ("undefined" === k || "boolean" === k) a2 = null;
    var h = false;
    if (null === a2) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l2:
          case n2:
            h = true;
        }
    }
    if (h) return h = a2, c2 = c2(h), a2 = "" === d ? "." + Q(h, 0) : d, I(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P, "$&/") + "/"), R(c2, b, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O(c2) && (c2 = N(c2, e2 + (!c2.key || h && h.key === c2.key ? "" : ("" + c2.key).replace(P, "$&/") + "/") + a2)), b.push(c2)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I(a2)) for (var g = 0; g < a2.length; g++) {
      k = a2[g];
      var f = d + Q(k, g);
      h += R(k, b, e2, f, c2);
    }
    else if (f = A(a2), "function" === typeof f) for (a2 = f.call(a2), g = 0; !(k = a2.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e2, f, c2);
    else if ("object" === k) throw b = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a2, b, e2) {
    if (null == a2) return a2;
    var d = [], c2 = 0;
    R(a2, d, "", "", function(a3) {
      return b.call(e2, a3, c2++);
    });
    return d;
  }
  function T(a2) {
    if (-1 === a2._status) {
      var b = a2._result;
      b = b();
      b.then(function(b2) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b2;
      }, function(b2) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b2;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a2, b, e2) {
    S(a2, function() {
      b.apply(this, arguments);
    }, e2);
  }, count: function(a2) {
    var b = 0;
    S(a2, function() {
      b++;
    });
    return b;
  }, toArray: function(a2) {
    return S(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!O(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p2;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a2, b, e2) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d = C2({}, a2.props), c2 = a2.key, k = a2.ref, h = a2._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c2 = "" + b.key);
      if (a2.type && a2.type.defaultProps) var g = a2.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e2;
    else if (1 < f) {
      g = Array(f);
      for (var m2 = 0; m2 < f; m2++) g[m2] = arguments[m2 + 2];
      d.children = g;
    }
    return { $$typeof: l2, type: a2.type, key: c2, ref: k, props: d, _owner: h };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t2, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a2) {
    var b = M.bind(null, a2);
    b.type = a2;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v, render: a2 };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T };
  };
  react_production_min.memo = function(a2, b) {
    return { $$typeof: x, type: a2, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a2) {
    var b = V.transition;
    V.transition = {};
    try {
      a2();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a2, b) {
    return U.current.useCallback(a2, b);
  };
  react_production_min.useContext = function(a2) {
    return U.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b) {
    return U.current.useEffect(a2, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b, e2) {
    return U.current.useImperativeHandle(a2, b, e2);
  };
  react_production_min.useInsertionEffect = function(a2, b) {
    return U.current.useInsertionEffect(a2, b);
  };
  react_production_min.useLayoutEffect = function(a2, b) {
    return U.current.useLayoutEffect(a2, b);
  };
  react_production_min.useMemo = function(a2, b) {
    return U.current.useMemo(a2, b);
  };
  react_production_min.useReducer = function(a2, b, e2) {
    return U.current.useReducer(a2, b, e2);
  };
  react_production_min.useRef = function(a2) {
    return U.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b, e2) {
    return U.current.useSyncExternalStore(a2, b, e2);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var react_development = { exports: {} };
react_development.exports;
var hasRequiredReact_development;
function requireReact_development() {
  if (hasRequiredReact_development) return react_development.exports;
  hasRequiredReact_development = 1;
  (function(module, exports) {
    var define_process_env_default2 = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    if (define_process_env_default2.NODE_ENV !== "production") {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray2(a2) {
          return isArrayImpl(a2);
        }
        function typeName(value2) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value2) {
          {
            try {
              testStringCoercion(value2);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value2) {
          return "" + value2;
        }
        function checkKeyStringCoercion(value2) {
          {
            if (willCoercionThrow(value2)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
              return testStringCoercion(value2);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement2(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR2 = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR2 + getElementKey(_child, 0) : nameSoFar;
            if (isArray2(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c2) {
                return c2;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR2 : nameSoFar + SUBSEPARATOR;
          if (isArray2(children)) {
            for (var i2 = 0; i2 < children.length; i2++) {
              child = children[i2];
              nextName = nextNamePrefix + getElementKey(child, i2);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray2(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!render.name && !render.displayName) {
                  render.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!type.name && !type.displayName) {
                  type.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState2);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value2, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value2, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value2);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype2 = Component2.prototype;
          return !!(prototype2 && prototype2.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray2(node)) {
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i2 = 0; i2 < keys.length; i2++) {
              var key = keys[i2];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray2(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement2.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i2 = 2; i2 < arguments.length; i2++) {
              validateChildKeys(arguments[i2], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i2 = 2; i2 < arguments.length; i2++) {
            validateChildKeys(arguments[i2], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task2) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task2);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue2 = ReactCurrentActQueue.current;
                if (queue2 !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue2);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue2 = ReactCurrentActQueue.current;
            if (queue2 !== null) {
              try {
                flushActQueue(queue2);
                enqueueTask(function() {
                  if (queue2.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue2) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i2 = 0;
              try {
                for (; i2 < queue2.length; i2++) {
                  var callback = queue2[i2];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue2.length = 0;
              } catch (error2) {
                queue2 = queue2.slice(i2 + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray2,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(react_development, react_development.exports);
  return react_development.exports;
}
var define_process_env_default$g = {};
if (define_process_env_default$g.NODE_ENV === "production") {
  react.exports = requireReact_production_min();
} else {
  react.exports = requireReact_development();
}
var reactExports = react.exports;
const React__default$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = reactExports, k = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q(c2, a2, g) {
    var b, d = {}, e2 = null, h = null;
    void 0 !== g && (e2 = "" + g);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h = a2.ref);
    for (b in a2) m2.call(a2, b) && !p2.hasOwnProperty(b) && (d[b] = a2[b]);
    if (c2 && c2.defaultProps) for (b in a2 = c2.defaultProps, a2) void 0 === d[b] && (d[b] = a2[b]);
    return { $$typeof: k, type: c2, key: e2, ref: h, props: d, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  var define_process_env_default2 = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  if (define_process_env_default2.NODE_ENV !== "production") {
    (function() {
      var React2 = reactExports;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
              c2--;
            }
            for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
              if (sampleLines[s2] !== controlLines[c2]) {
                if (s2 !== 1 || c2 !== 1) {
                  do {
                    s2--;
                    c2--;
                    if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype2 = Component.prototype;
        return !!(prototype2 && prototype2.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a2) {
        return isArrayImpl(a2);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value2) {
        {
          try {
            testStringCoercion(value2);
            return false;
          } catch (e2) {
            return true;
          }
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkKeyStringCoercion(value2) {
        {
          if (willCoercionThrow(value2)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty2.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty2.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray2(node)) {
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name2 = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name2, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray2(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray2(children)) {
                  for (var i2 = 0; i2 < children.length; i2++) {
                    validateChildKeys(children[i2], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty2.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
var define_process_env_default$f = {};
if (define_process_env_default$f.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f(a2, b) {
      var c2 = a2.length;
      a2.push(b);
      a: for (; 0 < c2; ) {
        var d = c2 - 1 >>> 1, e2 = a2[d];
        if (0 < g(e2, b)) a2[d] = b, a2[c2] = e2, c2 = d;
        else break a;
      }
    }
    function h(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k(a2) {
      if (0 === a2.length) return null;
      var b = a2[0], c2 = a2.pop();
      if (c2 !== b) {
        a2[0] = c2;
        a: for (var d = 0, e2 = a2.length, w = e2 >>> 1; d < w; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x = a2[n2];
          if (0 > g(C2, c2)) n2 < e2 && 0 > g(x, C2) ? (a2[d] = x, a2[n2] = c2, d = n2) : (a2[d] = C2, a2[m2] = c2, d = m2);
          else if (n2 < e2 && 0 > g(x, c2)) a2[d] = x, a2[n2] = c2, d = n2;
          else break a;
        }
      }
      return b;
    }
    function g(a2, b) {
      var c2 = a2.sortIndex - b.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a2) {
      for (var b = h(t2); null !== b; ) {
        if (null === b.callback) k(t2);
        else if (b.startTime <= a2) k(t2), b.sortIndex = b.expirationTime, f(r2, b);
        else break;
        b = h(t2);
      }
    }
    function H(a2) {
      B = false;
      G(a2);
      if (!A) if (null !== h(r2)) A = true, I(J);
      else {
        var b = h(t2);
        null !== b && K(H, b.startTime - a2);
      }
    }
    function J(a2, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c2 = y;
      try {
        G(b);
        for (v = h(r2); null !== v && (!(v.expirationTime > b) || a2 && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e2 = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e2 ? v.callback = e2 : v === h(r2) && k(r2);
            G(b);
          } else k(r2);
          v = h(r2);
        }
        if (null !== v) var w = true;
        else {
          var m2 = h(t2);
          null !== m2 && K(H, m2.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c2, z = false;
      }
    }
    var N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a2 = exports.unstable_now();
        Q = a2;
        var b = true;
        try {
          b = O(true, a2);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a2) {
      O = a2;
      N || (N = true, S());
    }
    function K(a2, b) {
      L = D(function() {
        a2(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r2);
    };
    exports.unstable_next = function(a2) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c2 = y;
      y = b;
      try {
        return a2();
      } finally {
        y = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a2, b) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y;
      y = a2;
      try {
        return b();
      } finally {
        y = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a2, b, c2) {
      var d = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d + c2 : d) : c2 = d;
      switch (a2) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a2 = { id: u2++, callback: b, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d ? (a2.sortIndex = c2, f(t2, a2), null === h(r2) && a2 === h(t2) && (B ? (E(L), L = -1) : B = true, K(H, c2 - d))) : (a2.sortIndex = e2, f(r2, a2), A || z || (A = true, I(J)));
      return a2;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a2) {
      var b = y;
      return function() {
        var c2 = y;
        y = b;
        try {
          return a2.apply(this, arguments);
        } finally {
          y = c2;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var scheduler_development = {};
var hasRequiredScheduler_development;
function requireScheduler_development() {
  if (hasRequiredScheduler_development) return scheduler_development;
  hasRequiredScheduler_development = 1;
  (function(exports) {
    var define_process_env_default2 = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    if (define_process_env_default2.NODE_ENV !== "production") {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek2(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i2) {
          var index = i2;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i2) {
          var index = i2;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a2, b) {
          var diff = a2.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a2.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task2, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek2(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek2(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek2(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek2(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            var currentTime;
            if (enableProfiling) ;
            else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek2(taskQueue);
          while (currentTask !== null && true) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek2(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek2(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek2(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout2;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout2 = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout2 = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout2 = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout2 = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout2 = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout2;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek2(taskQueue) === null && newTask === peek2(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek2(taskQueue);
        }
        function unstable_cancelCallback(task2) {
          task2.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(scheduler_development);
  return scheduler_development;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  var define_process_env_default2 = {};
  if (define_process_env_default2.NODE_ENV === "production") {
    scheduler.exports = requireScheduler_production_min();
  } else {
    scheduler.exports = requireScheduler_development();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = reactExports, ca = requireScheduler();
  function p2(a2) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b) {
    ha(a2, b);
    ha(a2 + "Capture", b);
  }
  function ha(a2, b) {
    ea[a2] = b;
    for (a2 = 0; a2 < b.length; a2++) da.add(b[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2)) return true;
    if (ja.call(la, a2)) return false;
    if (ka.test(a2)) return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b, c2, d) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b, c2, d) {
    if (null === b || "undefined" === typeof b || pa(a2, b, c2, d)) return true;
    if (d) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a2, b, c2, d, e2, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z[a2] = new v(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b = a2[0];
    z[b] = new v(b, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z[a2] = new v(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z[a2] = new v(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z[a2] = new v(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z[a2] = new v(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z[a2] = new v(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z[a2] = new v(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z[a2] = new v(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b = a2.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta(a2, b, c2, d) {
    var e2 = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e2 ? 0 !== e2.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c2, e2, d) && (c2 = null), d || null === e2 ? oa(b) && (null === c2 ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b = e2.attributeName, d = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d ? a2.setAttributeNS(d, b, c2) : a2.setAttribute(b, c2)));
  }
  var ua2 = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La) try {
      throw Error();
    } catch (c2) {
      var b = c2.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b) {
    if (!a2 || Na) return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a2, [], b);
      } else {
        try {
          b.call();
        } catch (l2) {
          d = l2;
        }
        a2.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d && "string" === typeof l2.stack) {
        for (var e2 = l2.stack.split("\n"), f = d.stack.split("\n"), g = e2.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e2[g] !== f[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e2[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e2[g] !== f[h]) {
                var k = "\n" + e2[g].replace(" at new ", " at ");
                a2.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a2.displayName));
                return k;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b.displayName || b.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b = a2.displayName || null, null !== b ? b : Qa(a2.type) || "Memo";
      case Ha:
        b = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b.render, a2 = a2.displayName || a2.name || "", b.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a2) {
    var b = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b), d = "" + a2[b];
    if (!a2.hasOwnProperty(b) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f = c2.set;
      Object.defineProperty(a2, b, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a3) {
        d = "" + a3;
        f.call(this, a3);
      } });
      Object.defineProperty(a2, b, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a3) {
        d = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b = a2._valueTracker;
    if (!b) return true;
    var c2 = b.getValue();
    var d = "";
    a2 && (d = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d;
    return a2 !== c2 ? (b.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b) {
      return a2.body;
    }
  }
  function Ya(a2, b) {
    var c2 = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b) {
    var c2 = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c2 = Sa(null != b.value ? b.value : c2);
    a2._wrapperState = { initialChecked: d, initialValue: c2, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a2, b) {
    b = b.checked;
    null != b && ta(a2, "checked", b, false);
  }
  function bb(a2, b) {
    ab(a2, b);
    var c2 = Sa(b.value), d = b.type;
    if (null != c2) if ("number" === d) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d || "reset" === d) {
      a2.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a2, b.type, c2) : b.hasOwnProperty("defaultValue") && cb(a2, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
  }
  function db(a2, b, c2) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a2._wrapperState.initialValue;
      c2 || b === a2.value || (a2.value = b);
      a2.defaultValue = b;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b, c2) {
    if ("number" !== b || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b, c2, d) {
    a2 = a2.options;
    if (b) {
      b = {};
      for (var e2 = 0; e2 < c2.length; e2++) b["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e2 = b.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b = null;
      for (e2 = 0; e2 < a2.length; e2++) {
        if (a2[e2].value === c2) {
          a2[e2].selected = true;
          d && (a2[e2].defaultSelected = true);
          return;
        }
        null !== b || a2[e2].disabled || (b = a2[e2]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a2, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p2(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b) {
    var c2 = b.value;
    if (null == c2) {
      c2 = b.children;
      b = b.defaultValue;
      if (null != c2) {
        if (null != b) throw Error(p2(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p2(93));
          c2 = c2[0];
        }
        b = c2;
      }
      null == b && (b = "");
      c2 = b;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b) {
    var c2 = Sa(b.value), d = Sa(b.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d && (a2.defaultValue = "" + d);
  }
  function jb(a2) {
    var b = a2.textContent;
    b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c2, d, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b, c2, d, e2);
      });
    } : a2;
  }(function(a2, b) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b.firstChild; ) a2.appendChild(b.firstChild);
    }
  });
  function ob(a2, b) {
    if (b) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b;
        return;
      }
    }
    a2.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b) {
      b = b + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b] = pb[a2];
    });
  });
  function rb(a2, b, c2) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c2 || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b).trim() : b + "px";
  }
  function sb(a2, b) {
    a2 = a2.style;
    for (var c2 in b) if (b.hasOwnProperty(c2)) {
      var d = 0 === c2.indexOf("--"), e2 = rb(c2, b[c2], d);
      "float" === c2 && (c2 = "cssFloat");
      d ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b) {
    if (b) {
      if (tb[a2] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p2(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p2(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p2(62));
    }
  }
  function vb(a2, b) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p2(280));
      var b = a2.stateNode;
      b && (b = Db(b), yb(a2.stateNode, a2.type, b));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b) for (a2 = 0; a2 < b.length; a2++) Bb(b[a2]);
    }
  }
  function Gb(a2, b) {
    return a2(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b, c2) {
    if (Ib) return a2(b, c2);
    Ib = true;
    try {
      return Gb(a2, b, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d = Db(c2);
    if (null === d) return null;
    c2 = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a2 = a2.type, d = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p2(231, b, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b, c2, d, e2, f, g, h, k) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b, c2, d, e2, f, g, h, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b, c2, d, e2, f, g, h, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p2(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b = a2, c2 = a2;
    if (a2.alternate) for (; b.return; ) b = b.return;
    else {
      a2 = b;
      do
        b = a2, 0 !== (b.flags & 4098) && (c2 = b.return), a2 = b.return;
      while (a2);
    }
    return 3 === b.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b = a2.memoizedState;
      null === b && (a2 = a2.alternate, null !== a2 && (b = a2.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p2(188));
  }
  function Yb(a2) {
    var b = a2.alternate;
    if (!b) {
      b = Vb(a2);
      if (null === b) throw Error(p2(188));
      return b !== a2 ? null : a2;
    }
    for (var c2 = a2, d = b; ; ) {
      var e2 = c2.return;
      if (null === e2) break;
      var f = e2.alternate;
      if (null === f) {
        d = e2.return;
        if (null !== d) {
          c2 = d;
          continue;
        }
        break;
      }
      if (e2.child === f.child) {
        for (f = e2.child; f; ) {
          if (f === c2) return Xb(e2), a2;
          if (f === d) return Xb(e2), b;
          f = f.sibling;
        }
        throw Error(p2(188));
      }
      if (c2.return !== d.return) c2 = e2, d = f;
      else {
        for (var g = false, h = e2.child; h; ) {
          if (h === c2) {
            g = true;
            c2 = e2;
            d = f;
            break;
          }
          if (h === d) {
            g = true;
            d = e2;
            c2 = f;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f.child; h; ) {
            if (h === c2) {
              g = true;
              c2 = f;
              d = e2;
              break;
            }
            if (h === d) {
              g = true;
              d = f;
              c2 = e2;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p2(189));
        }
      }
      if (c2.alternate !== d) throw Error(p2(190));
    }
    if (3 !== c2.tag) throw Error(p2(188));
    return c2.stateNode.current === c2 ? a2 : b;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b = $b(a2);
      if (null !== b) return b;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d = 0, e2 = a2.suspendedLanes, f = a2.pingedLanes, g = c2 & 268435455;
    if (0 !== g) {
      var h = g & ~e2;
      0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c2 & ~e2, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e2) && (e2 = d & -d, f = b & -b, e2 >= f || 16 === e2 && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c2 & 16);
    b = a2.entangledLanes;
    if (0 !== b) for (a2 = a2.entanglements, b &= d; 0 < b; ) c2 = 31 - oc(b), e2 = 1 << c2, d |= a2[c2], b &= ~e2;
    return d;
  }
  function vc(a2, b) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b) {
    for (var c2 = a2.suspendedLanes, d = a2.pingedLanes, e2 = a2.expirationTimes, f = a2.pendingLanes; 0 < f; ) {
      var g = 31 - oc(f), h = 1 << g, k = e2[g];
      if (-1 === k) {
        if (0 === (h & c2) || 0 !== (h & d)) e2[g] = vc(h, b);
      } else k <= b && (a2.expiredLanes |= h);
      f &= ~h;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b = [], c2 = 0; 31 > c2; c2++) b.push(a2);
    return b;
  }
  function Ac(a2, b, c2) {
    a2.pendingLanes |= b;
    536870912 !== b && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b = 31 - oc(b);
    a2[b] = c2;
  }
  function Bc(a2, b) {
    var c2 = a2.pendingLanes & ~b;
    a2.pendingLanes = b;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b;
    a2.mutableReadLanes &= b;
    a2.entangledLanes &= b;
    b = a2.entanglements;
    var d = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e2 = 31 - oc(c2), f = 1 << e2;
      b[e2] = 0;
      d[e2] = -1;
      a2[e2] = -1;
      c2 &= ~f;
    }
  }
  function Cc(a2, b) {
    var c2 = a2.entangledLanes |= b;
    for (a2 = a2.entanglements; c2; ) {
      var d = 31 - oc(c2), e2 = 1 << d;
      e2 & b | a2[d] & b && (a2[d] |= b);
      c2 &= ~e2;
    }
  }
  var C2 = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a2, b, c2, d, e2, f) {
    if (null === a2 || a2.nativeEvent !== f) return a2 = { blockedOn: b, domEventName: c2, eventSystemFlags: d, nativeEvent: f, targetContainers: [e2] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a2;
    a2.eventSystemFlags |= d;
    b = a2.targetContainers;
    null !== e2 && -1 === b.indexOf(e2) && b.push(e2);
    return a2;
  }
  function Uc(a2, b, c2, d, e2) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a2, b, c2, d, e2), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b, c2, d, e2), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b, c2, d, e2), true;
      case "pointerover":
        var f = e2.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a2, b, c2, d, e2));
        return true;
      case "gotpointercapture":
        return f = e2.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a2, b, c2, d, e2)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b = Wc(a2.target);
    if (null !== b) {
      var c2 = Vb(b);
      if (null !== c2) {
        if (b = c2.tag, 13 === b) {
          if (b = Wb(c2), null !== b) {
            a2.blockedOn = b;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b = a2.targetContainers; 0 < b.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d = new c2.constructor(c2.type, c2);
        wb = d;
        c2.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c2), null !== b && Fc(b), a2.blockedOn = c2, false;
      b.shift();
    }
    return true;
  }
  function Zc(a2, b, c2) {
    Xc(a2) && c2.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b) {
    a2.blockedOn === b && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b(b2) {
      return ad(b2, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d = Kc[c2];
        d.blockedOn === a2 && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c2 = 0; c2 < Qc.length; c2++) d = Qc[c2], d.blockedOn === a2 && (d.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua2.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b, c2, d) {
    var e2 = C2, f = cd.transition;
    cd.transition = null;
    try {
      C2 = 1, fd(a2, b, c2, d);
    } finally {
      C2 = e2, cd.transition = f;
    }
  }
  function gd(a2, b, c2, d) {
    var e2 = C2, f = cd.transition;
    cd.transition = null;
    try {
      C2 = 4, fd(a2, b, c2, d);
    } finally {
      C2 = e2, cd.transition = f;
    }
  }
  function fd(a2, b, c2, d) {
    if (dd) {
      var e2 = Yc(a2, b, c2, d);
      if (null === e2) hd(a2, b, d, id, c2), Sc(a2, d);
      else if (Uc(e2, a2, b, c2, d)) d.stopPropagation();
      else if (Sc(a2, d), b & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e2; ) {
          var f = Cb(e2);
          null !== f && Ec(f);
          f = Yc(a2, b, c2, d);
          null === f && hd(a2, b, d, id, c2);
          if (f === e2) break;
          e2 = f;
        }
        null !== e2 && d.stopPropagation();
      } else hd(a2, b, d, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b, c2, d) {
    id = null;
    a2 = xb(d);
    a2 = Wc(a2);
    if (null !== a2) if (b = Vb(a2), null === b) a2 = null;
    else if (c2 = b.tag, 13 === c2) {
      a2 = Wb(b);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a2 = null;
    } else b !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b = ld, c2 = b.length, d, e2 = "value" in kd ? kd.value : kd.textContent, f = e2.length;
    for (a2 = 0; a2 < c2 && b[a2] === e2[a2]; a2++) ;
    var g = c2 - a2;
    for (d = 1; d <= g && b[c2 - d] === e2[f - d]; d++) ;
    return md = e2.slice(a2, 1 < d ? 1 - d : void 0);
  }
  function od(a2) {
    var b = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b && (a2 = 13)) : a2 = b;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b(b2, d, e2, f, g) {
      this._reactName = b2;
      this._targetInst = e2;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b2 = a2[c2], this[c2] = b2 ? b2(f) : f[c2]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a2) : (a2 = Od[a2]) ? !!b[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a2) {
    if (a2.key) {
      var b = Md[a2.key] || a2.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a2, b) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie = false;
  function je(a2, b) {
    switch (a2) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a2 = b.data, a2 === ee && fe ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b) {
    if (ie) return "compositionend" === a2 || !ae && ge(a2, b) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b ? !!le[a2.type] : "textarea" === b ? true : false;
  }
  function ne(a2, b, c2, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c2 = new td("onChange", "change", null, c2, d), a2.push({ event: c2, listeners: b }));
  }
  var pe = null, qe = null;
  function re2(a2) {
    se(a2, 0);
  }
  function te(a2) {
    var b = ue(a2);
    if (Wa(b)) return a2;
  }
  function ve(a2, b) {
    if ("change" === a2) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a2, xb(a2));
      Jb(re2, b);
    }
  }
  function Ce(a2, b, c2) {
    "focusin" === a2 ? (Ae(), pe = b, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
  }
  function Ee(a2, b) {
    if ("click" === a2) return te(b);
  }
  function Fe(a2, b) {
    if ("input" === a2 || "change" === a2) return te(b);
  }
  function Ge(a2, b) {
    return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a2, b) {
    if (He(a2, b)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b) return false;
    var c2 = Object.keys(a2), d = Object.keys(b);
    if (c2.length !== d.length) return false;
    for (d = 0; d < c2.length; d++) {
      var e2 = c2[d];
      if (!ja.call(b, e2) || !He(a2[e2], b[e2])) return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d; c2; ) {
      if (3 === c2.nodeType) {
        d = a2 + c2.textContent.length;
        if (a2 <= b && d >= b) return { node: c2, offset: b - a2 };
        a2 = d;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b) {
    return a2 && b ? a2 === b ? true : a2 && 3 === a2.nodeType ? false : b && 3 === b.nodeType ? Le(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a2 = window, b = Xa(); b instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c2 = false;
      }
      if (c2) a2 = b.contentWindow;
      else break;
      b = Xa(a2.document);
    }
    return b;
  }
  function Ne(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b = Me(), c2 = a2.focusedElem, d = a2.selectionRange;
    if (b !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d && Ne(c2)) {
        if (b = d.start, a2 = d.end, void 0 === a2 && (a2 = b), "selectionStart" in c2) c2.selectionStart = b, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b = c2.ownerDocument || document) && b.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e2 = c2.textContent.length, f = Math.min(d.start, e2);
          d = void 0 === d.end ? f : Math.min(d.end, e2);
          !a2.extend && f > d && (e2 = d, d = f, f = e2);
          e2 = Ke(c2, f);
          var g = Ke(
            c2,
            d
          );
          e2 && g && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e2.node, e2.offset), a2.removeAllRanges(), f > d ? (a2.addRange(b), a2.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a2.addRange(b)));
        }
      }
      b = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b.length; c2++) a2 = b[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a2, b, c2) {
    var d = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c2), a2.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a2, b) {
    var c2 = {};
    c2[a2.toLowerCase()] = b.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b;
    c2["Moz" + a2] = "moz" + b;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2]) return Xe[a2];
    if (!We[a2]) return a2;
    var b = We[a2], c2;
    for (c2 in b) if (b.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b[c2];
    return a2;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b) {
    df.set(a2, b);
    fa(b, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b, c2) {
    var d = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d, b, void 0, a2);
    a2.currentTarget = null;
  }
  function se(a2, b) {
    b = 0 !== (b & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d = a2[c2], e2 = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e2.isPropagationStopped()) break a;
          nf(e2, h, l2);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e2.isPropagationStopped()) break a;
          nf(e2, h, l2);
          f = k;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D(a2, b) {
    var c2 = b[of];
    void 0 === c2 && (c2 = b[of] = /* @__PURE__ */ new Set());
    var d = a2 + "__bubble";
    c2.has(d) || (pf(b, a2, 2, false), c2.add(d));
  }
  function qf(a2, b, c2) {
    var d = 0;
    b && (d |= 4);
    pf(c2, a2, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a2), qf(b2, true, a2));
      });
      var b = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a2, b, c2, d) {
    switch (jd(b)) {
      case 1:
        var e2 = ed;
        break;
      case 4:
        e2 = gd;
        break;
      default:
        e2 = fd;
    }
    c2 = e2.bind(null, b, c2, a2);
    e2 = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e2 = true);
    d ? void 0 !== e2 ? a2.addEventListener(b, c2, { capture: true, passive: e2 }) : a2.addEventListener(b, c2, true) : void 0 !== e2 ? a2.addEventListener(b, c2, { passive: e2 }) : a2.addEventListener(b, c2, false);
  }
  function hd(a2, b, c2, d, e2) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e2 || 8 === h.nodeType && h.parentNode === e2) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e2 || 8 === k.nodeType && k.parentNode === e2) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e3 = xb(c2), g2 = [];
      a: {
        var h2 = df.get(a2);
        if (void 0 !== h2) {
          var k2 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t2 = 0 !== (b & 4), J = !t2 && "scroll" === a2, x = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
          t2 = [];
          for (var w = d2, u2; null !== w; ) {
            u2 = w;
            var F = u2.stateNode;
            5 === u2.tag && null !== F && (u2 = F, null !== x && (F = Kb(w, x), null != F && t2.push(tf(w, F, u2))));
            if (J) break;
            w = w.return;
          }
          0 < t2.length && (h2 = new k2(h2, n2, null, c2, e3), g2.push({ event: h2, listeners: t2 }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a2 || "pointerover" === a2;
          k2 = "mouseout" === a2 || "pointerout" === a2;
          if (h2 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k2 || h2) {
            h2 = e3.window === e3 ? e3 : (h2 = e3.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k2) {
              if (n2 = c2.relatedTarget || c2.toElement, k2 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J = Vb(n2), n2 !== J || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k2 = null, n2 = d2;
            if (k2 !== n2) {
              t2 = Bd;
              F = "onMouseLeave";
              x = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
              J = null == k2 ? h2 : ue(k2);
              u2 = null == n2 ? h2 : ue(n2);
              h2 = new t2(F, w + "leave", k2, c2, e3);
              h2.target = J;
              h2.relatedTarget = u2;
              F = null;
              Wc(e3) === d2 && (t2 = new t2(x, w + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J, F = t2);
              J = F;
              if (k2 && n2) b: {
                t2 = k2;
                x = n2;
                w = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w++;
                u2 = 0;
                for (F = x; F; F = vf(F)) u2++;
                for (; 0 < w - u2; ) t2 = vf(t2), w--;
                for (; 0 < u2 - w; ) x = vf(x), u2--;
                for (; w--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate) break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k2 && wf(g2, h2, k2, t2, false);
              null !== n2 && null !== J && wf(g2, J, n2, t2, true);
            }
          }
        }
        a: {
          h2 = d2 ? ue(d2) : window;
          k2 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a2, d2))) {
            ne(g2, na, c2, e3);
            break a;
          }
          xa && xa(a2, h2, d2);
          "focusout" === a2 && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c2, e3);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c2, e3);
        }
        var $a;
        if (ae) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a2, c2) : ke(a2, c2)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g2.push({ event: e3, listeners: d2 }), e3.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a2, b, c2) {
    return { instance: a2, listener: b, currentTarget: c2 };
  }
  function oe(a2, b) {
    for (var c2 = b + "Capture", d = []; null !== a2; ) {
      var e2 = a2, f = e2.stateNode;
      5 === e2.tag && null !== f && (e2 = f, f = Kb(a2, c2), null != f && d.unshift(tf(a2, f, e2)), f = Kb(a2, b), null != f && d.push(tf(a2, f, e2)));
      a2 = a2.return;
    }
    return d;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b, c2, d, e2) {
    for (var f = b._reactName, g = []; null !== c2 && c2 !== d; ) {
      var h = c2, k = h.alternate, l2 = h.stateNode;
      if (null !== k && k === d) break;
      5 === h.tag && null !== l2 && (h = l2, e2 ? (k = Kb(c2, f), null != k && g.unshift(tf(c2, k, h))) : e2 || (k = Kb(c2, f), null != k && g.push(tf(c2, k, h))));
      c2 = c2.return;
    }
    0 !== g.length && a2.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b, c2) {
    b = zf(b);
    if (zf(a2) !== b && c2) throw Error(p2(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b) {
    var c2 = b, d = 0;
    do {
      var e2 = c2.nextSibling;
      a2.removeChild(c2);
      if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
        if (0 === d) {
          a2.removeChild(e2);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d++;
      c2 = e2;
    } while (c2);
    bd(b);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b = a2.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a2.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b) return a2;
          b--;
        } else "/$" === c2 && b++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b = a2[Of];
    if (b) return b;
    for (var c2 = a2.parentNode; c2; ) {
      if (b = c2[uf] || c2[Of]) {
        c2 = b.alternate;
        if (null !== b.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of]) return c2;
          a2 = Mf(a2);
        }
        return b;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p2(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a2, b) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d = a2.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f;
    for (f in c2) e2[f] = b[f];
    d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a2, b, c2) {
    if (H.current !== Vf) throw Error(p2(168));
    G(H, b);
    G(Wf, c2);
  }
  function bg(a2, b, c2) {
    var d = a2.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c2;
    d = d.getChildContext();
    for (var e2 in d) if (!(e2 in b)) throw Error(p2(108, Ra(a2) || "Unknown", e2));
    return A({}, c2, d);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a2);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a2, b, c2) {
    var d = a2.stateNode;
    if (!d) throw Error(p2(169));
    c2 ? (a2 = bg(a2, b, Xf), d.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
    G(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b = C2;
      try {
        var c2 = eg;
        for (C2 = 1; a2 < c2.length; a2++) {
          var d = c2[a2];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e2) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
      } finally {
        C2 = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b;
  }
  function ug(a2, b, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d = rg;
    a2 = sg;
    var e2 = 32 - oc(d) - 1;
    d &= ~(1 << e2);
    c2 += 1;
    var f = 32 - oc(b) + e2;
    if (30 < f) {
      var g = e2 - e2 % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e2 -= g;
      rg = 1 << 32 - oc(b) + e2 | c2 << e2 | d;
      sg = f + a2;
    } else rg = 1 << f | c2 << e2 | d, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a2, b) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b;
    c2.return = a2;
    b = a2.deletions;
    null === b ? (a2.deletions = [c2], a2.flags |= 16) : b.push(c2);
  }
  function Cg(a2, b) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b = 1 !== b.nodeType || c2.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a2.stateNode = b, xg = a2, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a2.stateNode = b, xg = a2, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I) {
      var b = yg;
      if (b) {
        var c2 = b;
        if (!Cg(a2, b)) {
          if (Dg(a2)) throw Error(p2(418));
          b = Lf(c2.nextSibling);
          var d = xg;
          b && Cg(a2, b) ? Ag(d, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p2(418));
        a2.flags = a2.flags & -4097 | 2;
        I = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I) return Fg(a2), I = true, false;
    var b;
    (b = 3 !== a2.tag) && !(b = 5 !== a2.tag) && (b = a2.type, b = "head" !== b && "body" !== b && !Ef(a2.type, a2.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a2)) throw Hg(), Error(p2(418));
      for (; b; ) Ag(a2, b), b = Lf(b.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p2(317));
      a: {
        a2 = a2.nextSibling;
        for (b = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua2.ReactCurrentBatchConfig;
  function Lg(a2, b, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p2(309));
          var d = c2.stateNode;
        }
        if (!d) throw Error(p2(147, a2));
        var e2 = d, f = "" + a2;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a3) {
          var b2 = e2.refs;
          null === a3 ? delete b2[f] : b2[f] = a3;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a2) throw Error(p2(284));
      if (!c2._owner) throw Error(p2(290, a2));
    }
    return a2;
  }
  function Mg(a2, b) {
    a2 = Object.prototype.toString.call(b);
    throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b = a2._init;
    return b(a2._payload);
  }
  function Og(a2) {
    function b(b2, c3) {
      if (a2) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c3], b2.flags |= 16) : d2.push(c3);
      }
    }
    function c2(c3, d2) {
      if (!a2) return null;
      for (; null !== d2; ) b(c3, d2), d2 = d2.sibling;
      return null;
    }
    function d(a3, b2) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
      return a3;
    }
    function e2(a3, b2) {
      a3 = Pg(a3, b2);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f(b2, c3, d2) {
      b2.index = d2;
      if (!a2) return b2.flags |= 1048576, c3;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c3 ? (b2.flags |= 2, c3) : d2;
      b2.flags |= 2;
      return c3;
    }
    function g(b2) {
      a2 && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a3, b2, c3, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c3, a3.mode, d2), b2.return = a3, b2;
      b2 = e2(b2, c3);
      b2.return = a3;
      return b2;
    }
    function k(a3, b2, c3, d2) {
      var f2 = c3.type;
      if (f2 === ya) return m2(a3, b2, c3.props.children, d2, c3.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e2(b2, c3.props), d2.ref = Lg(a3, b2, c3), d2.return = a3, d2;
      d2 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d2);
      d2.ref = Lg(a3, b2, c3);
      d2.return = a3;
      return d2;
    }
    function l2(a3, b2, c3, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c3.containerInfo || b2.stateNode.implementation !== c3.implementation) return b2 = Sg(c3, a3.mode, d2), b2.return = a3, b2;
      b2 = e2(b2, c3.children || []);
      b2.return = a3;
      return b2;
    }
    function m2(a3, b2, c3, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c3, a3.mode, d2, f2), b2.return = a3, b2;
      b2 = e2(b2, c3);
      b2.return = a3;
      return b2;
    }
    function q(a3, b2, c3) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a3.mode, c3), b2.return = a3, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c3 = Rg(b2.type, b2.key, b2.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b2), c3.return = a3, c3;
          case wa:
            return b2 = Sg(b2, a3.mode, c3), b2.return = a3, b2;
          case Ha:
            var d2 = b2._init;
            return q(a3, d2(b2._payload), c3);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a3.mode, c3, null), b2.return = a3, b2;
        Mg(a3, b2);
      }
      return null;
    }
    function r2(a3, b2, c3, d2) {
      var e3 = null !== b2 ? b2.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h(a3, b2, "" + c3, d2);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e3 ? k(a3, b2, c3, d2) : null;
          case wa:
            return c3.key === e3 ? l2(a3, b2, c3, d2) : null;
          case Ha:
            return e3 = c3._init, r2(
              a3,
              b2,
              e3(c3._payload),
              d2
            );
        }
        if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b2, c3, d2, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y(a3, b2, c3, d2, e3) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a3 = a3.get(c3) || null, h(b2, a3, "" + d2, e3);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, k(b2, a3, d2, e3);
          case wa:
            return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, l2(b2, a3, d2, e3);
          case Ha:
            var f2 = d2._init;
            return y(a3, b2, c3, f2(d2._payload), e3);
        }
        if (eb(d2) || Ka(d2)) return a3 = a3.get(c3) || null, m2(b2, a3, d2, e3, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n2(e3, g2, h2, k2) {
      for (var l3 = null, m3 = null, u2 = g2, w = g2 = 0, x = null; null !== u2 && w < h2.length; w++) {
        u2.index > w ? (x = u2, u2 = null) : x = u2.sibling;
        var n3 = r2(e3, u2, h2[w], k2);
        if (null === n3) {
          null === u2 && (u2 = x);
          break;
        }
        a2 && u2 && null === n3.alternate && b(e3, u2);
        g2 = f(n3, g2, w);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x;
      }
      if (w === h2.length) return c2(e3, u2), I && tg(e3, w), l3;
      if (null === u2) {
        for (; w < h2.length; w++) u2 = q(e3, h2[w], k2), null !== u2 && (g2 = f(u2, g2, w), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I && tg(e3, w);
        return l3;
      }
      for (u2 = d(e3, u2); w < h2.length; w++) x = y(u2, e3, w, h2[w], k2), null !== x && (a2 && null !== x.alternate && u2.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m3 ? l3 = x : m3.sibling = x, m3 = x);
      a2 && u2.forEach(function(a3) {
        return b(e3, a3);
      });
      I && tg(e3, w);
      return l3;
    }
    function t2(e3, g2, h2, k2) {
      var l3 = Ka(h2);
      if ("function" !== typeof l3) throw Error(p2(150));
      h2 = l3.call(h2);
      if (null == h2) throw Error(p2(151));
      for (var u2 = l3 = null, m3 = g2, w = g2 = 0, x = null, n3 = h2.next(); null !== m3 && !n3.done; w++, n3 = h2.next()) {
        m3.index > w ? (x = m3, m3 = null) : x = m3.sibling;
        var t3 = r2(e3, m3, n3.value, k2);
        if (null === t3) {
          null === m3 && (m3 = x);
          break;
        }
        a2 && m3 && null === t3.alternate && b(e3, m3);
        g2 = f(t3, g2, w);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x;
      }
      if (n3.done) return c2(
        e3,
        m3
      ), I && tg(e3, w), l3;
      if (null === m3) {
        for (; !n3.done; w++, n3 = h2.next()) n3 = q(e3, n3.value, k2), null !== n3 && (g2 = f(n3, g2, w), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I && tg(e3, w);
        return l3;
      }
      for (m3 = d(e3, m3); !n3.done; w++, n3 = h2.next()) n3 = y(m3, e3, w, n3.value, k2), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w : n3.key), g2 = f(n3, g2, w), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a2 && m3.forEach(function(a3) {
        return b(e3, a3);
      });
      I && tg(e3, w);
      return l3;
    }
    function J(a3, d2, f2, h2) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l3 = d2; null !== l3; ) {
                if (l3.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d2 = e2(l3, f2.props.children);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    }
                  } else if (l3.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l3.type) {
                    c2(a3, l3.sibling);
                    d2 = e2(l3, f2.props);
                    d2.ref = Lg(a3, l3, f2);
                    d2.return = a3;
                    a3 = d2;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else b(a3, l3);
                l3 = l3.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a3.mode, h2, f2.key), d2.return = a3, a3 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a3.mode, h2), h2.ref = Lg(a3, d2, f2), h2.return = a3, a3 = h2);
            }
            return g(a3);
          case wa:
            a: {
              for (l3 = f2.key; null !== d2; ) {
                if (d2.key === l3) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c2(a3, d2.sibling);
                  d2 = e2(d2, f2.children || []);
                  d2.return = a3;
                  a3 = d2;
                  break a;
                } else {
                  c2(a3, d2);
                  break;
                }
                else b(a3, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a3.mode, h2);
              d2.return = a3;
              a3 = d2;
            }
            return g(a3);
          case Ha:
            return l3 = f2._init, J(a3, d2, l3(f2._payload), h2);
        }
        if (eb(f2)) return n2(a3, d2, f2, h2);
        if (Ka(f2)) return t2(a3, d2, f2, h2);
        Mg(a3, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c2(a3, d2.sibling), d2 = e2(d2, f2), d2.return = a3, a3 = d2) : (c2(a3, d2), d2 = Qg(f2, a3.mode, h2), d2.return = a3, a3 = d2), g(a3)) : c2(a3, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b = Wg.current;
    E(Wg);
    a2._currentValue = b;
  }
  function bh(a2, b, c2) {
    for (; null !== a2; ) {
      var d = a2.alternate;
      (a2.childLanes & b) !== b ? (a2.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function ch(a2, b) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b = a2._currentValue;
    if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p2(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg = Yg.next = a2;
    return b;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b, c2, d) {
    var e2 = b.interleaved;
    null === e2 ? (c2.next = c2, gh(b)) : (c2.next = e2.next, e2.next = c2);
    b.interleaved = c2;
    return ih(a2, d);
  }
  function ih(a2, b) {
    a2.lanes |= b;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b) {
    a2 = a2.updateQueue;
    b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b) {
    return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b, c2) {
    var d = a2.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e2 = d.pending;
      null === e2 ? b.next = b : (b.next = e2.next, e2.next = b);
      d.pending = b;
      return ih(a2, c2);
    }
    e2 = d.interleaved;
    null === e2 ? (b.next = b, gh(d)) : (b.next = e2.next, e2.next = b);
    d.interleaved = b;
    return ih(a2, c2);
  }
  function oh(a2, b, c2) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c2 & 4194240))) {
      var d = b.lanes;
      d &= a2.pendingLanes;
      c2 |= d;
      b.lanes = c2;
      Cc(a2, c2);
    }
  }
  function ph(a2, b) {
    var c2 = a2.updateQueue, d = a2.alternate;
    if (null !== d && (d = d.updateQueue, c2 === d)) {
      var e2 = null, f = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f ? e2 = f = g : f = f.next = g;
          c2 = c2.next;
        } while (null !== c2);
        null === f ? e2 = f = b : f = f.next = b;
      } else e2 = f = b;
      c2 = { baseState: d.baseState, firstBaseUpdate: e2, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b : a2.next = b;
    c2.lastBaseUpdate = b;
  }
  function qh(a2, b, c2, d) {
    var e2 = a2.updateQueue;
    jh = false;
    var f = e2.firstBaseUpdate, g = e2.lastBaseUpdate, h = e2.shared.pending;
    if (null !== h) {
      e2.shared.pending = null;
      var k = h, l2 = k.next;
      k.next = null;
      null === g ? f = l2 : g.next = l2;
      g = k;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h = m2.lastBaseUpdate, h !== g && (null === h ? m2.firstBaseUpdate = l2 : h.next = l2, m2.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e2.baseState;
      g = 0;
      m2 = l2 = k = null;
      h = f;
      do {
        var r2 = h.lane, y = h.eventTime;
        if ((d & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h;
            r2 = b;
            y = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q = n2.call(y, q, r2);
                  break a;
                }
                q = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y, q, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q = A({}, q, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h] : r2.push(h));
        } else y = { eventTime: y, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m2 ? (l2 = m2 = y, k = q) : m2 = m2.next = y, g |= r2;
        h = h.next;
        if (null === h) if (h = e2.shared.pending, null === h) break;
        else r2 = h, h = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      } while (1);
      null === m2 && (k = q);
      e2.baseState = k;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = m2;
      b = e2.shared.interleaved;
      if (null !== b) {
        e2 = b;
        do
          g |= e2.lane, e2 = e2.next;
        while (e2 !== b);
      } else null === f && (e2.shared.lanes = 0);
      rh |= g;
      a2.lanes = g;
      a2.memoizedState = q;
    }
  }
  function sh(a2, b, c2) {
    a2 = b.effects;
    b.effects = null;
    if (null !== a2) for (b = 0; b < a2.length; b++) {
      var d = a2[b], e2 = d.callback;
      if (null !== e2) {
        d.callback = null;
        d = c2;
        if ("function" !== typeof e2) throw Error(p2(191, e2));
        e2.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a2) {
    if (a2 === th) throw Error(p2(174));
    return a2;
  }
  function yh(a2, b) {
    G(wh, b);
    G(vh, a2);
    G(uh, th);
    a2 = b.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b.parentNode : b, b = a2.namespaceURI || null, a2 = a2.tagName, b = lb(b, a2);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b = xh(uh.current);
    var c2 = lb(b, a2.type);
    b !== c2 && (G(vh, a2), G(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a2) {
    for (var b = a2; null !== b; ) {
      if (13 === b.tag) {
        var c2 = b.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a2) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a2) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua2.ReactCurrentDispatcher, Gh = ua2.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p2(321));
  }
  function Mh(a2, b) {
    if (null === b) return false;
    for (var c2 = 0; c2 < b.length && c2 < a2.length; c2++) if (!He(a2[c2], b[c2])) return false;
    return true;
  }
  function Nh(a2, b, c2, d, e2, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d, e2);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p2(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d, e2);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p2(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a2 : O = O.next = a2;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a2 = M.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a2;
    else {
      if (null === a2) throw Error(p2(310));
      N = a2;
      a2 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a2 : O = O.next = a2;
    }
    return O;
  }
  function Vh(a2, b) {
    return "function" === typeof b ? b(a2) : b;
  }
  function Wh(a2) {
    var b = Uh(), c2 = b.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d = N, e2 = d.baseQueue, f = c2.pending;
    if (null !== f) {
      if (null !== e2) {
        var g = e2.next;
        e2.next = f.next;
        f.next = g;
      }
      d.baseQueue = e2 = f;
      c2.pending = null;
    }
    if (null !== e2) {
      f = e2.next;
      d = d.baseState;
      var h = g = null, k = null, l2 = f;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) null !== k && (k = k.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a2(d, l2.action);
        else {
          var q = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k ? (h = k = q, g = d) : k = k.next = q;
          M.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f);
      null === k ? g = d : k.next = h;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c2.lastRenderedState = d;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e2 = a2;
      do
        f = e2.lane, M.lanes |= f, rh |= f, e2 = e2.next;
      while (e2 !== a2);
    } else null === e2 && (c2.lanes = 0);
    return [b.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b = Uh(), c2 = b.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d = c2.dispatch, e2 = c2.pending, f = b.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g = e2 = e2.next;
      do
        f = a2(f, g.action), g = g.next;
      while (g !== e2);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c2.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a2, b) {
    var c2 = M, d = Uh(), e2 = b(), f = !He(d.memoizedState, e2);
    f && (d.memoizedState = e2, dh = true);
    d = d.queue;
    $h(ai.bind(null, c2, d, a2), [a2]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d, e2, b), void 0, null);
      if (null === Q) throw Error(p2(349));
      0 !== (Hh & 30) || di(c2, b, e2);
    }
    return e2;
  }
  function di(a2, b, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b, value: c2 };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a2]) : (c2 = b.stores, null === c2 ? b.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b, c2, d) {
    b.value = c2;
    b.getSnapshot = d;
    ei(b) && fi(a2);
  }
  function ai(a2, b, c2) {
    return c2(function() {
      ei(b) && fi(a2);
    });
  }
  function ei(a2) {
    var b = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b();
      return !He(a2, c2);
    } catch (d) {
      return true;
    }
  }
  function fi(a2) {
    var b = ih(a2, 1);
    null !== b && gi(b, a2, 1, -1);
  }
  function hi(a2) {
    var b = Th();
    "function" === typeof a2 && (a2 = a2());
    b.memoizedState = b.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M, a2);
    return [b.memoizedState, a2];
  }
  function bi(a2, b, c2, d) {
    a2 = { tag: a2, create: b, destroy: c2, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a2.next = a2) : (c2 = b.lastEffect, null === c2 ? b.lastEffect = a2.next = a2 : (d = c2.next, c2.next = a2, a2.next = d, b.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a2, b, c2, d) {
    var e2 = Th();
    M.flags |= a2;
    e2.memoizedState = bi(1 | b, c2, void 0, void 0 === d ? null : d);
  }
  function li(a2, b, c2, d) {
    var e2 = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e2.memoizedState = bi(b, c2, f, d);
        return;
      }
    }
    M.flags |= a2;
    e2.memoizedState = bi(1 | b, c2, f, d);
  }
  function mi(a2, b) {
    return ki(8390656, 8, a2, b);
  }
  function $h(a2, b) {
    return li(2048, 8, a2, b);
  }
  function ni(a2, b) {
    return li(4, 2, a2, b);
  }
  function oi(a2, b) {
    return li(4, 4, a2, b);
  }
  function pi(a2, b) {
    if ("function" === typeof b) return a2 = a2(), b(a2), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a2 = a2(), b.current = a2, function() {
      b.current = null;
    };
  }
  function qi(a2, b, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi.bind(null, b, a2), c2);
  }
  function ri() {
  }
  function si(a2, b) {
    var c2 = Uh();
    b = void 0 === b ? null : b;
    var d = c2.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c2.memoizedState = [a2, b];
    return a2;
  }
  function ti(a2, b) {
    var c2 = Uh();
    b = void 0 === b ? null : b;
    var d = c2.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a2 = a2();
    c2.memoizedState = [a2, b];
    return a2;
  }
  function ui(a2, b, c2) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He(c2, b) || (c2 = yc(), M.lanes |= c2, rh |= c2, a2.baseState = true);
    return b;
  }
  function vi2(a2, b) {
    var c2 = C2;
    C2 = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b();
    } finally {
      C2 = c2, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a2, b, c2) {
    var d = yi(a2);
    c2 = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b, c2);
    else if (c2 = hh(a2, b, c2, d), null !== c2) {
      var e2 = R();
      gi(c2, a2, d, e2);
      Bi(c2, b, d);
    }
  }
  function ii(a2, b, c2) {
    var d = yi(a2), e2 = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b, e2);
    else {
      var f = a2.alternate;
      if (0 === a2.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h = f(g, c2);
        e2.hasEagerState = true;
        e2.eagerState = h;
        if (He(h, g)) {
          var k = b.interleaved;
          null === k ? (e2.next = e2, gh(b)) : (e2.next = k.next, k.next = e2);
          b.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c2 = hh(a2, b, e2, d);
      null !== c2 && (e2 = R(), gi(c2, a2, d, e2), Bi(c2, b, d));
    }
  }
  function zi(a2) {
    var b = a2.alternate;
    return a2 === M || null !== b && b === M;
  }
  function Ai(a2, b) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b.next = b : (b.next = c2.next, c2.next = b);
    a2.pending = b;
  }
  function Bi(a2, b, c2) {
    if (0 !== (c2 & 4194240)) {
      var d = b.lanes;
      d &= a2.pendingLanes;
      c2 |= d;
      b.lanes = c2;
      Cc(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b) {
    Th().memoizedState = [a2, void 0 === b ? null : b];
    return a2;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b) {
    return ki(4194308, 4, a2, b);
  }, useInsertionEffect: function(a2, b) {
    return ki(4, 2, a2, b);
  }, useMemo: function(a2, b) {
    var c2 = Th();
    b = void 0 === b ? null : b;
    a2 = a2();
    c2.memoizedState = [a2, b];
    return a2;
  }, useReducer: function(a2, b, c2) {
    var d = Th();
    b = void 0 !== c2 ? c2(b) : b;
    d.memoizedState = d.baseState = b;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b };
    d.queue = a2;
    a2 = a2.dispatch = xi.bind(null, M, a2);
    return [d.memoizedState, a2];
  }, useRef: function(a2) {
    var b = Th();
    a2 = { current: a2 };
    return b.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b = a2[0];
    a2 = vi2.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b, c2) {
    var d = M, e2 = Th();
    if (I) {
      if (void 0 === c2) throw Error(p2(407));
      c2 = c2();
    } else {
      c2 = b();
      if (null === Q) throw Error(p2(349));
      0 !== (Hh & 30) || di(d, b, c2);
    }
    e2.memoizedState = c2;
    var f = { value: c2, getSnapshot: b };
    e2.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a2
    ), [a2]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c2, b), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b = Q.identifierPrefix;
    if (I) {
      var c2 = sg;
      var d = rg;
      c2 = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c2;
      b = ":" + b + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b += "H" + c2.toString(32));
      b += ":";
    } else c2 = Lh++, b = ":" + b + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b = Uh();
      return ui(b, N.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b = Uh().memoizedState;
      return [a2, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b = Uh();
    return null === N ? b.memoizedState = a2 : ui(b, N.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b = Uh().memoizedState;
    return [a2, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a2, b) {
    if (a2 && a2.defaultProps) {
      b = A({}, b);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b[c2] && (b[c2] = a2[c2]);
      return b;
    }
    return b;
  }
  function Di(a2, b, c2, d) {
    b = a2.memoizedState;
    c2 = c2(d, b);
    c2 = null === c2 || void 0 === c2 ? b : A({}, b, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b, c2) {
    a2 = a2._reactInternals;
    var d = R(), e2 = yi(a2), f = mh(d, e2);
    f.payload = b;
    void 0 !== c2 && null !== c2 && (f.callback = c2);
    b = nh(a2, f, e2);
    null !== b && (gi(b, a2, e2, d), oh(b, a2, e2));
  }, enqueueReplaceState: function(a2, b, c2) {
    a2 = a2._reactInternals;
    var d = R(), e2 = yi(a2), f = mh(d, e2);
    f.tag = 1;
    f.payload = b;
    void 0 !== c2 && null !== c2 && (f.callback = c2);
    b = nh(a2, f, e2);
    null !== b && (gi(b, a2, e2, d), oh(b, a2, e2));
  }, enqueueForceUpdate: function(a2, b) {
    a2 = a2._reactInternals;
    var c2 = R(), d = yi(a2), e2 = mh(c2, d);
    e2.tag = 2;
    void 0 !== b && null !== b && (e2.callback = b);
    b = nh(a2, e2, d);
    null !== b && (gi(b, a2, d, c2), oh(b, a2, d));
  } };
  function Fi(a2, b, c2, d, e2, f, g) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c2, d) || !Ie(e2, f) : true;
  }
  function Gi(a2, b, c2) {
    var d = false, e2 = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e2 = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a2, e2) : Vf);
    b = new b(c2, f);
    a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a2.stateNode = b;
    b._reactInternals = a2;
    d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a2, b, c2, d) {
    a2 = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c2, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c2, d);
    b.state !== a2 && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a2, b, c2, d) {
    var e2 = a2.stateNode;
    e2.props = c2;
    e2.state = a2.memoizedState;
    e2.refs = {};
    kh(a2);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e2.context = eh(f) : (f = Zf(b) ? Xf : H.current, e2.context = Yf(a2, f));
    e2.state = a2.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a2, b, f, c2), e2.state = a2.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d), e2.state = a2.memoizedState);
    "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b) {
    try {
      var c2 = "", d = b;
      do
        c2 += Pa(d), d = d.return;
      while (d);
      var e2 = c2;
    } catch (f) {
      e2 = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a2, source: b, stack: e2, digest: null };
  }
  function Ki(a2, b, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b ? b : null };
  }
  function Li(a2, b) {
    try {
      console.error(b.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a2, b, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d = b.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a2, b);
    };
    return c2;
  }
  function Qi(a2, b, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d = a2.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e2 = b.value;
      c2.payload = function() {
        return d(e2);
      };
      c2.callback = function() {
        Li(a2, b);
      };
    }
    var f = a2.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c2.callback = function() {
      Li(a2, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b, c2) {
    var d = a2.pingCache;
    if (null === d) {
      d = a2.pingCache = new Mi();
      var e2 = /* @__PURE__ */ new Set();
      d.set(b, e2);
    } else e2 = d.get(b), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d.set(b, e2));
    e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b, c2), b.then(a2, a2));
  }
  function Ui(a2) {
    do {
      var b;
      if (b = 13 === a2.tag) b = a2.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b, c2, d, e2) {
    if (0 === (a2.mode & 1)) return a2 === b ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c2, b, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e2;
    return a2;
  }
  var Wi = ua2.ReactCurrentOwner, dh = false;
  function Xi(a2, b, c2, d) {
    b.child = null === a2 ? Vg(b, null, c2, d) : Ug(b, a2.child, c2, d);
  }
  function Yi(a2, b, c2, d, e2) {
    c2 = c2.render;
    var f = b.ref;
    ch(b, e2);
    d = Nh(a2, b, c2, d, f, e2);
    c2 = Sh();
    if (null !== a2 && !dh) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b, e2);
    I && c2 && vg(b);
    b.flags |= 1;
    Xi(a2, b, d, e2);
    return b.child;
  }
  function $i(a2, b, c2, d, e2) {
    if (null === a2) {
      var f = c2.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b.tag = 15, b.type = f, bj(a2, b, f, d, e2);
      a2 = Rg(c2.type, null, d, b, b.mode, e2);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    f = a2.child;
    if (0 === (a2.lanes & e2)) {
      var g = f.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g, d) && a2.ref === b.ref) return Zi(a2, b, e2);
    }
    b.flags |= 1;
    a2 = Pg(f, d);
    a2.ref = b.ref;
    a2.return = b;
    return b.child = a2;
  }
  function bj(a2, b, c2, d, e2) {
    if (null !== a2) {
      var f = a2.memoizedProps;
      if (Ie(f, d) && a2.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
      else return b.lanes = a2.lanes, Zi(a2, b, e2);
    }
    return cj(a2, b, c2, d, e2);
  }
  function dj(a2, b, c2) {
    var d = b.pendingProps, e2 = d.children, f = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f ? f.baseLanes | c2 : c2, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a2, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c2;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c2, b.memoizedState = null) : d = c2, G(ej, fj), fj |= d;
    Xi(a2, b, e2, c2);
    return b.child;
  }
  function gj(a2, b) {
    var c2 = b.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a2, b, c2, d, e2) {
    var f = Zf(c2) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e2);
    c2 = Nh(a2, b, c2, d, f, e2);
    d = Sh();
    if (null !== a2 && !dh) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b, e2);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a2, b, c2, e2);
    return b.child;
  }
  function hj(a2, b, c2, d, e2) {
    if (Zf(c2)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e2);
    if (null === b.stateNode) ij(a2, b), Gi(b, c2, d), Ii(b, c2, d, e2), d = true;
    else if (null === a2) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b, l2));
      var m2 = c2.getDerivedStateFromProps, q = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l2) && Hi(b, g, d, l2);
      jh = false;
      var r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e2);
      k = b.memoizedState;
      h !== d || r2 !== k || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c2, m2, d), k = b.memoizedState), (h = jh || Fi(b, c2, h, d, r2, k, l2)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l2, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a2, b);
      h = b.memoizedProps;
      l2 = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l2;
      q = b.pendingProps;
      r2 = g.context;
      k = c2.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c2) ? Xf : H.current, k = Yf(b, k));
      var y = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r2 !== k) && Hi(b, g, d, k);
      jh = false;
      r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e2);
      var n2 = b.memoizedState;
      h !== q || r2 !== n2 || Wf.current || jh ? ("function" === typeof y && (Di(b, c2, y, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c2, l2, d, r2, n2, k) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k, d = l2) : ("function" !== typeof g.componentDidUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a2, b, c2, d, f, e2);
  }
  function jj(a2, b, c2, d, e2, f) {
    gj(a2, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e2 && dg(b, c2, false), Zi(a2, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c2.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a2 && g ? (b.child = Ug(b, a2.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a2, b, h, f);
    b.memoizedState = d.state;
    e2 && dg(b, c2, true);
    return b.child;
  }
  function kj(a2) {
    var b = a2.stateNode;
    b.pendingContext ? ag(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a2, b.context, false);
    yh(a2, b.containerInfo);
  }
  function lj(a2, b, c2, d, e2) {
    Ig();
    Jg(e2);
    b.flags |= 256;
    Xi(a2, b, c2, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b, c2) {
    var d = b.pendingProps, e2 = L.current, f = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
    if (h) f = true, b.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
    G(L, e2 & 1);
    if (null === a2) {
      Eg(b);
      a2 = b.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a2.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a2 = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a2 = Tg(a2, d, c2, null), f.return = b, a2.return = b, f.sibling = a2, b.child = f, b.child.memoizedState = nj(c2), b.memoizedState = mj, a2) : qj(b, g);
    }
    e2 = a2.memoizedState;
    if (null !== e2 && (h = e2.dehydrated, null !== h)) return rj(a2, b, g, d, h, e2, c2);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e2 = a2.child;
      h = e2.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e2 ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e2, k), d.subtreeFlags = e2.subtreeFlags & 14680064);
      null !== h ? f = Pg(h, f) : (f = Tg(f, g, c2, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a2.child.memoizedState;
      g = null === g ? nj(c2) : { baseLanes: g.baseLanes | c2, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a2.childLanes & ~c2;
      b.memoizedState = mj;
      return d;
    }
    f = a2.child;
    a2 = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c2);
    d.return = b;
    d.sibling = null;
    null !== a2 && (c2 = b.deletions, null === c2 ? (b.deletions = [a2], b.flags |= 16) : c2.push(a2));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a2, b) {
    b = pj({ mode: "visible", children: b }, a2.mode, 0, null);
    b.return = a2;
    return a2.child = b;
  }
  function sj(a2, b, c2, d) {
    null !== d && Jg(d);
    Ug(b, a2.child, null, c2);
    a2 = qj(b, b.pendingProps.children);
    a2.flags |= 2;
    b.memoizedState = null;
    return a2;
  }
  function rj(a2, b, c2, d, e2, f, g) {
    if (c2) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p2(422))), sj(a2, b, g, d);
      if (null !== b.memoizedState) return b.child = a2.child, b.flags |= 128, null;
      f = d.fallback;
      e2 = b.mode;
      d = pj({ mode: "visible", children: d.children }, e2, 0, null);
      f = Tg(f, e2, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a2.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a2, b, g, null);
    if ("$!" === e2.data) {
      d = e2.nextSibling && e2.nextSibling.dataset;
      if (d) var h = d.dgst;
      d = h;
      f = Error(p2(419));
      d = Ki(f, d, void 0);
      return sj(a2, b, g, d);
    }
    h = 0 !== (g & a2.childLanes);
    if (dh || h) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e2 = 2;
            break;
          case 16:
            e2 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e2 = 32;
            break;
          case 536870912:
            e2 = 268435456;
            break;
          default:
            e2 = 0;
        }
        e2 = 0 !== (e2 & (d.suspendedLanes | g)) ? 0 : e2;
        0 !== e2 && e2 !== f.retryLane && (f.retryLane = e2, ih(a2, e2), gi(d, a2, e2, -1));
      }
      tj();
      d = Ki(Error(p2(421)));
      return sj(a2, b, g, d);
    }
    if ("$?" === e2.data) return b.flags |= 128, b.child = a2.child, b = uj.bind(null, a2), e2._reactRetry = b, null;
    a2 = f.treeContext;
    yg = Lf(e2.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a2, b, c2) {
    a2.lanes |= b;
    var d = a2.alternate;
    null !== d && (d.lanes |= b);
    bh(a2.return, b, c2);
  }
  function wj(a2, b, c2, d, e2) {
    var f = a2.memoizedState;
    null === f ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c2, tailMode: e2 } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c2, f.tailMode = e2);
  }
  function xj(a2, b, c2) {
    var d = b.pendingProps, e2 = d.revealOrder, f = d.tail;
    Xi(a2, b, d.children, c2);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b);
        else if (19 === a2.tag) vj(a2, c2, b);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e2) {
      case "forwards":
        c2 = b.child;
        for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b.child, b.child = null) : (e2 = c2.sibling, c2.sibling = null);
        wj(b, false, e2, c2, f);
        break;
      case "backwards":
        c2 = null;
        e2 = b.child;
        for (b.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        wj(b, true, c2, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a2, b) {
    0 === (b.mode & 1) && null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a2, b, c2) {
    null !== a2 && (b.dependencies = a2.dependencies);
    rh |= b.lanes;
    if (0 === (c2 & b.childLanes)) return null;
    if (null !== a2 && b.child !== a2.child) throw Error(p2(153));
    if (null !== b.child) {
      a2 = b.child;
      c2 = Pg(a2, a2.pendingProps);
      b.child = c2;
      for (c2.return = b; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b;
      c2.sibling = null;
    }
    return b.child;
  }
  function yj(a2, b, c2) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e2 = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e2;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c2 & b.child.childLanes)) return oj(a2, b, c2);
          G(L, L.current & 1);
          a2 = Zi(a2, b, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c2 & b.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d) return xj(a2, b, c2);
          b.flags |= 128;
        }
        e2 = b.memoizedState;
        null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a2, b, c2);
    }
    return Zi(a2, b, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b) {
    for (var c2 = b.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b, c2, d) {
    var e2 = a2.memoizedProps;
    if (e2 !== d) {
      a2 = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c2) {
        case "input":
          e2 = Ya(a2, e2);
          d = Ya(a2, d);
          f = [];
          break;
        case "select":
          e2 = A({}, e2, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e2 = gb(a2, e2);
          d = gb(a2, d);
          f = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d.onClick && (a2.onclick = Bf);
      }
      ub(c2, d);
      var g;
      c2 = null;
      for (l2 in e2) if (!d.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
        var h = e2[l2];
        for (g in h) h.hasOwnProperty(g) && (c2 || (c2 = {}), c2[g] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f || (f = []) : (f = f || []).push(l2, null));
      for (l2 in d) {
        var k = d[l2];
        h = null != e2 ? e2[l2] : void 0;
        if (d.hasOwnProperty(l2) && k !== h && (null != k || null != h)) if ("style" === l2) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c2 || (c2 = {}), c2[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c2 || (c2 = {}), c2[g] = k[g]);
        } else c2 || (f || (f = []), f.push(
          l2,
          c2
        )), c2 = k;
        else "dangerouslySetInnerHTML" === l2 ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l2, k)) : "children" === l2 ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l2, "" + k) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k && "onScroll" === l2 && D("scroll", a2), f || h === k || (f = [])) : (f = f || []).push(l2, k));
      }
      c2 && (f = f || []).push("style", c2);
      var l2 = f;
      if (b.updateQueue = l2) b.flags |= 4;
    }
  };
  Cj = function(a2, b, c2, d) {
    c2 !== d && (b.flags |= 4);
  };
  function Dj(a2, b) {
    if (!I) switch (a2.tailMode) {
      case "hidden":
        b = a2.tail;
        for (var c2 = null; null !== b; ) null !== b.alternate && (c2 = b), b = b.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d = null; null !== c2; ) null !== c2.alternate && (d = c2), c2 = c2.sibling;
        null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a2) {
    var b = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d = 0;
    if (b) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags & 14680064, d |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
    else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags, d |= e2.flags, e2.return = a2, e2 = e2.sibling;
    a2.subtreeFlags |= d;
    a2.childLanes = c2;
    return b;
  }
  function Ej(a2, b, c2) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b) ? b.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e2 = xh(wh.current);
        c2 = b.type;
        if (null !== a2 && null != b.stateNode) Bj(a2, b, c2, d, e2), a2.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p2(166));
            S(b);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c2 = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a2 = 0 !== (b.mode & 1);
            switch (c2) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c2, f);
            e2 = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a2), e2 = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h,
                a2
              ), e2 = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
            switch (c2) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e2;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d.is ? a2 = g.createElement(c2, { is: d.is }) : (a2 = g.createElement(c2), "select" === c2 && (g = a2, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a2 = g.createElementNS(a2, c2);
            a2[Of] = b;
            a2[Pf] = d;
            zj(a2, b, false, false);
            b.stateNode = a2;
            a: {
              g = vb(c2, d);
              switch (c2) {
                case "dialog":
                  D("cancel", a2);
                  D("close", a2);
                  e2 = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a2);
                  e2 = d;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a2);
                  e2 = d;
                  break;
                case "source":
                  D("error", a2);
                  e2 = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a2
                  );
                  D("load", a2);
                  e2 = d;
                  break;
                case "details":
                  D("toggle", a2);
                  e2 = d;
                  break;
                case "input":
                  Za(a2, d);
                  e2 = Ya(a2, d);
                  D("invalid", a2);
                  break;
                case "option":
                  e2 = d;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d.multiple };
                  e2 = A({}, d, { value: void 0 });
                  D("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d);
                  e2 = gb(a2, d);
                  D("invalid", a2);
                  break;
                default:
                  e2 = d;
              }
              ub(c2, e2);
              h = e2;
              for (f in h) if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a2, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a2, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c2 || "" !== k) && ob(a2, k) : "number" === typeof k && ob(a2, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a2) : null != k && ta(a2, f, k, g));
              }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d.value && a2.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a2.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a2, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a2,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e2.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a2 && null != b.stateNode) Cj(a2, b, a2.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p2(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c2 = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a2) {
              if (!f) throw Error(p2(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p2(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c2, b;
        d = null !== d;
        d !== (null !== a2 && null !== a2.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a2, b), null === a2 && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b.child; null !== a2; ) {
            g = Ch(a2);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c2;
              for (c2 = b.child; null !== c2; ) f = c2, a2 = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a2, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a2 = g.dependencies, f.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a2 = a2.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a2 = Ch(g), null !== a2) {
            if (b.flags |= 128, d = true, c2 = a2.updateQueue, null !== c2 && (b.updateQueue = c2, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c2 && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c2 = f.last, null !== c2 ? c2.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c2 = L.current, G(L, d ? c2 & 1 | 2 : c2 & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a2 && null !== a2.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p2(156, b.tag));
  }
  function Ij(a2, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a2 = b.flags, a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a2 = b.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b.flags = a2 & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a2 = b.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b.alternate) throw Error(p2(340));
          Ig();
        }
        a2 = b.flags;
        return a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a2, b) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d) {
      W(a2, b, d);
    }
    else c2.current = null;
  }
  function Mj(a2, b, c2) {
    try {
      c2();
    } catch (d) {
      W(a2, b, d);
    }
  }
  var Nj = false;
  function Oj(a2, b) {
    Cf = dd;
    a2 = Me();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d = c2.getSelection && c2.getSelection();
        if (d && 0 !== d.rangeCount) {
          c2 = d.anchorNode;
          var e2 = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c2.nodeType, f.nodeType;
          } catch (F) {
            c2 = null;
            break a;
          }
          var g = 0, h = -1, k = -1, l2 = 0, m2 = 0, q = a2, r2 = null;
          b: for (; ; ) {
            for (var y; ; ) {
              q !== c2 || 0 !== e2 && 3 !== q.nodeType || (h = g + e2);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y = q.firstChild)) break;
              r2 = q;
              q = y;
            }
            for (; ; ) {
              if (q === a2) break b;
              r2 === c2 && ++l2 === e2 && (h = g);
              r2 === f && ++m2 === d && (k = g);
              if (null !== (y = q.nextSibling)) break;
              q = r2;
              r2 = q.parentNode;
            }
            q = y;
          }
          c2 = -1 === h || -1 === k ? null : { start: h, end: k };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a2 = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a2) a2.return = b, V = a2;
    else for (; null !== V; ) {
      b = V;
      try {
        var n2 = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J = n2.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u2 = b.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p2(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a2 = b.sibling;
      if (null !== a2) {
        a2.return = b.return;
        V = a2;
        break;
      }
      V = b.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a2, b, c2) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e2 = d = d.next;
      do {
        if ((e2.tag & a2) === a2) {
          var f = e2.destroy;
          e2.destroy = void 0;
          void 0 !== f && Mj(b, c2, f);
        }
        e2 = e2.next;
      } while (e2 !== d);
    }
  }
  function Qj(a2, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c2 = b = b.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d = c2.create;
          c2.destroy = d();
        }
        c2 = c2.next;
      } while (c2 !== b);
    }
  }
  function Rj(a2) {
    var b = a2.ref;
    if (null !== b) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b ? b(a2) : b.current = a2;
    }
  }
  function Sj(a2) {
    var b = a2.alternate;
    null !== b && (a2.alternate = null, Sj(b));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b = a2.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b, c2) {
    var d = a2.tag;
    if (5 === d || 6 === d) a2 = a2.stateNode, b ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b) : c2.insertBefore(a2, b) : (8 === c2.nodeType ? (b = c2.parentNode, b.insertBefore(a2, c2)) : (b = c2, b.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a2 = a2.child, null !== a2)) for (Vj(a2, b, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b, c2), a2 = a2.sibling;
  }
  function Wj(a2, b, c2) {
    var d = a2.tag;
    if (5 === d || 6 === d) a2 = a2.stateNode, b ? c2.insertBefore(a2, b) : c2.appendChild(a2);
    else if (4 !== d && (a2 = a2.child, null !== a2)) for (Wj(a2, b, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b, c2), a2 = a2.sibling;
  }
  var X = null, Xj = false;
  function Yj(a2, b, c2) {
    for (c2 = c2.child; null !== c2; ) Zj(a2, b, c2), c2 = c2.sibling;
  }
  function Zj(a2, b, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h) {
    }
    switch (c2.tag) {
      case 5:
        U || Lj(c2, b);
      case 6:
        var d = X, e2 = Xj;
        X = null;
        Yj(a2, b, c2);
        X = d;
        Xj = e2;
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
        break;
      case 4:
        d = X;
        e2 = Xj;
        X = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b, c2);
        X = d;
        Xj = e2;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c2.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e2 = d = d.next;
          do {
            var f = e2, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c2, b, g) : 0 !== (f & 4) && Mj(c2, b, g));
            e2 = e2.next;
          } while (e2 !== d);
        }
        Yj(a2, b, c2);
        break;
      case 1:
        if (!U && (Lj(c2, b), d = c2.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c2.memoizedProps, d.state = c2.memoizedState, d.componentWillUnmount();
        } catch (h) {
          W(c2, b, h);
        }
        Yj(a2, b, c2);
        break;
      case 21:
        Yj(a2, b, c2);
        break;
      case 22:
        c2.mode & 1 ? (U = (d = U) || null !== c2.memoizedState, Yj(a2, b, c2), U = d) : Yj(a2, b, c2);
        break;
      default:
        Yj(a2, b, c2);
    }
  }
  function ak(a2) {
    var b = a2.updateQueue;
    if (null !== b) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a2, b2);
        c2.has(b2) || (c2.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a2, b) {
    var c2 = b.deletions;
    if (null !== c2) for (var d = 0; d < c2.length; d++) {
      var e2 = c2[d];
      try {
        var f = a2, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X) throw Error(p2(160));
        Zj(f, g, e2);
        X = null;
        Xj = false;
        var k = e2.alternate;
        null !== k && (k.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b, l2);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a2), b = b.sibling;
  }
  function dk(a2, b) {
    var c2 = a2.alternate, d = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a2);
        ek(a2);
        if (d & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b, a2);
        ek(a2);
        d & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b, a2);
        ek(a2);
        d & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e2 = a2.stateNode;
          try {
            ob(e2, "");
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        if (d & 4 && (e2 = a2.stateNode, null != e2)) {
          var f = a2.memoizedProps, g = null !== c2 ? c2.memoizedProps : f, h = a2.type, k = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k) try {
            "input" === h && "radio" === f.type && null != f.name && ab(e2, f);
            vb(h, g);
            var l2 = vb(h, f);
            for (g = 0; g < k.length; g += 2) {
              var m2 = k[g], q = k[g + 1];
              "style" === m2 ? sb(e2, q) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q) : "children" === m2 ? ob(e2, q) : ta(e2, m2, q, l2);
            }
            switch (h) {
              case "input":
                bb(e2, f);
                break;
              case "textarea":
                ib(e2, f);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f.multiple;
                var y = f.value;
                null != y ? fb(e2, !!f.multiple, y, false) : r2 !== !!f.multiple && (null != f.defaultValue ? fb(
                  e2,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e2, !!f.multiple, f.multiple ? [] : "", false));
            }
            e2[Pf] = f;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        ck(b, a2);
        ek(a2);
        if (d & 4) {
          if (null === a2.stateNode) throw Error(p2(162));
          e2 = a2.stateNode;
          f = a2.memoizedProps;
          try {
            e2.nodeValue = f;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b, a2);
        ek(a2);
        if (d & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        break;
      case 4:
        ck(b, a2);
        ek(a2);
        break;
      case 13:
        ck(b, a2);
        ek(a2);
        e2 = a2.child;
        e2.flags & 8192 && (f = null !== e2.memoizedState, e2.stateNode.isHidden = f, !f || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a2);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U = (l2 = U) || m2, ck(b, a2), U = l2) : ck(b, a2);
        ek(a2);
        if (d & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q = V = m2; null !== V; ) {
              r2 = V;
              y = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d = r2;
                    c2 = r2.return;
                    try {
                      b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y ? (y.return = r2, V = y) : gk(q);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q = a2; ; ) {
            if (5 === q.tag) {
              if (null === m2) {
                m2 = q;
                try {
                  e2 = q.stateNode, l2 ? (f = e2.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q.tag) {
              if (null === m2) try {
                q.stateNode.nodeValue = l2 ? "" : q.memoizedProps;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a2) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a2) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a2) break a;
              m2 === q && (m2 = null);
              q = q.return;
            }
            m2 === q && (m2 = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a2);
        ek(a2);
        d & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b = a2.flags;
    if (b & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p2(160));
        }
        switch (d.tag) {
          case 5:
            var e2 = d.stateNode;
            d.flags & 32 && (ob(e2, ""), d.flags &= -33);
            var f = Uj(a2);
            Wj(a2, f, e2);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h = Uj(a2);
            Vj(a2, h, g);
            break;
          default:
            throw Error(p2(161));
        }
      } catch (k) {
        W(a2, a2.return, k);
      }
      a2.flags &= -3;
    }
    b & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b, c2) {
    V = a2;
    ik(a2);
  }
  function ik(a2, b, c2) {
    for (var d = 0 !== (a2.mode & 1); null !== V; ) {
      var e2 = V, f = e2.child;
      if (22 === e2.tag && d) {
        var g = null !== e2.memoizedState || Jj;
        if (!g) {
          var h = e2.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l2 = U;
          Jj = g;
          if ((U = k) && !l2) for (V = e2; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e2) : null !== k ? (k.return = g, V = k) : jk(e2);
          for (; null !== f; ) V = f, ik(f), f = f.sibling;
          V = e2;
          Jj = h;
          U = l2;
        }
        kk(a2);
      } else 0 !== (e2.subtreeFlags & 8772) && null !== f ? (f.return = e2, V = f) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c2 = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c2) d.componentDidMount();
              else {
                var e2 = b.elementType === b.type ? c2.memoizedProps : Ci(b.type, c2.memoizedProps);
                d.componentDidUpdate(e2, c2.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c2 = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c2 = b.child.stateNode;
                    break;
                  case 1:
                    c2 = b.child.stateNode;
                }
                sh(b, g, c2);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c2 && b.flags & 4) {
                c2 = h;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c2.focus();
                    break;
                  case "img":
                    k.src && (c2.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l2 = b.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q = m2.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p2(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r2) {
          W(b, b.return, r2);
        }
      }
      if (b === a2) {
        V = null;
        break;
      }
      c2 = b.sibling;
      if (null !== c2) {
        c2.return = b.return;
        V = c2;
        break;
      }
      V = b.return;
    }
  }
  function gk(a2) {
    for (; null !== V; ) {
      var b = V;
      if (b === a2) {
        V = null;
        break;
      }
      var c2 = b.sibling;
      if (null !== c2) {
        c2.return = b.return;
        V = c2;
        break;
      }
      V = b.return;
    }
  }
  function jk(a2) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c2, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e2 = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e2, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a2) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V = h;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua2.ReactCurrentDispatcher, nk = ua2.ReactCurrentOwner, ok = ua2.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a2 = C2;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi(a2, b, c2, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p2(185));
    Ac(a2, c2, d);
    if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d), 1 === c2 && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a2, b) {
    var c2 = a2.callbackNode;
    wc(a2, b);
    var d = uc(a2, a2 === Q ? Z : 0);
    if (0 === d) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b = d & -d, a2.callbackPriority !== b) {
      null != c2 && bc(c2);
      if (1 === b) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p2(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2) return null;
    var d = uc(a2, a2 === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a2.expiredLanes) || b) b = Ik(a2, d);
    else {
      b = d;
      var e2 = K;
      K |= 2;
      var f = Jk();
      if (Q !== a2 || Z !== b) uk = null, Gj = B() + 500, Kk(a2, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a2, h);
        }
      while (1);
      $g();
      mk.current = f;
      K = e2;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e2 = xc(a2), 0 !== e2 && (d = e2, b = Nk(a2, e2)));
      if (1 === b) throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
      if (6 === b) Ck(a2, d);
      else {
        e2 = a2.current.alternate;
        if (0 === (d & 30) && !Ok(e2) && (b = Ik(a2, d), 2 === b && (f = xc(a2), 0 !== f && (d = f, b = Nk(a2, f))), 1 === b)) throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
        a2.finishedWork = e2;
        a2.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p2(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a2, 0)) break;
              e2 = a2.suspendedLanes;
              if ((e2 & d) !== d) {
                R();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d);
            if ((d & 4194240) === d) break;
            b = a2.eventTimes;
            for (e2 = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f = 1 << g;
              g = b[g];
              g > e2 && (e2 = g);
              d &= ~f;
            }
            d = e2;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p2(329));
        }
      }
    }
    Dk(a2, B());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b).flags |= 256);
    a2 = Ik(a2, b);
    2 !== a2 && (b = tk, tk = c2, null !== b && Fj(b));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b = a2; ; ) {
      if (b.flags & 16384) {
        var c2 = b.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d = 0; d < c2.length; d++) {
          var e2 = c2[d], f = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f(), e2)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c2 = b.child;
      if (b.subtreeFlags & 16384 && null !== c2) c2.return = b, b = c2;
      else {
        if (b === a2) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b) {
    b &= ~rk;
    b &= ~qk;
    a2.suspendedLanes |= b;
    a2.pingedLanes &= ~b;
    for (a2 = a2.expirationTimes; 0 < b; ) {
      var c2 = 31 - oc(b), d = 1 << c2;
      a2[c2] = -1;
      b &= ~d;
    }
  }
  function Ek(a2) {
    if (0 !== (K & 6)) throw Error(p2(327));
    Hk();
    var b = uc(a2, 0);
    if (0 === (b & 1)) return Dk(a2, B()), null;
    var c2 = Ik(a2, b);
    if (0 !== a2.tag && 2 === c2) {
      var d = xc(a2);
      0 !== d && (b = d, c2 = Nk(a2, d));
    }
    if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b), Dk(a2, B()), c2;
    if (6 === c2) throw Error(p2(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b;
    Pk(a2, tk, uk);
    Dk(a2, B());
    return null;
  }
  function Qk(a2, b) {
    var c2 = K;
    K |= 1;
    try {
      return a2(b);
    } finally {
      K = c2, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c2 = ok.transition, d = C2;
    try {
      if (ok.transition = null, C2 = 1, a2) return a2();
    } finally {
      C2 = d, ok.transition = c2, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a2, b) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y) for (c2 = Y.return; null !== c2; ) {
      var d = c2;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
    Q = a2;
    Y = a2 = Pg(a2.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c2 = fh[b], d = c2.interleaved, null !== d) {
        c2.interleaved = null;
        var e2 = d.next, f = c2.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e2;
          d.next = g;
        }
        c2.pending = d;
      }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b) {
    do {
      var c2 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e2 = d.queue;
            null !== e2 && (e2.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a2, g = c2.return, h = c2, k = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l2 = k, m2 = h, q = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y = Ui(g);
            if (null !== y) {
              y.flags &= -257;
              Vi(y, g, h, f, b);
              y.mode & 1 && Si(f, l2, b);
              b = y;
              k = l2;
              var n2 = b.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k);
                b.updateQueue = t2;
              } else n2.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l2, b);
                tj();
                break a;
              }
              k = Error(p2(426));
            }
          } else if (I && h.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h, f, b);
              Jg(Ji(k, h));
              break a;
            }
          }
          f = k = Ji(k, h);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x = Ni(f, k, b);
                ph(f, x);
                break a;
              case 1:
                h = k;
                var w = f.type, u2 = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c2);
      } catch (na) {
        b = na;
        Y === c2 && null !== c2 && (Y = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a2, b) {
    var c2 = K;
    K |= 2;
    var d = Jk();
    if (Q !== a2 || Z !== b) uk = null, Kk(a2, b);
    do
      try {
        Tk();
        break;
      } catch (e2) {
        Mk(a2, e2);
      }
    while (1);
    $g();
    K = c2;
    mk.current = d;
    if (null !== Y) throw Error(p2(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a2) {
    var b = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b ? Sk(a2) : Y = b;
    nk.current = null;
  }
  function Sk(a2) {
    var b = a2;
    do {
      var c2 = b.alternate;
      a2 = b.return;
      if (0 === (b.flags & 32768)) {
        if (c2 = Ej(c2, b, fj), null !== c2) {
          Y = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b);
        if (null !== c2) {
          c2.flags &= 32767;
          Y = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a2;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a2, b, c2) {
    var d = C2, e2 = ok.transition;
    try {
      ok.transition = null, C2 = 1, Wk(a2, b, c2, d);
    } finally {
      ok.transition = e2, C2 = d;
    }
    return null;
  }
  function Wk(a2, b, c2, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p2(327));
    c2 = a2.finishedWork;
    var e2 = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p2(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f = c2.lanes | c2.childLanes;
    Bc(a2, f);
    a2 === Q && (Y = Q = null, Z = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C2;
      C2 = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      hk(c2);
      dc();
      K = h;
      C2 = g;
      ok.transition = f;
    } else a2.current = c2;
    vk && (vk = false, wk = a2, xk = e2);
    f = a2.pendingLanes;
    0 === f && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B());
    if (null !== b) for (d = a2.onRecoverableError, c2 = 0; c2 < b.length; c2++) e2 = b[c2], d(e2.value, { componentStack: e2.stack, digest: e2.digest });
    if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f = a2.pendingLanes;
    0 !== (f & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b = ok.transition, c2 = C2;
      try {
        ok.transition = null;
        C2 = 16 > a2 ? 16 : a2;
        if (null === wk) var d = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p2(331));
          var e2 = K;
          K |= 4;
          for (V = a2.current; null !== V; ) {
            var f = V, g = f.child;
            if (0 !== (V.flags & 16)) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l2 = h[k];
                  for (V = l2; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f);
                    }
                    var q = m2.child;
                    if (null !== q) q.return = m2, V = q;
                    else for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y;
                        V = r2;
                        break;
                      }
                      V = y;
                    }
                  }
                }
                var n2 = f.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J = t2.sibling;
                      t2.sibling = null;
                      t2 = J;
                    } while (null !== t2);
                  }
                }
                V = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
            else b: for (; null !== V; ) {
              f = V;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x = f.sibling;
              if (null !== x) {
                x.return = f.return;
                V = x;
                break b;
              }
              V = f.return;
            }
          }
          var w = a2.current;
          for (V = w; null !== V; ) {
            g = V;
            var u2 = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u2) u2.return = g, V = u2;
            else b: for (g = w; null !== V; ) {
              h = V;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V = null;
                break b;
              }
              var F = h.sibling;
              if (null !== F) {
                F.return = h.return;
                V = F;
                break b;
              }
              V = h.return;
            }
          }
          K = e2;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C2 = c2, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a2, b, c2) {
    b = Ji(c2, b);
    b = Ni(a2, b, 1);
    a2 = nh(a2, b, 1);
    b = R();
    null !== a2 && (Ac(a2, 1, b), Dk(a2, b));
  }
  function W(a2, b, c2) {
    if (3 === a2.tag) Xk(a2, a2, c2);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a2, c2);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b, a2, 1);
          b = nh(b, a2, 1);
          a2 = R();
          null !== b && (Ac(b, 1, a2), Dk(b, a2));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a2, b, c2) {
    var d = a2.pingCache;
    null !== d && d.delete(b);
    b = R();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b);
  }
  function Yk(a2, b) {
    0 === b && (0 === (a2.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R();
    a2 = ih(a2, b);
    null !== a2 && (Ac(a2, b, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b = a2.memoizedState, c2 = 0;
    null !== b && (c2 = b.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d = a2.stateNode;
        var e2 = a2.memoizedState;
        null !== e2 && (c2 = e2.retryLane);
        break;
      case 19:
        d = a2.stateNode;
        break;
      default:
        throw Error(p2(314));
    }
    null !== d && d.delete(b);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b, c2) {
    if (null !== a2) if (a2.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b.flags & 128)) return dh = false, yj(a2, b, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a2, b);
        a2 = b.pendingProps;
        var e2 = Yf(b, H.current);
        ch(b, c2);
        e2 = Nh(null, b, d, a2, e2, c2);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b), e2.updater = Ei, b.stateNode = e2, e2._reactInternals = b, Ii(b, d, a2, c2), b = jj(null, b, d, true, f, c2)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e2, c2), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a2, b);
          a2 = b.pendingProps;
          e2 = d._init;
          d = e2(d._payload);
          b.type = d;
          e2 = b.tag = Zk(d);
          a2 = Ci(d, a2);
          switch (e2) {
            case 0:
              b = cj(null, b, d, a2, c2);
              break a;
            case 1:
              b = hj(null, b, d, a2, c2);
              break a;
            case 11:
              b = Yi(null, b, d, a2, c2);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a2), c2);
              break a;
          }
          throw Error(p2(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), cj(a2, b, d, e2, c2);
      case 1:
        return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), hj(a2, b, d, e2, c2);
      case 3:
        a: {
          kj(b);
          if (null === a2) throw Error(p2(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e2 = f.element;
          lh(a2, b);
          qh(b, d, null, c2);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e2 = Ji(Error(p2(423)), b);
            b = lj(a2, b, d, c2, e2);
            break a;
          } else if (d !== e2) {
            e2 = Ji(Error(p2(424)), b);
            b = lj(a2, b, d, c2, e2);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c2 = Vg(b, null, d, c2), b.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d === e2) {
              b = Zi(a2, b, c2);
              break a;
            }
            Xi(a2, b, d, c2);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a2 && Eg(b), d = b.type, e2 = b.pendingProps, f = null !== a2 ? a2.memoizedProps : null, g = e2.children, Ef(d, e2) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a2, b), Xi(a2, b, g, c2), b.child;
      case 6:
        return null === a2 && Eg(b), null;
      case 13:
        return oj(a2, b, c2);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = Ug(b, null, d, c2) : Xi(a2, b, d, c2), b.child;
      case 11:
        return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), Yi(a2, b, d, e2, c2);
      case 7:
        return Xi(a2, b, b.pendingProps, c2), b.child;
      case 8:
        return Xi(a2, b, b.pendingProps.children, c2), b.child;
      case 12:
        return Xi(a2, b, b.pendingProps.children, c2), b.child;
      case 10:
        a: {
          d = b.type._context;
          e2 = b.pendingProps;
          f = b.memoizedProps;
          g = e2.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e2.children && !Wf.current) {
              b = Zi(a2, b, c2);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h = f.dependencies;
            if (null !== h) {
              g = f.child;
              for (var k = h.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c2 & -c2);
                    k.tag = 2;
                    var l2 = f.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k.next = k : (k.next = m2.next, m2.next = k);
                      l2.pending = k;
                    }
                  }
                  f.lanes |= c2;
                  k = f.alternate;
                  null !== k && (k.lanes |= c2);
                  bh(
                    f.return,
                    c2,
                    b
                  );
                  h.lanes |= c2;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p2(341));
              g.lanes |= c2;
              h = g.alternate;
              null !== h && (h.lanes |= c2);
              bh(g, c2, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a2, b, e2.children, c2);
          b = b.child;
        }
        return b;
      case 9:
        return e2 = b.type, d = b.pendingProps.children, ch(b, c2), e2 = eh(e2), d = d(e2), b.flags |= 1, Xi(a2, b, d, c2), b.child;
      case 14:
        return d = b.type, e2 = Ci(d, b.pendingProps), e2 = Ci(d.type, e2), $i(a2, b, d, e2, c2);
      case 15:
        return bj(a2, b, b.type, b.pendingProps, c2);
      case 17:
        return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), ij(a2, b), b.tag = 1, Zf(d) ? (a2 = true, cg(b)) : a2 = false, ch(b, c2), Gi(b, d, e2), Ii(b, d, e2, c2), jj(null, b, d, true, a2, c2);
      case 19:
        return xj(a2, b, c2);
      case 22:
        return dj(a2, b, c2);
    }
    throw Error(p2(156, b.tag));
  };
  function Fk(a2, b) {
    return ac(a2, b);
  }
  function $k(a2, b, c2, d) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b, c2, d) {
    return new $k(a2, b, c2, d);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga) return 14;
    }
    return 2;
  }
  function Pg(a2, b) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b = a2.dependencies;
    c2.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b, c2, d, e2, f) {
    var g = 2;
    d = a2;
    if ("function" === typeof a2) aj(a2) && (g = 1);
    else if ("string" === typeof a2) g = 5;
    else a: switch (a2) {
      case ya:
        return Tg(c2.children, e2, f, b);
      case za:
        g = 8;
        e2 |= 8;
        break;
      case Aa:
        return a2 = Bg(12, c2, b, e2 | 2), a2.elementType = Aa, a2.lanes = f, a2;
      case Ea:
        return a2 = Bg(13, c2, b, e2), a2.elementType = Ea, a2.lanes = f, a2;
      case Fa:
        return a2 = Bg(19, c2, b, e2), a2.elementType = Fa, a2.lanes = f, a2;
      case Ia:
        return pj(c2, e2, f, b);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
    }
    b = Bg(g, c2, b, e2);
    b.elementType = a2;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a2, b, c2, d) {
    a2 = Bg(7, a2, d, b);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b, c2, d) {
    a2 = Bg(22, a2, d, b);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b, c2) {
    a2 = Bg(6, a2, null, b);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b, c2) {
    b = Bg(4, null !== a2.children ? a2.children : [], a2.key, b);
    b.lanes = c2;
    b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b;
  }
  function al(a2, b, c2, d, e2) {
    this.tag = b;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e2;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b, c2, d, e2, f, g, h, k) {
    a2 = new al(a2, b, c2, h, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a2.current = f;
    f.stateNode = a2;
    f.memoizedState = { element: d, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a2;
  }
  function cl(a2, b, c2) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a2, containerInfo: b, implementation: c2 };
  }
  function dl(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
      var b = a2;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p2(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b);
    }
    return b;
  }
  function el(a2, b, c2, d, e2, f, g, h, k) {
    a2 = bl(c2, d, true, a2, e2, f, g, h, k);
    a2.context = dl(null);
    c2 = a2.current;
    d = R();
    e2 = yi(c2);
    f = mh(d, e2);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c2, f, e2);
    a2.current.lanes = e2;
    Ac(a2, e2, d);
    Dk(a2, d);
    return a2;
  }
  function fl(a2, b, c2, d) {
    var e2 = b.current, f = R(), g = yi(e2);
    c2 = dl(c2);
    null === b.context ? b.context = c2 : b.pendingContext = c2;
    b = mh(f, g);
    b.payload = { element: a2 };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a2 = nh(e2, b, g);
    null !== a2 && (gi(a2, e2, g, f), oh(a2, e2, g));
    return g;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b ? c2 : b;
    }
  }
  function il(a2, b) {
    hl(a2, b);
    (a2 = a2.alternate) && hl(a2, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b = this._internalRoot;
    if (null === b) throw Error(p2(409));
    fl(a2, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b = Hc();
      a2 = { blockedOn: null, target: a2, priority: b };
      for (var c2 = 0; c2 < Qc.length && 0 !== b && b < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b, c2, d, e2) {
    if (e2) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a3 = gl(g);
          f.call(a3);
        };
      }
      var g = el(b, d, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g;
      a2[uf] = g.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g;
    }
    for (; e2 = a2.lastChild; ) a2.removeChild(e2);
    if ("function" === typeof d) {
      var h = d;
      d = function() {
        var a3 = gl(k);
        h.call(a3);
      };
    }
    var k = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k;
    a2[uf] = k.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b, k, c2, d);
    });
    return k;
  }
  function rl(a2, b, c2, d, e2) {
    var f = c2._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e2) {
        var h = e2;
        e2 = function() {
          var a3 = gl(g);
          h.call(a3);
        };
      }
      fl(b, g, a2, e2);
    } else g = ql(c2, b, a2, e2, d);
    return gl(g);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b = a2.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c2 = tc(b.pendingLanes);
          0 !== c2 && (Cc(b, c2 | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a2, 1);
          if (null !== b2) {
            var c3 = R();
            gi(b2, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b = ih(a2, 134217728);
      if (null !== b) {
        var c2 = R();
        gi(b, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b = yi(a2), c2 = ih(a2, b);
      if (null !== c2) {
        var d = R();
        gi(c2, a2, b, d);
      }
      il(a2, b);
    }
  };
  Hc = function() {
    return C2;
  };
  Ic = function(a2, b) {
    var c2 = C2;
    try {
      return C2 = a2, b();
    } finally {
      C2 = c2;
    }
  };
  yb = function(a2, b, c2) {
    switch (b) {
      case "input":
        bb(a2, c2);
        b = c2.name;
        if ("radio" === c2.type && null != b) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c2.length; b++) {
            var d = c2[b];
            if (d !== a2 && d.form === a2.form) {
              var e2 = Db(d);
              if (!e2) throw Error(p2(90));
              Wa(d);
              bb(d, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b = c2.value, null != b && fb(a2, !!c2.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua2.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p2(200));
    return cl(a2, b, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b) {
    if (!nl(a2)) throw Error(p2(299));
    var c2 = false, d = "", e2 = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c2 = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e2 = b.onRecoverableError));
    b = bl(a2, 1, false, null, null, c2, false, d, e2);
    a2[uf] = b.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b = a2._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a2.render) throw Error(p2(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p2(268, a2));
    }
    a2 = Zb(b);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b, c2) {
    if (!ol(b)) throw Error(p2(200));
    return rl(null, a2, b, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b, c2) {
    if (!nl(a2)) throw Error(p2(405));
    var d = null != c2 && c2.hydratedSources || null, e2 = false, f = "", g = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g = c2.onRecoverableError));
    b = el(b, null, a2, 1, null != c2 ? c2 : null, e2, false, f, g);
    a2[uf] = b.current;
    sf(a2);
    if (d) for (a2 = 0; a2 < d.length; a2++) c2 = d[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c2, e2] : b.mutableSourceEagerHydrationData.push(
      c2,
      e2
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a2, b, c2) {
    if (!ol(b)) throw Error(p2(200));
    return rl(null, a2, b, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2)) throw Error(p2(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c2, d) {
    if (!ol(c2)) throw Error(p2(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
    return rl(a2, b, c2, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var reactDom_development = {};
var hasRequiredReactDom_development;
function requireReactDom_development() {
  if (hasRequiredReactDom_development) return reactDom_development;
  hasRequiredReactDom_development = 1;
  var define_process_env_default2 = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  if (define_process_env_default2.NODE_ENV !== "production") {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React2 = reactExports;
      var Scheduler = requireScheduler();
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var suppressWarning = false;
      function setSuppressWarning(newSuppressWarning) {
        {
          suppressWarning = newSuppressWarning;
        }
      }
      function warn(format) {
        {
          if (!suppressWarning) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          if (!suppressWarning) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;
      var DehydratedFragment = 18;
      var SuspenseListComponent = 19;
      var ScopeComponent = 21;
      var OffscreenComponent = 22;
      var LegacyHiddenComponent = 23;
      var CacheComponent = 24;
      var TracingMarkerComponent = 25;
      var enableClientRenderFallbackOnTextMismatch = true;
      var enableNewReconciler = false;
      var enableLazyContextPropagation = false;
      var enableLegacyHidden = false;
      var enableCustomElementPropertySupport = false;
      var warnAboutStringRefs = true;
      var enableSchedulingProfiler = true;
      var enableProfilerTimer = true;
      var enableProfilerCommitHooks = true;
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      var possibleRegistrationNames = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        {
          if (registrationNameDependencies[registrationName]) {
            error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
          }
        }
        registrationNameDependencies[registrationName] = dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          if (registrationName === "onDoubleClick") {
            possibleRegistrationNames.ondblclick = registrationName;
          }
        }
        for (var i2 = 0; i2 < dependencies.length; i2++) {
          allNativeEvents.add(dependencies[i2]);
        }
      }
      var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value2) {
        {
          try {
            testStringCoercion(value2);
            return false;
          } catch (e2) {
            return true;
          }
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkAttributeStringCoercion(value2, attributeName) {
        {
          if (willCoercionThrow(value2)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      function checkKeyStringCoercion(value2) {
        {
          if (willCoercionThrow(value2)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      function checkPropStringCoercion(value2, propName) {
        {
          if (willCoercionThrow(value2)) {
            error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value2, propName) {
        {
          if (willCoercionThrow(value2)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      function checkHtmlStringCoercion(value2) {
        {
          if (willCoercionThrow(value2)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      function checkFormFieldValueStringCoercion(value2) {
        {
          if (willCoercionThrow(value2)) {
            error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value2));
            return testStringCoercion(value2);
          }
        }
      }
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null) {
          return propertyInfo.type === RESERVED;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
          return true;
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name2, value2, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value2) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name2.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function shouldRemoveAttribute(name2, value2, propertyInfo, isCustomComponentTag) {
        if (value2 === null || typeof value2 === "undefined") {
          return true;
        }
        if (shouldRemoveAttributeWithWarning(name2, value2, propertyInfo, isCustomComponentTag)) {
          return true;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (propertyInfo !== null) {
          switch (propertyInfo.type) {
            case BOOLEAN:
              return !value2;
            case OVERLOADED_BOOLEAN:
              return value2 === false;
            case NUMERIC:
              return isNaN(value2);
            case POSITIVE_NUMERIC:
              return isNaN(value2) || value2 < 1;
          }
        }
        return false;
      }
      function getPropertyInfo(name2) {
        return properties.hasOwnProperty(name2) ? properties[name2] : null;
      }
      function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name2;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          RESERVED,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name2 = _ref[0], attributeName = _ref[1];
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name2.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEAN,
          false,
          // mustUseProperty
          name2.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEAN,
          true,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["rowSpan", "start"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          NUMERIC,
          false,
          // mustUseProperty
          name2.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          false,
          // sanitizeURL
          false
        );
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        false,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        true,
        // sanitizeURL
        false
      );
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          true,
          // sanitizeURL
          true
        );
      });
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url2) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url2)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url2));
          }
        }
      }
      function getValueForProperty(node, name2, expected, propertyInfo) {
        {
          if (propertyInfo.mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            return node[propertyName];
          } else {
            {
              checkAttributeStringCoercion(expected, name2);
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL("" + expected);
            }
            var attributeName = propertyInfo.attributeName;
            var stringValue = null;
            if (propertyInfo.type === OVERLOADED_BOOLEAN) {
              if (node.hasAttribute(attributeName)) {
                var value2 = node.getAttribute(attributeName);
                if (value2 === "") {
                  return true;
                }
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return value2;
                }
                if (value2 === "" + expected) {
                  return expected;
                }
                return value2;
              }
            } else if (node.hasAttribute(attributeName)) {
              if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                return node.getAttribute(attributeName);
              }
              if (propertyInfo.type === BOOLEAN) {
                return expected;
              }
              stringValue = node.getAttribute(attributeName);
            }
            if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
              return stringValue === null ? expected : stringValue;
            } else if (stringValue === "" + expected) {
              return expected;
            } else {
              return stringValue;
            }
          }
        }
      }
      function getValueForAttribute(node, name2, expected, isCustomComponentTag) {
        {
          if (!isAttributeNameSafe(name2)) {
            return;
          }
          if (!node.hasAttribute(name2)) {
            return expected === void 0 ? void 0 : null;
          }
          var value2 = node.getAttribute(name2);
          {
            checkAttributeStringCoercion(expected, name2);
          }
          if (value2 === "" + expected) {
            return expected;
          }
          return value2;
        }
      }
      function setValueForProperty(node, name2, value2, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name2);
        if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
          return;
        }
        if (shouldRemoveAttribute(name2, value2, propertyInfo, isCustomComponentTag)) {
          value2 = null;
        }
        if (isCustomComponentTag || propertyInfo === null) {
          if (isAttributeNameSafe(name2)) {
            var _attributeName = name2;
            if (value2 === null) {
              node.removeAttribute(_attributeName);
            } else {
              {
                checkAttributeStringCoercion(value2, name2);
              }
              node.setAttribute(_attributeName, "" + value2);
            }
          }
          return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
          var propertyName = propertyInfo.propertyName;
          if (value2 === null) {
            var type = propertyInfo.type;
            node[propertyName] = type === BOOLEAN ? false : "";
          } else {
            node[propertyName] = value2;
          }
          return;
        }
        var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
        if (value2 === null) {
          node.removeAttribute(attributeName);
        } else {
          var _type = propertyInfo.type;
          var attributeValue;
          if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value2 === true) {
            attributeValue = "";
          } else {
            {
              {
                checkAttributeStringCoercion(value2, attributeName);
              }
              attributeValue = "" + value2;
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL(attributeValue.toString());
            }
          }
          if (attributeNamespace) {
            node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
          } else {
            node.setAttribute(attributeName, attributeValue);
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_CACHE_TYPE = Symbol.for("react.cache");
      var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
              c2--;
            }
            for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
              if (sampleLines[s2] !== controlLines[c2]) {
                if (s2 !== 1 || c2 !== 1) {
                  do {
                    s2--;
                    c2--;
                    if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype2 = Component.prototype;
        return !!(prototype2 && prototype2.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      function describeFiber(fiber) {
        fiber._debugOwner ? fiber._debugOwner.type : null;
        fiber._debugSource;
        switch (fiber.tag) {
          case HostComponent:
            return describeBuiltInComponentFrame(fiber.type);
          case LazyComponent:
            return describeBuiltInComponentFrame("Lazy");
          case SuspenseComponent:
            return describeBuiltInComponentFrame("Suspense");
          case SuspenseListComponent:
            return describeBuiltInComponentFrame("SuspenseList");
          case FunctionComponent:
          case IndeterminateComponent:
          case SimpleMemoComponent:
            return describeFunctionComponentFrame(fiber.type);
          case ForwardRef:
            return describeFunctionComponentFrame(fiber.type.render);
          case ClassComponent:
            return describeClassComponentFrame(fiber.type);
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          var node = workInProgress2;
          do {
            info += describeFiber(node);
            node = node.return;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      function getWrappedName$1(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName$1(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromFiber(fiber) {
        var tag = fiber.tag, type = fiber.type;
        switch (tag) {
          case CacheComponent:
            return "Cache";
          case ContextConsumer:
            var context = type;
            return getContextName$1(context) + ".Consumer";
          case ContextProvider:
            var provider = type;
            return getContextName$1(provider._context) + ".Provider";
          case DehydratedFragment:
            return "DehydratedFragment";
          case ForwardRef:
            return getWrappedName$1(type, type.render, "ForwardRef");
          case Fragment:
            return "Fragment";
          case HostComponent:
            return type;
          case HostPortal:
            return "Portal";
          case HostRoot:
            return "Root";
          case HostText:
            return "Text";
          case LazyComponent:
            return getComponentNameFromType(type);
          case Mode:
            if (type === REACT_STRICT_MODE_TYPE) {
              return "StrictMode";
            }
            return "Mode";
          case OffscreenComponent:
            return "Offscreen";
          case Profiler:
            return "Profiler";
          case ScopeComponent:
            return "Scope";
          case SuspenseComponent:
            return "Suspense";
          case SuspenseListComponent:
            return "SuspenseList";
          case TracingMarkerComponent:
            return "TracingMarker";
          case ClassComponent:
          case FunctionComponent:
          case IncompleteClassComponent:
          case IndeterminateComponent:
          case MemoComponent:
          case SimpleMemoComponent:
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            break;
        }
        return null;
      }
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var current2 = null;
      var isRendering = false;
      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current2 === null) {
            return null;
          }
          var owner = current2._debugOwner;
          if (owner !== null && typeof owner !== "undefined") {
            return getComponentNameFromFiber(owner);
          }
        }
        return null;
      }
      function getCurrentFiberStackInDev() {
        {
          if (current2 === null) {
            return "";
          }
          return getStackByFiberInDevAndProd(current2);
        }
      }
      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current2 = null;
          isRendering = false;
        }
      }
      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
          current2 = fiber;
          isRendering = false;
        }
      }
      function getCurrentFiber() {
        {
          return current2;
        }
      }
      function setIsRendering(rendering) {
        {
          isRendering = rendering;
        }
      }
      function toString4(value2) {
        return "" + value2;
      }
      function getToStringValue(value2) {
        switch (typeof value2) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value2;
          case "object":
            {
              checkFormFieldValueStringCoercion(value2);
            }
            return value2;
          default:
            return "";
        }
      }
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
      }
      function getTracker(node) {
        return node._valueTracker;
      }
      function detachTracker(node) {
        node._valueTracker = null;
      }
      function getValueFromNode(node) {
        var value2 = "";
        if (!node) {
          return value2;
        }
        if (isCheckable(node)) {
          value2 = node.checked ? "true" : "false";
        } else {
          value2 = node.value;
        }
        return value2;
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value";
        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
        {
          checkFormFieldValueStringCoercion(node[valueField]);
        }
        var currentValue = "" + node[valueField];
        if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
          return;
        }
        var get22 = descriptor.get, set22 = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get22.call(this);
          },
          set: function(value2) {
            {
              checkFormFieldValueStringCoercion(value2);
            }
            currentValue = "" + value2;
            set22.call(this, value2);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        var tracker = {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value2) {
            {
              checkFormFieldValueStringCoercion(value2);
            }
            currentValue = "" + value2;
          },
          stopTracking: function() {
            detachTracker(node);
            delete node[valueField];
          }
        };
        return tracker;
      }
      function track(node) {
        if (getTracker(node)) {
          return;
        }
        node._valueTracker = trackValueOnNode(node);
      }
      function updateValueIfChanged(node) {
        if (!node) {
          return false;
        }
        var tracker = getTracker(node);
        if (!tracker) {
          return true;
        }
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(node);
        if (nextValue !== lastValue) {
          tracker.setValue(nextValue);
          return true;
        }
        return false;
      }
      function getActiveElement(doc) {
        doc = doc || (typeof document !== "undefined" ? document : void 0);
        if (typeof doc === "undefined") {
          return null;
        }
        try {
          return doc.activeElement || doc.body;
        } catch (e2) {
          return doc.body;
        }
      }
      var didWarnValueDefaultValue = false;
      var didWarnCheckedDefaultChecked = false;
      var didWarnControlledToUncontrolled = false;
      var didWarnUncontrolledToControlled = false;
      function isControlled(props) {
        var usesChecked = props.type === "checkbox" || props.type === "radio";
        return usesChecked ? props.checked != null : props.value != null;
      }
      function getHostProps(element, props) {
        var node = element;
        var checked = props.checked;
        var hostProps = assign({}, props, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: checked != null ? checked : node._wrapperState.initialChecked
        });
        return hostProps;
      }
      function initWrapperState(element, props) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnCheckedDefaultChecked = true;
          }
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnValueDefaultValue = true;
          }
        }
        var node = element;
        var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
        node._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
          controlled: isControlled(props)
        };
      }
      function updateChecked(element, props) {
        var node = element;
        var checked = props.checked;
        if (checked != null) {
          setValueForProperty(node, "checked", checked, false);
        }
      }
      function updateWrapper(element, props) {
        var node = element;
        {
          var controlled = isControlled(props);
          if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnUncontrolledToControlled = true;
          }
          if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnControlledToUncontrolled = true;
          }
        }
        updateChecked(element, props);
        var value2 = getToStringValue(props.value);
        var type = props.type;
        if (value2 != null) {
          if (type === "number") {
            if (value2 === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
            // eslint-disable-next-line
            node.value != value2) {
              node.value = toString4(value2);
            }
          } else if (node.value !== toString4(value2)) {
            node.value = toString4(value2);
          }
        } else if (type === "submit" || type === "reset") {
          node.removeAttribute("value");
          return;
        }
        {
          if (props.hasOwnProperty("value")) {
            setDefaultValue(node, props.type, value2);
          } else if (props.hasOwnProperty("defaultValue")) {
            setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
          }
        }
        {
          if (props.checked == null && props.defaultChecked != null) {
            node.defaultChecked = !!props.defaultChecked;
          }
        }
      }
      function postMountWrapper(element, props, isHydrating2) {
        var node = element;
        if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
          var type = props.type;
          var isButton = type === "submit" || type === "reset";
          if (isButton && (props.value === void 0 || props.value === null)) {
            return;
          }
          var initialValue = toString4(node._wrapperState.initialValue);
          if (!isHydrating2) {
            {
              if (initialValue !== node.value) {
                node.value = initialValue;
              }
            }
          }
          {
            node.defaultValue = initialValue;
          }
        }
        var name2 = node.name;
        if (name2 !== "") {
          node.name = "";
        }
        {
          node.defaultChecked = !node.defaultChecked;
          node.defaultChecked = !!node._wrapperState.initialChecked;
        }
        if (name2 !== "") {
          node.name = name2;
        }
      }
      function restoreControlledState(element, props) {
        var node = element;
        updateWrapper(node, props);
        updateNamedCousins(node, props);
      }
      function updateNamedCousins(rootNode, props) {
        var name2 = props.name;
        if (props.type === "radio" && name2 != null) {
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          {
            checkAttributeStringCoercion(name2, "name");
          }
          var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
          for (var i2 = 0; i2 < group.length; i2++) {
            var otherNode = group[i2];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherProps = getFiberCurrentPropsFromNode(otherNode);
            if (!otherProps) {
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            }
            updateValueIfChanged(otherNode);
            updateWrapper(otherNode, otherProps);
          }
        }
      }
      function setDefaultValue(node, type, value2) {
        if (
          // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
          type !== "number" || getActiveElement(node.ownerDocument) !== node
        ) {
          if (value2 == null) {
            node.defaultValue = toString4(node._wrapperState.initialValue);
          } else if (node.defaultValue !== toString4(value2)) {
            node.defaultValue = toString4(value2);
          }
        }
      }
      var didWarnSelectedSetOnOption = false;
      var didWarnInvalidChild = false;
      var didWarnInvalidInnerHTML = false;
      function validateProps(element, props) {
        {
          if (props.value == null) {
            if (typeof props.children === "object" && props.children !== null) {
              React2.Children.forEach(props.children, function(child) {
                if (child == null) {
                  return;
                }
                if (typeof child === "string" || typeof child === "number") {
                  return;
                }
                if (!didWarnInvalidChild) {
                  didWarnInvalidChild = true;
                  error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              });
            } else if (props.dangerouslySetInnerHTML != null) {
              if (!didWarnInvalidInnerHTML) {
                didWarnInvalidInnerHTML = true;
                error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
              }
            }
          }
          if (props.selected != null && !didWarnSelectedSetOnOption) {
            error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
            didWarnSelectedSetOnOption = true;
          }
        }
      }
      function postMountWrapper$1(element, props) {
        if (props.value != null) {
          element.setAttribute("value", toString4(getToStringValue(props.value)));
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a2) {
        return isArrayImpl(a2);
      }
      var didWarnValueDefaultValue$1;
      {
        didWarnValueDefaultValue$1 = false;
      }
      function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) {
          return "\n\nCheck the render method of `" + ownerName + "`.";
        }
        return "";
      }
      var valuePropNames = ["value", "defaultValue"];
      function checkSelectPropTypes(props) {
        {
          checkControlledValueProps("select", props);
          for (var i2 = 0; i2 < valuePropNames.length; i2++) {
            var propName = valuePropNames[i2];
            if (props[propName] == null) {
              continue;
            }
            var propNameIsArray = isArray2(props[propName]);
            if (props.multiple && !propNameIsArray) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
            } else if (!props.multiple && propNameIsArray) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
            }
          }
        }
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        var options2 = node.options;
        if (multiple) {
          var selectedValues = propValue;
          var selectedValue = {};
          for (var i2 = 0; i2 < selectedValues.length; i2++) {
            selectedValue["$" + selectedValues[i2]] = true;
          }
          for (var _i = 0; _i < options2.length; _i++) {
            var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
            if (options2[_i].selected !== selected) {
              options2[_i].selected = selected;
            }
            if (selected && setDefaultSelected) {
              options2[_i].defaultSelected = true;
            }
          }
        } else {
          var _selectedValue = toString4(getToStringValue(propValue));
          var defaultSelected = null;
          for (var _i2 = 0; _i2 < options2.length; _i2++) {
            if (options2[_i2].value === _selectedValue) {
              options2[_i2].selected = true;
              if (setDefaultSelected) {
                options2[_i2].defaultSelected = true;
              }
              return;
            }
            if (defaultSelected === null && !options2[_i2].disabled) {
              defaultSelected = options2[_i2];
            }
          }
          if (defaultSelected !== null) {
            defaultSelected.selected = true;
          }
        }
      }
      function getHostProps$1(element, props) {
        return assign({}, props, {
          value: void 0
        });
      }
      function initWrapperState$1(element, props) {
        var node = element;
        {
          checkSelectPropTypes(props);
        }
        node._wrapperState = {
          wasMultiple: !!props.multiple
        };
        {
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnValueDefaultValue$1 = true;
          }
        }
      }
      function postMountWrapper$2(element, props) {
        var node = element;
        node.multiple = !!props.multiple;
        var value2 = props.value;
        if (value2 != null) {
          updateOptions(node, !!props.multiple, value2, false);
        } else if (props.defaultValue != null) {
          updateOptions(node, !!props.multiple, props.defaultValue, true);
        }
      }
      function postUpdateWrapper(element, props) {
        var node = element;
        var wasMultiple = node._wrapperState.wasMultiple;
        node._wrapperState.wasMultiple = !!props.multiple;
        var value2 = props.value;
        if (value2 != null) {
          updateOptions(node, !!props.multiple, value2, false);
        } else if (wasMultiple !== !!props.multiple) {
          if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          } else {
            updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
          }
        }
      }
      function restoreControlledState$1(element, props) {
        var node = element;
        var value2 = props.value;
        if (value2 != null) {
          updateOptions(node, !!props.multiple, value2, false);
        }
      }
      var didWarnValDefaultVal = false;
      function getHostProps$2(element, props) {
        var node = element;
        if (props.dangerouslySetInnerHTML != null) {
          throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
        }
        var hostProps = assign({}, props, {
          value: void 0,
          defaultValue: void 0,
          children: toString4(node._wrapperState.initialValue)
        });
        return hostProps;
      }
      function initWrapperState$2(element, props) {
        var node = element;
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
            error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
            didWarnValDefaultVal = true;
          }
        }
        var initialValue = props.value;
        if (initialValue == null) {
          var children = props.children, defaultValue = props.defaultValue;
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            {
              if (defaultValue != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray2(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                children = children[0];
              }
              defaultValue = children;
            }
          }
          if (defaultValue == null) {
            defaultValue = "";
          }
          initialValue = defaultValue;
        }
        node._wrapperState = {
          initialValue: getToStringValue(initialValue)
        };
      }
      function updateWrapper$1(element, props) {
        var node = element;
        var value2 = getToStringValue(props.value);
        var defaultValue = getToStringValue(props.defaultValue);
        if (value2 != null) {
          var newValue = toString4(value2);
          if (newValue !== node.value) {
            node.value = newValue;
          }
          if (props.defaultValue == null && node.defaultValue !== newValue) {
            node.defaultValue = newValue;
          }
        }
        if (defaultValue != null) {
          node.defaultValue = toString4(defaultValue);
        }
      }
      function postMountWrapper$3(element, props) {
        var node = element;
        var textContent = node.textContent;
        if (textContent === node._wrapperState.initialValue) {
          if (textContent !== "" && textContent !== null) {
            node.value = textContent;
          }
        }
      }
      function restoreControlledState$2(element, props) {
        updateWrapper$1(element, props);
      }
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      function getIntrinsicNamespace(type) {
        switch (type) {
          case "svg":
            return SVG_NAMESPACE;
          case "math":
            return MATH_NAMESPACE;
          default:
            return HTML_NAMESPACE;
        }
      }
      function getChildNamespace(parentNamespace, type) {
        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
          return getIntrinsicNamespace(type);
        }
        if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
          return HTML_NAMESPACE;
        }
        return parentNamespace;
      }
      var createMicrosoftUnsafeLocalFunction = function(func) {
        if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
          return function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
              return func(arg0, arg1, arg2, arg3);
            });
          };
        } else {
          return func;
        }
      };
      var reusableSVGContainer;
      var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
        if (node.namespaceURI === SVG_NAMESPACE) {
          if (!("innerHTML" in node)) {
            reusableSVGContainer = reusableSVGContainer || document.createElement("div");
            reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
            var svgNode = reusableSVGContainer.firstChild;
            while (node.firstChild) {
              node.removeChild(node.firstChild);
            }
            while (svgNode.firstChild) {
              node.appendChild(svgNode.firstChild);
            }
            return;
          }
        }
        node.innerHTML = html;
      });
      var ELEMENT_NODE = 1;
      var TEXT_NODE = 3;
      var COMMENT_NODE = 8;
      var DOCUMENT_NODE = 9;
      var DOCUMENT_FRAGMENT_NODE = 11;
      var setTextContent = function(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      };
      var shorthandToLonghand = {
        animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
        background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
        fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
        gap: ["columnGap", "rowGap"],
        grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      };
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      function dangerousStyleValue(name2, value2, isCustomProperty) {
        var isEmpty = value2 == null || typeof value2 === "boolean" || value2 === "";
        if (isEmpty) {
          return "";
        }
        if (!isCustomProperty && typeof value2 === "number" && value2 !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
          return value2 + "px";
        }
        {
          checkCSSPropertyStringCoercion(value2, name2);
        }
        return ("" + value2).trim();
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern = /^ms-/;
      function hyphenateStyleName(name2) {
        return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern$1 = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error(
            "Unsupported style property %s. Did you mean %s?",
            name2,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name2.replace(msPattern$1, "ms-"))
          );
        };
        var warnBadVendoredStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name2, value2) {
          if (warnedStyleValues.hasOwnProperty(value2) && warnedStyleValues[value2]) {
            return;
          }
          warnedStyleValues[value2] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value2.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name2, value2) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name2);
        };
        var warnStyleValueIsInfinity = function(name2, value2) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name2);
        };
        warnValidStyle = function(name2, value2) {
          if (name2.indexOf("-") > -1) {
            warnHyphenatedStyleName(name2);
          } else if (badVendoredStyleNamePattern.test(name2)) {
            warnBadVendoredStyleName(name2);
          } else if (badStyleValueWithSemicolonPattern.test(value2)) {
            warnStyleValueWithSemicolon(name2, value2);
          }
          if (typeof value2 === "number") {
            if (isNaN(value2)) {
              warnStyleValueIsNaN(name2, value2);
            } else if (!isFinite(value2)) {
              warnStyleValueIsInfinity(name2, value2);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      function createDangerousStringForStyles(styles2) {
        {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles2) {
            if (!styles2.hasOwnProperty(styleName)) {
              continue;
            }
            var styleValue = styles2[styleName];
            if (styleValue != null) {
              var isCustomProperty = styleName.indexOf("--") === 0;
              serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
      }
      function setValueForStyles(node, styles2) {
        var style22 = node.style;
        for (var styleName in styles2) {
          if (!styles2.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf("--") === 0;
          {
            if (!isCustomProperty) {
              warnValidStyle$1(styleName, styles2[styleName]);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles2[styleName], isCustomProperty);
          if (styleName === "float") {
            styleName = "cssFloat";
          }
          if (isCustomProperty) {
            style22.setProperty(styleName, styleValue);
          } else {
            style22[styleName] = styleValue;
          }
        }
      }
      function isValueEmpty(value2) {
        return value2 == null || typeof value2 === "boolean" || value2 === "";
      }
      function expandShorthandMap(styles2) {
        var expanded = {};
        for (var key in styles2) {
          var longhands = shorthandToLonghand[key] || [key];
          for (var i2 = 0; i2 < longhands.length; i2++) {
            expanded[longhands[i2]] = key;
          }
        }
        return expanded;
      }
      function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        {
          if (!nextStyles) {
            return;
          }
          var expandedUpdates = expandShorthandMap(styleUpdates);
          var expandedStyles = expandShorthandMap(nextStyles);
          var warnedAbout = {};
          for (var key in expandedUpdates) {
            var originalKey = expandedUpdates[key];
            var correctOriginalKey = expandedStyles[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
              var warningKey = originalKey + "," + correctOriginalKey;
              if (warnedAbout[warningKey]) {
                continue;
              }
              warnedAbout[warningKey] = true;
              error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
            }
          }
        }
      }
      var omittedCloseTags = {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
        // NOTE: menuitem's close tag should be omitted, but that causes problems.
      };
      var voidElementTags = assign({
        menuitem: true
      }, omittedCloseTags);
      var HTML = "__html";
      function assertValidProps(tag, props) {
        if (!props) {
          return;
        }
        if (voidElementTags[tag]) {
          if (props.children != null || props.dangerouslySetInnerHTML != null) {
            throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          }
        }
        if (props.dangerouslySetInnerHTML != null) {
          if (props.children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
        }
        {
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
        }
        if (props.style != null && typeof props.style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name2) {
        {
          if (hasOwnProperty2.call(warnedProperties, name2) && warnedProperties[name2]) {
            return true;
          }
          if (rARIACamel.test(name2)) {
            var ariaName = "aria-" + name2.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
              warnedProperties[name2] = true;
              return true;
            }
            if (name2 !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
              warnedProperties[name2] = true;
              return true;
            }
          }
          if (rARIA.test(name2)) {
            var lowerCasedName = name2.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name2] = true;
              return false;
            }
            if (name2 !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties[name2] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid2 = validateProperty(type, key);
            if (!isValid2) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name2, value2, eventRegistry) {
          if (hasOwnProperty2.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
            return true;
          }
          var lowerCasedName = name2.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (eventRegistry != null) {
            var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies2.hasOwnProperty(name2)) {
              return true;
            }
            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name2)) {
              error("Unknown event handler property `%s`. It will be ignored.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name2)) {
            if (INVALID_EVENT_NAME_REGEX.test(name2)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "is" && value2 !== null && value2 !== void 0 && typeof value2 !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value2);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value2 === "number" && isNaN(value2)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
            warnedProperties$1[name2] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name2);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name2) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (!isReserved && name2 !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value2 === "boolean" && shouldRemoveAttributeWithWarning(name2, value2, propertyInfo, false)) {
            if (value2) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value2, name2, name2, value2, name2);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value2, name2, name2, value2, name2, name2, name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value2, propertyInfo, false)) {
            warnedProperties$1[name2] = true;
            return false;
          }
          if ((value2 === "false" || value2 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value2, name2, value2 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value2);
            warnedProperties$1[name2] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid2 = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid2) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
      var IS_NON_DELEGATED = 1 << 1;
      var IS_CAPTURE_PHASE = 1 << 2;
      var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
      var currentReplayingEvent = null;
      function setReplayingEvent(event) {
        {
          if (currentReplayingEvent !== null) {
            error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = event;
      }
      function resetReplayingEvent() {
        {
          if (currentReplayingEvent === null) {
            error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = null;
      }
      function isReplayingEvent(event) {
        return event === currentReplayingEvent;
      }
      function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        if (target.correspondingUseElement) {
          target = target.correspondingUseElement;
        }
        return target.nodeType === TEXT_NODE ? target.parentNode : target;
      }
      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (!internalInstance) {
          return;
        }
        if (typeof restoreImpl !== "function") {
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        }
        var stateNode = internalInstance.stateNode;
        if (stateNode) {
          var _props = getFiberCurrentPropsFromNode(stateNode);
          restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
      }
      function setRestoreImplementation(impl) {
        restoreImpl = impl;
      }
      function enqueueStateRestore(target) {
        if (restoreTarget) {
          if (restoreQueue) {
            restoreQueue.push(target);
          } else {
            restoreQueue = [target];
          }
        } else {
          restoreTarget = target;
        }
      }
      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }
      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }
        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);
        if (queuedTargets) {
          for (var i2 = 0; i2 < queuedTargets.length; i2++) {
            restoreStateOfTarget(queuedTargets[i2]);
          }
        }
      }
      var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
      };
      var flushSyncImpl = function() {
      };
      var isInsideEventHandler = false;
      function finishEventHandler() {
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
          flushSyncImpl();
          restoreStateIfNeeded();
        }
      }
      function batchedUpdates(fn, a2, b) {
        if (isInsideEventHandler) {
          return fn(a2, b);
        }
        isInsideEventHandler = true;
        try {
          return batchedUpdatesImpl(fn, a2, b);
        } finally {
          isInsideEventHandler = false;
          finishEventHandler();
        }
      }
      function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl;
        flushSyncImpl = _flushSyncImpl;
      }
      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }
      function shouldPreventMouseEvent(name2, type, props) {
        switch (name2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            return !!(props.disabled && isInteractive(type));
          default:
            return false;
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null) {
          return null;
        }
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null) {
          return null;
        }
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }
        if (listener && typeof listener !== "function") {
          throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        }
        return listener;
      }
      var passiveBrowserEventsSupported = false;
      if (canUseDOM2) {
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e2) {
          passiveBrowserEventsSupported = false;
        }
      }
      function invokeGuardedCallbackProd(name2, func, context, a2, b, c2, d, e2, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
          func.apply(context, funcArgs);
        } catch (error2) {
          this.onError(error2);
        }
      }
      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");
          invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a2, b, c2, d, e2, f) {
            if (typeof document === "undefined" || document === null) {
              throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
            }
            var evt = document.createEvent("Event");
            var didCall = false;
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            function restoreAfterDispatch() {
              fakeNode.removeEventListener(evtType, callCallback2, false);
              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }
            }
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback2() {
              didCall = true;
              restoreAfterDispatch();
              func.apply(context, funcArgs);
              didError = false;
            }
            var error2;
            var didSetError = false;
            var isCrossOriginError = false;
            function handleWindowError(event) {
              error2 = event.error;
              didSetError = true;
              if (error2 === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }
              if (event.defaultPrevented) {
                if (error2 != null && typeof error2 === "object") {
                  try {
                    error2._suppressLogging = true;
                  } catch (inner) {
                  }
                }
              }
            }
            var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback2, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);
            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }
            if (didCall && didError) {
              if (!didSetError) {
                error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
              } else if (isCrossOriginError) {
                error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
              }
              this.onError(error2);
            }
            window.removeEventListener("error", handleWindowError);
            if (!didCall) {
              restoreAfterDispatch();
              return invokeGuardedCallbackProd.apply(this, arguments);
            }
          };
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function(error2) {
          hasError = true;
          caughtError = error2;
        }
      };
      function invokeGuardedCallback(name2, func, context, a2, b, c2, d, e2, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }
      function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a2, b, c2, d, e2, f) {
        invokeGuardedCallback.apply(this, arguments);
        if (hasError) {
          var error2 = clearCaughtError();
          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error2;
          }
        }
      }
      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error2 = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error2;
        }
      }
      function hasCaughtError() {
        return hasError;
      }
      function clearCaughtError() {
        if (hasError) {
          var error2 = caughtError;
          hasError = false;
          caughtError = null;
          return error2;
        } else {
          throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      function get2(key) {
        return key._reactInternals;
      }
      function has2(key) {
        return key._reactInternals !== void 0;
      }
      function set2(key, value2) {
        key._reactInternals = value2;
      }
      var NoFlags = (
        /*                      */
        0
      );
      var PerformedWork = (
        /*                */
        1
      );
      var Placement = (
        /*                    */
        2
      );
      var Update2 = (
        /*                       */
        4
      );
      var ChildDeletion = (
        /*                */
        16
      );
      var ContentReset = (
        /*                 */
        32
      );
      var Callback = (
        /*                     */
        64
      );
      var DidCapture = (
        /*                   */
        128
      );
      var ForceClientRender = (
        /*            */
        256
      );
      var Ref = (
        /*                          */
        512
      );
      var Snapshot = (
        /*                     */
        1024
      );
      var Passive = (
        /*                      */
        2048
      );
      var Hydrating = (
        /*                    */
        4096
      );
      var Visibility = (
        /*                   */
        8192
      );
      var StoreConsistency = (
        /*             */
        16384
      );
      var HostEffectMask = (
        /*               */
        32767
      );
      var Incomplete = (
        /*                   */
        32768
      );
      var ShouldCapture = (
        /*                */
        65536
      );
      var ForceUpdateForLegacySuspense = (
        /* */
        131072
      );
      var Forked = (
        /*                       */
        1048576
      );
      var RefStatic = (
        /*                    */
        2097152
      );
      var LayoutStatic = (
        /*                 */
        4194304
      );
      var PassiveStatic = (
        /*                */
        8388608
      );
      var MountLayoutDev = (
        /*               */
        16777216
      );
      var MountPassiveDev = (
        /*              */
        33554432
      );
      var BeforeMutationMask = (
        // TODO: Remove Update flag from before mutation phase by re-landing Visibility
        // flag logic (see #20043)
        Update2 | Snapshot | 0
      );
      var MutationMask = Placement | Update2 | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
      var LayoutMask = Update2 | Callback | Ref | Visibility;
      var PassiveMask = Passive | ChildDeletion;
      var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      function getNearestMountedFiber(fiber) {
        var node = fiber;
        var nearestMounted = fiber;
        if (!fiber.alternate) {
          var nextNode = node;
          do {
            node = nextNode;
            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
              nearestMounted = node.return;
            }
            nextNode = node.return;
          } while (nextNode);
        } else {
          while (node.return) {
            node = node.return;
          }
        }
        if (node.tag === HostRoot) {
          return nearestMounted;
        }
        return null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState === null) {
            var current22 = fiber.alternate;
            if (current22 !== null) {
              suspenseState = current22.memoizedState;
            }
          }
          if (suspenseState !== null) {
            return suspenseState.dehydrated;
          }
        }
        return null;
      }
      function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
      }
      function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
      }
      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;
          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance2 = ownerFiber.stateNode;
            if (!instance2._warnedAboutRefsInRender) {
              error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
            }
            instance2._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get2(component);
        if (!fiber) {
          return false;
        }
        return getNearestMountedFiber(fiber) === fiber;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber) {
          throw new Error("Unable to find node on an unmounted component.");
        }
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          var nearestMounted = getNearestMountedFiber(fiber);
          if (nearestMounted === null) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (nearestMounted !== fiber) {
            return null;
          }
          return fiber;
        }
        var a2 = fiber;
        var b = alternate;
        while (true) {
          var parentA = a2.return;
          if (parentA === null) {
            break;
          }
          var parentB = parentA.alternate;
          if (parentB === null) {
            var nextParent = parentA.return;
            if (nextParent !== null) {
              a2 = b = nextParent;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            var child = parentA.child;
            while (child) {
              if (child === a2) {
                assertIsMounted(parentA);
                return fiber;
              }
              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }
              child = child.sibling;
            }
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a2.return !== b.return) {
            a2 = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;
            while (_child) {
              if (_child === a2) {
                didFindChild = true;
                a2 = parentA;
                b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a2 = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              _child = parentB.child;
              while (_child) {
                if (_child === a2) {
                  didFindChild = true;
                  a2 = parentB;
                  b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a2 = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
              }
            }
          }
          if (a2.alternate !== b) {
            throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (a2.tag !== HostRoot) {
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (a2.stateNode.current === a2) {
          return fiber;
        }
        return alternate;
      }
      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
      }
      function findCurrentHostFiberImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        }
        var child = node.child;
        while (child !== null) {
          var match = findCurrentHostFiberImpl(child);
          if (match !== null) {
            return match;
          }
          child = child.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        }
        var child = node.child;
        while (child !== null) {
          if (child.tag !== HostPortal) {
            var match = findCurrentHostFiberWithNoPortalsImpl(child);
            if (match !== null) {
              return match;
            }
          }
          child = child.sibling;
        }
        return null;
      }
      var scheduleCallback = Scheduler.unstable_scheduleCallback;
      var cancelCallback = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var unstable_yieldValue = Scheduler.unstable_yieldValue;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      var injectedProfilingHooks = null;
      var hasLoggedError = false;
      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) {
          return true;
        }
        if (!hook.supportsFiber) {
          {
            error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
          }
          return true;
        }
        try {
          if (enableSchedulingProfiler) {
            internals = assign({}, internals, {
              getLaneLabelMap,
              injectProfilingHooks
            });
          }
          rendererID = hook.inject(internals);
          injectedHook = hook;
        } catch (err) {
          {
            error("React instrumentation encountered an error: %s.", err);
          }
        }
        if (hook.checkDCE) {
          return true;
        } else {
          return false;
        }
      }
      function onScheduleRoot(root2, children) {
        {
          if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
            try {
              injectedHook.onScheduleFiberRoot(rendererID, root2, children);
            } catch (err) {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitRoot(root2, eventPriority) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
          try {
            var didError = (root2.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) {
              var schedulerPriority;
              switch (eventPriority) {
                case DiscreteEventPriority:
                  schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriority = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority;
                  break;
              }
              injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
            }
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onPostCommitRoot(root2) {
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root2);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
          try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        {
          if (typeof unstable_yieldValue === "function") {
            unstable_setDisableYieldValue(newIsStrictMode);
            setSuppressWarning(newIsStrictMode);
          }
          if (injectedHook && typeof injectedHook.setStrictMode === "function") {
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
      }
      function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
      }
      function getLaneLabelMap() {
        {
          var map = /* @__PURE__ */ new Map();
          var lane = 1;
          for (var index2 = 0; index2 < TotalLanes; index2++) {
            var label = getLabelForLane(lane);
            map.set(lane, label);
            lane *= 2;
          }
          return map;
        }
      }
      function markCommitStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
            injectedProfilingHooks.markCommitStarted(lanes);
          }
        }
      }
      function markCommitStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
            injectedProfilingHooks.markCommitStopped();
          }
        }
      }
      function markComponentRenderStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
            injectedProfilingHooks.markComponentRenderStarted(fiber);
          }
        }
      }
      function markComponentRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
            injectedProfilingHooks.markComponentRenderStopped();
          }
        }
      }
      function markComponentPassiveEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStopped();
          }
        }
      }
      function markComponentPassiveEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
          }
        }
      }
      function markComponentLayoutEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStopped();
          }
        }
      }
      function markComponentLayoutEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
          }
        }
      }
      function markComponentErrored(fiber, thrownValue, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
          }
        }
      }
      function markComponentSuspended(fiber, wakeable, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
          }
        }
      }
      function markLayoutEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
            injectedProfilingHooks.markLayoutEffectsStarted(lanes);
          }
        }
      }
      function markLayoutEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
            injectedProfilingHooks.markLayoutEffectsStopped();
          }
        }
      }
      function markPassiveEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
            injectedProfilingHooks.markPassiveEffectsStarted(lanes);
          }
        }
      }
      function markPassiveEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
            injectedProfilingHooks.markPassiveEffectsStopped();
          }
        }
      }
      function markRenderStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
            injectedProfilingHooks.markRenderStarted(lanes);
          }
        }
      }
      function markRenderYielded() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
            injectedProfilingHooks.markRenderYielded();
          }
        }
      }
      function markRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
            injectedProfilingHooks.markRenderStopped();
          }
        }
      }
      function markRenderScheduled(lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
            injectedProfilingHooks.markRenderScheduled(lane);
          }
        }
      }
      function markForceUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
          }
        }
      }
      function markStateUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
          }
        }
      }
      var NoMode = (
        /*                         */
        0
      );
      var ConcurrentMode = (
        /*                 */
        1
      );
      var ProfileMode = (
        /*                    */
        2
      );
      var StrictLegacyMode = (
        /*               */
        8
      );
      var StrictEffectsMode = (
        /*              */
        16
      );
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      var TotalLanes = 31;
      var NoLanes = (
        /*                        */
        0
      );
      var NoLane = (
        /*                          */
        0
      );
      var SyncLane = (
        /*                        */
        1
      );
      var InputContinuousHydrationLane = (
        /*    */
        2
      );
      var InputContinuousLane = (
        /*             */
        4
      );
      var DefaultHydrationLane = (
        /*            */
        8
      );
      var DefaultLane = (
        /*                     */
        16
      );
      var TransitionHydrationLane = (
        /*                */
        32
      );
      var TransitionLanes = (
        /*                       */
        4194240
      );
      var TransitionLane1 = (
        /*                        */
        64
      );
      var TransitionLane2 = (
        /*                        */
        128
      );
      var TransitionLane3 = (
        /*                        */
        256
      );
      var TransitionLane4 = (
        /*                        */
        512
      );
      var TransitionLane5 = (
        /*                        */
        1024
      );
      var TransitionLane6 = (
        /*                        */
        2048
      );
      var TransitionLane7 = (
        /*                        */
        4096
      );
      var TransitionLane8 = (
        /*                        */
        8192
      );
      var TransitionLane9 = (
        /*                        */
        16384
      );
      var TransitionLane10 = (
        /*                       */
        32768
      );
      var TransitionLane11 = (
        /*                       */
        65536
      );
      var TransitionLane12 = (
        /*                       */
        131072
      );
      var TransitionLane13 = (
        /*                       */
        262144
      );
      var TransitionLane14 = (
        /*                       */
        524288
      );
      var TransitionLane15 = (
        /*                       */
        1048576
      );
      var TransitionLane16 = (
        /*                       */
        2097152
      );
      var RetryLanes = (
        /*                            */
        130023424
      );
      var RetryLane1 = (
        /*                             */
        4194304
      );
      var RetryLane2 = (
        /*                             */
        8388608
      );
      var RetryLane3 = (
        /*                             */
        16777216
      );
      var RetryLane4 = (
        /*                             */
        33554432
      );
      var RetryLane5 = (
        /*                             */
        67108864
      );
      var SomeRetryLane = RetryLane1;
      var SelectiveHydrationLane = (
        /*          */
        134217728
      );
      var NonIdleLanes = (
        /*                          */
        268435455
      );
      var IdleHydrationLane = (
        /*               */
        268435456
      );
      var IdleLane = (
        /*                        */
        536870912
      );
      var OffscreenLane = (
        /*                   */
        1073741824
      );
      function getLabelForLane(lane) {
        {
          if (lane & SyncLane) {
            return "Sync";
          }
          if (lane & InputContinuousHydrationLane) {
            return "InputContinuousHydration";
          }
          if (lane & InputContinuousLane) {
            return "InputContinuous";
          }
          if (lane & DefaultHydrationLane) {
            return "DefaultHydration";
          }
          if (lane & DefaultLane) {
            return "Default";
          }
          if (lane & TransitionHydrationLane) {
            return "TransitionHydration";
          }
          if (lane & TransitionLanes) {
            return "Transition";
          }
          if (lane & RetryLanes) {
            return "Retry";
          }
          if (lane & SelectiveHydrationLane) {
            return "SelectiveHydration";
          }
          if (lane & IdleHydrationLane) {
            return "IdleHydration";
          }
          if (lane & IdleLane) {
            return "Idle";
          }
          if (lane & OffscreenLane) {
            return "Offscreen";
          }
        }
      }
      var NoTimestamp = -1;
      var nextTransitionLane = TransitionLane1;
      var nextRetryLane = RetryLane1;
      function getHighestPriorityLanes(lanes) {
        switch (getHighestPriorityLane(lanes)) {
          case SyncLane:
            return SyncLane;
          case InputContinuousHydrationLane:
            return InputContinuousHydrationLane;
          case InputContinuousLane:
            return InputContinuousLane;
          case DefaultHydrationLane:
            return DefaultHydrationLane;
          case DefaultLane:
            return DefaultLane;
          case TransitionHydrationLane:
            return TransitionHydrationLane;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return lanes & TransitionLanes;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return lanes & RetryLanes;
          case SelectiveHydrationLane:
            return SelectiveHydrationLane;
          case IdleHydrationLane:
            return IdleHydrationLane;
          case IdleLane:
            return IdleLane;
          case OffscreenLane:
            return OffscreenLane;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes) {
        var pendingLanes = root2.pendingLanes;
        if (pendingLanes === NoLanes) {
          return NoLanes;
        }
        var nextLanes = NoLanes;
        var suspendedLanes = root2.suspendedLanes;
        var pingedLanes = root2.pingedLanes;
        var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
        if (nonIdlePendingLanes !== NoLanes) {
          var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
          if (nonIdleUnblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
          } else {
            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
            if (nonIdlePingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
            }
          }
        } else {
          var unblockedLanes = pendingLanes & ~suspendedLanes;
          if (unblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(unblockedLanes);
          } else {
            if (pingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(pingedLanes);
            }
          }
        }
        if (nextLanes === NoLanes) {
          return NoLanes;
        }
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
        // bother waiting until the root is complete.
        (wipLanes & suspendedLanes) === NoLanes) {
          var nextLane = getHighestPriorityLane(nextLanes);
          var wipLane = getHighestPriorityLane(wipLanes);
          if (
            // Tests whether the next lane is equal or lower priority than the wip
            // one. This works because the bits decrease in priority as you go left.
            nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
            // only difference between default updates and transition updates is that
            // default updates do not support refresh transitions.
            nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
          ) {
            return wipLanes;
          }
        }
        if ((nextLanes & InputContinuousLane) !== NoLanes) {
          nextLanes |= pendingLanes & DefaultLane;
        }
        var entangledLanes = root2.entangledLanes;
        if (entangledLanes !== NoLanes) {
          var entanglements = root2.entanglements;
          var lanes = nextLanes & entangledLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            nextLanes |= entanglements[index2];
            lanes &= ~lane;
          }
        }
        return nextLanes;
      }
      function getMostRecentEventTime(root2, lanes) {
        var eventTimes = root2.eventTimes;
        var mostRecentEventTime = NoTimestamp;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var eventTime = eventTimes[index2];
          if (eventTime > mostRecentEventTime) {
            mostRecentEventTime = eventTime;
          }
          lanes &= ~lane;
        }
        return mostRecentEventTime;
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case SyncLane:
          case InputContinuousHydrationLane:
          case InputContinuousLane:
            return currentTime + 250;
          case DefaultHydrationLane:
          case DefaultLane:
          case TransitionHydrationLane:
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return currentTime + 5e3;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return NoTimestamp;
          case SelectiveHydrationLane:
          case IdleHydrationLane:
          case IdleLane:
          case OffscreenLane:
            return NoTimestamp;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return NoTimestamp;
        }
      }
      function markStarvedLanesAsExpired(root2, currentTime) {
        var pendingLanes = root2.pendingLanes;
        var suspendedLanes = root2.suspendedLanes;
        var pingedLanes = root2.pingedLanes;
        var expirationTimes = root2.expirationTimes;
        var lanes = pendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var expirationTime = expirationTimes[index2];
          if (expirationTime === NoTimestamp) {
            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
              expirationTimes[index2] = computeExpirationTime(lane, currentTime);
            }
          } else if (expirationTime <= currentTime) {
            root2.expiredLanes |= lane;
          }
          lanes &= ~lane;
        }
      }
      function getHighestPriorityPendingLanes(root2) {
        return getHighestPriorityLanes(root2.pendingLanes);
      }
      function getLanesToRetrySynchronouslyOnError(root2) {
        var everythingButOffscreen = root2.pendingLanes & -1073741825;
        if (everythingButOffscreen !== NoLanes) {
          return everythingButOffscreen;
        }
        if (everythingButOffscreen & OffscreenLane) {
          return OffscreenLane;
        }
        return NoLanes;
      }
      function includesSyncLane(lanes) {
        return (lanes & SyncLane) !== NoLanes;
      }
      function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
      }
      function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
      }
      function includesOnlyNonUrgentLanes(lanes) {
        var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
        return (lanes & UrgentLanes) === NoLanes;
      }
      function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
      }
      function includesBlockingLane(root2, lanes) {
        var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
        return (lanes & SyncDefaultLanes) !== NoLanes;
      }
      function includesExpiredLane(root2, lanes) {
        return (lanes & root2.expiredLanes) !== NoLanes;
      }
      function isTransitionLane(lane) {
        return (lane & TransitionLanes) !== NoLanes;
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        if ((nextTransitionLane & TransitionLanes) === NoLanes) {
          nextTransitionLane = TransitionLane1;
        }
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        if ((nextRetryLane & RetryLanes) === NoLanes) {
          nextRetryLane = RetryLane1;
        }
        return lane;
      }
      function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
      }
      function pickArbitraryLane(lanes) {
        return getHighestPriorityLane(lanes);
      }
      function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
      }
      function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
      }
      function includesSomeLane(a2, b) {
        return (a2 & b) !== NoLanes;
      }
      function isSubsetOfLanes(set22, subset) {
        return (set22 & subset) === subset;
      }
      function mergeLanes(a2, b) {
        return a2 | b;
      }
      function removeLanes(set22, subset) {
        return set22 & ~subset;
      }
      function intersectLanes(a2, b) {
        return a2 & b;
      }
      function laneToLanes(lane) {
        return lane;
      }
      function higherPriorityLane(a2, b) {
        return a2 !== NoLane && a2 < b ? a2 : b;
      }
      function createLaneMap(initial) {
        var laneMap = [];
        for (var i2 = 0; i2 < TotalLanes; i2++) {
          laneMap.push(initial);
        }
        return laneMap;
      }
      function markRootUpdated(root2, updateLane, eventTime) {
        root2.pendingLanes |= updateLane;
        if (updateLane !== IdleLane) {
          root2.suspendedLanes = NoLanes;
          root2.pingedLanes = NoLanes;
        }
        var eventTimes = root2.eventTimes;
        var index2 = laneToIndex(updateLane);
        eventTimes[index2] = eventTime;
      }
      function markRootSuspended(root2, suspendedLanes) {
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        var expirationTimes = root2.expirationTimes;
        var lanes = suspendedLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootPinged(root2, pingedLanes, eventTime) {
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      }
      function markRootFinished(root2, remainingLanes) {
        var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = NoLanes;
        root2.pingedLanes = NoLanes;
        root2.expiredLanes &= remainingLanes;
        root2.mutableReadLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        var entanglements = root2.entanglements;
        var eventTimes = root2.eventTimes;
        var expirationTimes = root2.expirationTimes;
        var lanes = noLongerPendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          entanglements[index2] = NoLanes;
          eventTimes[index2] = NoTimestamp;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        var entanglements = root2.entanglements;
        var lanes = rootEntangledLanes;
        while (lanes) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          if (
            // Is this one of the newly entangled lanes?
            lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
            entanglements[index2] & entangledLanes
          ) {
            entanglements[index2] |= entangledLanes;
          }
          lanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root2, renderLanes2) {
        var renderLane = getHighestPriorityLane(renderLanes2);
        var lane;
        switch (renderLane) {
          case InputContinuousLane:
            lane = InputContinuousHydrationLane;
            break;
          case DefaultLane:
            lane = DefaultHydrationLane;
            break;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            lane = TransitionHydrationLane;
            break;
          case IdleLane:
            lane = IdleHydrationLane;
            break;
          default:
            lane = NoLane;
            break;
        }
        if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
          return NoLane;
        }
        return lane;
      }
      function addFiberToLanesMap(root2, fiber, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          updaters.add(fiber);
          lanes &= ~lane;
        }
      }
      function movePendingFibersToMemoized(root2, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
        var memoizedUpdaters = root2.memoizedUpdaters;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          if (updaters.size > 0) {
            updaters.forEach(function(fiber) {
              var alternate = fiber.alternate;
              if (alternate === null || !memoizedUpdaters.has(alternate)) {
                memoizedUpdaters.add(fiber);
              }
            });
            updaters.clear();
          }
          lanes &= ~lane;
        }
      }
      function getTransitionsForLanes(root2, lanes) {
        {
          return null;
        }
      }
      var DiscreteEventPriority = SyncLane;
      var ContinuousEventPriority = InputContinuousLane;
      var DefaultEventPriority = DefaultLane;
      var IdleEventPriority = IdleLane;
      var currentUpdatePriority = NoLane;
      function getCurrentUpdatePriority() {
        return currentUpdatePriority;
      }
      function setCurrentUpdatePriority(newPriority) {
        currentUpdatePriority = newPriority;
      }
      function runWithPriority(priority, fn) {
        var previousPriority = currentUpdatePriority;
        try {
          currentUpdatePriority = priority;
          return fn();
        } finally {
          currentUpdatePriority = previousPriority;
        }
      }
      function higherEventPriority(a2, b) {
        return a2 !== 0 && a2 < b ? a2 : b;
      }
      function lowerEventPriority(a2, b) {
        return a2 > b ? a2 : b;
      }
      function isHigherEventPriority(a2, b) {
        return a2 !== 0 && a2 < b;
      }
      function lanesToEventPriority(lanes) {
        var lane = getHighestPriorityLane(lanes);
        if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
          return DiscreteEventPriority;
        }
        if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
          return ContinuousEventPriority;
        }
        if (includesNonIdleWork(lane)) {
          return DefaultEventPriority;
        }
        return IdleEventPriority;
      }
      function isRootDehydrated(root2) {
        var currentState = root2.current.memoizedState;
        return currentState.isDehydrated;
      }
      var _attemptSynchronousHydration;
      function setAttemptSynchronousHydration(fn) {
        _attemptSynchronousHydration = fn;
      }
      function attemptSynchronousHydration(fiber) {
        _attemptSynchronousHydration(fiber);
      }
      var attemptContinuousHydration;
      function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
      }
      var attemptHydrationAtCurrentPriority;
      function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
      }
      var getCurrentUpdatePriority$1;
      function setGetCurrentUpdatePriority(fn) {
        getCurrentUpdatePriority$1 = fn;
      }
      var attemptHydrationAtPriority;
      function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
      }
      var hasScheduledReplayAttempt = false;
      var queuedDiscreteEvents = [];
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = [
        "mousedown",
        "mouseup",
        "touchcancel",
        "touchend",
        "touchstart",
        "auxclick",
        "dblclick",
        "pointercancel",
        "pointerdown",
        "pointerup",
        "dragend",
        "dragstart",
        "drop",
        "compositionend",
        "compositionstart",
        "keydown",
        "keypress",
        "keyup",
        "input",
        "textInput",
        // Intentionally camelCase
        "copy",
        "cut",
        "paste",
        "click",
        "change",
        "contextmenu",
        "reset",
        "submit"
      ];
      function isDiscreteEventThatRequiresHydration(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
      }
      function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        };
      }
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout": {
            var pointerId = nativeEvent.pointerId;
            queuedPointers.delete(pointerId);
            break;
          }
          case "gotpointercapture":
          case "lostpointercapture": {
            var _pointerId = nativeEvent.pointerId;
            queuedPointerCaptures.delete(_pointerId);
            break;
          }
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn !== null) {
            var _fiber2 = getInstanceFromNode(blockedOn);
            if (_fiber2 !== null) {
              attemptContinuousHydration(_fiber2);
            }
          }
          return queuedEvent;
        }
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
          targetContainers.push(targetContainer);
        }
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin": {
            var focusEvent = nativeEvent;
            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
            return true;
          }
          case "dragenter": {
            var dragEvent = nativeEvent;
            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
            return true;
          }
          case "mouseover": {
            var mouseEvent = nativeEvent;
            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
            return true;
          }
          case "pointerover": {
            var pointerEvent = nativeEvent;
            var pointerId = pointerEvent.pointerId;
            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
            return true;
          }
          case "gotpointercapture": {
            var _pointerEvent = nativeEvent;
            var _pointerId2 = _pointerEvent.pointerId;
            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
            return true;
          }
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted !== null) {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance2 = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance2 !== null) {
                queuedTarget.blockedOn = instance2;
                attemptHydrationAtPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (tag === HostRoot) {
              var root2 = nearestMounted.stateNode;
              if (isRootDehydrated(root2)) {
                queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                return;
              }
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function queueExplicitHydrationTarget(target) {
        var updatePriority = getCurrentUpdatePriority$1();
        var queuedTarget = {
          blockedOn: null,
          target,
          priority: updatePriority
        };
        var i2 = 0;
        for (; i2 < queuedExplicitHydrationTargets.length; i2++) {
          if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i2].priority)) {
            break;
          }
        }
        queuedExplicitHydrationTargets.splice(i2, 0, queuedTarget);
        if (i2 === 0) {
          attemptExplicitHydrationTarget(queuedTarget);
        }
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null) {
          return false;
        }
        var targetContainers = queuedEvent.targetContainers;
        while (targetContainers.length > 0) {
          var targetContainer = targetContainers[0];
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
          if (nextBlockedOn === null) {
            {
              var nativeEvent = queuedEvent.nativeEvent;
              var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
              setReplayingEvent(nativeEventClone);
              nativeEvent.target.dispatchEvent(nativeEventClone);
              resetReplayingEvent();
            }
          } else {
            var _fiber3 = getInstanceFromNode(nextBlockedOn);
            if (_fiber3 !== null) {
              attemptContinuousHydration(_fiber3);
            }
            queuedEvent.blockedOn = nextBlockedOn;
            return false;
          }
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
          map.delete(key);
        }
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
          queuedFocus = null;
        }
        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
          queuedDrag = null;
        }
        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
          queuedMouse = null;
        }
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        if (queuedEvent.blockedOn === unblocked) {
          queuedEvent.blockedOn = null;
          if (!hasScheduledReplayAttempt) {
            hasScheduledReplayAttempt = true;
            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
          }
        }
      }
      function retryIfBlockedOn(unblocked) {
        if (queuedDiscreteEvents.length > 0) {
          scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
          for (var i2 = 1; i2 < queuedDiscreteEvents.length; i2++) {
            var queuedEvent = queuedDiscreteEvents[i2];
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
            }
          }
        }
        if (queuedFocus !== null) {
          scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        }
        if (queuedDrag !== null) {
          scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        }
        if (queuedMouse !== null) {
          scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        }
        var unblock = function(queuedEvent2) {
          return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
        };
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
          var queuedTarget = queuedExplicitHydrationTargets[_i];
          if (queuedTarget.blockedOn === unblocked) {
            queuedTarget.blockedOn = null;
          }
        }
        while (queuedExplicitHydrationTargets.length > 0) {
          var nextExplicitTarget = queuedExplicitHydrationTargets[0];
          if (nextExplicitTarget.blockedOn !== null) {
            break;
          } else {
            attemptExplicitHydrationTarget(nextExplicitTarget);
            if (nextExplicitTarget.blockedOn === null) {
              queuedExplicitHydrationTargets.shift();
            }
          }
        }
      }
      var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
      var _enabled = true;
      function setEnabled(enabled) {
        _enabled = !!enabled;
      }
      function isEnabled() {
        return _enabled;
      }
      function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriority(domEventName);
        var listenerWrapper;
        switch (eventPriority) {
          case DiscreteEventPriority:
            listenerWrapper = dispatchDiscreteEvent;
            break;
          case ContinuousEventPriority:
            listenerWrapper = dispatchContinuousEvent;
            break;
          case DefaultEventPriority:
          default:
            listenerWrapper = dispatchEvent;
            break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      }
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(DiscreteEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(ContinuousEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!_enabled) {
          return;
        }
        {
          dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        }
      }
      function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn === null) {
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
          clearIfContinuousEvent(domEventName, nativeEvent);
          return;
        }
        if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
          nativeEvent.stopPropagation();
          return;
        }
        clearIfContinuousEvent(domEventName, nativeEvent);
        if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
          while (blockedOn !== null) {
            var fiber = getInstanceFromNode(blockedOn);
            if (fiber !== null) {
              attemptSynchronousHydration(fiber);
            }
            var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (nextBlockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            }
            if (nextBlockedOn === blockedOn) {
              break;
            }
            blockedOn = nextBlockedOn;
          }
          if (blockedOn !== null) {
            nativeEvent.stopPropagation();
          }
          return;
        }
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
      var return_targetInst = null;
      function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return_targetInst = null;
        var nativeEventTarget = getEventTarget(nativeEvent);
        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted === null) {
            targetInst = null;
          } else {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance2 = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance2 !== null) {
                return instance2;
              }
              targetInst = null;
            } else if (tag === HostRoot) {
              var root2 = nearestMounted.stateNode;
              if (isRootDehydrated(root2)) {
                return getContainerFromFiber(nearestMounted);
              }
              targetInst = null;
            } else if (nearestMounted !== targetInst) {
              targetInst = null;
            }
          }
        }
        return_targetInst = targetInst;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return DiscreteEventPriority;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return ContinuousEventPriority;
          case "message": {
            var schedulerPriority = getCurrentPriorityLevel();
            switch (schedulerPriority) {
              case ImmediatePriority:
                return DiscreteEventPriority;
              case UserBlockingPriority:
                return ContinuousEventPriority;
              case NormalPriority:
              case LowPriority:
                return DefaultEventPriority;
              case IdlePriority:
                return IdleEventPriority;
              default:
                return DefaultEventPriority;
            }
          }
          default:
            return DefaultEventPriority;
        }
      }
      function addEventBubbleListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, false);
        return listener;
      }
      function addEventCaptureListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, true);
        return listener;
      }
      function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
          capture: true,
          passive
        });
        return listener;
      }
      function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
          passive
        });
        return listener;
      }
      var root = null;
      var startText = null;
      var fallbackText = null;
      function initialize(nativeEventTarget) {
        root = nativeEventTarget;
        startText = getText();
        return true;
      }
      function reset() {
        root = null;
        startText = null;
        fallbackText = null;
      }
      function getData() {
        if (fallbackText) {
          return fallbackText;
        }
        var start;
        var startValue = startText;
        var startLength = startValue.length;
        var end;
        var endValue = getText();
        var endLength = endValue.length;
        for (start = 0; start < startLength; start++) {
          if (startValue[start] !== endValue[start]) {
            break;
          }
        }
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd; end++) {
          if (startValue[startLength - end] !== endValue[endLength - end]) {
            break;
          }
        }
        var sliceTail = end > 1 ? 1 - end : void 0;
        fallbackText = endValue.slice(start, sliceTail);
        return fallbackText;
      }
      function getText() {
        if ("value" in root) {
          return root.value;
        }
        return root.textContent;
      }
      function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ("charCode" in nativeEvent) {
          charCode = nativeEvent.charCode;
          if (charCode === 0 && keyCode === 13) {
            charCode = 13;
          }
        } else {
          charCode = keyCode;
        }
        if (charCode === 10) {
          charCode = 13;
        }
        if (charCode >= 32 || charCode === 13) {
          return charCode;
        }
        return 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var _propName in Interface) {
            if (!Interface.hasOwnProperty(_propName)) {
              continue;
            }
            var normalize = Interface[_propName];
            if (normalize) {
              this[_propName] = normalize(nativeEvent);
            } else {
              this[_propName] = nativeEvent[_propName];
            }
          }
          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
          if (defaultPrevented) {
            this.isDefaultPrevented = functionThatReturnsTrue;
          } else {
            this.isDefaultPrevented = functionThatReturnsFalse;
          }
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.preventDefault) {
              event.preventDefault();
            } else if (typeof event.returnValue !== "unknown") {
              event.returnValue = false;
            }
            this.isDefaultPrevented = functionThatReturnsTrue;
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.stopPropagation) {
              event.stopPropagation();
            } else if (typeof event.cancelBubble !== "unknown") {
              event.cancelBubble = true;
            }
            this.isPropagationStopped = functionThatReturnsTrue;
          },
          /**
           * We release all dispatched `SyntheticEvent`s after each event loop, adding
           * them back into the pool. This allows a way to hold onto a reference that
           * won't be added back into the pool.
           */
          persist: function() {
          },
          /**
           * Checks if this event should be released back into the pool.
           *
           * @return {boolean} True if this should not be released, false otherwise.
           */
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, {
        view: 0,
        detail: 0
      });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      function updateMouseMovementPolyfillState(event) {
        if (event !== lastMouseEvent) {
          if (lastMouseEvent && event.type === "mousemove") {
            lastMovementX = event.screenX - lastMouseEvent.screenX;
            lastMovementY = event.screenY - lastMouseEvent.screenY;
          } else {
            lastMovementX = 0;
            lastMovementY = 0;
          }
          lastMouseEvent = event;
        }
      }
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
          return event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) {
            return event.movementX;
          }
          updateMouseMovementPolyfillState(event);
          return lastMovementX;
        },
        movementY: function(event) {
          if ("movementY" in event) {
            return event.movementY;
          }
          return lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, {
        dataTransfer: 0
      });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, {
        relatedTarget: 0
      });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, {
        data: 0
      });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var SyntheticInputEvent = SyntheticCompositionEvent;
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        "8": "Backspace",
        "9": "Tab",
        "12": "Clear",
        "13": "Enter",
        "16": "Shift",
        "17": "Control",
        "18": "Alt",
        "19": "Pause",
        "20": "CapsLock",
        "27": "Escape",
        "32": " ",
        "33": "PageUp",
        "34": "PageDown",
        "35": "End",
        "36": "Home",
        "37": "ArrowLeft",
        "38": "ArrowUp",
        "39": "ArrowRight",
        "40": "ArrowDown",
        "45": "Insert",
        "46": "Delete",
        "112": "F1",
        "113": "F2",
        "114": "F3",
        "115": "F4",
        "116": "F5",
        "117": "F6",
        "118": "F7",
        "119": "F8",
        "120": "F9",
        "121": "F10",
        "122": "F11",
        "123": "F12",
        "144": "NumLock",
        "145": "ScrollLock",
        "224": "Meta"
      };
      function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key !== "Unidentified") {
            return key;
          }
        }
        if (nativeEvent.type === "keypress") {
          var charCode = getEventCharCode(nativeEvent);
          return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
          return translateToKey[nativeEvent.keyCode] || "Unidentified";
        }
        return "";
      }
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) {
          return nativeEvent.getModifierState(keyArg);
        }
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
      }
      function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        // Legacy Interface
        charCode: function(event) {
          if (event.type === "keypress") {
            return getEventCharCode(event);
          }
          return 0;
        },
        keyCode: function(event) {
          if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode;
          }
          return 0;
        },
        which: function(event) {
          if (event.type === "keypress") {
            return getEventCharCode(event);
          }
          if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode;
          }
          return 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : (
            // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
            "wheelDeltaX" in event ? -event.wheelDeltaX : 0
          );
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : (
            // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
            "wheelDeltaY" in event ? -event.wheelDeltaY : (
              // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
              "wheelDelta" in event ? -event.wheelDelta : 0
            )
          );
        },
        deltaZ: 0,
        // Browsers without "deltaMode" is reporting in raw wheel delta where one
        // notch on the scroll is always +/- 120, roughly equivalent to pixels.
        // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
        // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var START_KEYCODE = 229;
      var canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window;
      var documentMode = null;
      if (canUseDOM2 && "documentMode" in document) {
        documentMode = document.documentMode;
      }
      var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
      var SPACEBAR_CODE = 32;
      var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
      function registerEvents() {
        registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
      }
      var hasSpaceKeypress = false;
      function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
        !(nativeEvent.ctrlKey && nativeEvent.altKey);
      }
      function getCompositionEventType(domEventName) {
        switch (domEventName) {
          case "compositionstart":
            return "onCompositionStart";
          case "compositionend":
            return "onCompositionEnd";
          case "compositionupdate":
            return "onCompositionUpdate";
        }
      }
      function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
      }
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
          case "keydown":
            return nativeEvent.keyCode !== START_KEYCODE;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === "object" && "data" in detail) {
          return detail.data;
        }
        return null;
      }
      function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === "ko";
      }
      var isComposing = false;
      function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) {
          eventType = getCompositionEventType(domEventName);
        } else if (!isComposing) {
          if (isFallbackCompositionStart(domEventName, nativeEvent)) {
            eventType = "onCompositionStart";
          }
        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
          eventType = "onCompositionEnd";
        }
        if (!eventType) {
          return null;
        }
        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
          if (!isComposing && eventType === "onCompositionStart") {
            isComposing = initialize(nativeEventTarget);
          } else if (eventType === "onCompositionEnd") {
            if (isComposing) {
              fallbackData = getData();
            }
          }
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners.length > 0) {
          var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners
          });
          if (fallbackData) {
            event.data = fallbackData;
          } else {
            var customData = getDataFromCustomEvent(nativeEvent);
            if (customData !== null) {
              event.data = customData;
            }
          }
        }
      }
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return null;
            }
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            var chars2 = nativeEvent.data;
            if (chars2 === SPACEBAR_CHAR && hasSpaceKeypress) {
              return null;
            }
            return chars2;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing) {
          if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
            var chars2 = getData();
            reset();
            isComposing = false;
            return chars2;
          }
          return null;
        }
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!isKeypressCommand(nativeEvent)) {
              if (nativeEvent.char && nativeEvent.char.length > 1) {
                return nativeEvent.char;
              } else if (nativeEvent.which) {
                return String.fromCharCode(nativeEvent.which);
              }
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars2;
        if (canUseTextInputEvent) {
          chars2 = getNativeBeforeInputChars(domEventName, nativeEvent);
        } else {
          chars2 = getFallbackBeforeInputChars(domEventName, nativeEvent);
        }
        if (!chars2) {
          return null;
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
        if (listeners.length > 0) {
          var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners
          });
          event.data = chars2;
        }
      }
      function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === "input") {
          return !!supportedInputTypes[elem.type];
        }
        if (nodeName === "textarea") {
          return true;
        }
        return false;
      }
      /**
       * Checks if an event is supported in the current execution environment.
       *
       * NOTE: This will not work correctly for non-generic events such as `change`,
       * `reset`, `load`, `error`, and `select`.
       *
       * Borrows from Modernizr.
       *
       * @param {string} eventNameSuffix Event name, e.g. "click".
       * @return {boolean} True if the event is supported.
       * @internal
       * @license Modernizr 3.0.0pre (Custom Build) | MIT
       */
      function isEventSupported(eventNameSuffix) {
        if (!canUseDOM2) {
          return false;
        }
        var eventName = "on" + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }
        return isSupported;
      }
      function registerEvents$1() {
        registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        enqueueStateRestore(target);
        var listeners = accumulateTwoPhaseListeners(inst, "onChange");
        if (listeners.length > 0) {
          var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
          dispatchQueue.push({
            event,
            listeners
          });
        }
      }
      var activeElement = null;
      var activeElementInst = null;
      function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === "select" || nodeName === "input" && elem.type === "file";
      }
      function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates(runEventInBatch, dispatchQueue);
      }
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) {
          return targetInst;
        }
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === "change") {
          return targetInst;
        }
      }
      var isInputEventSupported = false;
      if (canUseDOM2) {
        isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
      }
      function startWatchingForValueChange(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent("onpropertychange", handlePropertyChange);
      }
      function stopWatchingForValueChange() {
        if (!activeElement) {
          return;
        }
        activeElement.detachEvent("onpropertychange", handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
      }
      function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== "value") {
          return;
        }
        if (getInstIfValueChanged(activeElementInst)) {
          manualDispatchChangeEvent(nativeEvent);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        if (domEventName === "focusin") {
          stopWatchingForValueChange();
          startWatchingForValueChange(target, targetInst);
        } else if (domEventName === "focusout") {
          stopWatchingForValueChange();
        }
      }
      function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
          return getInstIfValueChanged(activeElementInst);
        }
      }
      function shouldUseClickEvent(elem) {
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === "click") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === "input" || domEventName === "change") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function handleControlledInputBlur(node) {
        var state = node._wrapperState;
        if (!state || !state.controlled || node.type !== "number") {
          return;
        }
        {
          setDefaultValue(node, "number", node.value);
        }
      }
      function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(domEventName, targetInst);
          if (inst) {
            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
            return;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(domEventName, targetNode, targetInst);
        }
        if (domEventName === "focusout") {
          handleControlledInputBlur(targetNode);
        }
      }
      function registerEvents$2() {
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      }
      function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
        var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
        if (isOverEvent && !isReplayingEvent(nativeEvent)) {
          var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
          if (related) {
            if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
              return;
            }
          }
        }
        if (!isOutEvent && !isOverEvent) {
          return;
        }
        var win;
        if (nativeEventTarget.window === nativeEventTarget) {
          win = nativeEventTarget;
        } else {
          var doc = nativeEventTarget.ownerDocument;
          if (doc) {
            win = doc.defaultView || doc.parentWindow;
          } else {
            win = window;
          }
        }
        var from;
        var to;
        if (isOutEvent) {
          var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
          from = targetInst;
          to = _related ? getClosestInstanceFromNode(_related) : null;
          if (to !== null) {
            var nearestMounted = getNearestMountedFiber(to);
            if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
              to = null;
            }
          }
        } else {
          from = null;
          to = targetInst;
        }
        if (from === to) {
          return;
        }
        var SyntheticEventCtor = SyntheticMouseEvent;
        var leaveEventType = "onMouseLeave";
        var enterEventType = "onMouseEnter";
        var eventTypePrefix = "mouse";
        if (domEventName === "pointerout" || domEventName === "pointerover") {
          SyntheticEventCtor = SyntheticPointerEvent;
          leaveEventType = "onPointerLeave";
          enterEventType = "onPointerEnter";
          eventTypePrefix = "pointer";
        }
        var fromNode = from == null ? win : getNodeFromInstance(from);
        var toNode = to == null ? win : getNodeFromInstance(to);
        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = null;
        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (nativeTargetInst === targetInst) {
          var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
          enterEvent.target = toNode;
          enterEvent.relatedTarget = fromNode;
          enter = enterEvent;
        }
        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
      }
      function is2(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is2;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) {
          return true;
        }
        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
          return false;
        }
        for (var i2 = 0; i2 < keysA.length; i2++) {
          var currentKey = keysA[i2];
          if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
            return false;
          }
        }
        return true;
      }
      function getLeafNode(node) {
        while (node && node.firstChild) {
          node = node.firstChild;
        }
        return node;
      }
      function getSiblingNode(node) {
        while (node) {
          if (node.nextSibling) {
            return node.nextSibling;
          }
          node = node.parentNode;
        }
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        var nodeStart = 0;
        var nodeEnd = 0;
        while (node) {
          if (node.nodeType === TEXT_NODE) {
            nodeEnd = nodeStart + node.textContent.length;
            if (nodeStart <= offset && nodeEnd >= offset) {
              return {
                node,
                offset: offset - nodeStart
              };
            }
            nodeStart = nodeEnd;
          }
          node = getLeafNode(getSiblingNode(node));
        }
      }
      function getOffsets(outerNode) {
        var ownerDocument2 = outerNode.ownerDocument;
        var win = ownerDocument2 && ownerDocument2.defaultView || window;
        var selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0) {
          return null;
        }
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
        try {
          anchorNode.nodeType;
          focusNode.nodeType;
        } catch (e2) {
          return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
      }
      function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length = 0;
        var start = -1;
        var end = -1;
        var indexWithinAnchor = 0;
        var indexWithinFocus = 0;
        var node = outerNode;
        var parentNode = null;
        outer: while (true) {
          var next = null;
          while (true) {
            if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
              start = length + anchorOffset;
            }
            if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
              end = length + focusOffset;
            }
            if (node.nodeType === TEXT_NODE) {
              length += node.nodeValue.length;
            }
            if ((next = node.firstChild) === null) {
              break;
            }
            parentNode = node;
            node = next;
          }
          while (true) {
            if (node === outerNode) {
              break outer;
            }
            if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
              start = length;
            }
            if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
              end = length;
            }
            if ((next = node.nextSibling) !== null) {
              break;
            }
            node = parentNode;
            parentNode = node.parentNode;
          }
          node = next;
        }
        if (start === -1 || end === -1) {
          return null;
        }
        return {
          start,
          end
        };
      }
      function setOffsets(node, offsets) {
        var doc = node.ownerDocument || document;
        var win = doc && doc.defaultView || window;
        if (!win.getSelection) {
          return;
        }
        var selection = win.getSelection();
        var length = node.textContent.length;
        var start = Math.min(offsets.start, length);
        var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
        if (!selection.extend && start > end) {
          var temp = end;
          end = start;
          start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
          if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
            return;
          }
          var range = doc.createRange();
          range.setStart(startMarker.node, startMarker.offset);
          selection.removeAllRanges();
          if (start > end) {
            selection.addRange(range);
            selection.extend(endMarker.node, endMarker.offset);
          } else {
            range.setEnd(endMarker.node, endMarker.offset);
            selection.addRange(range);
          }
        }
      }
      function isTextNode(node) {
        return node && node.nodeType === TEXT_NODE;
      }
      function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
          return false;
        } else if (outerNode === innerNode) {
          return true;
        } else if (isTextNode(outerNode)) {
          return false;
        } else if (isTextNode(innerNode)) {
          return containsNode(outerNode, innerNode.parentNode);
        } else if ("contains" in outerNode) {
          return outerNode.contains(innerNode);
        } else if (outerNode.compareDocumentPosition) {
          return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        } else {
          return false;
        }
      }
      function isInDocument(node) {
        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
      }
      function isSameOriginFrame(iframe) {
        try {
          return typeof iframe.contentWindow.location.href === "string";
        } catch (err) {
          return false;
        }
      }
      function getActiveElementDeep() {
        var win = window;
        var element = getActiveElement();
        while (element instanceof win.HTMLIFrameElement) {
          if (isSameOriginFrame(element)) {
            win = element.contentWindow;
          } else {
            return element;
          }
          element = getActiveElement(win.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
      }
      function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
          focusedElem,
          selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
        };
      }
      function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
          if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
            setSelection(priorFocusedElem, priorSelectionRange);
          }
          var ancestors = [];
          var ancestor = priorFocusedElem;
          while (ancestor = ancestor.parentNode) {
            if (ancestor.nodeType === ELEMENT_NODE) {
              ancestors.push({
                element: ancestor,
                left: ancestor.scrollLeft,
                top: ancestor.scrollTop
              });
            }
          }
          if (typeof priorFocusedElem.focus === "function") {
            priorFocusedElem.focus();
          }
          for (var i2 = 0; i2 < ancestors.length; i2++) {
            var info = ancestors[i2];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
      }
      function getSelection(input) {
        var selection;
        if ("selectionStart" in input) {
          selection = {
            start: input.selectionStart,
            end: input.selectionEnd
          };
        } else {
          selection = getOffsets(input);
        }
        return selection || {
          start: 0,
          end: 0
        };
      }
      function setSelection(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === void 0) {
          end = start;
        }
        if ("selectionStart" in input) {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, input.value.length);
        } else {
          setOffsets(input, offsets);
        }
      }
      var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && document.documentMode <= 11;
      function registerEvents$3() {
        registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      var lastSelection = null;
      var mouseDown = false;
      function getSelection$1(node) {
        if ("selectionStart" in node && hasSelectionCapabilities(node)) {
          return {
            start: node.selectionStart,
            end: node.selectionEnd
          };
        } else {
          var win = node.ownerDocument && node.ownerDocument.defaultView || window;
          var selection = win.getSelection();
          return {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
          };
        }
      }
      function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
      }
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = getEventTargetDocument(nativeEventTarget);
        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
          return;
        }
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
          lastSelection = currentSelection;
          var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.target = activeElement$1;
          }
        }
      }
      function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
              activeElement$1 = targetNode;
              activeElementInst$1 = targetInst;
              lastSelection = null;
            }
            break;
          case "focusout":
            activeElement$1 = null;
            activeElementInst$1 = null;
            lastSelection = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) {
              break;
            }
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes2 = {};
        prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes2["Webkit" + styleProp] = "webkit" + eventName;
        prefixes2["Moz" + styleProp] = "moz" + eventName;
        return prefixes2;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style2 = {};
      if (canUseDOM2) {
        style2 = document.createElement("div").style;
        if (!("AnimationEvent" in window)) {
          delete vendorPrefixes.animationend.animation;
          delete vendorPrefixes.animationiteration.animation;
          delete vendorPrefixes.animationstart.animation;
        }
        if (!("TransitionEvent" in window)) {
          delete vendorPrefixes.transitionend.transition;
        }
      }
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) {
          return prefixedEventNames[eventName];
        } else if (!vendorPrefixes[eventName]) {
          return eventName;
        }
        var prefixMap = vendorPrefixes[eventName];
        for (var styleProp in prefixMap) {
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2) {
            return prefixedEventNames[eventName] = prefixMap[styleProp];
          }
        }
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      function registerSimpleEvents() {
        for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {
          var eventName = simpleEventPluginEvents[i2];
          var domEventName = eventName.toLowerCase();
          var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
          registerSimpleEvent(domEventName, "on" + capitalizedEvent);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      }
      function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName === void 0) {
          return;
        }
        var SyntheticEventCtor = SyntheticEvent;
        var reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (getEventCharCode(nativeEvent) === 0) {
              return;
            }
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (nativeEvent.button === 2) {
              return;
            }
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        {
          var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          domEventName === "scroll";
          var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
          if (_listeners.length > 0) {
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event: _event,
              listeners: _listeners
            });
          }
        }
      }
      registerSimpleEvents();
      registerEvents$2();
      registerEvents$1();
      registerEvents$3();
      registerEvents();
      function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
        if (shouldProcessPolyfillPlugins) {
          extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
      }
      var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
      var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
      function executeDispatch(event, listener, currentTarget) {
        var type = event.type || "unknown-event";
        event.currentTarget = currentTarget;
        invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
        event.currentTarget = null;
      }
      function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase) {
          for (var i2 = dispatchListeners.length - 1; i2 >= 0; i2--) {
            var _dispatchListeners$i = dispatchListeners[i2], instance2 = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance2 !== previousInstance && event.isPropagationStopped()) {
              return;
            }
            executeDispatch(event, listener, currentTarget);
            previousInstance = instance2;
          }
        } else {
          for (var _i = 0; _i < dispatchListeners.length; _i++) {
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event.isPropagationStopped()) {
              return;
            }
            executeDispatch(event, _listener, _currentTarget);
            previousInstance = _instance;
          }
        }
      }
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
          var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
          processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
        }
        rethrowCaughtError();
      }
      function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent);
        var dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        {
          if (!nonDelegatedEvents.has(domEventName)) {
            error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
          }
        }
        var isCapturePhaseListener = false;
        var listenerSet = getEventListenerSet(targetElement);
        var listenerSetKey = getListenerSetKey(domEventName);
        if (!listenerSet.has(listenerSetKey)) {
          addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
          listenerSet.add(listenerSetKey);
        }
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        {
          if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
            error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
          }
        }
        var eventSystemFlags = 0;
        if (isCapturePhaseListener) {
          eventSystemFlags |= IS_CAPTURE_PHASE;
        }
        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            if (domEventName !== "selectionchange") {
              if (!nonDelegatedEvents.has(domEventName)) {
                listenToNativeEvent(domEventName, false, rootContainerElement);
              }
              listenToNativeEvent(domEventName, true, rootContainerElement);
            }
          });
          var ownerDocument2 = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          if (ownerDocument2 !== null) {
            if (!ownerDocument2[listeningMarker]) {
              ownerDocument2[listeningMarker] = true;
              listenToNativeEvent("selectionchange", false, ownerDocument2);
            }
          }
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
        var isPassiveListener = void 0;
        if (passiveBrowserEventsSupported) {
          if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
            isPassiveListener = true;
          }
        }
        targetContainer = targetContainer;
        if (isCapturePhaseListener) {
          if (isPassiveListener !== void 0) {
            addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            addEventCaptureListener(targetContainer, domEventName, listener);
          }
        } else {
          if (isPassiveListener !== void 0) {
            addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            addEventBubbleListener(targetContainer, domEventName, listener);
          }
        }
      }
      function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
          var targetContainerNode = targetContainer;
          if (targetInst !== null) {
            var node = targetInst;
            mainLoop: while (true) {
              if (node === null) {
                return;
              }
              var nodeTag = node.tag;
              if (nodeTag === HostRoot || nodeTag === HostPortal) {
                var container = node.stateNode.containerInfo;
                if (isMatchingRootContainer(container, targetContainerNode)) {
                  break;
                }
                if (nodeTag === HostPortal) {
                  var grandNode = node.return;
                  while (grandNode !== null) {
                    var grandTag = grandNode.tag;
                    if (grandTag === HostRoot || grandTag === HostPortal) {
                      var grandContainer = grandNode.stateNode.containerInfo;
                      if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                        return;
                      }
                    }
                    grandNode = grandNode.return;
                  }
                }
                while (container !== null) {
                  var parentNode = getClosestInstanceFromNode(container);
                  if (parentNode === null) {
                    return;
                  }
                  var parentTag = parentNode.tag;
                  if (parentTag === HostComponent || parentTag === HostText) {
                    node = ancestorInst = parentNode;
                    continue mainLoop;
                  }
                  container = container.parentNode;
                }
              }
              node = node.return;
            }
          }
        }
        batchedUpdates(function() {
          return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
      }
      function createDispatchListener(instance2, listener, currentTarget) {
        return {
          instance: instance2,
          listener,
          currentTarget
        };
      }
      function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
        var captureName = reactName !== null ? reactName + "Capture" : null;
        var reactEventName = inCapturePhase ? captureName : reactName;
        var listeners = [];
        var instance2 = targetFiber;
        var lastHostComponent = null;
        while (instance2 !== null) {
          var _instance2 = instance2, stateNode = _instance2.stateNode, tag = _instance2.tag;
          if (tag === HostComponent && stateNode !== null) {
            lastHostComponent = stateNode;
            if (reactEventName !== null) {
              var listener = getListener(instance2, reactEventName);
              if (listener != null) {
                listeners.push(createDispatchListener(instance2, listener, lastHostComponent));
              }
            }
          }
          if (accumulateTargetOnly) {
            break;
          }
          instance2 = instance2.return;
        }
        return listeners;
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        var captureName = reactName + "Capture";
        var listeners = [];
        var instance2 = targetFiber;
        while (instance2 !== null) {
          var _instance3 = instance2, stateNode = _instance3.stateNode, tag = _instance3.tag;
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            var captureListener = getListener(instance2, captureName);
            if (captureListener != null) {
              listeners.unshift(createDispatchListener(instance2, captureListener, currentTarget));
            }
            var bubbleListener = getListener(instance2, reactName);
            if (bubbleListener != null) {
              listeners.push(createDispatchListener(instance2, bubbleListener, currentTarget));
            }
          }
          instance2 = instance2.return;
        }
        return listeners;
      }
      function getParent(inst) {
        if (inst === null) {
          return null;
        }
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);
        if (inst) {
          return inst;
        }
        return null;
      }
      function getLowestCommonAncestor(instA, instB) {
        var nodeA = instA;
        var nodeB = instB;
        var depthA = 0;
        for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }
        var depthB = 0;
        for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }
        while (depthA - depthB > 0) {
          nodeA = getParent(nodeA);
          depthA--;
        }
        while (depthB - depthA > 0) {
          nodeB = getParent(nodeB);
          depthB--;
        }
        var depth = depthA;
        while (depth--) {
          if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
            return nodeA;
          }
          nodeA = getParent(nodeA);
          nodeB = getParent(nodeB);
        }
        return null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        var registrationName = event._reactName;
        var listeners = [];
        var instance2 = target;
        while (instance2 !== null) {
          if (instance2 === common) {
            break;
          }
          var _instance4 = instance2, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
          if (alternate !== null && alternate === common) {
            break;
          }
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            if (inCapturePhase) {
              var captureListener = getListener(instance2, registrationName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance2, captureListener, currentTarget));
              }
            } else if (!inCapturePhase) {
              var bubbleListener = getListener(instance2, registrationName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance2, bubbleListener, currentTarget));
              }
            }
          }
          instance2 = instance2.return;
        }
        if (listeners.length !== 0) {
          dispatchQueue.push({
            event,
            listeners
          });
        }
      }
      function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
        var common = from && to ? getLowestCommonAncestor(from, to) : null;
        if (from !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
        }
        if (to !== null && enterEvent !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
        }
      }
      function getListenerSetKey(domEventName, capture) {
        return domEventName + "__bubble";
      }
      var didWarnInvalidHydration = false;
      var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
      var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
      var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
      var AUTOFOCUS = "autoFocus";
      var CHILDREN = "children";
      var STYLE = "style";
      var HTML$1 = "__html";
      var warnedUnknownTags;
      var validatePropertiesInDevelopment;
      var warnForPropDifference;
      var warnForExtraAttributes;
      var warnForInvalidEventListener;
      var canDiffStyleForHydrationWarning;
      var normalizeHTML;
      {
        warnedUnknownTags = {
          // There are working polyfills for <dialog>. Let people use it.
          dialog: true,
          // Electron ships a custom <webview> tag to display external web content in
          // an isolated frame and process.
          // This tag is not present in non Electron environments such as JSDom which
          // is often used for testing purposes.
          // @see https://electronjs.org/docs/api/webview-tag
          webview: true
        };
        validatePropertiesInDevelopment = function(type, props) {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, {
            registrationNameDependencies,
            possibleRegistrationNames
          });
        };
        canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;
        warnForPropDifference = function(propName, serverValue, clientValue) {
          if (didWarnInvalidHydration) {
            return;
          }
          var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
          var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
          if (normalizedServerValue === normalizedClientValue) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
        };
        warnForExtraAttributes = function(attributeNames) {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          var names2 = [];
          attributeNames.forEach(function(name2) {
            names2.push(name2);
          });
          error("Extra attributes from the server: %s", names2);
        };
        warnForInvalidEventListener = function(registrationName, listener) {
          if (listener === false) {
            error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
          } else {
            error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
          }
        };
        normalizeHTML = function(parent, html) {
          var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
          testElement.innerHTML = html;
          return testElement.innerHTML;
        };
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        {
          checkHtmlStringCoercion(markup);
        }
        var markupString = typeof markup === "string" ? markup : "" + markup;
        return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
        if (normalizedServerText === normalizedClientText) {
          return;
        }
        if (shouldWarnDev) {
          {
            if (!didWarnInvalidHydration) {
              didWarnInvalidHydration = true;
              error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            }
          }
        }
        if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
          throw new Error("Text content does not match server-rendered HTML.");
        }
      }
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function noop2() {
      }
      function trapClickOnNonInteractiveElement(node) {
        node.onclick = noop2;
      }
      function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for (var propKey in nextProps) {
          if (!nextProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = nextProps[propKey];
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            setValueForStyles(domElement, nextProp);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            if (nextHtml != null) {
              setInnerHTML(domElement, nextHtml);
            }
          } else if (propKey === CHILDREN) {
            if (typeof nextProp === "string") {
              var canSetTextContent = tag !== "textarea" || nextProp !== "";
              if (canSetTextContent) {
                setTextContent(domElement, nextProp);
              }
            } else if (typeof nextProp === "number") {
              setTextContent(domElement, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (propKey === AUTOFOCUS) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (nextProp != null) {
            setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
          }
        }
      }
      function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        for (var i2 = 0; i2 < updatePayload.length; i2 += 2) {
          var propKey = updatePayload[i2];
          var propValue = updatePayload[i2 + 1];
          if (propKey === STYLE) {
            setValueForStyles(domElement, propValue);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            setInnerHTML(domElement, propValue);
          } else if (propKey === CHILDREN) {
            setTextContent(domElement, propValue);
          } else {
            setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
          }
        }
      }
      function createElement2(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag;
        var ownerDocument2 = getOwnerDocumentFromRootContainer(rootContainerElement);
        var domElement;
        var namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE) {
          namespaceURI = getIntrinsicNamespace(type);
        }
        if (namespaceURI === HTML_NAMESPACE) {
          {
            isCustomComponentTag = isCustomComponent(type, props);
            if (!isCustomComponentTag && type !== type.toLowerCase()) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
          if (type === "script") {
            var div = ownerDocument2.createElement("div");
            div.innerHTML = "<script><\/script>";
            var firstChild = div.firstChild;
            domElement = div.removeChild(firstChild);
          } else if (typeof props.is === "string") {
            domElement = ownerDocument2.createElement(type, {
              is: props.is
            });
          } else {
            domElement = ownerDocument2.createElement(type);
            if (type === "select") {
              var node = domElement;
              if (props.multiple) {
                node.multiple = true;
              } else if (props.size) {
                node.size = props.size;
              }
            }
          }
        } else {
          domElement = ownerDocument2.createElementNS(namespaceURI, type);
        }
        {
          if (namespaceURI === HTML_NAMESPACE) {
            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty2.call(warnedUnknownTags, type)) {
              warnedUnknownTags[type] = true;
              error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
            }
          }
        }
        return domElement;
      }
      function createTextNode(text, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
      }
      function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        {
          validatePropertiesInDevelopment(tag, rawProps);
        }
        var props;
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            props = rawProps;
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "video":
          case "audio":
            for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
              listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
            }
            props = rawProps;
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            props = rawProps;
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            props = rawProps;
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            props = getHostProps(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            props = rawProps;
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            props = getHostProps$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            props = getHostProps$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          default:
            props = rawProps;
        }
        assertValidProps(tag, props);
        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, false);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "option":
            postMountWrapper$1(domElement, rawProps);
            break;
          case "select":
            postMountWrapper$2(domElement, rawProps);
            break;
          default:
            if (typeof props.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
      }
      function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        {
          validatePropertiesInDevelopment(tag, nextRawProps);
        }
        var updatePayload = null;
        var lastProps;
        var nextProps;
        switch (tag) {
          case "input":
            lastProps = getHostProps(domElement, lastRawProps);
            nextProps = getHostProps(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "select":
            lastProps = getHostProps$1(domElement, lastRawProps);
            nextProps = getHostProps$1(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "textarea":
            lastProps = getHostProps$2(domElement, lastRawProps);
            nextProps = getHostProps$2(domElement, nextRawProps);
            updatePayload = [];
            break;
          default:
            lastProps = lastRawProps;
            nextProps = nextRawProps;
            if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        assertValidProps(tag, nextProps);
        var propKey;
        var styleName;
        var styleUpdates = null;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                if (!styleUpdates) {
                  styleUpdates = {};
                }
                styleUpdates[styleName] = "";
              }
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
          else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (propKey === AUTOFOCUS) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (!updatePayload) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, null);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps != null ? lastProps[propKey] : void 0;
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
            continue;
          }
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              if (!styleUpdates) {
                if (!updatePayload) {
                  updatePayload = [];
                }
                updatePayload.push(propKey, styleUpdates);
              }
              styleUpdates = nextProp;
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
            if (nextHtml != null) {
              if (lastHtml !== nextHtml) {
                (updatePayload = updatePayload || []).push(propKey, nextHtml);
              }
            }
          } else if (propKey === CHILDREN) {
            if (typeof nextProp === "string" || typeof nextProp === "number") {
              (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
            if (!updatePayload && lastProp !== nextProp) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, nextProp);
          }
        }
        if (styleUpdates) {
          {
            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
          }
          (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
        }
        return updatePayload;
      }
      function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
          updateChecked(domElement, nextRawProps);
        }
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
        var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
        switch (tag) {
          case "input":
            updateWrapper(domElement, nextRawProps);
            break;
          case "textarea":
            updateWrapper$1(domElement, nextRawProps);
            break;
          case "select":
            postUpdateWrapper(domElement, nextRawProps);
            break;
        }
      }
      function getPossibleStandardName(propName) {
        {
          var lowerCasedName = propName.toLowerCase();
          if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            return null;
          }
          return possibleStandardNames[lowerCasedName] || null;
        }
      }
      function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
        var isCustomComponentTag;
        var extraAttributeNames;
        {
          isCustomComponentTag = isCustomComponent(tag, rawProps);
          validatePropertiesInDevelopment(tag, rawProps);
        }
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
              listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
            }
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
        }
        assertValidProps(tag, rawProps);
        {
          extraAttributeNames = /* @__PURE__ */ new Set();
          var attributes = domElement.attributes;
          for (var _i = 0; _i < attributes.length; _i++) {
            var name2 = attributes[_i].name.toLowerCase();
            switch (name2) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributeNames.add(attributes[_i].name);
            }
          }
        }
        var updatePayload = null;
        for (var propKey in rawProps) {
          if (!rawProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = rawProps[propKey];
          if (propKey === CHILDREN) {
            if (typeof nextProp === "string") {
              if (domElement.textContent !== nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN, nextProp];
              }
            } else if (typeof nextProp === "number") {
              if (domElement.textContent !== "" + nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN, "" + nextProp];
              }
            }
          } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof isCustomComponentTag === "boolean") {
            var serverValue = void 0;
            var propertyInfo = getPropertyInfo(propKey);
            if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            propKey === "value" || propKey === "checked" || propKey === "selected") ;
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var serverHTML = domElement.innerHTML;
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                var expectedHTML = normalizeHTML(domElement, nextHtml);
                if (expectedHTML !== serverHTML) {
                  warnForPropDifference(propKey, serverHTML, expectedHTML);
                }
              }
            } else if (propKey === STYLE) {
              extraAttributeNames.delete(propKey);
              if (canDiffStyleForHydrationWarning) {
                var expectedStyle = createDangerousStringForStyles(nextProp);
                serverValue = domElement.getAttribute("style");
                if (expectedStyle !== serverValue) {
                  warnForPropDifference(propKey, serverValue, expectedStyle);
                }
              }
            } else if (isCustomComponentTag && true) {
              extraAttributeNames.delete(propKey.toLowerCase());
              serverValue = getValueForAttribute(domElement, propKey, nextProp);
              if (nextProp !== serverValue) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
              var isMismatchDueToBadCasing = false;
              if (propertyInfo !== null) {
                extraAttributeNames.delete(propertyInfo.attributeName);
                serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
              } else {
                var ownNamespace = parentNamespace;
                if (ownNamespace === HTML_NAMESPACE) {
                  ownNamespace = getIntrinsicNamespace(tag);
                }
                if (ownNamespace === HTML_NAMESPACE) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                } else {
                  var standardName = getPossibleStandardName(propKey);
                  if (standardName !== null && standardName !== propKey) {
                    isMismatchDueToBadCasing = true;
                    extraAttributeNames.delete(standardName);
                  }
                  extraAttributeNames.delete(propKey);
                }
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
              }
              var dontWarnCustomElement = enableCustomElementPropertySupport;
              if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            }
          }
        }
        {
          if (shouldWarnDev) {
            if (
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
            ) {
              warnForExtraAttributes(extraAttributeNames);
            }
          }
        }
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, true);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "select":
          case "option":
            break;
          default:
            if (typeof rawProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        return updatePayload;
      }
      function diffHydratedText(textNode, text, isConcurrentMode) {
        var isDifferent = textNode.nodeValue !== text;
        return isDifferent;
      }
      function warnForDeletedHydratableElement(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
        }
      }
      function warnForDeletedHydratableText(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedElement(parentNode, tag, props) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedText(parentNode, text) {
        {
          if (text === "") {
            return;
          }
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
        }
      }
      function restoreControlledState$3(domElement, tag, props) {
        switch (tag) {
          case "input":
            restoreControlledState(domElement, props);
            return;
          case "textarea":
            restoreControlledState$2(domElement, props);
            return;
          case "select":
            restoreControlledState$1(domElement, props);
            return;
        }
      }
      var validateDOMNesting = function() {
      };
      var updatedAncestorInfo = function() {
      };
      {
        var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
        var inScopeTags = [
          "applet",
          "caption",
          "html",
          "table",
          "td",
          "th",
          "marquee",
          "object",
          "template",
          // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
          // TODO: Distinguish by namespace here -- for <title>, including it here
          // errs on the side of fewer warnings
          "foreignObject",
          "desc",
          "title"
        ];
        var buttonScopeTags = inScopeTags.concat(["button"]);
        var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
        var emptyAncestorInfo = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null
        };
        updatedAncestorInfo = function(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
          var info = {
            tag
          };
          if (inScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.aTagInScope = null;
            ancestorInfo.buttonTagInScope = null;
            ancestorInfo.nobrTagInScope = null;
          }
          if (buttonScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.pTagInButtonScope = null;
          }
          if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
            ancestorInfo.listItemTagAutoclosing = null;
            ancestorInfo.dlItemTagAutoclosing = null;
          }
          ancestorInfo.current = info;
          if (tag === "form") {
            ancestorInfo.formTag = info;
          }
          if (tag === "a") {
            ancestorInfo.aTagInScope = info;
          }
          if (tag === "button") {
            ancestorInfo.buttonTagInScope = info;
          }
          if (tag === "nobr") {
            ancestorInfo.nobrTagInScope = info;
          }
          if (tag === "p") {
            ancestorInfo.pTagInButtonScope = info;
          }
          if (tag === "li") {
            ancestorInfo.listItemTagAutoclosing = info;
          }
          if (tag === "dd" || tag === "dt") {
            ancestorInfo.dlItemTagAutoclosing = info;
          }
          return ancestorInfo;
        };
        var isTagValidWithParent = function(tag, parentTag) {
          switch (parentTag) {
            case "select":
              return tag === "option" || tag === "optgroup" || tag === "#text";
            case "optgroup":
              return tag === "option" || tag === "#text";
            case "option":
              return tag === "#text";
            case "tr":
              return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
            case "tbody":
            case "thead":
            case "tfoot":
              return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
            case "colgroup":
              return tag === "col" || tag === "template";
            case "table":
              return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
            case "head":
              return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
            case "html":
              return tag === "head" || tag === "body" || tag === "frameset";
            case "frameset":
              return tag === "frame";
            case "#document":
              return tag === "html";
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
            case "rp":
            case "rt":
              return impliedEndTags.indexOf(parentTag) === -1;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return parentTag == null;
          }
          return true;
        };
        var findInvalidAncestorForTag = function(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        };
        var didWarn$1 = {};
        validateDOMNesting = function(childTag, childText, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfo;
          var parentInfo = ancestorInfo.current;
          var parentTag = parentInfo && parentInfo.tag;
          if (childText != null) {
            if (childTag != null) {
              error("validateDOMNesting: when childText is passed, childTag should be null");
            }
            childTag = "#text";
          }
          var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
          var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          var invalidParentOrAncestor = invalidParent || invalidAncestor;
          if (!invalidParentOrAncestor) {
            return;
          }
          var ancestorTag = invalidParentOrAncestor.tag;
          var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
          if (didWarn$1[warnKey]) {
            return;
          }
          didWarn$1[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = "";
          if (childTag === "#text") {
            if (/\S/.test(childText)) {
              tagDisplayName = "Text nodes";
            } else {
              tagDisplayName = "Whitespace text nodes";
              whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
            }
          } else {
            tagDisplayName = "<" + childTag + ">";
          }
          if (invalidParent) {
            var info = "";
            if (ancestorTag === "table" && childTag === "tr") {
              info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
            }
            error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
          } else {
            error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
          }
        };
      }
      var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
      var SUSPENSE_START_DATA = "$";
      var SUSPENSE_END_DATA = "/$";
      var SUSPENSE_PENDING_START_DATA = "$?";
      var SUSPENSE_FALLBACK_START_DATA = "$!";
      var STYLE$1 = "style";
      var eventsEnabled = null;
      var selectionInformation = null;
      function getRootHostContext(rootContainerInstance) {
        var type;
        var namespace;
        var nodeType = rootContainerInstance.nodeType;
        switch (nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
            var root2 = rootContainerInstance.documentElement;
            namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
            break;
          }
          default: {
            var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
            var ownNamespace = container.namespaceURI || null;
            type = container.tagName;
            namespace = getChildNamespace(ownNamespace, type);
            break;
          }
        }
        {
          var validatedTag = type.toLowerCase();
          var ancestorInfo = updatedAncestorInfo(null, validatedTag);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        {
          var parentHostContextDev = parentHostContext;
          var namespace = getChildNamespace(parentHostContextDev.namespace, type);
          var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getPublicInstance(instance2) {
        return instance2;
      }
      function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled();
        selectionInformation = getSelectionInformation();
        var activeInstance = null;
        setEnabled(false);
        return activeInstance;
      }
      function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation);
        setEnabled(eventsEnabled);
        eventsEnabled = null;
        selectionInformation = null;
      }
      function createInstance2(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          validateDOMNesting(type, null, hostContextDev.ancestorInfo);
          if (typeof props.children === "string" || typeof props.children === "number") {
            var string = "" + props.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
          parentNamespace = hostContextDev.namespace;
        }
        var domElement = createElement2(type, props, rootContainerInstance, parentNamespace);
        precacheFiberNode(internalInstanceHandle, domElement);
        updateFiberProps(domElement, props);
        return domElement;
      }
      function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        setInitialProperties(domElement, type, props, rootContainerInstance);
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!props.autoFocus;
          case "img":
            return true;
          default:
            return false;
        }
      }
      function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        {
          var hostContextDev = hostContext;
          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
            var string = "" + newProps.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
        }
        return diffProperties(domElement, type, oldProps, newProps);
      }
      function shouldSetTextContent(type, props) {
        return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
      }
      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        {
          var hostContextDev = hostContext;
          validateDOMNesting(null, text, hostContextDev.ancestorInfo);
        }
        var textNode = createTextNode(text, rootContainerInstance);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
      }
      function getCurrentEventPriority() {
        var currentEvent = window.event;
        if (currentEvent === void 0) {
          return DefaultEventPriority;
        }
        return getEventPriority(currentEvent.type);
      }
      var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
      var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
      var noTimeout = -1;
      var localPromise = typeof Promise === "function" ? Promise : void 0;
      var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error2) {
        setTimeout(function() {
          throw error2;
        });
      }
      function commitMount(domElement, type, newProps, internalInstanceHandle) {
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            if (newProps.autoFocus) {
              domElement.focus();
            }
            return;
          case "img": {
            if (newProps.src) {
              domElement.src = newProps.src;
            }
            return;
          }
        }
      }
      function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
        updateFiberProps(domElement, newProps);
      }
      function resetTextContent(domElement) {
        setTextContent(domElement, "");
      }
      function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      }
      function appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function appendChildToContainer(container, child) {
        var parentNode;
        if (container.nodeType === COMMENT_NODE) {
          parentNode = container.parentNode;
          parentNode.insertBefore(child, container);
        } else {
          parentNode = container;
          parentNode.appendChild(child);
        }
        var reactRootContainer = container._reactRootContainer;
        if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
          trapClickOnNonInteractiveElement(parentNode);
        }
      }
      function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
      }
      function insertInContainerBefore(container, child, beforeChild) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.insertBefore(child, beforeChild);
        } else {
          container.insertBefore(child, beforeChild);
        }
      }
      function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
      }
      function removeChildFromContainer(container, child) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.removeChild(child);
        } else {
          container.removeChild(child);
        }
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance;
        var depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && nextNode.nodeType === COMMENT_NODE) {
            var data = nextNode.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
              depth++;
            }
          }
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
        if (container.nodeType === COMMENT_NODE) {
          clearSuspenseBoundary(container.parentNode, suspenseInstance);
        } else if (container.nodeType === ELEMENT_NODE) {
          clearSuspenseBoundary(container, suspenseInstance);
        }
        retryIfBlockedOn(container);
      }
      function hideInstance(instance2) {
        instance2 = instance2;
        var style22 = instance2.style;
        if (typeof style22.setProperty === "function") {
          style22.setProperty("display", "none", "important");
        } else {
          style22.display = "none";
        }
      }
      function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
      }
      function unhideInstance(instance2, props) {
        instance2 = instance2;
        var styleProp = props[STYLE$1];
        var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
        instance2.style.display = dangerousStyleValue("display", display);
      }
      function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
      }
      function clearContainer(container) {
        if (container.nodeType === ELEMENT_NODE) {
          container.textContent = "";
        } else if (container.nodeType === DOCUMENT_NODE) {
          if (container.documentElement) {
            container.removeChild(container.documentElement);
          }
        }
      }
      function canHydrateInstance(instance2, type, props) {
        if (instance2.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance2.nodeName.toLowerCase()) {
          return null;
        }
        return instance2;
      }
      function canHydrateTextInstance(instance2, text) {
        if (text === "" || instance2.nodeType !== TEXT_NODE) {
          return null;
        }
        return instance2;
      }
      function canHydrateSuspenseInstance(instance2) {
        if (instance2.nodeType !== COMMENT_NODE) {
          return null;
        }
        return instance2;
      }
      function isSuspenseInstancePending(instance2) {
        return instance2.data === SUSPENSE_PENDING_START_DATA;
      }
      function isSuspenseInstanceFallback(instance2) {
        return instance2.data === SUSPENSE_FALLBACK_START_DATA;
      }
      function getSuspenseInstanceFallbackErrorDetails(instance2) {
        var dataset = instance2.nextSibling && instance2.nextSibling.dataset;
        var digest, message2, stack;
        if (dataset) {
          digest = dataset.dgst;
          {
            message2 = dataset.msg;
            stack = dataset.stck;
          }
        }
        {
          return {
            message: message2,
            digest,
            stack
          };
        }
      }
      function registerSuspenseInstanceRetry(instance2, callback) {
        instance2._reactRetry = callback;
      }
      function getNextHydratable(node) {
        for (; node != null; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
            break;
          }
          if (nodeType === COMMENT_NODE) {
            var nodeData = node.data;
            if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
              break;
            }
            if (nodeData === SUSPENSE_END_DATA) {
              return null;
            }
          }
        }
        return node;
      }
      function getNextHydratableSibling(instance2) {
        return getNextHydratable(instance2.nextSibling);
      }
      function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
      }
      function getFirstHydratableChildWithinContainer(parentContainer) {
        return getNextHydratable(parentContainer.firstChild);
      }
      function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
        return getNextHydratable(parentInstance.nextSibling);
      }
      function hydrateInstance(instance2, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, instance2);
        updateFiberProps(instance2, props);
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          parentNamespace = hostContextDev.namespace;
        }
        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedProperties(instance2, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
      }
      function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedText(textInstance, text);
      }
      function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, suspenseInstance);
      }
      function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        var node = suspenseInstance.nextSibling;
        var depth = 0;
        while (node) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                return getNextHydratableSibling(node);
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              depth++;
            }
          }
          node = node.nextSibling;
        }
        return null;
      }
      function getParentSuspenseInstance(targetInstance) {
        var node = targetInstance.previousSibling;
        var depth = 0;
        while (node) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              if (depth === 0) {
                return node;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_END_DATA) {
              depth++;
            }
          }
          node = node.previousSibling;
        }
        return null;
      }
      function commitHydratedContainer(container) {
        retryIfBlockedOn(container);
      }
      function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
      }
      function shouldDeleteUnhydratedTailInstances(parentType) {
        return parentType !== "head" && parentType !== "body";
      }
      function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
        var shouldWarnDev = true;
        checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
      }
      function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
      }
      function didNotHydrateInstanceWithinContainer(parentContainer, instance2) {
        {
          if (instance2.nodeType === ELEMENT_NODE) {
            warnForDeletedHydratableElement(parentContainer, instance2);
          } else if (instance2.nodeType === COMMENT_NODE) ;
          else {
            warnForDeletedHydratableText(parentContainer, instance2);
          }
        }
      }
      function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance2) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) {
            if (instance2.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentNode, instance2);
            } else if (instance2.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentNode, instance2);
            }
          }
        }
      }
      function didNotHydrateInstance(parentType, parentProps, parentInstance, instance2, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance2.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentInstance, instance2);
            } else if (instance2.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentInstance, instance2);
            }
          }
        }
      }
      function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
        {
          warnForInsertedHydratedElement(parentContainer, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
        {
          warnForInsertedHydratedText(parentContainer, text);
        }
      }
      function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);
        }
      }
      function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedElement(parentInstance, type);
          }
        }
      }
      function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedText(parentInstance, text);
          }
        }
      }
      function errorHydratingContainer(parentContainer) {
        {
          error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
        }
      }
      function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function precacheFiberNode(hostInst, node) {
        node[internalInstanceKey] = hostInst;
      }
      function markContainerAsRoot(hostRoot, node) {
        node[internalContainerInstanceKey] = hostRoot;
      }
      function unmarkContainerAsRoot(node) {
        node[internalContainerInstanceKey] = null;
      }
      function isContainerMarkedAsRoot(node) {
        return !!node[internalContainerInstanceKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) {
          return targetInst;
        }
        var parentNode = targetNode.parentNode;
        while (parentNode) {
          targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
          if (targetInst) {
            var alternate = targetInst.alternate;
            if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
              var suspenseInstance = getParentSuspenseInstance(targetNode);
              while (suspenseInstance !== null) {
                var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                if (targetSuspenseInst) {
                  return targetSuspenseInst;
                }
                suspenseInstance = getParentSuspenseInstance(suspenseInstance);
              }
            }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
        if (inst) {
          if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
            return inst;
          } else {
            return null;
          }
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText) {
          return inst.stateNode;
        }
        throw new Error("getNodeFromInstance: Invalid argument.");
      }
      function getFiberCurrentPropsFromNode(node) {
        return node[internalPropsKey] || null;
      }
      function updateFiberProps(node, props) {
        node[internalPropsKey] = props;
      }
      function getEventListenerSet(node) {
        var elementListenerSet = node[internalEventHandlersKey];
        if (elementListenerSet === void 0) {
          elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
        }
        return elementListenerSet;
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has22 = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs) {
            if (has22(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var valueStack = [];
      var fiberStack;
      {
        fiberStack = [];
      }
      var index = -1;
      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }
      function pop(cursor, fiber) {
        if (index < 0) {
          {
            error("Unexpected pop.");
          }
          return;
        }
        {
          if (fiber !== fiberStack[index]) {
            error("Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }
      function push(cursor, value2, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value2;
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;
      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
        {
          if (didPushOwnContextIfProvider && isContextProvider(Component)) {
            return previousContext;
          }
          return contextStackCursor.current;
        }
      }
      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
        {
          var instance2 = workInProgress2.stateNode;
          instance2.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
          instance2.__reactInternalMemoizedMaskedChildContext = maskedContext;
        }
      }
      function getMaskedContext(workInProgress2, unmaskedContext) {
        {
          var type = workInProgress2.type;
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var instance2 = workInProgress2.stateNode;
          if (instance2 && instance2.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
            return instance2.__reactInternalMemoizedMaskedChildContext;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name2);
          }
          if (instance2) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return context;
        }
      }
      function hasContextChanged() {
        {
          return didPerformWorkStackCursor.current;
        }
      }
      function isContextProvider(type) {
        {
          var childContextTypes = type.childContextTypes;
          return childContextTypes !== null && childContextTypes !== void 0;
        }
      }
      function popContext(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function popTopLevelContextObject(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function pushTopLevelContextObject(fiber, context, didChange) {
        {
          if (contextStackCursor.current !== emptyContextObject) {
            throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
          }
          push(contextStackCursor, context, fiber);
          push(didPerformWorkStackCursor, didChange, fiber);
        }
      }
      function processChildContext(fiber, type, parentContext) {
        {
          var instance2 = fiber.stateNode;
          var childContextTypes = type.childContextTypes;
          if (typeof instance2.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromFiber(fiber) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance2.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
            }
          }
          {
            var name2 = getComponentNameFromFiber(fiber) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name2);
          }
          return assign({}, parentContext, childContext);
        }
      }
      function pushContextProvider(workInProgress2) {
        {
          var instance2 = workInProgress2.stateNode;
          var memoizedMergedChildContext = instance2 && instance2.__reactInternalMemoizedMergedChildContext || emptyContextObject;
          previousContext = contextStackCursor.current;
          push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
          push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
          return true;
        }
      }
      function invalidateContextProvider(workInProgress2, type, didChange) {
        {
          var instance2 = workInProgress2.stateNode;
          if (!instance2) {
            throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
          }
          if (didChange) {
            var mergedContext = processChildContext(workInProgress2, type, previousContext);
            instance2.__reactInternalMemoizedMergedChildContext = mergedContext;
            pop(didPerformWorkStackCursor, workInProgress2);
            pop(contextStackCursor, workInProgress2);
            push(contextStackCursor, mergedContext, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          } else {
            pop(didPerformWorkStackCursor, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          }
        }
      }
      function findCurrentUnmaskedContext(fiber) {
        {
          if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
            throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
          }
          var node = fiber;
          do {
            switch (node.tag) {
              case HostRoot:
                return node.stateNode.context;
              case ClassComponent: {
                var Component = node.type;
                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }
                break;
              }
            }
            node = node.return;
          } while (node !== null);
          throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      var LegacyRoot = 0;
      var ConcurrentRoot = 1;
      var syncQueue = null;
      var includesLegacySyncCallbacks = false;
      var isFlushingSyncQueue = false;
      function scheduleSyncCallback(callback) {
        if (syncQueue === null) {
          syncQueue = [callback];
        } else {
          syncQueue.push(callback);
        }
      }
      function scheduleLegacySyncCallback(callback) {
        includesLegacySyncCallbacks = true;
        scheduleSyncCallback(callback);
      }
      function flushSyncCallbacksOnlyInLegacyMode() {
        if (includesLegacySyncCallbacks) {
          flushSyncCallbacks();
        }
      }
      function flushSyncCallbacks() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = true;
          var i2 = 0;
          var previousUpdatePriority = getCurrentUpdatePriority();
          try {
            var isSync = true;
            var queue2 = syncQueue;
            setCurrentUpdatePriority(DiscreteEventPriority);
            for (; i2 < queue2.length; i2++) {
              var callback = queue2[i2];
              do {
                callback = callback(isSync);
              } while (callback !== null);
            }
            syncQueue = null;
            includesLegacySyncCallbacks = false;
          } catch (error2) {
            if (syncQueue !== null) {
              syncQueue = syncQueue.slice(i2 + 1);
            }
            scheduleCallback(ImmediatePriority, flushSyncCallbacks);
            throw error2;
          } finally {
            setCurrentUpdatePriority(previousUpdatePriority);
            isFlushingSyncQueue = false;
          }
        }
        return null;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function isForkedChild(workInProgress2) {
        warnIfNotHydrating();
        return (workInProgress2.flags & Forked) !== NoFlags;
      }
      function getForksAtLevel(workInProgress2) {
        warnIfNotHydrating();
        return treeForkCount;
      }
      function getTreeId() {
        var overflow = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        var baseOverflow = treeContextOverflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index2 + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          treeContextId = 1 << restOfLength | id;
          treeContextOverflow = overflow;
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          treeContextId = 1 << length | _id;
          treeContextOverflow = _overflow;
        }
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        var returnFiber = workInProgress2.return;
        if (returnFiber !== null) {
          var numberOfForks = 1;
          var slotIndex = 0;
          pushTreeFork(workInProgress2, numberOfForks);
          pushTreeId(workInProgress2, numberOfForks, slotIndex);
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      function popTreeContext(workInProgress2) {
        while (workInProgress2 === treeForkProvider) {
          treeForkProvider = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
          treeForkCount = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
        }
        while (workInProgress2 === treeContextProvider) {
          treeContextProvider = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextOverflow = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextId = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
        }
      }
      function getSuspendedTreeContext() {
        warnIfNotHydrating();
        if (treeContextProvider !== null) {
          return {
            id: treeContextId,
            overflow: treeContextOverflow
          };
        } else {
          return null;
        }
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      function warnIfNotHydrating() {
        {
          if (!getIsHydrating()) {
            error("Expected to be hydrating. This is a bug in React. Please file an issue.");
          }
        }
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var didSuspendOrErrorDEV = false;
      var hydrationErrors = null;
      function warnIfHydrating() {
        {
          if (isHydrating) {
            error("We should not be hydrating here. This is a bug in React. Please file a bug.");
          }
        }
      }
      function markDidThrowWhileHydratingDEV() {
        {
          didSuspendOrErrorDEV = true;
        }
      }
      function didSuspendOrErrorWhileHydratingDEV() {
        {
          return didSuspendOrErrorDEV;
        }
      }
      function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        return true;
      }
      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
        nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        if (treeContext !== null) {
          restoreSuspendedTreeContext(fiber, treeContext);
        }
        return true;
      }
      function warnUnhydratedInstance(returnFiber, instance2) {
        {
          switch (returnFiber.tag) {
            case HostRoot: {
              didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance2);
              break;
            }
            case HostComponent: {
              var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
              didNotHydrateInstance(
                returnFiber.type,
                returnFiber.memoizedProps,
                returnFiber.stateNode,
                instance2,
                // TODO: Delete this argument when we remove the legacy root API.
                isConcurrentMode
              );
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance2);
              break;
            }
          }
        }
      }
      function deleteHydratableInstance(returnFiber, instance2) {
        warnUnhydratedInstance(returnFiber, instance2);
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance2;
        childToDelete.return = returnFiber;
        var deletions = returnFiber.deletions;
        if (deletions === null) {
          returnFiber.deletions = [childToDelete];
          returnFiber.flags |= ChildDeletion;
        } else {
          deletions.push(childToDelete);
        }
      }
      function warnNonhydratedInstance(returnFiber, fiber) {
        {
          if (didSuspendOrErrorDEV) {
            return;
          }
          switch (returnFiber.tag) {
            case HostRoot: {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  fiber.pendingProps;
                  didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                  break;
              }
              break;
            }
            case HostComponent: {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent: {
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _type,
                    _props,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostText: {
                  var _text = fiber.pendingProps;
                  var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _text,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode
                  );
                  break;
                }
              }
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              var _parentInstance = suspenseState.dehydrated;
              if (_parentInstance !== null) switch (fiber.tag) {
                case HostComponent:
                  var _type2 = fiber.type;
                  fiber.pendingProps;
                  didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                  break;
                case HostText:
                  var _text2 = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                  break;
              }
              break;
            }
            default:
              return;
          }
        }
      }
      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & -4097 | Placement;
        warnNonhydratedInstance(returnFiber, fiber);
      }
      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent: {
            var type = fiber.type;
            fiber.pendingProps;
            var instance2 = canHydrateInstance(nextInstance, type);
            if (instance2 !== null) {
              fiber.stateNode = instance2;
              hydrationParentFiber = fiber;
              nextHydratableInstance = getFirstHydratableChild(instance2);
              return true;
            }
            return false;
          }
          case HostText: {
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          case SuspenseComponent: {
            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
            if (suspenseInstance !== null) {
              var suspenseState = {
                dehydrated: suspenseInstance,
                treeContext: getSuspendedTreeContext(),
                retryLane: OffscreenLane
              };
              fiber.memoizedState = suspenseState;
              var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
              dehydratedFragment.return = fiber;
              fiber.child = dehydratedFragment;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          default:
            return false;
        }
      }
      function shouldClientRenderOnMismatch(fiber) {
        return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
      }
      function throwOnHydrationMismatch(fiber) {
        throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
      }
      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          var prevHydrationParentFiber = hydrationParentFiber;
          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
        }
      }
      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance2 = fiber.stateNode;
        var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
        var updatePayload = hydrateInstance(instance2, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
        fiber.updateQueue = updatePayload;
        if (updatePayload !== null) {
          return true;
        }
        return false;
      }
      function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedContainerTextInstance(
                  parentContainer,
                  textInstance,
                  textContent,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  textInstance,
                  textContent,
                  // TODO: Delete this argument when we remove the legacy root API.
                  _isConcurrentMode2
                );
                break;
              }
            }
          }
        }
        return shouldUpdate;
      }
      function prepareToHydrateHostSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        }
        hydrateSuspenseInstance(suspenseInstance, fiber);
      }
      function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        }
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }
      function popToNextHostParent(fiber) {
        var parent = fiber.return;
        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
          parent = parent.return;
        }
        hydrationParentFiber = parent;
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) {
          return false;
        }
        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }
        if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
          var nextInstance = nextHydratableInstance;
          if (nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnIfUnhydratedTailNodes(fiber);
              throwOnHydrationMismatch();
            } else {
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
          }
        }
        popToNextHostParent(fiber);
        if (fiber.tag === SuspenseComponent) {
          nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
        } else {
          nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        }
        return true;
      }
      function hasUnhydratedTailNodes() {
        return isHydrating && nextHydratableInstance !== null;
      }
      function warnIfUnhydratedTailNodes(fiber) {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          warnUnhydratedInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }
      function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
        didSuspendOrErrorDEV = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        if (hydrationErrors !== null) {
          queueRecoverableErrors(hydrationErrors);
          hydrationErrors = null;
        }
      }
      function getIsHydrating() {
        return isHydrating;
      }
      function queueHydrationError(error2) {
        if (hydrationErrors === null) {
          hydrationErrors = [error2];
        } else {
          hydrationErrors.push(error2);
        }
      }
      var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
      var NoTransition = null;
      function requestCurrentTransition() {
        return ReactCurrentBatchConfig$1.transition;
      }
      var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance2) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance2) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      };
      {
        var findStrictRoot = function(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;
          while (node !== null) {
            if (node.mode & StrictLegacyMode) {
              maybeStrictRoot = node;
            }
            node = node.return;
          }
          return maybeStrictRoot;
        };
        var setToSortedString = function(set22) {
          var array = [];
          set22.forEach(function(value2) {
            array.push(value2);
          });
          return array.sort().join(", ");
        };
        var pendingComponentWillMountWarnings = [];
        var pendingUNSAFE_ComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUNSAFE_ComponentWillUpdateWarnings = [];
        var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance2) {
          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }
          if (typeof instance2.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
          instance2.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillMount === "function") {
            pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
          }
          if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
          }
          if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillUpdate === "function") {
            pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillMountWarnings.length > 0) {
            pendingComponentWillMountWarnings.forEach(function(fiber) {
              componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillMountWarnings = [];
          }
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
              UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillMountWarnings = [];
          }
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
              componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillReceivePropsWarnings = [];
          }
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          }
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillUpdateWarnings.length > 0) {
            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
              componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillUpdateWarnings = [];
          }
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
              UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
          }
          if (UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
          }
          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
          }
          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
          }
          if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
          }
          if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
          }
          if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
          }
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance2) {
          var strictRoot = findStrictRoot(fiber);
          if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
          }
          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }
          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance2 !== null && typeof instance2.getChildContext === "function") {
            if (warningsForRoot === void 0) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }
            warningsForRoot.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length === 0) {
              return;
            }
            var firstFiber = fiberArray[0];
            var uniqueNames = /* @__PURE__ */ new Set();
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
              setCurrentFiber(firstFiber);
              error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
            } finally {
              resetCurrentFiber();
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
      }
      var didWarnAboutMaps;
      var didWarnAboutGenerators;
      var didWarnAboutStringRefs;
      var ownerHasKeyUseWarning;
      var ownerHasFunctionTypeWarning;
      var warnForMissingKey = function(child, returnFiber) {
      };
      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefs = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};
        warnForMissingKey = function(child, returnFiber) {
          if (child === null || typeof child !== "object") {
            return;
          }
          if (!child._store || child._store.validated || child.key != null) {
            return;
          }
          if (typeof child._store !== "object") {
            throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
          }
          child._store.validated = true;
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasKeyUseWarning[componentName]) {
            return;
          }
          ownerHasKeyUseWarning[componentName] = true;
          error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
        };
      }
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function coerceRef(returnFiber, current22, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
            // because these cannot be automatically converted to an arrow function
            // using a codemod. Therefore, we don't have to warn about string refs again.
            !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
            !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
            !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
            element._owner) {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (!didWarnAboutStringRefs[componentName]) {
                {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                }
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
          if (element._owner) {
            var owner = element._owner;
            var inst;
            if (owner) {
              var ownerFiber = owner;
              if (ownerFiber.tag !== ClassComponent) {
                throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
              }
              inst = ownerFiber.stateNode;
            }
            if (!inst) {
              throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
            }
            var resolvedInst = inst;
            {
              checkPropStringCoercion(mixedRef, "ref");
            }
            var stringRef = "" + mixedRef;
            if (current22 !== null && current22.ref !== null && typeof current22.ref === "function" && current22.ref._stringRef === stringRef) {
              return current22.ref;
            }
            var ref = function(value2) {
              var refs = resolvedInst.refs;
              if (value2 === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value2;
              }
            };
            ref._stringRef = stringRef;
            return ref;
          } else {
            if (typeof mixedRef !== "string") {
              throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            }
            if (!element._owner) {
              throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
            }
          }
        }
        return mixedRef;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        var childString = Object.prototype.toString.call(newChild);
        throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
      }
      function warnOnFunctionType(returnFiber) {
        {
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasFunctionTypeWarning[componentName]) {
            return;
          }
          ownerHasFunctionTypeWarning[componentName] = true;
          error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
        }
      }
      function resolveLazy(lazyType) {
        var payload = lazyType._payload;
        var init = lazyType._init;
        return init(payload);
      }
      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }
          var childToDelete = currentFirstChild;
          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }
          return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = /* @__PURE__ */ new Map();
          var existingChild = currentFirstChild;
          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }
            existingChild = existingChild.sibling;
          }
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          var clone2 = createWorkInProgress(fiber, pendingProps);
          clone2.index = 0;
          clone2.sibling = null;
          return clone2;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects) {
            newFiber.flags |= Forked;
            return lastPlacedIndex;
          }
          var current22 = newFiber.alternate;
          if (current22 !== null) {
            var oldIndex = current22.index;
            if (oldIndex < lastPlacedIndex) {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.flags |= Placement;
            return lastPlacedIndex;
          }
        }
        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.flags |= Placement;
          }
          return newFiber;
        }
        function updateTextNode(returnFiber, current22, textContent, lanes) {
          if (current22 === null || current22.tag !== HostText) {
            var created2 = createFiberFromText(textContent, returnFiber.mode, lanes);
            created2.return = returnFiber;
            return created2;
          } else {
            var existing = useFiber(current22, textContent);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateElement(returnFiber, current22, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE) {
            return updateFragment2(returnFiber, current22, element.props.children, lanes, element.key);
          }
          if (current22 !== null) {
            if (current22.elementType === elementType || // Keep this check inline so it only runs on the false path:
            isCompatibleFamilyForHotReloading(current22, element) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current22.type) {
              var existing = useFiber(current22, element.props);
              existing.ref = coerceRef(returnFiber, current22, element);
              existing.return = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            }
          }
          var created2 = createFiberFromElement(element, returnFiber.mode, lanes);
          created2.ref = coerceRef(returnFiber, current22, element);
          created2.return = returnFiber;
          return created2;
        }
        function updatePortal(returnFiber, current22, portal, lanes) {
          if (current22 === null || current22.tag !== HostPortal || current22.stateNode.containerInfo !== portal.containerInfo || current22.stateNode.implementation !== portal.implementation) {
            var created2 = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created2.return = returnFiber;
            return created2;
          } else {
            var existing = useFiber(current22, portal.children || []);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateFragment2(returnFiber, current22, fragment, lanes, key) {
          if (current22 === null || current22.tag !== Fragment) {
            var created2 = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
            created2.return = returnFiber;
            return created2;
          } else {
            var existing = useFiber(current22, fragment);
            existing.return = returnFiber;
            return existing;
          }
        }
        function createChild(returnFiber, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var created2 = createFiberFromText("" + newChild, returnFiber.mode, lanes);
            created2.return = returnFiber;
            return created2;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                _created.ref = coerceRef(returnFiber, null, newChild);
                _created.return = returnFiber;
                return _created;
              }
              case REACT_PORTAL_TYPE: {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                _created2.return = returnFiber;
                return _created2;
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return createChild(returnFiber, init(payload), lanes);
              }
            }
            if (isArray2(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
              _created3.return = returnFiber;
              return _created3;
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = oldFiber !== null ? oldFiber.key : null;
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }
            return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                if (newChild.key === key) {
                  return updateElement(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_PORTAL_TYPE: {
                if (newChild.key === key) {
                  return updatePortal(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return updateSlot(returnFiber, oldFiber, init(payload), lanes);
              }
            }
            if (isArray2(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }
              return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updateElement(returnFiber, _matchedFiber, newChild, lanes);
              }
              case REACT_PORTAL_TYPE: {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
              }
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
            }
            if (isArray2(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function warnOnInvalidKey(child, knownKeys, returnFiber) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child, returnFiber);
                var key = child.key;
                if (typeof key !== "string") {
                  break;
                }
                if (knownKeys === null) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", key);
                break;
              case REACT_LAZY_TYPE:
                var payload = child._payload;
                var init = child._init;
                warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                break;
            }
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          {
            var knownKeys = null;
            for (var i2 = 0; i2 < newChildren.length; i2++) {
              var child = newChildren[i2];
              knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
              if (_newFiber === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }
              previousNewFiber = _newFiber;
            }
            if (getIsHydrating()) {
              var _numberOfForks = newIdx;
              pushTreeFork(returnFiber, _numberOfForks);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
            if (_newFiber2 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }
              previousNewFiber = _newFiber2;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks2 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks2);
          }
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          if (typeof iteratorFn !== "function") {
            throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            newChildrenIterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (newChildrenIterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren) {
              var knownKeys = null;
              var _step = _newChildren.next();
              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          if (newChildren == null) {
            throw new Error("An iterable object provided no iterator.");
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();
          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, lanes);
              if (_newFiber3 === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }
              previousNewFiber = _newFiber3;
            }
            if (getIsHydrating()) {
              var _numberOfForks3 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks3);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }
              previousNewFiber = _newFiber4;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks4 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks4);
          }
          return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent);
            existing.return = returnFiber;
            return existing;
          }
          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created2 = createFiberFromText(textContent, returnFiber.mode, lanes);
          created2.return = returnFiber;
          return created2;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
          var key = element.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                if (child.tag === Fragment) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, element.props.children);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              } else {
                if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var _existing = useFiber(child, element.props);
                  _existing.ref = coerceRef(returnFiber, child, element);
                  _existing.return = returnFiber;
                  {
                    _existing._debugSource = element._source;
                    _existing._debugOwner = element._owner;
                  }
                  return _existing;
                }
              }
              deleteRemainingChildren(returnFiber, child);
              break;
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          if (element.type === REACT_FRAGMENT_TYPE) {
            var created2 = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
            created2.return = returnFiber;
            return created2;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
          var key = portal.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || []);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          var created2 = createFiberFromPortal(portal, returnFiber.mode, lanes);
          created2.return = returnFiber;
          return created2;
        }
        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
            }
            if (isArray2(newChild)) {
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            }
            if (getIteratorFn(newChild)) {
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers2;
      }
      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);
      function cloneChildFibers(current22, workInProgress2) {
        if (current22 !== null && workInProgress2.child !== current22.child) {
          throw new Error("Resuming work not yet implemented.");
        }
        if (workInProgress2.child === null) {
          return;
        }
        var currentChild = workInProgress2.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        workInProgress2.child = newChild;
        newChild.return = workInProgress2;
        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
          newChild.return = workInProgress2;
        }
        newChild.sibling = null;
      }
      function resetChildFibers(workInProgress2, lanes) {
        var child = workInProgress2.child;
        while (child !== null) {
          resetWorkInProgress(child, lanes);
          child = child.sibling;
        }
      }
      var valueCursor = createCursor(null);
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastFullyObservedContext = null;
      var isDisallowedContextReadInDEV = false;
      function resetContextDependencies() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function enterDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = true;
        }
      }
      function exitDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function pushProvider(providerFiber, context, nextValue) {
        {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
      }
      function popProvider(context, providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        {
          {
            context._currentValue = currentValue;
          }
        }
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        var node = parent;
        while (node !== null) {
          var alternate = node.alternate;
          if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
            node.childLanes = mergeLanes(node.childLanes, renderLanes2);
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
          } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
          }
          if (node === propagationRoot) {
            break;
          }
          node = node.return;
        }
        {
          if (node !== propagationRoot) {
            error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
      }
      function propagateContextChange(workInProgress2, context, renderLanes2) {
        {
          propagateContextChange_eager(workInProgress2, context, renderLanes2);
        }
      }
      function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
        var fiber = workInProgress2.child;
        if (fiber !== null) {
          fiber.return = workInProgress2;
        }
        while (fiber !== null) {
          var nextFiber = void 0;
          var list = fiber.dependencies;
          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.firstContext;
            while (dependency !== null) {
              if (dependency.context === context) {
                if (fiber.tag === ClassComponent) {
                  var lane = pickArbitraryLane(renderLanes2);
                  var update = createUpdate(NoTimestamp, lane);
                  update.tag = ForceUpdate;
                  var updateQueue = fiber.updateQueue;
                  if (updateQueue === null) ;
                  else {
                    var sharedQueue = updateQueue.shared;
                    var pending = sharedQueue.pending;
                    if (pending === null) {
                      update.next = update;
                    } else {
                      update.next = pending.next;
                      pending.next = update;
                    }
                    sharedQueue.pending = update;
                  }
                }
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                list.lanes = mergeLanes(list.lanes, renderLanes2);
                break;
              }
              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
          } else if (fiber.tag === DehydratedFragment) {
            var parentSuspense = fiber.return;
            if (parentSuspense === null) {
              throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
            }
            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
            var _alternate = parentSuspense.alternate;
            if (_alternate !== null) {
              _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
            nextFiber = fiber.sibling;
          } else {
            nextFiber = fiber.child;
          }
          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;
            while (nextFiber !== null) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              var sibling = nextFiber.sibling;
              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }
              nextFiber = nextFiber.return;
            }
          }
          fiber = nextFiber;
        }
      }
      function prepareToReadContext(workInProgress2, renderLanes2) {
        currentlyRenderingFiber = workInProgress2;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        var dependencies = workInProgress2.dependencies;
        if (dependencies !== null) {
          {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
              if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                markWorkInProgressReceivedUpdate();
              }
              dependencies.firstContext = null;
            }
          }
        }
      }
      function readContext(context) {
        {
          if (isDisallowedContextReadInDEV) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        var value2 = context._currentValue;
        if (lastFullyObservedContext === context) ;
        else {
          var contextItem = {
            context,
            memoizedValue: value2,
            next: null
          };
          if (lastContextDependency === null) {
            if (currentlyRenderingFiber === null) {
              throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
            lastContextDependency = contextItem;
            currentlyRenderingFiber.dependencies = {
              lanes: NoLanes,
              firstContext: contextItem
            };
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }
        return value2;
      }
      var concurrentQueues = null;
      function pushConcurrentUpdateQueue(queue2) {
        if (concurrentQueues === null) {
          concurrentQueues = [queue2];
        } else {
          concurrentQueues.push(queue2);
        }
      }
      function finishQueueingConcurrentUpdates() {
        if (concurrentQueues !== null) {
          for (var i2 = 0; i2 < concurrentQueues.length; i2++) {
            var queue2 = concurrentQueues[i2];
            var lastInterleavedUpdate = queue2.interleaved;
            if (lastInterleavedUpdate !== null) {
              queue2.interleaved = null;
              var firstInterleavedUpdate = lastInterleavedUpdate.next;
              var lastPendingUpdate = queue2.pending;
              if (lastPendingUpdate !== null) {
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = firstInterleavedUpdate;
                lastInterleavedUpdate.next = firstPendingUpdate;
              }
              queue2.pending = lastInterleavedUpdate;
            }
          }
          concurrentQueues = null;
        }
      }
      function enqueueConcurrentHookUpdate(fiber, queue2, update, lane) {
        var interleaved = queue2.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue2);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue2.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue2, update, lane) {
        var interleaved = queue2.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue2);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue2.interleaved = update;
      }
      function enqueueConcurrentClassUpdate(fiber, queue2, update, lane) {
        var interleaved = queue2.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue2);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue2.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, lane);
        }
        {
          if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          }
        }
        var node = sourceFiber;
        var parent = sourceFiber.return;
        while (parent !== null) {
          parent.childLanes = mergeLanes(parent.childLanes, lane);
          alternate = parent.alternate;
          if (alternate !== null) {
            alternate.childLanes = mergeLanes(alternate.childLanes, lane);
          } else {
            {
              if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
          }
          node = parent;
          parent = parent.return;
        }
        if (node.tag === HostRoot) {
          var root2 = node.stateNode;
          return root2;
        } else {
          return null;
        }
      }
      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate;
      var currentlyProcessingQueue;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;
      }
      function initializeUpdateQueue(fiber) {
        var queue2 = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            interleaved: null,
            lanes: NoLanes
          },
          effects: null
        };
        fiber.updateQueue = queue2;
      }
      function cloneUpdateQueue(current22, workInProgress2) {
        var queue2 = workInProgress2.updateQueue;
        var currentQueue = current22.updateQueue;
        if (queue2 === currentQueue) {
          var clone2 = {
            baseState: currentQueue.baseState,
            firstBaseUpdate: currentQueue.firstBaseUpdate,
            lastBaseUpdate: currentQueue.lastBaseUpdate,
            shared: currentQueue.shared,
            effects: currentQueue.effects
          };
          workInProgress2.updateQueue = clone2;
        }
      }
      function createUpdate(eventTime, lane) {
        var update = {
          eventTime,
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
        return update;
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
          return null;
        }
        var sharedQueue = updateQueue.shared;
        {
          if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
            error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
        if (isUnsafeClassRenderPhaseUpdate()) {
          var pending = sharedQueue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          sharedQueue.pending = update;
          return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
        } else {
          return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
        }
      }
      function entangleTransitions(root2, fiber, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
          return;
        }
        var sharedQueue = updateQueue.shared;
        if (isTransitionLane(lane)) {
          var queueLanes = sharedQueue.lanes;
          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          sharedQueue.lanes = newQueueLanes;
          markRootEntangled(root2, newQueueLanes);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue2 = workInProgress2.updateQueue;
        var current22 = workInProgress2.alternate;
        if (current22 !== null) {
          var currentQueue = current22.updateQueue;
          if (queue2 === currentQueue) {
            var newFirst = null;
            var newLast = null;
            var firstBaseUpdate = queue2.firstBaseUpdate;
            if (firstBaseUpdate !== null) {
              var update = firstBaseUpdate;
              do {
                var clone2 = {
                  eventTime: update.eventTime,
                  lane: update.lane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLast === null) {
                  newFirst = newLast = clone2;
                } else {
                  newLast.next = clone2;
                  newLast = clone2;
                }
                update = update.next;
              } while (update !== null);
              if (newLast === null) {
                newFirst = newLast = capturedUpdate;
              } else {
                newLast.next = capturedUpdate;
                newLast = capturedUpdate;
              }
            } else {
              newFirst = newLast = capturedUpdate;
            }
            queue2 = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = queue2;
            return;
          }
        }
        var lastBaseUpdate = queue2.lastBaseUpdate;
        if (lastBaseUpdate === null) {
          queue2.firstBaseUpdate = capturedUpdate;
        } else {
          lastBaseUpdate.next = capturedUpdate;
        }
        queue2.lastBaseUpdate = capturedUpdate;
      }
      function getStateFromUpdate(workInProgress2, queue2, update, prevState, nextProps, instance2) {
        switch (update.tag) {
          case ReplaceState: {
            var payload = update.payload;
            if (typeof payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              var nextState = payload.call(instance2, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    payload.call(instance2, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
              return nextState;
            }
            return payload;
          }
          case CaptureUpdate: {
            workInProgress2.flags = workInProgress2.flags & -65537 | DidCapture;
          }
          case UpdateState: {
            var _payload = update.payload;
            var partialState;
            if (typeof _payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              partialState = _payload.call(instance2, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    _payload.call(instance2, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
            } else {
              partialState = _payload;
            }
            if (partialState === null || partialState === void 0) {
              return prevState;
            }
            return assign({}, prevState, partialState);
          }
          case ForceUpdate: {
            hasForceUpdate = true;
            return prevState;
          }
        }
        return prevState;
      }
      function processUpdateQueue(workInProgress2, props, instance2, renderLanes2) {
        var queue2 = workInProgress2.updateQueue;
        hasForceUpdate = false;
        {
          currentlyProcessingQueue = queue2.shared;
        }
        var firstBaseUpdate = queue2.firstBaseUpdate;
        var lastBaseUpdate = queue2.lastBaseUpdate;
        var pendingQueue = queue2.shared.pending;
        if (pendingQueue !== null) {
          queue2.shared.pending = null;
          var lastPendingUpdate = pendingQueue;
          var firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          if (lastBaseUpdate === null) {
            firstBaseUpdate = firstPendingUpdate;
          } else {
            lastBaseUpdate.next = firstPendingUpdate;
          }
          lastBaseUpdate = lastPendingUpdate;
          var current22 = workInProgress2.alternate;
          if (current22 !== null) {
            var currentQueue = current22.updateQueue;
            var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
            if (currentLastBaseUpdate !== lastBaseUpdate) {
              if (currentLastBaseUpdate === null) {
                currentQueue.firstBaseUpdate = firstPendingUpdate;
              } else {
                currentLastBaseUpdate.next = firstPendingUpdate;
              }
              currentQueue.lastBaseUpdate = lastPendingUpdate;
            }
          }
        }
        if (firstBaseUpdate !== null) {
          var newState = queue2.baseState;
          var newLanes = NoLanes;
          var newBaseState = null;
          var newFirstBaseUpdate = null;
          var newLastBaseUpdate = null;
          var update = firstBaseUpdate;
          do {
            var updateLane = update.lane;
            var updateEventTime = update.eventTime;
            if (!isSubsetOfLanes(renderLanes2, updateLane)) {
              var clone2 = {
                eventTime: updateEventTime,
                lane: updateLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              if (newLastBaseUpdate === null) {
                newFirstBaseUpdate = newLastBaseUpdate = clone2;
                newBaseState = newState;
              } else {
                newLastBaseUpdate = newLastBaseUpdate.next = clone2;
              }
              newLanes = mergeLanes(newLanes, updateLane);
            } else {
              if (newLastBaseUpdate !== null) {
                var _clone = {
                  eventTime: updateEventTime,
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
              }
              newState = getStateFromUpdate(workInProgress2, queue2, update, newState, props, instance2);
              var callback = update.callback;
              if (callback !== null && // If the update was already committed, we should not queue its
              // callback again.
              update.lane !== NoLane) {
                workInProgress2.flags |= Callback;
                var effects = queue2.effects;
                if (effects === null) {
                  queue2.effects = [update];
                } else {
                  effects.push(update);
                }
              }
            }
            update = update.next;
            if (update === null) {
              pendingQueue = queue2.shared.pending;
              if (pendingQueue === null) {
                break;
              } else {
                var _lastPendingUpdate = pendingQueue;
                var _firstPendingUpdate = _lastPendingUpdate.next;
                _lastPendingUpdate.next = null;
                update = _firstPendingUpdate;
                queue2.lastBaseUpdate = _lastPendingUpdate;
                queue2.shared.pending = null;
              }
            }
          } while (true);
          if (newLastBaseUpdate === null) {
            newBaseState = newState;
          }
          queue2.baseState = newBaseState;
          queue2.firstBaseUpdate = newFirstBaseUpdate;
          queue2.lastBaseUpdate = newLastBaseUpdate;
          var lastInterleaved = queue2.shared.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              newLanes = mergeLanes(newLanes, interleaved.lane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (firstBaseUpdate === null) {
            queue2.shared.lanes = NoLanes;
          }
          markSkippedUpdateLanes(newLanes);
          workInProgress2.lanes = newLanes;
          workInProgress2.memoizedState = newState;
        }
        {
          currentlyProcessingQueue = null;
        }
      }
      function callCallback(callback, context) {
        if (typeof callback !== "function") {
          throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
        }
        callback.call(context);
      }
      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }
      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }
      function commitUpdateQueue(finishedWork, finishedQueue, instance2) {
        var effects = finishedQueue.effects;
        finishedQueue.effects = null;
        if (effects !== null) {
          for (var i2 = 0; i2 < effects.length; i2++) {
            var effect = effects[i2];
            var callback = effect.callback;
            if (callback !== null) {
              effect.callback = null;
              callCallback(callback, instance2);
            }
          }
        }
      }
      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);
      function requiredContext(c2) {
        if (c2 === NO_CONTEXT) {
          throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        }
        return c2;
      }
      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }
      function pushHostContext(fiber) {
        requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type);
        if (context === nextContext) {
          return;
        }
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }
      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }
      var DefaultSuspenseContext = 0;
      var SubtreeSuspenseContextMask = 1;
      var InvisibleParentSuspenseContext = 1;
      var ForceSuspenseFallback = 2;
      var suspenseStackCursor = createCursor(DefaultSuspenseContext);
      function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
      }
      function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
      }
      function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
      }
      function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
      }
      function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
      }
      function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
      }
      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
        var nextState = workInProgress2.memoizedState;
        if (nextState !== null) {
          if (nextState.dehydrated !== null) {
            return true;
          }
          return false;
        }
        workInProgress2.memoizedProps;
        {
          return true;
        }
      }
      function findFirstSuspended(row) {
        var node = row;
        while (node !== null) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              var dehydrated = state.dehydrated;
              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                return node;
              }
            }
          } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
          // keep track of whether it suspended or not.
          node.memoizedProps.revealOrder !== void 0) {
            var didSuspend = (node.flags & DidCapture) !== NoFlags;
            if (didSuspend) {
              return node;
            }
          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) {
            return null;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === row) {
              return null;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var NoFlags$1 = (
        /*   */
        0
      );
      var HasEffect = (
        /* */
        1
      );
      var Insertion = (
        /*  */
        2
      );
      var Layout = (
        /*    */
        4
      );
      var Passive$1 = (
        /*   */
        8
      );
      var workInProgressSources = [];
      function resetWorkInProgressVersions() {
        for (var i2 = 0; i2 < workInProgressSources.length; i2++) {
          var mutableSource = workInProgressSources[i2];
          {
            mutableSource._workInProgressVersionPrimary = null;
          }
        }
        workInProgressSources.length = 0;
      }
      function registerMutableSourceForHydration(root2, mutableSource) {
        var getVersion = mutableSource._getVersion;
        var version = getVersion(mutableSource._source);
        if (root2.mutableSourceEagerHydrationData == null) {
          root2.mutableSourceEagerHydrationData = [mutableSource, version];
        } else {
          root2.mutableSourceEagerHydrationData.push(mutableSource, version);
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
      var didWarnAboutMismatchedHooksForComponent;
      var didWarnUncachedGetSnapshot;
      {
        didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      }
      var renderLanes = NoLanes;
      var currentlyRenderingFiber$1 = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var localIdCounter = 0;
      var globalClientIdCounter = 0;
      var RE_RENDER_LIMIT = 25;
      var currentHookNameInDev = null;
      var hookTypesDev = null;
      var hookTypesUpdateIndexDev = -1;
      var ignorePreviousDependencies = false;
      function mountHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev === null) {
            hookTypesDev = [hookName];
          } else {
            hookTypesDev.push(hookName);
          }
        }
      }
      function updateHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev !== null) {
            hookTypesUpdateIndexDev++;
            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
              warnOnHookMismatchInDev(hookName);
            }
          }
        }
      }
      function checkDepsAreArrayDev(deps) {
        {
          if (deps !== void 0 && deps !== null && !isArray2(deps)) {
            error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
          }
        }
      }
      function warnOnHookMismatchInDev(currentHookName) {
        {
          var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            if (hookTypesDev !== null) {
              var table = "";
              var secondColumnStart = 30;
              for (var i2 = 0; i2 <= hookTypesUpdateIndexDev; i2++) {
                var oldHookName = hookTypesDev[i2];
                var newHookName = i2 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                var row = i2 + 1 + ". " + oldHookName;
                while (row.length < secondColumnStart) {
                  row += " ";
                }
                row += newHookName + "\n";
                table += row;
              }
              error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
            }
          }
        }
      }
      function throwInvalidHookError() {
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        {
          if (ignorePreviousDependencies) {
            return false;
          }
        }
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
          }
        }
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
          if (objectIs(nextDeps[i2], prevDeps[i2])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function renderWithHooks(current22, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress2;
        {
          hookTypesDev = current22 !== null ? current22._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = current22 !== null && current22.type !== workInProgress2.type;
        }
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = NoLanes;
        {
          if (current22 !== null && current22.memoizedState !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
          } else if (hookTypesDev !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
          } else {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
          }
        }
        var children = Component(props, secondArg);
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            numberOfReRenders += 1;
            {
              ignorePreviousDependencies = false;
            }
            currentHook = null;
            workInProgressHook = null;
            workInProgress2.updateQueue = null;
            {
              hookTypesUpdateIndexDev = -1;
            }
            ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
            children = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        {
          workInProgress2._debugHookTypes = hookTypesDev;
        }
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          currentHookNameInDev = null;
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          if (current22 !== null && (current22.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
          // and creates false positives. To make this work in legacy mode, we'd
          // need to mark fibers that commit in an incomplete state, somehow. For
          // now I'll disable the warning that most of the bugs that would trigger
          // it are either exclusive to concurrent mode or exist in both.
          (current22.mode & ConcurrentMode) !== NoMode) {
            error("Internal React error: Expected static flag was missing. Please notify the React team.");
          }
        }
        didScheduleRenderPhaseUpdate = false;
        if (didRenderTooFewHooks) {
          throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        }
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current22, workInProgress2, lanes) {
        workInProgress2.updateQueue = current22.updateQueue;
        if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
          workInProgress2.flags &= -50333701;
        } else {
          workInProgress2.flags &= -2053;
        }
        current22.lanes = removeLanes(current22.lanes, lanes);
      }
      function resetHooksAfterThrow() {
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        if (didScheduleRenderPhaseUpdate) {
          var hook = currentlyRenderingFiber$1.memoizedState;
          while (hook !== null) {
            var queue2 = hook.queue;
            if (queue2 !== null) {
              queue2.pending = null;
            }
            hook = hook.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          isUpdatingOpaqueValueInRenderPhase = false;
        }
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        localIdCounter = 0;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        if (workInProgressHook === null) {
          currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
        } else {
          workInProgressHook = workInProgressHook.next = hook;
        }
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        var nextCurrentHook;
        if (currentHook === null) {
          var current22 = currentlyRenderingFiber$1.alternate;
          if (current22 !== null) {
            nextCurrentHook = current22.memoizedState;
          } else {
            nextCurrentHook = null;
          }
        } else {
          nextCurrentHook = currentHook.next;
        }
        var nextWorkInProgressHook;
        if (workInProgressHook === null) {
          nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
        } else {
          nextWorkInProgressHook = workInProgressHook.next;
        }
        if (nextWorkInProgressHook !== null) {
          workInProgressHook = nextWorkInProgressHook;
          nextWorkInProgressHook = workInProgressHook.next;
          currentHook = nextCurrentHook;
        } else {
          if (nextCurrentHook === null) {
            throw new Error("Rendered more hooks than during the previous render.");
          }
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
          } else {
            workInProgressHook = workInProgressHook.next = newHook;
          }
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null,
          stores: null
        };
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState2;
        if (init !== void 0) {
          initialState2 = init(initialArg);
        } else {
          initialState2 = initialArg;
        }
        hook.memoizedState = hook.baseState = initialState2;
        var queue2 = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState2
        };
        hook.queue = queue2;
        var dispatch = queue2.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue2);
        return [hook.memoizedState, dispatch];
      }
      function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue2 = hook.queue;
        if (queue2 === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue2.lastRenderedReducer = reducer;
        var current22 = currentHook;
        var baseQueue = current22.baseQueue;
        var pendingQueue = queue2.pending;
        if (pendingQueue !== null) {
          if (baseQueue !== null) {
            var baseFirst = baseQueue.next;
            var pendingFirst = pendingQueue.next;
            baseQueue.next = pendingFirst;
            pendingQueue.next = baseFirst;
          }
          {
            if (current22.baseQueue !== baseQueue) {
              error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
            }
          }
          current22.baseQueue = baseQueue = pendingQueue;
          queue2.pending = null;
        }
        if (baseQueue !== null) {
          var first = baseQueue.next;
          var newState = current22.baseState;
          var newBaseState = null;
          var newBaseQueueFirst = null;
          var newBaseQueueLast = null;
          var update = first;
          do {
            var updateLane = update.lane;
            if (!isSubsetOfLanes(renderLanes, updateLane)) {
              var clone2 = {
                lane: updateLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              };
              if (newBaseQueueLast === null) {
                newBaseQueueFirst = newBaseQueueLast = clone2;
                newBaseState = newState;
              } else {
                newBaseQueueLast = newBaseQueueLast.next = clone2;
              }
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
              markSkippedUpdateLanes(updateLane);
            } else {
              if (newBaseQueueLast !== null) {
                var _clone = {
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              }
              if (update.hasEagerState) {
                newState = update.eagerState;
              } else {
                var action = update.action;
                newState = reducer(newState, action);
              }
            }
            update = update.next;
          } while (update !== null && update !== first);
          if (newBaseQueueLast === null) {
            newBaseState = newState;
          } else {
            newBaseQueueLast.next = newBaseQueueFirst;
          }
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          hook.baseState = newBaseState;
          hook.baseQueue = newBaseQueueLast;
          queue2.lastRenderedState = newState;
        }
        var lastInterleaved = queue2.interleaved;
        if (lastInterleaved !== null) {
          var interleaved = lastInterleaved;
          do {
            var interleavedLane = interleaved.lane;
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
            markSkippedUpdateLanes(interleavedLane);
            interleaved = interleaved.next;
          } while (interleaved !== lastInterleaved);
        } else if (baseQueue === null) {
          queue2.lanes = NoLanes;
        }
        var dispatch = queue2.dispatch;
        return [hook.memoizedState, dispatch];
      }
      function rerenderReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue2 = hook.queue;
        if (queue2 === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue2.lastRenderedReducer = reducer;
        var dispatch = queue2.dispatch;
        var lastRenderPhaseUpdate = queue2.pending;
        var newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
          queue2.pending = null;
          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          var update = firstRenderPhaseUpdate;
          do {
            var action = update.action;
            newState = reducer(newState, action);
            update = update.next;
          } while (update !== firstRenderPhaseUpdate);
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          if (hook.baseQueue === null) {
            hook.baseState = newState;
          }
          queue2.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountMutableSource(source, getSnapshot, subscribe) {
        {
          return void 0;
        }
      }
      function updateMutableSource(source, getSnapshot, subscribe) {
        {
          return void 0;
        }
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = mountWorkInProgressHook();
        var nextSnapshot;
        var isHydrating2 = getIsHydrating();
        if (isHydrating2) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          nextSnapshot = getServerSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              if (nextSnapshot !== getServerSnapshot()) {
                error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
        } else {
          nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var root2 = getWorkInProgressRoot();
          if (root2 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root2, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        hook.memoizedState = nextSnapshot;
        var inst = {
          value: nextSnapshot,
          getSnapshot
        };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        fiber.flags |= Passive;
        pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
        return nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = updateWorkInProgressHook();
        var nextSnapshot = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            if (!objectIs(nextSnapshot, cachedSnapshot)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var prevSnapshot = hook.memoizedState;
        var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
        if (snapshotChanged) {
          hook.memoizedState = nextSnapshot;
          markWorkInProgressReceivedUpdate();
        }
        var inst = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
        // checking whether we scheduled a subscription effect above.
        workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          var root2 = getWorkInProgressRoot();
          if (root2 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root2, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        return nextSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= StoreConsistency;
        var check = {
          getSnapshot,
          value: renderedSnapshot
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.stores = [check];
        } else {
          var stores = componentUpdateQueue.stores;
          if (stores === null) {
            componentUpdateQueue.stores = [check];
          } else {
            stores.push(check);
          }
        }
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        if (checkIfSnapshotChanged(inst)) {
          forceStoreRerender(fiber);
        }
      }
      function subscribeToStore(fiber, inst, subscribe) {
        var handleStoreChange = function() {
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        };
        return subscribe(handleStoreChange);
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        if (root2 !== null) {
          scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
        }
      }
      function mountState(initialState2) {
        var hook = mountWorkInProgressHook();
        if (typeof initialState2 === "function") {
          initialState2 = initialState2();
        }
        hook.memoizedState = hook.baseState = initialState2;
        var queue2 = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState2
        };
        hook.queue = queue2;
        var dispatch = queue2.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue2);
        return [hook.memoizedState, dispatch];
      }
      function updateState(initialState2) {
        return updateReducer(basicStateReducer);
      }
      function rerenderState(initialState2) {
        return rerenderReducer(basicStateReducer);
      }
      function pushEffect(tag, create, destroy, deps) {
        var effect = {
          tag,
          create,
          destroy,
          deps,
          // Circular
          next: null
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var lastEffect = componentUpdateQueue.lastEffect;
          if (lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = lastEffect.next;
            lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }
        return effect;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        {
          var _ref2 = {
            current: initialValue
          };
          hook.memoizedState = _ref2;
          return _ref2;
        }
      }
      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var destroy = void 0;
        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
              return;
            }
          }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
      }
      function mountEffect(create, deps) {
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
        } else {
          return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
        }
      }
      function updateEffect(create, deps) {
        return updateEffectImpl(Passive, Passive$1, create, deps);
      }
      function mountInsertionEffect(create, deps) {
        return mountEffectImpl(Update2, Insertion, create, deps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(Update2, Insertion, create, deps);
      }
      function mountLayoutEffect(create, deps) {
        var fiberFlags = Update2;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update2, Layout, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if (typeof ref === "function") {
          var refCallback = ref;
          var _inst = create();
          refCallback(_inst);
          return function() {
            refCallback(null);
          };
        } else if (ref !== null && ref !== void 0) {
          var refObject = ref;
          {
            if (!refObject.hasOwnProperty("current")) {
              error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
            }
          }
          var _inst2 = create();
          refObject.current = _inst2;
          return function() {
            refObject.current = null;
          };
        }
      }
      function mountImperativeHandle(ref, create, deps) {
        {
          if (typeof create !== "function") {
            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
          }
        }
        var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
        var fiberFlags = Update2;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function updateImperativeHandle(ref, create, deps) {
        {
          if (typeof create !== "function") {
            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
          }
        }
        var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
        return updateEffectImpl(Update2, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function mountDebugValue(value2, formatterFn) {
      }
      var updateDebugValue = mountDebugValue;
      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function mountDeferredValue(value2) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = value2;
        return value2;
      }
      function updateDeferredValue(value2) {
        var hook = updateWorkInProgressHook();
        var resolvedCurrentHook = currentHook;
        var prevValue = resolvedCurrentHook.memoizedState;
        return updateDeferredValueImpl(hook, prevValue, value2);
      }
      function rerenderDeferredValue(value2) {
        var hook = updateWorkInProgressHook();
        if (currentHook === null) {
          hook.memoizedState = value2;
          return value2;
        } else {
          var prevValue = currentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value2);
        }
      }
      function updateDeferredValueImpl(hook, prevValue, value2) {
        var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
        if (shouldDeferValue) {
          if (!objectIs(value2, prevValue)) {
            var deferredLane = claimNextTransitionLane();
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
            markSkippedUpdateLanes(deferredLane);
            hook.baseState = true;
          }
          return prevValue;
        } else {
          if (hook.baseState) {
            hook.baseState = false;
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = value2;
          return value2;
        }
      }
      function startTransition(setPending, callback, options2) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
        setPending(true);
        var prevTransition = ReactCurrentBatchConfig$2.transition;
        ReactCurrentBatchConfig$2.transition = {};
        var currentTransition = ReactCurrentBatchConfig$2.transition;
        {
          ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
        }
        try {
          setPending(false);
          callback();
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$2.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      function mountTransition() {
        var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
        var start = startTransition.bind(null, setPending);
        var hook = mountWorkInProgressHook();
        hook.memoizedState = start;
        return [isPending, start];
      }
      function updateTransition() {
        var _updateState = updateState(), isPending = _updateState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      function rerenderTransition() {
        var _rerenderState = rerenderState(), isPending = _rerenderState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      var isUpdatingOpaqueValueInRenderPhase = false;
      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        {
          return isUpdatingOpaqueValueInRenderPhase;
        }
      }
      function mountId() {
        var hook = mountWorkInProgressHook();
        var root2 = getWorkInProgressRoot();
        var identifierPrefix = root2.identifierPrefix;
        var id;
        if (getIsHydrating()) {
          var treeId = getTreeId();
          id = ":" + identifierPrefix + "R" + treeId;
          var localId = localIdCounter++;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          id += ":";
        } else {
          var globalClientId = globalClientIdCounter++;
          id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
        }
        hook.memoizedState = id;
        return id;
      }
      function updateId() {
        var hook = updateWorkInProgressHook();
        var id = hook.memoizedState;
        return id;
      }
      function dispatchReducerAction(fiber, queue2, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue2, update);
        } else {
          var root2 = enqueueConcurrentHookUpdate(fiber, queue2, update, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitionUpdate(root2, queue2, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function dispatchSetState(fiber, queue2, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue2, update);
        } else {
          var alternate = fiber.alternate;
          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
            var lastRenderedReducer = queue2.lastRenderedReducer;
            if (lastRenderedReducer !== null) {
              var prevDispatcher;
              {
                prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              }
              try {
                var currentState = queue2.lastRenderedState;
                var eagerState = lastRenderedReducer(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState)) {
                  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue2, update, lane);
                  return;
                }
              } catch (error2) {
              } finally {
                {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              }
            }
          }
          var root2 = enqueueConcurrentHookUpdate(fiber, queue2, update, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitionUpdate(root2, queue2, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
      }
      function enqueueRenderPhaseUpdate(queue2, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue2.pending;
        if (pending === null) {
          update.next = update;
        } else {
          update.next = pending.next;
          pending.next = update;
        }
        queue2.pending = update;
      }
      function entangleTransitionUpdate(root2, queue2, lane) {
        if (isTransitionLane(lane)) {
          var queueLanes = queue2.lanes;
          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          queue2.lanes = newQueueLanes;
          markRootEntangled(root2, newQueueLanes);
        }
      }
      function markUpdateInDevTools(fiber, lane, action) {
        {
          markStateUpdateScheduled(fiber, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
      };
      var HooksDispatcherOnMountInDEV = null;
      var HooksDispatcherOnMountWithHookTypesInDEV = null;
      var HooksDispatcherOnUpdateInDEV = null;
      var HooksDispatcherOnRerenderInDEV = null;
      var InvalidNestedHooksDispatcherOnMountInDEV = null;
      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
      var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      {
        var warnInvalidContextAccess = function() {
          error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        };
        var warnInvalidHookAccess = function() {
          error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        };
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState2) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderState(initialState2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value2, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value2) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value2);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
      }
      var now$1 = Scheduler.unstable_now;
      var commitTime = 0;
      var layoutEffectStartTime = -1;
      var profilerStartTime = -1;
      var passiveEffectStartTime = -1;
      var currentUpdateIsNested = false;
      var nestedUpdateScheduled = false;
      function isCurrentUpdateNested() {
        return currentUpdateIsNested;
      }
      function markNestedUpdateScheduled() {
        {
          nestedUpdateScheduled = true;
        }
      }
      function resetNestedUpdateFlag() {
        {
          currentUpdateIsNested = false;
          nestedUpdateScheduled = false;
        }
      }
      function syncNestedUpdateFlag() {
        {
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
        }
      }
      function getCommitTime() {
        return commitTime;
      }
      function recordCommitTime() {
        commitTime = now$1();
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now$1();
        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now$1();
        }
      }
      function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
      }
      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
          var elapsedTime = now$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }
          profilerStartTime = -1;
        }
      }
      function recordLayoutEffectDuration(fiber) {
        if (layoutEffectStartTime >= 0) {
          var elapsedTime = now$1() - layoutEffectStartTime;
          layoutEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root2 = parentFiber.stateNode;
                root2.effectDuration += elapsedTime;
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                parentStateNode.effectDuration += elapsedTime;
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function recordPassiveEffectDuration(fiber) {
        if (passiveEffectStartTime >= 0) {
          var elapsedTime = now$1() - passiveEffectStartTime;
          passiveEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root2 = parentFiber.stateNode;
                if (root2 !== null) {
                  root2.passiveEffectDuration += elapsedTime;
                }
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                if (parentStateNode !== null) {
                  parentStateNode.passiveEffectDuration += elapsedTime;
                }
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function startLayoutEffectTimer() {
        layoutEffectStartTime = now$1();
      }
      function startPassiveEffectTimer() {
        passiveEffectStartTime = now$1();
      }
      function transferActualDuration(fiber) {
        var child = fiber.child;
        while (child) {
          fiber.actualDuration += child.actualDuration;
          child = child.sibling;
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      var fakeInternalInstance = {};
      var didWarnAboutStateAssignmentForComponent;
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      var didWarnAboutLegacyContext$1;
      {
        didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function() {
            throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState;
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
        workInProgress2.memoizedState = memoizedState;
        if (workInProgress2.lanes === NoLanes) {
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = memoizedState;
        }
      }
      var classComponentUpdater = {
        isMounted,
        enqueueSetState: function(inst, payload, callback) {
          var fiber = get2(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.payload = payload;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(fiber, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitions(root2, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var fiber = get2(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ReplaceState;
          update.payload = payload;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(fiber, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitions(root2, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var fiber = get2(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ForceUpdate;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(fiber, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitions(root2, fiber, lane);
          }
          {
            markForceUpdateScheduled(fiber, lane);
          }
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance2 = workInProgress2.stateNode;
        if (typeof instance2.shouldComponentUpdate === "function") {
          var shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            if (shouldUpdate === void 0) {
              error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
            }
          }
          return shouldUpdate;
        }
        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }
        return true;
      }
      function checkClassInstance(workInProgress2, ctor, newProps) {
        var instance2 = workInProgress2.stateNode;
        {
          var name2 = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance2.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
            }
          }
          if (instance2.getInitialState && !instance2.getInitialState.isReactClassApproved && !instance2.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
          }
          if (instance2.getDefaultProps && !instance2.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
          }
          if (instance2.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
          }
          if (instance2.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
          }
          {
            if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
            // this one.
            (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name2);
            }
            if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
            // this one.
            (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name2);
            }
            if (instance2.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
            }
          }
          if (typeof instance2.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance2.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance2.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
          }
          if (typeof instance2.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
          }
          if (typeof instance2.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
          }
          if (typeof instance2.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
          }
          var hasMutatedProps = instance2.props !== newProps;
          if (instance2.props !== void 0 && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
          }
          if (instance2.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
          }
          if (typeof instance2.getSnapshotBeforeUpdate === "function" && typeof instance2.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance2.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof instance2.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
          }
          var _state = instance2.state;
          if (_state && (typeof _state !== "object" || isArray2(_state))) {
            error("%s.state: must be set to an object or null", name2);
          }
          if (typeof instance2.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
          }
        }
      }
      function adoptClassInstance(workInProgress2, instance2) {
        instance2.updater = classComponentUpdater;
        workInProgress2.stateNode = instance2;
        set2(instance2, workInProgress2);
        {
          instance2._reactInternalInstance = fakeInternalInstance;
        }
      }
      function constructClassInstance(workInProgress2, ctor, props) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid2 = (
              // Allow null for conditional declaration
              contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
            );
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === void 0) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== void 0) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
        }
        var instance2 = new ctor(props, context);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              instance2 = new ctor(props, context);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        var state = workInProgress2.memoizedState = instance2.state !== null && instance2.state !== void 0 ? instance2.state : null;
        adoptClassInstance(workInProgress2, instance2);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance2.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance2.componentWillMount === "function" && instance2.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance2.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        if (isLegacyContextConsumer) {
          cacheContext(workInProgress2, unmaskedContext, context);
        }
        return instance2;
      }
      function callComponentWillMount(workInProgress2, instance2) {
        var oldState = instance2.state;
        if (typeof instance2.componentWillMount === "function") {
          instance2.componentWillMount();
        }
        if (typeof instance2.UNSAFE_componentWillMount === "function") {
          instance2.UNSAFE_componentWillMount();
        }
        if (oldState !== instance2.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
        }
      }
      function callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext) {
        var oldState = instance2.state;
        if (typeof instance2.componentWillReceiveProps === "function") {
          instance2.componentWillReceiveProps(newProps, nextContext);
        }
        if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
          instance2.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }
        if (instance2.state !== oldState) {
          {
            var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
        }
      }
      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        {
          checkClassInstance(workInProgress2, ctor, newProps);
        }
        var instance2 = workInProgress2.stateNode;
        instance2.props = newProps;
        instance2.state = workInProgress2.memoizedState;
        instance2.refs = {};
        initializeUpdateQueue(workInProgress2);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance2.context = readContext(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          instance2.context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        {
          if (instance2.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance2);
          }
          {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance2);
          }
        }
        instance2.state = workInProgress2.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          instance2.state = workInProgress2.memoizedState;
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance2.getSnapshotBeforeUpdate !== "function" && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
          callComponentWillMount(workInProgress2, instance2);
          processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
          instance2.state = workInProgress2.memoizedState;
        }
        if (typeof instance2.componentDidMount === "function") {
          var fiberFlags = Update2;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          workInProgress2.flags |= fiberFlags;
        }
      }
      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        var instance2 = workInProgress2.stateNode;
        var oldProps = workInProgress2.memoizedProps;
        instance2.props = oldProps;
        var oldContext = instance2.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance2.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance2.componentDidMount === "function") {
            var fiberFlags = Update2;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
            if (typeof instance2.componentWillMount === "function") {
              instance2.componentWillMount();
            }
            if (typeof instance2.UNSAFE_componentWillMount === "function") {
              instance2.UNSAFE_componentWillMount();
            }
          }
          if (typeof instance2.componentDidMount === "function") {
            var _fiberFlags = Update2;
            {
              _fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags;
          }
        } else {
          if (typeof instance2.componentDidMount === "function") {
            var _fiberFlags2 = Update2;
            {
              _fiberFlags2 |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags2 |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags2;
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance2.props = newProps;
        instance2.state = newState;
        instance2.context = nextContext;
        return shouldUpdate;
      }
      function updateClassInstance(current22, workInProgress2, ctor, newProps, renderLanes2) {
        var instance2 = workInProgress2.stateNode;
        cloneUpdateQueue(current22, workInProgress2);
        var unresolvedOldProps = workInProgress2.memoizedProps;
        var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
        instance2.props = oldProps;
        var unresolvedNewProps = workInProgress2.pendingProps;
        var oldContext = instance2.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
          if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance2.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && true) {
          if (typeof instance2.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current22.memoizedProps || oldState !== current22.memoizedState) {
              workInProgress2.flags |= Update2;
            }
          }
          if (typeof instance2.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current22.memoizedProps || oldState !== current22.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
        // both before and after `shouldComponentUpdate` has been called. Not ideal,
        // but I'm loath to refactor this function. This only happens for memoized
        // components so it's not that common.
        enableLazyContextPropagation;
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillUpdate === "function" || typeof instance2.componentWillUpdate === "function")) {
            if (typeof instance2.componentWillUpdate === "function") {
              instance2.componentWillUpdate(newProps, newState, nextContext);
            }
            if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
              instance2.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }
          }
          if (typeof instance2.componentDidUpdate === "function") {
            workInProgress2.flags |= Update2;
          }
          if (typeof instance2.getSnapshotBeforeUpdate === "function") {
            workInProgress2.flags |= Snapshot;
          }
        } else {
          if (typeof instance2.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current22.memoizedProps || oldState !== current22.memoizedState) {
              workInProgress2.flags |= Update2;
            }
          }
          if (typeof instance2.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current22.memoizedProps || oldState !== current22.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance2.props = newProps;
        instance2.state = newState;
        instance2.context = nextContext;
        return shouldUpdate;
      }
      function createCapturedValueAtFiber(value2, source) {
        return {
          value: value2,
          source,
          stack: getStackByFiberInDevAndProd(source),
          digest: null
        };
      }
      function createCapturedValue(value2, digest, stack) {
        return {
          value: value2,
          source: null,
          stack: stack != null ? stack : null,
          digest: digest != null ? digest : null
        };
      }
      function showErrorDialog(boundary, errorInfo) {
        return true;
      }
      function logCapturedError(boundary, errorInfo) {
        try {
          var logError = showErrorDialog(boundary, errorInfo);
          if (logError === false) {
            return;
          }
          var error2 = errorInfo.value;
          if (true) {
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            var componentStack = stack !== null ? stack : "";
            if (error2 != null && error2._suppressLogging) {
              if (boundary.tag === ClassComponent) {
                return;
              }
              console["error"](error2);
            }
            var componentName = source ? getComponentNameFromFiber(source) : null;
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
            var errorBoundaryMessage;
            if (boundary.tag === HostRoot) {
              errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
            } else {
              var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            }
            var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
            console["error"](combinedMessage);
          }
        } catch (e2) {
          setTimeout(function() {
            throw e2;
          });
        }
      }
      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
      function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error2 = errorInfo.value;
        update.callback = function() {
          onUncaughtError(error2);
          logCapturedError(fiber, errorInfo);
        };
        return update;
      }
      function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === "function") {
          var error$1 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error$1);
          };
          update.callback = function() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }
            var error$12 = errorInfo.value;
            var stack = errorInfo.stack;
            this.componentDidCatch(error$12, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                if (!includesSomeLane(fiber.lanes, SyncLane)) {
                  error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                }
              }
            }
          };
        }
        return update;
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        var threadIDs;
        if (pingCache === null) {
          pingCache = root2.pingCache = new PossiblyWeakMap$1();
          threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else {
          threadIDs = pingCache.get(wakeable);
          if (threadIDs === void 0) {
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          }
        }
        if (!threadIDs.has(lanes)) {
          threadIDs.add(lanes);
          var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root2, lanes);
            }
          }
          wakeable.then(ping, ping);
        }
      }
      function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
        var wakeables = suspenseBoundary.updateQueue;
        if (wakeables === null) {
          var updateQueue = /* @__PURE__ */ new Set();
          updateQueue.add(wakeable);
          suspenseBoundary.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        }
      }
      function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
        var tag = sourceFiber.tag;
        if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
          var currentSource = sourceFiber.alternate;
          if (currentSource) {
            sourceFiber.updateQueue = currentSource.updateQueue;
            sourceFiber.memoizedState = currentSource.memoizedState;
            sourceFiber.lanes = currentSource.lanes;
          } else {
            sourceFiber.updateQueue = null;
            sourceFiber.memoizedState = null;
          }
        }
      }
      function getNearestSuspenseBoundaryToCapture(returnFiber) {
        var node = returnFiber;
        do {
          if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
            return node;
          }
          node = node.return;
        } while (node !== null);
        return null;
      }
      function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
        if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
          if (suspenseBoundary === returnFiber) {
            suspenseBoundary.flags |= ShouldCapture;
          } else {
            suspenseBoundary.flags |= DidCapture;
            sourceFiber.flags |= ForceUpdateForLegacySuspense;
            sourceFiber.flags &= -52805;
            if (sourceFiber.tag === ClassComponent) {
              var currentSourceFiber = sourceFiber.alternate;
              if (currentSourceFiber === null) {
                sourceFiber.tag = IncompleteClassComponent;
              } else {
                var update = createUpdate(NoTimestamp, SyncLane);
                update.tag = ForceUpdate;
                enqueueUpdate(sourceFiber, update, SyncLane);
              }
            }
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
          }
          return suspenseBoundary;
        }
        suspenseBoundary.flags |= ShouldCapture;
        suspenseBoundary.lanes = rootRenderLanes;
        return suspenseBoundary;
      }
      function throwException(root2, returnFiber, sourceFiber, value2, rootRenderLanes) {
        sourceFiber.flags |= Incomplete;
        {
          if (isDevToolsPresent) {
            restorePendingUpdaters(root2, rootRenderLanes);
          }
        }
        if (value2 !== null && typeof value2 === "object" && typeof value2.then === "function") {
          var wakeable = value2;
          resetSuspendedComponent(sourceFiber);
          {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
            }
          }
          var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
          if (suspenseBoundary !== null) {
            suspenseBoundary.flags &= -257;
            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
            if (suspenseBoundary.mode & ConcurrentMode) {
              attachPingListener(root2, wakeable, rootRenderLanes);
            }
            attachRetryListener(suspenseBoundary, root2, wakeable);
            return;
          } else {
            if (!includesSyncLane(rootRenderLanes)) {
              attachPingListener(root2, wakeable, rootRenderLanes);
              renderDidSuspendDelayIfPossible();
              return;
            }
            var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
            value2 = uncaughtSuspenseError;
          }
        } else {
          if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
            markDidThrowWhileHydratingDEV();
            var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (_suspenseBoundary !== null) {
              if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                _suspenseBoundary.flags |= ForceClientRender;
              }
              markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
              queueHydrationError(createCapturedValueAtFiber(value2, sourceFiber));
              return;
            }
          }
        }
        value2 = createCapturedValueAtFiber(value2, sourceFiber);
        renderDidError(value2);
        var workInProgress2 = returnFiber;
        do {
          switch (workInProgress2.tag) {
            case HostRoot: {
              var _errorInfo = value2;
              workInProgress2.flags |= ShouldCapture;
              var lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
              enqueueCapturedUpdate(workInProgress2, update);
              return;
            }
            case ClassComponent:
              var errorInfo = value2;
              var ctor = workInProgress2.type;
              var instance2 = workInProgress2.stateNode;
              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance2 !== null && typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2))) {
                workInProgress2.flags |= ShouldCapture;
                var _lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                enqueueCapturedUpdate(workInProgress2, _update);
                return;
              }
              break;
          }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2 !== null);
      }
      function getSuspendedCache() {
        {
          return null;
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var didReceiveUpdate = false;
      var didWarnAboutBadClass;
      var didWarnAboutModulePatternComponent;
      var didWarnAboutContextTypeOnFunctionComponent;
      var didWarnAboutGetDerivedStateOnFunctionComponent;
      var didWarnAboutFunctionRefs;
      var didWarnAboutReassigningProps;
      var didWarnAboutRevealOrder;
      var didWarnAboutTailOptions;
      var didWarnAboutDefaultPropsOnFunctionComponent;
      {
        didWarnAboutBadClass = {};
        didWarnAboutModulePatternComponent = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
        didWarnAboutReassigningProps = false;
        didWarnAboutRevealOrder = {};
        didWarnAboutTailOptions = {};
        didWarnAboutDefaultPropsOnFunctionComponent = {};
      }
      function reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2) {
        if (current22 === null) {
          workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current22.child, nextChildren, renderLanes2);
        }
      }
      function forceUnmountCurrentAndReconcile(current22, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = reconcileChildFibers(workInProgress2, current22.child, null, renderLanes2);
        workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
      }
      function updateForwardRef(current22, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var render2 = Component.render;
        var ref = workInProgress2.ref;
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current22, workInProgress2, render2, nextProps, ref, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current22, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current22 !== null && !didReceiveUpdate) {
          bailoutHooks(current22, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current22, workInProgress2, Component, nextProps, renderLanes2) {
        if (current22 === null) {
          var type = Component.type;
          if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
          Component.defaultProps === void 0) {
            var resolvedType = type;
            {
              resolvedType = resolveFunctionForHotReloading(type);
            }
            workInProgress2.tag = SimpleMemoComponent;
            workInProgress2.type = resolvedType;
            {
              validateFunctionComponentInDev(workInProgress2, type);
            }
            return updateSimpleMemoComponent(current22, workInProgress2, resolvedType, nextProps, renderLanes2);
          }
          {
            var innerPropTypes = type.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(type)
              );
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
          child.ref = workInProgress2.ref;
          child.return = workInProgress2;
          workInProgress2.child = child;
          return child;
        }
        {
          var _type = Component.type;
          var _innerPropTypes = _type.propTypes;
          if (_innerPropTypes) {
            checkPropTypes(
              _innerPropTypes,
              nextProps,
              // Resolved props
              "prop",
              getComponentNameFromType(_type)
            );
          }
        }
        var currentChild = current22.child;
        var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current22, renderLanes2);
        if (!hasScheduledUpdateOrContext) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;
          if (compare(prevProps, nextProps) && current22.ref === workInProgress2.ref) {
            return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
          }
        }
        workInProgress2.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        newChild.ref = workInProgress2.ref;
        newChild.return = workInProgress2;
        workInProgress2.child = newChild;
        return newChild;
      }
      function updateSimpleMemoComponent(current22, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var outerMemoType = workInProgress2.elementType;
            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
              var lazyComponent = outerMemoType;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                outerMemoType = init(payload);
              } catch (x) {
                outerMemoType = null;
              }
              var outerPropTypes = outerMemoType && outerMemoType.propTypes;
              if (outerPropTypes) {
                checkPropTypes(
                  outerPropTypes,
                  nextProps,
                  // Resolved (SimpleMemoComponent has no defaultProps)
                  "prop",
                  getComponentNameFromType(outerMemoType)
                );
              }
            }
          }
        }
        if (current22 !== null) {
          var prevProps = current22.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current22.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
          workInProgress2.type === current22.type) {
            didReceiveUpdate = false;
            workInProgress2.pendingProps = nextProps = prevProps;
            if (!checkScheduledUpdateOrContext(current22, renderLanes2)) {
              workInProgress2.lanes = current22.lanes;
              return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
            } else if ((current22.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            }
          }
        }
        return updateFunctionComponent(current22, workInProgress2, Component, nextProps, renderLanes2);
      }
      function updateOffscreenComponent(current22, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        var prevState = current22 !== null ? current22.memoizedState : null;
        if (nextProps.mode === "hidden" || enableLegacyHidden) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            var nextState = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = nextState;
            pushRenderLanes(workInProgress2, renderLanes2);
          } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
            var spawnedCachePool = null;
            var nextBaseLanes;
            if (prevState !== null) {
              var prevBaseLanes = prevState.baseLanes;
              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
            } else {
              nextBaseLanes = renderLanes2;
            }
            workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
            var _nextState = {
              baseLanes: nextBaseLanes,
              cachePool: spawnedCachePool,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState;
            workInProgress2.updateQueue = null;
            pushRenderLanes(workInProgress2, nextBaseLanes);
            return null;
          } else {
            var _nextState2 = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState2;
            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
          }
        } else {
          var _subtreeRenderLanes;
          if (prevState !== null) {
            _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
            workInProgress2.memoizedState = null;
          } else {
            _subtreeRenderLanes = renderLanes2;
          }
          pushRenderLanes(workInProgress2, _subtreeRenderLanes);
        }
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateFragment(current22, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps;
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMode(current22, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps.children;
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateProfiler(current22, workInProgress2, renderLanes2) {
        {
          workInProgress2.flags |= Update2;
          {
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
        }
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markRef(current22, workInProgress2) {
        var ref = workInProgress2.ref;
        if (current22 === null && ref !== null || current22 !== null && current22.ref !== ref) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
      }
      function updateFunctionComponent(current22, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current22, workInProgress2, Component, nextProps, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current22, workInProgress2, Component, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current22 !== null && !didReceiveUpdate) {
          bailoutHooks(current22, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current22, workInProgress2, Component, nextProps, renderLanes2) {
        {
          switch (shouldError(workInProgress2)) {
            case false: {
              var _instance = workInProgress2.stateNode;
              var ctor = workInProgress2.type;
              var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
              var state = tempInstance.state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            }
            case true: {
              workInProgress2.flags |= DidCapture;
              workInProgress2.flags |= ShouldCapture;
              var error$1 = new Error("Simulated error coming from DevTools");
              var lane = pickArbitraryLane(renderLanes2);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
              enqueueCapturedUpdate(workInProgress2, update);
              break;
            }
          }
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var instance2 = workInProgress2.stateNode;
        var shouldUpdate;
        if (instance2 === null) {
          resetSuspendedCurrentOnMountInLegacyMode(current22, workInProgress2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          shouldUpdate = true;
        } else if (current22 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        } else {
          shouldUpdate = updateClassInstance(current22, workInProgress2, Component, nextProps, renderLanes2);
        }
        var nextUnitOfWork = finishClassComponent(current22, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
        {
          var inst = workInProgress2.stateNode;
          if (shouldUpdate && inst.props !== nextProps) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        return nextUnitOfWork;
      }
      function finishClassComponent(current22, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
        markRef(current22, workInProgress2);
        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, false);
          }
          return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
        }
        var instance2 = workInProgress2.stateNode;
        ReactCurrentOwner$1.current = workInProgress2;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;
          {
            stopProfilerTimerIfRunning();
          }
        } else {
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            setIsRendering(true);
            nextChildren = instance2.render();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance2.render();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
        }
        workInProgress2.flags |= PerformedWork;
        if (current22 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current22, workInProgress2, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        }
        workInProgress2.memoizedState = instance2.state;
        if (hasContext) {
          invalidateContextProvider(workInProgress2, Component, true);
        }
        return workInProgress2.child;
      }
      function pushHostRootContext(workInProgress2) {
        var root2 = workInProgress2.stateNode;
        if (root2.pendingContext) {
          pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
        } else if (root2.context) {
          pushTopLevelContextObject(workInProgress2, root2.context, false);
        }
        pushHostContainer(workInProgress2, root2.containerInfo);
      }
      function updateHostRoot(current22, workInProgress2, renderLanes2) {
        pushHostRootContext(workInProgress2);
        if (current22 === null) {
          throw new Error("Should have a current fiber. This is a bug in React.");
        }
        var nextProps = workInProgress2.pendingProps;
        var prevState = workInProgress2.memoizedState;
        var prevChildren = prevState.element;
        cloneUpdateQueue(current22, workInProgress2);
        processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
        var nextState = workInProgress2.memoizedState;
        workInProgress2.stateNode;
        var nextChildren = nextState.element;
        if (prevState.isDehydrated) {
          var overrideState = {
            element: nextChildren,
            isDehydrated: false,
            cache: nextState.cache,
            pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
            transitions: nextState.transitions
          };
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = overrideState;
          workInProgress2.memoizedState = overrideState;
          if (workInProgress2.flags & ForceClientRender) {
            var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current22, workInProgress2, nextChildren, renderLanes2, recoverableError);
          } else if (nextChildren !== prevChildren) {
            var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current22, workInProgress2, nextChildren, renderLanes2, _recoverableError);
          } else {
            enterHydrationState(workInProgress2);
            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            workInProgress2.child = child;
            var node = child;
            while (node) {
              node.flags = node.flags & -3 | Hydrating;
              node = node.sibling;
            }
          }
        } else {
          resetHydrationState();
          if (nextChildren === prevChildren) {
            return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
          }
          reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      function mountHostRootWithoutHydrating(current22, workInProgress2, nextChildren, renderLanes2, recoverableError) {
        resetHydrationState();
        queueHydrationError(recoverableError);
        workInProgress2.flags |= ForceClientRender;
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostComponent(current22, workInProgress2, renderLanes2) {
        pushHostContext(workInProgress2);
        if (current22 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        var type = workInProgress2.type;
        var nextProps = workInProgress2.pendingProps;
        var prevProps = current22 !== null ? current22.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);
        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress2.flags |= ContentReset;
        }
        markRef(current22, workInProgress2);
        reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostText(current22, workInProgress2) {
        if (current22 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        return null;
      }
      function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var lazyComponent = elementType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        workInProgress2.type = Component;
        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child;
        switch (resolvedTag) {
          case FunctionComponent: {
            {
              validateFunctionComponentInDev(workInProgress2, Component);
              workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
            }
            child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ClassComponent: {
            {
              workInProgress2.type = Component = resolveClassForHotReloading(Component);
            }
            child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ForwardRef: {
            {
              workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
            }
            child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case MemoComponent: {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = Component.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    resolvedProps,
                    // Resolved for outer only
                    "prop",
                    getComponentNameFromType(Component)
                  );
                }
              }
            }
            child = updateMemoComponent(
              null,
              workInProgress2,
              Component,
              resolveDefaultProps(Component.type, resolvedProps),
              // The inner type can have defaults too
              renderLanes2
            );
            return child;
          }
        }
        var hint = "";
        {
          if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
            hint = " Did you wrap a component in React.lazy() more than once?";
          }
        }
        throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
      }
      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        workInProgress2.tag = ClassComponent;
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        constructClassInstance(workInProgress2, Component, nextProps);
        mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
      }
      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var value2;
        var hasId;
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
          }
          setIsRendering(true);
          ReactCurrentOwner$1.current = workInProgress2;
          value2 = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        {
          if (typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value2 === "object" && value2 !== null && typeof value2.render === "function" && value2.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          workInProgress2.tag = ClassComponent;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          var hasContext = false;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          workInProgress2.memoizedState = value2.state !== null && value2.state !== void 0 ? value2.state : null;
          initializeUpdateQueue(workInProgress2);
          adoptClassInstance(workInProgress2, value2);
          mountClassInstance(workInProgress2, Component, props, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        } else {
          workInProgress2.tag = FunctionComponent;
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                value2 = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          reconcileChildren(null, workInProgress2, value2, renderLanes2);
          {
            validateFunctionComponentInDev(workInProgress2, Component);
          }
          return workInProgress2.child;
        }
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (workInProgress2.ref !== null) {
            var info = "";
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              info += "\n\nCheck the render method of `" + ownerName + "`.";
            }
            var warningKey = ownerName || "";
            var debugSource = workInProgress2._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
            }
            if (!didWarnAboutFunctionRefs[warningKey]) {
              didWarnAboutFunctionRefs[warningKey] = true;
              error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
            }
          }
          if (Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
              error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: NoLane
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return {
          baseLanes: renderLanes2,
          cachePool: getSuspendedCache(),
          transitions: null
        };
      }
      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
        var cachePool = null;
        return {
          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
          cachePool,
          transitions: prevOffscreenState.transitions
        };
      }
      function shouldRemainOnFallback(suspenseContext, current22, workInProgress2, renderLanes2) {
        if (current22 !== null) {
          var suspenseState = current22.memoizedState;
          if (suspenseState === null) {
            return false;
          }
        }
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      }
      function getRemainingWorkInPrimaryTree(current22, renderLanes2) {
        return removeLanes(current22.childLanes, renderLanes2);
      }
      function updateSuspenseComponent(current22, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        {
          if (shouldSuspend(workInProgress2)) {
            workInProgress2.flags |= DidCapture;
          }
        }
        var suspenseContext = suspenseStackCursor.current;
        var showFallback = false;
        var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current22)) {
          showFallback = true;
          workInProgress2.flags &= -129;
        } else {
          if (current22 === null || current22.memoizedState !== null) {
            {
              suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
            }
          }
        }
        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress2, suspenseContext);
        if (current22 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
          var suspenseState = workInProgress2.memoizedState;
          if (suspenseState !== null) {
            var dehydrated = suspenseState.dehydrated;
            if (dehydrated !== null) {
              return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
            }
          }
          var nextPrimaryChildren = nextProps.children;
          var nextFallbackChildren = nextProps.fallback;
          if (showFallback) {
            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var primaryChildFragment = workInProgress2.child;
            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackFragment;
          } else {
            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
          }
        } else {
          var prevState = current22.memoizedState;
          if (prevState !== null) {
            var _dehydrated = prevState.dehydrated;
            if (_dehydrated !== null) {
              return updateDehydratedSuspenseComponent(current22, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
            }
          }
          if (showFallback) {
            var _nextFallbackChildren = nextProps.fallback;
            var _nextPrimaryChildren = nextProps.children;
            var fallbackChildFragment = updateSuspenseFallbackChildren(current22, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
            var _primaryChildFragment2 = workInProgress2.child;
            var prevOffscreenState = current22.child.memoizedState;
            _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
            _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current22, renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          } else {
            var _nextPrimaryChildren2 = nextProps.children;
            var _primaryChildFragment3 = updateSuspensePrimaryChildren(current22, workInProgress2, _nextPrimaryChildren2, renderLanes2);
            workInProgress2.memoizedState = null;
            return _primaryChildFragment3;
          }
        }
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
        primaryChildFragment.return = workInProgress2;
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var progressedPrimaryFragment = workInProgress2.child;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        var fallbackChildFragment;
        if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = 0;
            primaryChildFragment.treeBaseDuration = 0;
          }
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        } else {
          primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        }
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
        return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
      }
      function updateWorkInProgressOffscreenFiber(current22, offscreenProps) {
        return createWorkInProgress(current22, offscreenProps);
      }
      function updateSuspensePrimaryChildren(current22, workInProgress2, primaryChildren, renderLanes2) {
        var currentPrimaryChildFragment = current22.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
          mode: "visible",
          children: primaryChildren
        });
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          primaryChildFragment.lanes = renderLanes2;
        }
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = null;
        if (currentFallbackChildFragment !== null) {
          var deletions = workInProgress2.deletions;
          if (deletions === null) {
            workInProgress2.deletions = [currentFallbackChildFragment];
            workInProgress2.flags |= ChildDeletion;
          } else {
            deletions.push(currentFallbackChildFragment);
          }
        }
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function updateSuspenseFallbackChildren(current22, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var currentPrimaryChildFragment = current22.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        if (
          // In legacy mode, we commit the primary tree as if it successfully
          // completed, even though it's in an inconsistent state.
          (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
          // already cloned. In legacy mode, the only case where this isn't true is
          // when DevTools forces us to display a fallback; we skip the first render
          // pass entirely and go straight to rendering the fallback. (In Concurrent
          // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
          // only codepath.)
          workInProgress2.child !== currentPrimaryChildFragment
        ) {
          var progressedPrimaryFragment = workInProgress2.child;
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
            primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
          }
          workInProgress2.deletions = null;
        } else {
          primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
          primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
        }
        var fallbackChildFragment;
        if (currentFallbackChildFragment !== null) {
          fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
        } else {
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
        }
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function retrySuspenseComponentWithoutHydrating(current22, workInProgress2, renderLanes2, recoverableError) {
        if (recoverableError !== null) {
          queueHydrationError(recoverableError);
        }
        reconcileChildFibers(workInProgress2, current22.child, null, renderLanes2);
        var nextProps = workInProgress2.pendingProps;
        var primaryChildren = nextProps.children;
        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
        primaryChildFragment.flags |= Placement;
        workInProgress2.memoizedState = null;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackAfterRetryWithoutHydrating(current22, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var fiberMode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
        var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
        fallbackChildFragment.flags |= Placement;
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
          reconcileChildFibers(workInProgress2, current22.child, null, renderLanes2);
        }
        return fallbackChildFragment;
      }
      function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          {
            error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
          }
          workInProgress2.lanes = laneToLanes(SyncLane);
        } else if (isSuspenseInstanceFallback(suspenseInstance)) {
          workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
        } else {
          workInProgress2.lanes = laneToLanes(OffscreenLane);
        }
        return null;
      }
      function updateDehydratedSuspenseComponent(current22, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
        if (!didSuspend) {
          warnIfHydrating();
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            return retrySuspenseComponentWithoutHydrating(
              current22,
              workInProgress2,
              renderLanes2,
              // TODO: When we delete legacy mode, we should make this error argument
              // required — every concurrent mode path that causes hydration to
              // de-opt to client rendering should have an error message.
              null
            );
          }
          if (isSuspenseInstanceFallback(suspenseInstance)) {
            var digest, message2, stack;
            {
              var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
              digest = _getSuspenseInstanceF.digest;
              message2 = _getSuspenseInstanceF.message;
              stack = _getSuspenseInstanceF.stack;
            }
            var error2;
            if (message2) {
              error2 = new Error(message2);
            } else {
              error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
            }
            var capturedValue = createCapturedValue(error2, digest, stack);
            return retrySuspenseComponentWithoutHydrating(current22, workInProgress2, renderLanes2, capturedValue);
          }
          var hasContextChanged2 = includesSomeLane(renderLanes2, current22.childLanes);
          if (didReceiveUpdate || hasContextChanged2) {
            var root2 = getWorkInProgressRoot();
            if (root2 !== null) {
              var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
              if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                suspenseState.retryLane = attemptHydrationAtLane;
                var eventTime = NoTimestamp;
                enqueueConcurrentRenderForLane(current22, attemptHydrationAtLane);
                scheduleUpdateOnFiber(root2, current22, attemptHydrationAtLane, eventTime);
              }
            }
            renderDidSuspendDelayIfPossible();
            var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
            return retrySuspenseComponentWithoutHydrating(current22, workInProgress2, renderLanes2, _capturedValue);
          } else if (isSuspenseInstancePending(suspenseInstance)) {
            workInProgress2.flags |= DidCapture;
            workInProgress2.child = current22.child;
            var retry = retryDehydratedSuspenseBoundary.bind(null, current22);
            registerSuspenseInstanceRetry(suspenseInstance, retry);
            return null;
          } else {
            reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Hydrating;
            return primaryChildFragment;
          }
        } else {
          if (workInProgress2.flags & ForceClientRender) {
            workInProgress2.flags &= -257;
            var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
            return retrySuspenseComponentWithoutHydrating(current22, workInProgress2, renderLanes2, _capturedValue2);
          } else if (workInProgress2.memoizedState !== null) {
            workInProgress2.child = current22.child;
            workInProgress2.flags |= DidCapture;
            return null;
          } else {
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current22, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var _primaryChildFragment4 = workInProgress2.child;
            _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          }
        }
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
        }
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
        var node = firstChild;
        while (node !== null) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            }
          } else if (node.tag === SuspenseListComponent) {
            scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress2) {
            return;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === workInProgress2) {
              return;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      function findLastContentRow(firstChild) {
        var row = firstChild;
        var lastContentRow = null;
        while (row !== null) {
          var currentRow = row.alternate;
          if (currentRow !== null && findFirstSuspended(currentRow) === null) {
            lastContentRow = row;
          }
          row = row.sibling;
        }
        return lastContentRow;
      }
      function validateRevealOrder(revealOrder) {
        {
          if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
            didWarnAboutRevealOrder[revealOrder] = true;
            if (typeof revealOrder === "string") {
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                case "forward":
                case "backward": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                default:
                  error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                  break;
              }
            } else {
              error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
            }
          }
        }
      }
      function validateTailOptions(tailMode, revealOrder) {
        {
          if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
            if (tailMode !== "collapsed" && tailMode !== "hidden") {
              didWarnAboutTailOptions[tailMode] = true;
              error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
            } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
              didWarnAboutTailOptions[tailMode] = true;
              error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
            }
          }
        }
      }
      function validateSuspenseListNestedChild(childSlot, index2) {
        {
          var isAnArray = isArray2(childSlot);
          var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
          if (isAnArray || isIterable) {
            var type = isAnArray ? "array" : "iterable";
            error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
            return false;
          }
        }
        return true;
      }
      function validateSuspenseListChildren(children, revealOrder) {
        {
          if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
            if (isArray2(children)) {
              for (var i2 = 0; i2 < children.length; i2++) {
                if (!validateSuspenseListNestedChild(children[i2], i2)) {
                  return;
                }
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var childrenIterator = iteratorFn.call(children);
                if (childrenIterator) {
                  var step = childrenIterator.next();
                  var _i = 0;
                  for (; !step.done; step = childrenIterator.next()) {
                    if (!validateSuspenseListNestedChild(step.value, _i)) {
                      return;
                    }
                    _i++;
                  }
                }
              } else {
                error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
              }
            }
          }
        }
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        if (renderState === null) {
          workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          };
        } else {
          renderState.isBackwards = isBackwards;
          renderState.rendering = null;
          renderState.renderingStartTime = 0;
          renderState.last = lastContentRow;
          renderState.tail = tail;
          renderState.tailMode = tailMode;
        }
      }
      function updateSuspenseListComponent(current22, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var revealOrder = nextProps.revealOrder;
        var tailMode = nextProps.tail;
        var newChildren = nextProps.children;
        validateRevealOrder(revealOrder);
        validateTailOptions(tailMode, revealOrder);
        validateSuspenseListChildren(newChildren, revealOrder);
        reconcileChildren(current22, workInProgress2, newChildren, renderLanes2);
        var suspenseContext = suspenseStackCursor.current;
        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback) {
          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          workInProgress2.flags |= DidCapture;
        } else {
          var didSuspendBefore = current22 !== null && (current22.flags & DidCapture) !== NoFlags;
          if (didSuspendBefore) {
            propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        pushSuspenseContext(workInProgress2, suspenseContext);
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          workInProgress2.memoizedState = null;
        } else {
          switch (revealOrder) {
            case "forwards": {
              var lastContentRow = findLastContentRow(workInProgress2.child);
              var tail;
              if (lastContentRow === null) {
                tail = workInProgress2.child;
                workInProgress2.child = null;
              } else {
                tail = lastContentRow.sibling;
                lastContentRow.sibling = null;
              }
              initSuspenseListRenderState(
                workInProgress2,
                false,
                // isBackwards
                tail,
                lastContentRow,
                tailMode
              );
              break;
            }
            case "backwards": {
              var _tail = null;
              var row = workInProgress2.child;
              workInProgress2.child = null;
              while (row !== null) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                  workInProgress2.child = row;
                  break;
                }
                var nextRow = row.sibling;
                row.sibling = _tail;
                _tail = row;
                row = nextRow;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                // isBackwards
                _tail,
                null,
                // last
                tailMode
              );
              break;
            }
            case "together": {
              initSuspenseListRenderState(
                workInProgress2,
                false,
                // isBackwards
                null,
                // tail
                null,
                // last
                void 0
              );
              break;
            }
            default: {
              workInProgress2.memoizedState = null;
            }
          }
        }
        return workInProgress2.child;
      }
      function updatePortalComponent(current22, workInProgress2, renderLanes2) {
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        var nextChildren = workInProgress2.pendingProps;
        if (current22 === null) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current22, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
      function updateContextProvider(current22, workInProgress2, renderLanes2) {
        var providerType = workInProgress2.type;
        var context = providerType._context;
        var newProps = workInProgress2.pendingProps;
        var oldProps = workInProgress2.memoizedProps;
        var newValue = newProps.value;
        {
          if (!("value" in newProps)) {
            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
              hasWarnedAboutUsingNoValuePropOnContextProvider = true;
              error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
            }
          }
          var providerPropTypes = workInProgress2.type.propTypes;
          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
          }
        }
        pushProvider(workInProgress2, context, newValue);
        {
          if (oldProps !== null) {
            var oldValue = oldProps.value;
            if (objectIs(oldValue, newValue)) {
              if (oldProps.children === newProps.children && !hasContextChanged()) {
                return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
              }
            } else {
              propagateContextChange(workInProgress2, context, renderLanes2);
            }
          }
        }
        var newChildren = newProps.children;
        reconcileChildren(current22, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingContextAsConsumer = false;
      function updateContextConsumer(current22, workInProgress2, renderLanes2) {
        var context = workInProgress2.type;
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress2.pendingProps;
        var render2 = newProps.children;
        {
          if (typeof render2 !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var newValue = readContext(context);
        {
          markComponentRenderStarted(workInProgress2);
        }
        var newChildren;
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          newChildren = render2(newValue);
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current22, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
      }
      function resetSuspendedCurrentOnMountInLegacyMode(current22, workInProgress2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          if (current22 !== null) {
            current22.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
        }
      }
      function bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2) {
        if (current22 !== null) {
          workInProgress2.dependencies = current22.dependencies;
        }
        {
          stopProfilerTimerIfRunning();
        }
        markSkippedUpdateLanes(workInProgress2.lanes);
        if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
          {
            return null;
          }
        }
        cloneChildFibers(current22, workInProgress2);
        return workInProgress2.child;
      }
      function remountFiber(current22, oldWorkInProgress, newWorkInProgress) {
        {
          var returnFiber = oldWorkInProgress.return;
          if (returnFiber === null) {
            throw new Error("Cannot swap the root fiber.");
          }
          current22.alternate = null;
          oldWorkInProgress.alternate = null;
          newWorkInProgress.index = oldWorkInProgress.index;
          newWorkInProgress.sibling = oldWorkInProgress.sibling;
          newWorkInProgress.return = oldWorkInProgress.return;
          newWorkInProgress.ref = oldWorkInProgress.ref;
          if (oldWorkInProgress === returnFiber.child) {
            returnFiber.child = newWorkInProgress;
          } else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null) {
              throw new Error("Expected parent to have a child.");
            }
            while (prevSibling.sibling !== oldWorkInProgress) {
              prevSibling = prevSibling.sibling;
              if (prevSibling === null) {
                throw new Error("Expected to find the previous sibling.");
              }
            }
            prevSibling.sibling = newWorkInProgress;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [current22];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(current22);
          }
          newWorkInProgress.flags |= Placement;
          return newWorkInProgress;
        }
      }
      function checkScheduledUpdateOrContext(current22, renderLanes2) {
        var updateLanes = current22.lanes;
        if (includesSomeLane(updateLanes, renderLanes2)) {
          return true;
        }
        return false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current22, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress2);
            workInProgress2.stateNode;
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress2);
            break;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress2);
            }
            break;
          }
          case HostPortal:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case ContextProvider: {
            var newValue = workInProgress2.memoizedProps.value;
            var context = workInProgress2.type._context;
            pushProvider(workInProgress2, context, newValue);
            break;
          }
          case Profiler:
            {
              var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (hasChildWork) {
                workInProgress2.flags |= Update2;
              }
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            break;
          case SuspenseComponent: {
            var state = workInProgress2.memoizedState;
            if (state !== null) {
              if (state.dehydrated !== null) {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                workInProgress2.flags |= DidCapture;
                return null;
              }
              var primaryChildFragment = workInProgress2.child;
              var primaryChildLanes = primaryChildFragment.childLanes;
              if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                return updateSuspenseComponent(current22, workInProgress2, renderLanes2);
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                var child = bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
                if (child !== null) {
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }
            break;
          }
          case SuspenseListComponent: {
            var didSuspendBefore = (current22.flags & DidCapture) !== NoFlags;
            var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
            if (didSuspendBefore) {
              if (_hasChildWork) {
                return updateSuspenseListComponent(current22, workInProgress2, renderLanes2);
              }
              workInProgress2.flags |= DidCapture;
            }
            var renderState = workInProgress2.memoizedState;
            if (renderState !== null) {
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }
            pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
            if (_hasChildWork) {
              break;
            } else {
              return null;
            }
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            workInProgress2.lanes = NoLanes;
            return updateOffscreenComponent(current22, workInProgress2, renderLanes2);
          }
        }
        return bailoutOnAlreadyFinishedWork(current22, workInProgress2, renderLanes2);
      }
      function beginWork(current22, workInProgress2, renderLanes2) {
        {
          if (workInProgress2._debugNeedsRemount && current22 !== null) {
            return remountFiber(current22, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
          }
        }
        if (current22 !== null) {
          var oldProps = current22.memoizedProps;
          var newProps = workInProgress2.pendingProps;
          if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
          workInProgress2.type !== current22.type) {
            didReceiveUpdate = true;
          } else {
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current22, renderLanes2);
            if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
            // may not be work scheduled on `current`, so we check for this flag.
            (workInProgress2.flags & DidCapture) === NoFlags) {
              didReceiveUpdate = false;
              return attemptEarlyBailoutIfNoScheduledUpdate(current22, workInProgress2, renderLanes2);
            }
            if ((current22.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            } else {
              didReceiveUpdate = false;
            }
          }
        } else {
          didReceiveUpdate = false;
          if (getIsHydrating() && isForkedChild(workInProgress2)) {
            var slotIndex = workInProgress2.index;
            var numberOfForks = getForksAtLevel();
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        workInProgress2.lanes = NoLanes;
        switch (workInProgress2.tag) {
          case IndeterminateComponent: {
            return mountIndeterminateComponent(current22, workInProgress2, workInProgress2.type, renderLanes2);
          }
          case LazyComponent: {
            var elementType = workInProgress2.elementType;
            return mountLazyComponent(current22, workInProgress2, elementType, renderLanes2);
          }
          case FunctionComponent: {
            var Component = workInProgress2.type;
            var unresolvedProps = workInProgress2.pendingProps;
            var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
            return updateFunctionComponent(current22, workInProgress2, Component, resolvedProps, renderLanes2);
          }
          case ClassComponent: {
            var _Component = workInProgress2.type;
            var _unresolvedProps = workInProgress2.pendingProps;
            var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
            return updateClassComponent(current22, workInProgress2, _Component, _resolvedProps, renderLanes2);
          }
          case HostRoot:
            return updateHostRoot(current22, workInProgress2, renderLanes2);
          case HostComponent:
            return updateHostComponent(current22, workInProgress2, renderLanes2);
          case HostText:
            return updateHostText(current22, workInProgress2);
          case SuspenseComponent:
            return updateSuspenseComponent(current22, workInProgress2, renderLanes2);
          case HostPortal:
            return updatePortalComponent(current22, workInProgress2, renderLanes2);
          case ForwardRef: {
            var type = workInProgress2.type;
            var _unresolvedProps2 = workInProgress2.pendingProps;
            var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
            return updateForwardRef(current22, workInProgress2, type, _resolvedProps2, renderLanes2);
          }
          case Fragment:
            return updateFragment(current22, workInProgress2, renderLanes2);
          case Mode:
            return updateMode(current22, workInProgress2, renderLanes2);
          case Profiler:
            return updateProfiler(current22, workInProgress2, renderLanes2);
          case ContextProvider:
            return updateContextProvider(current22, workInProgress2, renderLanes2);
          case ContextConsumer:
            return updateContextConsumer(current22, workInProgress2, renderLanes2);
          case MemoComponent: {
            var _type2 = workInProgress2.type;
            var _unresolvedProps3 = workInProgress2.pendingProps;
            var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = _type2.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    _resolvedProps3,
                    // Resolved for outer only
                    "prop",
                    getComponentNameFromType(_type2)
                  );
                }
              }
            }
            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
            return updateMemoComponent(current22, workInProgress2, _type2, _resolvedProps3, renderLanes2);
          }
          case SimpleMemoComponent: {
            return updateSimpleMemoComponent(current22, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
          }
          case IncompleteClassComponent: {
            var _Component2 = workInProgress2.type;
            var _unresolvedProps4 = workInProgress2.pendingProps;
            var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
            return mountIncompleteClassComponent(current22, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
          }
          case SuspenseListComponent: {
            return updateSuspenseListComponent(current22, workInProgress2, renderLanes2);
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent: {
            return updateOffscreenComponent(current22, workInProgress2, renderLanes2);
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= Update2;
      }
      function markRef$1(workInProgress2) {
        workInProgress2.flags |= Ref;
        {
          workInProgress2.flags |= RefStatic;
        }
      }
      var appendAllChildren;
      var updateHostContainer;
      var updateHostComponent$1;
      var updateHostText$1;
      {
        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
          var node = workInProgress2.child;
          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) ;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        };
        updateHostContainer = function(current22, workInProgress2) {
        };
        updateHostComponent$1 = function(current22, workInProgress2, type, newProps, rootContainerInstance) {
          var oldProps = current22.memoizedProps;
          if (oldProps === newProps) {
            return;
          }
          var instance2 = workInProgress2.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance2, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress2.updateQueue = updatePayload;
          if (updatePayload) {
            markUpdate(workInProgress2);
          }
        };
        updateHostText$1 = function(current22, workInProgress2, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress2);
          }
        };
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (getIsHydrating()) {
          return;
        }
        switch (renderState.tailMode) {
          case "hidden": {
            var tailNode = renderState.tail;
            var lastTailNode = null;
            while (tailNode !== null) {
              if (tailNode.alternate !== null) {
                lastTailNode = tailNode;
              }
              tailNode = tailNode.sibling;
            }
            if (lastTailNode === null) {
              renderState.tail = null;
            } else {
              lastTailNode.sibling = null;
            }
            break;
          }
          case "collapsed": {
            var _tailNode = renderState.tail;
            var _lastTailNode = null;
            while (_tailNode !== null) {
              if (_tailNode.alternate !== null) {
                _lastTailNode = _tailNode;
              }
              _tailNode = _tailNode.sibling;
            }
            if (_lastTailNode === null) {
              if (!hasRenderedATailFallback && renderState.tail !== null) {
                renderState.tail.sibling = null;
              } else {
                renderState.tail = null;
              }
            } else {
              _lastTailNode.sibling = null;
            }
            break;
          }
        }
      }
      function bubbleProperties(completedWork) {
        var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
        var newChildLanes = NoLanes;
        var subtreeFlags = NoFlags;
        if (!didBailout) {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration;
            var child = completedWork.child;
            while (child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
              subtreeFlags |= child.subtreeFlags;
              subtreeFlags |= child.flags;
              actualDuration += child.actualDuration;
              treeBaseDuration += child.treeBaseDuration;
              child = child.sibling;
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
          } else {
            var _child = completedWork.child;
            while (_child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
              subtreeFlags |= _child.subtreeFlags;
              subtreeFlags |= _child.flags;
              _child.return = completedWork;
              _child = _child.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        } else {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var _treeBaseDuration = completedWork.selfBaseDuration;
            var _child2 = completedWork.child;
            while (_child2 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
              subtreeFlags |= _child2.subtreeFlags & StaticMask;
              subtreeFlags |= _child2.flags & StaticMask;
              _treeBaseDuration += _child2.treeBaseDuration;
              _child2 = _child2.sibling;
            }
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else {
            var _child3 = completedWork.child;
            while (_child3 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
              subtreeFlags |= _child3.subtreeFlags & StaticMask;
              subtreeFlags |= _child3.flags & StaticMask;
              _child3.return = completedWork;
              _child3 = _child3.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        }
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeDehydratedSuspenseBoundary(current22, workInProgress2, nextState) {
        if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
          warnIfUnhydratedTailNodes(workInProgress2);
          resetHydrationState();
          workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
          return false;
        }
        var wasHydrated = popHydrationState(workInProgress2);
        if (nextState !== null && nextState.dehydrated !== null) {
          if (current22 === null) {
            if (!wasHydrated) {
              throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
            }
            prepareToHydrateHostSuspenseInstance(workInProgress2);
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var isTimedOutSuspense = nextState !== null;
                if (isTimedOutSuspense) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          } else {
            resetHydrationState();
            if ((workInProgress2.flags & DidCapture) === NoFlags) {
              workInProgress2.memoizedState = null;
            }
            workInProgress2.flags |= Update2;
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var _isTimedOutSuspense = nextState !== null;
                if (_isTimedOutSuspense) {
                  var _primaryChildFragment = workInProgress2.child;
                  if (_primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          }
        } else {
          upgradeHydrationErrorsToRecoverable();
          return true;
        }
      }
      function completeWork(current22, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case SimpleMemoComponent:
          case FunctionComponent:
          case ForwardRef:
          case Fragment:
          case Mode:
          case Profiler:
          case ContextConsumer:
          case MemoComponent:
            bubbleProperties(workInProgress2);
            return null;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostRoot: {
            var fiberRoot = workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }
            if (current22 === null || current22.child === null) {
              var wasHydrated = popHydrationState(workInProgress2);
              if (wasHydrated) {
                markUpdate(workInProgress2);
              } else {
                if (current22 !== null) {
                  var prevState = current22.memoizedState;
                  if (
                    // Check if this is a client root
                    !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                    (workInProgress2.flags & ForceClientRender) !== NoFlags
                  ) {
                    workInProgress2.flags |= Snapshot;
                    upgradeHydrationErrorsToRecoverable();
                  }
                }
              }
            }
            updateHostContainer(current22, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress2.type;
            if (current22 !== null && workInProgress2.stateNode != null) {
              updateHostComponent$1(current22, workInProgress2, type, newProps, rootContainerInstance);
              if (current22.ref !== workInProgress2.ref) {
                markRef$1(workInProgress2);
              }
            } else {
              if (!newProps) {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              var currentHostContext = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress2);
              if (_wasHydrated) {
                if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                  markUpdate(workInProgress2);
                }
              } else {
                var instance2 = createInstance2(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                appendAllChildren(instance2, workInProgress2, false, false);
                workInProgress2.stateNode = instance2;
                if (finalizeInitialChildren(instance2, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress2);
                }
              }
              if (workInProgress2.ref !== null) {
                markRef$1(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostText: {
            var newText = newProps;
            if (current22 && workInProgress2.stateNode != null) {
              var oldText = current22.memoizedProps;
              updateHostText$1(current22, workInProgress2, oldText, newText);
            } else {
              if (typeof newText !== "string") {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext = getHostContext();
              var _wasHydrated2 = popHydrationState(workInProgress2);
              if (_wasHydrated2) {
                if (prepareToHydrateHostTextInstance(workInProgress2)) {
                  markUpdate(workInProgress2);
                }
              } else {
                workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var nextState = workInProgress2.memoizedState;
            if (current22 === null || current22.memoizedState !== null && current22.memoizedState.dehydrated !== null) {
              var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current22, workInProgress2, nextState);
              if (!fallthroughToNormalSuspensePath) {
                if (workInProgress2.flags & ShouldCapture) {
                  return workInProgress2;
                } else {
                  return null;
                }
              }
            }
            if ((workInProgress2.flags & DidCapture) !== NoFlags) {
              workInProgress2.lanes = renderLanes2;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            var nextDidTimeout = nextState !== null;
            var prevDidTimeout = current22 !== null && current22.memoizedState !== null;
            if (nextDidTimeout !== prevDidTimeout) {
              if (nextDidTimeout) {
                var _offscreenFiber2 = workInProgress2.child;
                _offscreenFiber2.flags |= Visibility;
                if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                  var hasInvisibleChildContext = current22 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || true);
                  if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                    renderDidSuspend();
                  } else {
                    renderDidSuspendDelayIfPossible();
                  }
                }
              }
            }
            var wakeables = workInProgress2.updateQueue;
            if (wakeables !== null) {
              workInProgress2.flags |= Update2;
            }
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                if (nextDidTimeout) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            updateHostContainer(current22, workInProgress2);
            if (current22 === null) {
              preparePortalMount(workInProgress2.stateNode.containerInfo);
            }
            bubbleProperties(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          case IncompleteClassComponent: {
            var _Component = workInProgress2.type;
            if (isContextProvider(_Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              bubbleProperties(workInProgress2);
              return null;
            }
            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
            var renderedTail = renderState.rendering;
            if (renderedTail === null) {
              if (!didSuspendAlready) {
                var cannotBeSuspended = renderHasNotSuspendedYet() && (current22 === null || (current22.flags & DidCapture) === NoFlags);
                if (!cannotBeSuspended) {
                  var row = workInProgress2.child;
                  while (row !== null) {
                    var suspended = findFirstSuspended(row);
                    if (suspended !== null) {
                      didSuspendAlready = true;
                      workInProgress2.flags |= DidCapture;
                      cutOffTailIfNeeded(renderState, false);
                      var newThenables = suspended.updateQueue;
                      if (newThenables !== null) {
                        workInProgress2.updateQueue = newThenables;
                        workInProgress2.flags |= Update2;
                      }
                      workInProgress2.subtreeFlags = NoFlags;
                      resetChildFibers(workInProgress2, renderLanes2);
                      pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                      return workInProgress2.child;
                    }
                    row = row.sibling;
                  }
                }
                if (renderState.tail !== null && now() > getRenderTargetTime()) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              } else {
                cutOffTailIfNeeded(renderState, false);
              }
            } else {
              if (!didSuspendAlready) {
                var _suspended = findFirstSuspended(renderedTail);
                if (_suspended !== null) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  var _newThenables = _suspended.updateQueue;
                  if (_newThenables !== null) {
                    workInProgress2.updateQueue = _newThenables;
                    workInProgress2.flags |= Update2;
                  }
                  cutOffTailIfNeeded(renderState, true);
                  if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                } else if (
                  // The time it took to render last row is greater than the remaining
                  // time we have to render. So rendering one more row would likely
                  // exceed it.
                  now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                ) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              }
              if (renderState.isBackwards) {
                renderedTail.sibling = workInProgress2.child;
                workInProgress2.child = renderedTail;
              } else {
                var previousSibling = renderState.last;
                if (previousSibling !== null) {
                  previousSibling.sibling = renderedTail;
                } else {
                  workInProgress2.child = renderedTail;
                }
                renderState.last = renderedTail;
              }
            }
            if (renderState.tail !== null) {
              var next = renderState.tail;
              renderState.rendering = next;
              renderState.tail = next.sibling;
              renderState.renderingStartTime = now();
              next.sibling = null;
              var suspenseContext = suspenseStackCursor.current;
              if (didSuspendAlready) {
                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              } else {
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
              }
              pushSuspenseContext(workInProgress2, suspenseContext);
              return next;
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            popRenderLanes(workInProgress2);
            var _nextState = workInProgress2.memoizedState;
            var nextIsHidden = _nextState !== null;
            if (current22 !== null) {
              var _prevState = current22.memoizedState;
              var prevIsHidden = _prevState !== null;
              if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
              true) {
                workInProgress2.flags |= Visibility;
              }
            }
            if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
              bubbleProperties(workInProgress2);
            } else {
              if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                bubbleProperties(workInProgress2);
                {
                  if (workInProgress2.subtreeFlags & (Placement | Update2)) {
                    workInProgress2.flags |= Visibility;
                  }
                }
              }
            }
            return null;
          }
          case CacheComponent: {
            return null;
          }
          case TracingMarkerComponent: {
            return null;
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function unwindWork(current22, workInProgress2, renderLanes2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            var flags = workInProgress2.flags;
            if (flags & ShouldCapture) {
              workInProgress2.flags = flags & -65537 | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case HostRoot: {
            workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            var _flags = workInProgress2.flags;
            if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
              workInProgress2.flags = _flags & -65537 | DidCapture;
              return workInProgress2;
            }
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              if (workInProgress2.alternate === null) {
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              }
              resetHydrationState();
            }
            var _flags2 = workInProgress2.flags;
            if (_flags2 & ShouldCapture) {
              workInProgress2.flags = _flags2 & -65537 | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            return null;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(workInProgress2);
            return null;
          case CacheComponent:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current22, interruptedWork, renderLanes2) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case ClassComponent: {
            var childContextTypes = interruptedWork.type.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              popContext(interruptedWork);
            }
            break;
          }
          case HostRoot: {
            interruptedWork.stateNode;
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            resetWorkInProgressVersions();
            break;
          }
          case HostComponent: {
            popHostContext(interruptedWork);
            break;
          }
          case HostPortal:
            popHostContainer(interruptedWork);
            break;
          case SuspenseComponent:
            popSuspenseContext(interruptedWork);
            break;
          case SuspenseListComponent:
            popSuspenseContext(interruptedWork);
            break;
          case ContextProvider:
            var context = interruptedWork.type._context;
            popProvider(context, interruptedWork);
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(interruptedWork);
            break;
        }
      }
      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
      var nextEffect = null;
      var inProgressLanes = null;
      var inProgressRoot = null;
      function reportUncaughtErrorInDEV(error2) {
        {
          invokeGuardedCallback(null, function() {
            throw error2;
          });
          clearCaughtError();
        }
      }
      var callComponentWillUnmountWithTimer = function(current22, instance2) {
        instance2.props = current22.memoizedProps;
        instance2.state = current22.memoizedState;
        if (current22.mode & ProfileMode) {
          try {
            startLayoutEffectTimer();
            instance2.componentWillUnmount();
          } finally {
            recordLayoutEffectDuration(current22);
          }
        } else {
          instance2.componentWillUnmount();
        }
      };
      function safelyCallCommitHookLayoutEffectListMount(current22, nearestMountedAncestor) {
        try {
          commitHookEffectListMount(Layout, current22);
        } catch (error2) {
          captureCommitPhaseError(current22, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentWillUnmount(current22, nearestMountedAncestor, instance2) {
        try {
          callComponentWillUnmountWithTimer(current22, instance2);
        } catch (error2) {
          captureCommitPhaseError(current22, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentDidMount(current22, nearestMountedAncestor, instance2) {
        try {
          instance2.componentDidMount();
        } catch (error2) {
          captureCommitPhaseError(current22, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current22, nearestMountedAncestor) {
        try {
          commitAttachRef(current22);
        } catch (error2) {
          captureCommitPhaseError(current22, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current22, nearestMountedAncestor) {
        var ref = current22.ref;
        if (ref !== null) {
          if (typeof ref === "function") {
            var retVal;
            try {
              if (enableProfilerTimer && enableProfilerCommitHooks && current22.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(null);
                } finally {
                  recordLayoutEffectDuration(current22);
                }
              } else {
                retVal = ref(null);
              }
            } catch (error2) {
              captureCommitPhaseError(current22, nearestMountedAncestor, error2);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current22));
              }
            }
          } else {
            ref.current = null;
          }
        }
      }
      function safelyCallDestroy(current22, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error2) {
          captureCommitPhaseError(current22, nearestMountedAncestor, error2);
        }
      }
      var shouldFireAfterActiveInstanceBlur = false;
      function commitBeforeMutationEffects(root2, firstChild) {
        prepareForCommit(root2.containerInfo);
        nextEffect = firstChild;
        commitBeforeMutationEffects_begin();
        var shouldFire = shouldFireAfterActiveInstanceBlur;
        shouldFireAfterActiveInstanceBlur = false;
        return shouldFire;
      }
      function commitBeforeMutationEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitBeforeMutationEffects_complete();
          }
        }
      }
      function commitBeforeMutationEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            commitBeforeMutationEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitBeforeMutationEffectsOnFiber(finishedWork) {
        var current22 = finishedWork.alternate;
        var flags = finishedWork.flags;
        if ((flags & Snapshot) !== NoFlags) {
          setCurrentFiber(finishedWork);
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              break;
            }
            case ClassComponent: {
              if (current22 !== null) {
                var prevProps = current22.memoizedProps;
                var prevState = current22.memoizedState;
                var instance2 = finishedWork.stateNode;
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance2.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance2.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                var snapshot = instance2.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                  }
                }
                instance2.__reactInternalSnapshotBeforeUpdate = snapshot;
              }
              break;
            }
            case HostRoot: {
              {
                var root2 = finishedWork.stateNode;
                clearContainer(root2.containerInfo);
              }
              break;
            }
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
              break;
            default: {
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          resetCurrentFiber();
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              var destroy = effect.destroy;
              effect.destroy = void 0;
              if (destroy !== void 0) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStarted(finishedWork);
                  }
                }
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStopped();
                  }
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStarted(finishedWork);
                } else if ((flags & Layout) !== NoFlags$1) {
                  markComponentLayoutEffectMountStarted(finishedWork);
                }
              }
              var create = effect.create;
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(true);
                }
              }
              effect.destroy = create();
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(false);
                }
              }
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStopped();
                } else if ((flags & Layout) !== NoFlags$1) {
                  markComponentLayoutEffectMountStopped();
                }
              }
              {
                var destroy = effect.destroy;
                if (destroy !== void 0 && typeof destroy !== "function") {
                  var hookName = void 0;
                  if ((effect.tag & Layout) !== NoFlags) {
                    hookName = "useLayoutEffect";
                  } else if ((effect.tag & Insertion) !== NoFlags) {
                    hookName = "useInsertionEffect";
                  } else {
                    hookName = "useEffect";
                  }
                  var addendum = void 0;
                  if (destroy === null) {
                    addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                  } else if (typeof destroy.then === "function") {
                    addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                  } else {
                    addendum = " You returned: " + destroy;
                  }
                  error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitPassiveEffectDurations(finishedRoot, finishedWork) {
        {
          if ((finishedWork.flags & Update2) !== NoFlags) {
            switch (finishedWork.tag) {
              case Profiler: {
                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                var commitTime2 = getCommitTime();
                var phase = finishedWork.alternate === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onPostCommit === "function") {
                  onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                }
                var parentFiber = finishedWork.return;
                outer: while (parentFiber !== null) {
                  switch (parentFiber.tag) {
                    case HostRoot:
                      var root2 = parentFiber.stateNode;
                      root2.passiveEffectDuration += passiveEffectDuration;
                      break outer;
                    case Profiler:
                      var parentStateNode = parentFiber.stateNode;
                      parentStateNode.passiveEffectDuration += passiveEffectDuration;
                      break outer;
                  }
                  parentFiber = parentFiber.return;
                }
                break;
              }
            }
          }
        }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current22, finishedWork, committedLanes) {
        if ((finishedWork.flags & LayoutMask) !== NoFlags) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Layout | HasEffect, finishedWork);
                }
              }
              break;
            }
            case ClassComponent: {
              var instance2 = finishedWork.stateNode;
              if (finishedWork.flags & Update2) {
                if (!offscreenSubtreeWasHidden) {
                  if (current22 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance2.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance2.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance2.componentDidMount();
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance2.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current22.memoizedProps : resolveDefaultProps(finishedWork.type, current22.memoizedProps);
                    var prevState = current22.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance2.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance2.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
              }
              var updateQueue = finishedWork.updateQueue;
              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance2.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance2.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance2);
              }
              break;
            }
            case HostRoot: {
              var _updateQueue = finishedWork.updateQueue;
              if (_updateQueue !== null) {
                var _instance = null;
                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;
                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }
                commitUpdateQueue(finishedWork, _updateQueue, _instance);
              }
              break;
            }
            case HostComponent: {
              var _instance2 = finishedWork.stateNode;
              if (current22 === null && finishedWork.flags & Update2) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props);
              }
              break;
            }
            case HostText: {
              break;
            }
            case HostPortal: {
              break;
            }
            case Profiler: {
              {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime2 = getCommitTime();
                var phase = current22 === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onRender === "function") {
                  onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                }
                {
                  if (typeof onCommit === "function") {
                    onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                  }
                  enqueuePendingPassiveProfilerEffect(finishedWork);
                  var parentFiber = finishedWork.return;
                  outer: while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root2 = parentFiber.stateNode;
                        root2.effectDuration += effectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.effectDuration += effectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                }
              }
              break;
            }
            case SuspenseComponent: {
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            }
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
            case TracingMarkerComponent: {
              break;
            }
            default:
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (!offscreenSubtreeWasHidden) {
          {
            if (finishedWork.flags & Ref) {
              commitAttachRef(finishedWork);
            }
          }
        }
      }
      function reappearLayoutEffectsOnFiber(node) {
        switch (node.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (node.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              } finally {
                recordLayoutEffectDuration(node);
              }
            } else {
              safelyCallCommitHookLayoutEffectListMount(node, node.return);
            }
            break;
          }
          case ClassComponent: {
            var instance2 = node.stateNode;
            if (typeof instance2.componentDidMount === "function") {
              safelyCallComponentDidMount(node, node.return, instance2);
            }
            safelyAttachRef(node, node.return);
            break;
          }
          case HostComponent: {
            safelyAttachRef(node, node.return);
            break;
          }
        }
      }
      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        var hostSubtreeRoot = null;
        {
          var node = finishedWork;
          while (true) {
            if (node.tag === HostComponent) {
              if (hostSubtreeRoot === null) {
                hostSubtreeRoot = node;
                try {
                  var instance2 = node.stateNode;
                  if (isHidden) {
                    hideInstance(instance2);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if (node.tag === HostText) {
              if (hostSubtreeRoot === null) {
                try {
                  var _instance3 = node.stateNode;
                  if (isHidden) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === finishedWork) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node = node.return;
            }
            if (hostSubtreeRoot === node) {
              hostSubtreeRoot = null;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
          var instance2 = finishedWork.stateNode;
          var instanceToUse;
          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance2);
              break;
            default:
              instanceToUse = instance2;
          }
          if (typeof ref === "function") {
            var retVal;
            if (finishedWork.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                retVal = ref(instanceToUse);
              } finally {
                recordLayoutEffectDuration(finishedWork);
              }
            } else {
              retVal = ref(instanceToUse);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
              }
            }
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }
      function detachFiberMutation(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.return = null;
        }
        fiber.return = null;
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          fiber.alternate = null;
          detachFiberAfterEffects(alternate);
        }
        {
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          if (fiber.tag === HostComponent) {
            var hostInstance = fiber.stateNode;
            if (hostInstance !== null) {
              detachDeletedInstance(hostInstance);
            }
          }
          fiber.stateNode = null;
          {
            fiber._debugOwner = null;
          }
          {
            fiber.return = null;
            fiber.dependencies = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.stateNode = null;
            fiber.updateQueue = null;
          }
        }
      }
      function getHostParentFiber(fiber) {
        var parent = fiber.return;
        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }
          parent = parent.return;
        }
        throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }
      function getHostSibling(fiber) {
        var node = fiber;
        siblings: while (true) {
          while (node.sibling === null) {
            if (node.return === null || isHostParent(node.return)) {
              return null;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
          while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
            if (node.flags & Placement) {
              continue siblings;
            }
            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child.return = node;
              node = node.child;
            }
          }
          if (!(node.flags & Placement)) {
            return node.stateNode;
          }
        }
      }
      function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork);
        switch (parentFiber.tag) {
          case HostComponent: {
            var parent = parentFiber.stateNode;
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= -33;
            }
            var before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          }
          case HostRoot:
          case HostPortal: {
            var _parent = parentFiber.stateNode.containerInfo;
            var _before = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          if (before) {
            insertInContainerBefore(parent, stateNode, before);
          } else {
            appendChildToContainer(parent, stateNode);
          }
        } else if (tag === HostPortal) ;
        else {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          if (before) {
            insertBefore(parent, stateNode, before);
          } else {
            appendChild(parent, stateNode);
          }
        } else if (tag === HostPortal) ;
        else {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNode(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNode(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function commitDeletionEffects(root2, returnFiber, deletedFiber) {
        {
          var parent = returnFiber;
          findParent: while (parent !== null) {
            switch (parent.tag) {
              case HostComponent: {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break findParent;
              }
              case HostRoot: {
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break findParent;
              }
              case HostPortal: {
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break findParent;
              }
            }
            parent = parent.return;
          }
          if (hostParent === null) {
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = false;
        }
        detachFiberMutation(deletedFiber);
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        var child = parent.child;
        while (child !== null) {
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
          child = child.sibling;
        }
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        onCommitUnmount(deletedFiber);
        switch (deletedFiber.tag) {
          case HostComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
            }
          }
          case HostText: {
            {
              var prevHostParent = hostParent;
              var prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  removeChildFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  removeChild(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case DehydratedFragment: {
            {
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case HostPortal: {
            {
              var _prevHostParent = hostParent;
              var _prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = _prevHostParent;
              hostParentIsContainer = _prevHostParentIsContainer;
            }
            return;
          }
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (!offscreenSubtreeWasHidden) {
              var updateQueue = deletedFiber.updateQueue;
              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;
                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;
                  do {
                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                    if (destroy !== void 0) {
                      if ((tag & Insertion) !== NoFlags$1) {
                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                      } else if ((tag & Layout) !== NoFlags$1) {
                        {
                          markComponentLayoutEffectUnmountStarted(deletedFiber);
                        }
                        if (deletedFiber.mode & ProfileMode) {
                          startLayoutEffectTimer();
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          recordLayoutEffectDuration(deletedFiber);
                        } else {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        }
                        {
                          markComponentLayoutEffectUnmountStopped();
                        }
                      }
                    }
                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ClassComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var instance2 = deletedFiber.stateNode;
              if (typeof instance2.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance2);
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ScopeComponent: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case OffscreenComponent: {
            if (
              // TODO: Remove this dead flag
              deletedFiber.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            }
            break;
          }
          default: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
        }
      }
      function commitSuspenseCallback(finishedWork) {
        finishedWork.memoizedState;
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
          var current22 = finishedWork.alternate;
          if (current22 !== null) {
            var prevState = current22.memoizedState;
            if (prevState !== null) {
              var suspenseInstance = prevState.dehydrated;
              if (suspenseInstance !== null) {
                commitHydratedSuspenseInstance(suspenseInstance);
              }
            }
          }
        }
      }
      function attachSuspenseRetryListeners(finishedWork) {
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          if (retryCache === null) {
            retryCache = finishedWork.stateNode = new PossiblyWeakSet();
          }
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              {
                if (isDevToolsPresent) {
                  if (inProgressLanes !== null && inProgressRoot !== null) {
                    restorePendingUpdaters(inProgressRoot, inProgressLanes);
                  } else {
                    throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                  }
                }
              }
              wakeable.then(retry, retry);
            }
          });
        }
      }
      function commitMutationEffects(root2, finishedWork, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root2;
        setCurrentFiber(finishedWork);
        commitMutationEffectsOnFiber(finishedWork, root2);
        setCurrentFiber(finishedWork);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
        var deletions = parentFiber.deletions;
        if (deletions !== null) {
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            try {
              commitDeletionEffects(root2, parentFiber, childToDelete);
            } catch (error2) {
              captureCommitPhaseError(childToDelete, parentFiber, error2);
            }
          }
        }
        var prevDebugFiber = getCurrentFiber();
        if (parentFiber.subtreeFlags & MutationMask) {
          var child = parentFiber.child;
          while (child !== null) {
            setCurrentFiber(child);
            commitMutationEffectsOnFiber(child, root2);
            child = child.sibling;
          }
        }
        setCurrentFiber(prevDebugFiber);
      }
      function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
        var current22 = finishedWork.alternate;
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update2) {
              try {
                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                commitHookEffectListMount(Insertion | HasEffect, finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                recordLayoutEffectDuration(finishedWork);
              } else {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case ClassComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current22 !== null) {
                safelyDetachRef(current22, current22.return);
              }
            }
            return;
          }
          case HostComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current22 !== null) {
                safelyDetachRef(current22, current22.return);
              }
            }
            {
              if (finishedWork.flags & ContentReset) {
                var instance2 = finishedWork.stateNode;
                try {
                  resetTextContent(instance2);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              if (flags & Update2) {
                var _instance4 = finishedWork.stateNode;
                if (_instance4 != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current22 !== null ? current22.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    try {
                      commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostText: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update2) {
              {
                if (finishedWork.stateNode === null) {
                  throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current22 !== null ? current22.memoizedProps : newText;
                try {
                  commitTextUpdate(textInstance, oldText, newText);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case HostRoot: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update2) {
              {
                if (current22 !== null) {
                  var prevRootState = current22.memoizedState;
                  if (prevRootState.isDehydrated) {
                    try {
                      commitHydratedContainer(root2.containerInfo);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostPortal: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
          case SuspenseComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            var offscreenFiber = finishedWork.child;
            if (offscreenFiber.flags & Visibility) {
              var offscreenInstance = offscreenFiber.stateNode;
              var newState = offscreenFiber.memoizedState;
              var isHidden = newState !== null;
              offscreenInstance.isHidden = isHidden;
              if (isHidden) {
                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                if (!wasHidden) {
                  markCommitTimeOfFallback();
                }
              }
            }
            if (flags & Update2) {
              try {
                commitSuspenseCallback(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case OffscreenComponent: {
            var _wasHidden = current22 !== null && current22.memoizedState !== null;
            if (
              // TODO: Remove this dead flag
              finishedWork.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseMutationEffects(root2, finishedWork);
            }
            commitReconciliationEffects(finishedWork);
            if (flags & Visibility) {
              var _offscreenInstance = finishedWork.stateNode;
              var _newState = finishedWork.memoizedState;
              var _isHidden = _newState !== null;
              var offscreenBoundary = finishedWork;
              _offscreenInstance.isHidden = _isHidden;
              {
                if (_isHidden) {
                  if (!_wasHidden) {
                    if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                      nextEffect = offscreenBoundary;
                      var offscreenChild = offscreenBoundary.child;
                      while (offscreenChild !== null) {
                        nextEffect = offscreenChild;
                        disappearLayoutEffects_begin(offscreenChild);
                        offscreenChild = offscreenChild.sibling;
                      }
                    }
                  }
                }
              }
              {
                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
              }
            }
            return;
          }
          case SuspenseListComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update2) {
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case ScopeComponent: {
            return;
          }
          default: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & Placement) {
          try {
            commitPlacement(finishedWork);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= -3;
        }
        if (flags & Hydrating) {
          finishedWork.flags &= -4097;
        }
      }
      function commitLayoutEffects(finishedWork, root2, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root2;
        nextEffect = finishedWork;
        commitLayoutEffects_begin(finishedWork, root2, committedLanes);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
        var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent && isModernRoot) {
            var isHidden = fiber.memoizedState !== null;
            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
            if (newOffscreenSubtreeIsHidden) {
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              continue;
            } else {
              var current22 = fiber.alternate;
              var wasHidden = current22 !== null && current22.memoizedState !== null;
              var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
              var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
              if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                nextEffect = fiber;
                reappearLayoutEffects_begin(fiber);
              }
              var child = firstChild;
              while (child !== null) {
                nextEffect = child;
                commitLayoutEffects_begin(
                  child,
                  // New root; bubble back up to here and stop.
                  root2,
                  committedLanes
                );
                child = child.sibling;
              }
              nextEffect = fiber;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              continue;
            }
          }
          if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
          }
        }
      }
      function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & LayoutMask) !== NoFlags) {
            var current22 = fiber.alternate;
            setCurrentFiber(fiber);
            try {
              commitLayoutEffectOnFiber(root2, current22, fiber, committedLanes);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function disappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (fiber.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                } finally {
                  recordLayoutEffectDuration(fiber);
                }
              } else {
                commitHookEffectListUnmount(Layout, fiber, fiber.return);
              }
              break;
            }
            case ClassComponent: {
              safelyDetachRef(fiber, fiber.return);
              var instance2 = fiber.stateNode;
              if (typeof instance2.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance2);
              }
              break;
            }
            case HostComponent: {
              safelyDetachRef(fiber, fiber.return);
              break;
            }
            case OffscreenComponent: {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                disappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
              break;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            disappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function disappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function reappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent) {
            var isHidden = fiber.memoizedState !== null;
            if (isHidden) {
              reappearLayoutEffects_complete(subtreeRoot);
              continue;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            reappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function reappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            reappearLayoutEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
        nextEffect = finishedWork;
        commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
      }
      function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
          }
        }
      }
      function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            try {
              commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              } finally {
                recordPassiveEffectDuration(finishedWork);
              }
            } else {
              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffects(firstChild) {
        nextEffect = firstChild;
        commitPassiveUnmountEffects_begin();
      }
      function commitPassiveUnmountEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
            var deletions = fiber.deletions;
            if (deletions !== null) {
              for (var i2 = 0; i2 < deletions.length; i2++) {
                var fiberToDelete = deletions[i2];
                nextEffect = fiberToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
              }
              {
                var previousFiber = fiber.alternate;
                if (previousFiber !== null) {
                  var detachedChild = previousFiber.child;
                  if (detachedChild !== null) {
                    previousFiber.child = null;
                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null;
                      detachedChild = detachedSibling;
                    } while (detachedChild !== null);
                  }
                }
              }
              nextEffect = fiber;
            }
          }
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffects_complete();
          }
        }
      }
      function commitPassiveUnmountEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            commitPassiveUnmountOnFiber(fiber);
            resetCurrentFiber();
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              recordPassiveEffectDuration(finishedWork);
            } else {
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
          resetCurrentFiber();
          var child = fiber.child;
          if (child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var sibling = fiber.sibling;
          var returnFiber = fiber.return;
          {
            detachFiberAfterEffects(fiber);
            if (fiber === deletedSubtreeRoot) {
              nextEffect = null;
              return;
            }
          }
          if (sibling !== null) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            return;
          }
          nextEffect = returnFiber;
        }
      }
      function commitPassiveUnmountInsideDeletedTreeOnFiber(current22, nearestMountedAncestor) {
        switch (current22.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (current22.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1, current22, nearestMountedAncestor);
              recordPassiveEffectDuration(current22);
            } else {
              commitHookEffectListUnmount(Passive$1, current22, nearestMountedAncestor);
            }
            break;
          }
        }
      }
      function invokeLayoutEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Layout | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance2 = fiber.stateNode;
              try {
                instance2.componentDidMount();
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokeLayoutEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance2 = fiber.stateNode;
              if (typeof instance2.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance2);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
            }
          }
        }
      }
      if (typeof Symbol === "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        symbolFor("selector.component");
        symbolFor("selector.has_pseudo_class");
        symbolFor("selector.role");
        symbolFor("selector.test_id");
        symbolFor("selector.text");
      }
      var commitHooks = [];
      function onCommitRoot$1() {
        {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
      }
      var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
      function isLegacyActEnvironment(fiber) {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          var jestIsDefined = typeof jest !== "undefined";
          return jestIsDefined && isReactActEnvironmentGlobal !== false;
        }
      }
      function isConcurrentActEnvironment() {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
            error("The current testing environment is not configured to support act(...)");
          }
          return isReactActEnvironmentGlobal;
        }
      }
      var ceil = Math.ceil;
      var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
      var NoContext = (
        /*             */
        0
      );
      var BatchedContext = (
        /*               */
        1
      );
      var RenderContext = (
        /*                */
        2
      );
      var CommitContext = (
        /*                */
        4
      );
      var RootInProgress = 0;
      var RootFatalErrored = 1;
      var RootErrored = 2;
      var RootSuspended = 3;
      var RootSuspendedWithDelay = 4;
      var RootCompleted = 5;
      var RootDidNotComplete = 6;
      var executionContext = NoContext;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = NoLanes;
      var subtreeRenderLanes = NoLanes;
      var subtreeRenderLanesCursor = createCursor(NoLanes);
      var workInProgressRootExitStatus = RootInProgress;
      var workInProgressRootFatalError = null;
      var workInProgressRootSkippedLanes = NoLanes;
      var workInProgressRootInterleavedUpdatedLanes = NoLanes;
      var workInProgressRootPingedLanes = NoLanes;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var globalMostRecentFallbackTime = 0;
      var FALLBACK_THROTTLE_MS = 500;
      var workInProgressRootRenderTargetTime = Infinity;
      var RENDER_TIMEOUT_MS = 500;
      var workInProgressTransitions = null;
      function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
      }
      function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
      }
      var hasUncaughtError = false;
      var firstUncaughtError = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var rootDoesHavePassiveEffects = false;
      var rootWithPendingPassiveEffects = null;
      var pendingPassiveEffectsLanes = NoLanes;
      var pendingPassiveProfilerEffects = [];
      var pendingPassiveTransitions = null;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      var isFlushingPassiveEffects = false;
      var didScheduleUpdateDuringPassiveEffects = false;
      var NESTED_PASSIVE_UPDATE_LIMIT = 50;
      var nestedPassiveUpdateCount = 0;
      var rootWithPassiveNestedUpdates = null;
      var currentEventTime = NoTimestamp;
      var currentEventTransitionLane = NoLanes;
      var isRunningInsertionEffect = false;
      function getWorkInProgressRoot() {
        return workInProgressRoot;
      }
      function requestEventTime() {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          return now();
        }
        if (currentEventTime !== NoTimestamp) {
          return currentEventTime;
        }
        currentEventTime = now();
        return currentEventTime;
      }
      function requestUpdateLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
          return pickArbitraryLane(workInProgressRootRenderLanes);
        }
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
          if (ReactCurrentBatchConfig$3.transition !== null) {
            var transition = ReactCurrentBatchConfig$3.transition;
            if (!transition._updatedFibers) {
              transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            transition._updatedFibers.add(fiber);
          }
          if (currentEventTransitionLane === NoLane) {
            currentEventTransitionLane = claimNextTransitionLane();
          }
          return currentEventTransitionLane;
        }
        var updateLane = getCurrentUpdatePriority();
        if (updateLane !== NoLane) {
          return updateLane;
        }
        var eventLane = getCurrentEventPriority();
        return eventLane;
      }
      function requestRetryLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        }
        return claimNextRetryLane();
      }
      function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
        checkForNestedUpdates();
        {
          if (isRunningInsertionEffect) {
            error("useInsertionEffect must not schedule updates.");
          }
        }
        {
          if (isFlushingPassiveEffects) {
            didScheduleUpdateDuringPassiveEffects = true;
          }
        }
        markRootUpdated(root2, lane, eventTime);
        if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
          warnAboutRenderPhaseUpdatesInDEV(fiber);
        } else {
          {
            if (isDevToolsPresent) {
              addFiberToLanesMap(root2, fiber, lane);
            }
          }
          warnIfUpdatesNotWrappedWithActDEV(fiber);
          if (root2 === workInProgressRoot) {
            if ((executionContext & RenderContext) === NoContext) {
              workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
            }
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
              markRootSuspended$1(root2, workInProgressRootRenderLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
          if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
        var current22 = root2.current;
        current22.lanes = lane;
        markRootUpdated(root2, lane, eventTime);
        ensureRootIsScheduled(root2, eventTime);
      }
      function isUnsafeClassRenderPhaseUpdate(fiber) {
        return (
          // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
          // decided not to enable it.
          (executionContext & RenderContext) !== NoContext
        );
      }
      function ensureRootIsScheduled(root2, currentTime) {
        var existingCallbackNode = root2.callbackNode;
        markStarvedLanesAsExpired(root2, currentTime);
        var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (nextLanes === NoLanes) {
          if (existingCallbackNode !== null) {
            cancelCallback$1(existingCallbackNode);
          }
          root2.callbackNode = null;
          root2.callbackPriority = NoLane;
          return;
        }
        var newCallbackPriority = getHighestPriorityLane(nextLanes);
        var existingCallbackPriority = root2.callbackPriority;
        if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
        // Scheduler task, rather than an `act` task, cancel it and re-scheduled
        // on the `act` queue.
        !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
          {
            if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
              error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          return;
        }
        if (existingCallbackNode != null) {
          cancelCallback$1(existingCallbackNode);
        }
        var newCallbackNode;
        if (newCallbackPriority === SyncLane) {
          if (root2.tag === LegacyRoot) {
            if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
              ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
            }
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
          } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
          }
          {
            if (ReactCurrentActQueue$1.current !== null) {
              ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
            } else {
              scheduleMicrotask(function() {
                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                  flushSyncCallbacks();
                }
              });
            }
          }
          newCallbackNode = null;
        } else {
          var schedulerPriorityLevel;
          switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
              schedulerPriorityLevel = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriorityLevel = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              schedulerPriorityLevel = NormalPriority;
              break;
            case IdleEventPriority:
              schedulerPriorityLevel = IdlePriority;
              break;
            default:
              schedulerPriorityLevel = NormalPriority;
              break;
          }
          newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
        }
        root2.callbackPriority = newCallbackPriority;
        root2.callbackNode = newCallbackNode;
      }
      function performConcurrentWorkOnRoot(root2, didTimeout) {
        {
          resetNestedUpdateFlag();
        }
        currentEventTime = NoTimestamp;
        currentEventTransitionLane = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var originalCallbackNode = root2.callbackNode;
        var didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects) {
          if (root2.callbackNode !== originalCallbackNode) {
            return null;
          }
        }
        var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes) {
          return null;
        }
        var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
        var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
        if (exitStatus !== RootInProgress) {
          if (exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            markRootSuspended$1(root2, lanes);
          } else {
            var renderWasConcurrent = !includesBlockingLane(root2, lanes);
            var finishedWork = root2.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
              exitStatus = renderRootSync(root2, lanes);
              if (exitStatus === RootErrored) {
                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                if (_errorRetryLanes !== NoLanes) {
                  lanes = _errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var _fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now());
                throw _fatalError;
              }
            }
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            finishConcurrentRender(root2, exitStatus, lanes);
          }
        }
        ensureRootIsScheduled(root2, now());
        if (root2.callbackNode === originalCallbackNode) {
          return performConcurrentWorkOnRoot.bind(null, root2);
        }
        return null;
      }
      function recoverFromConcurrentError(root2, errorRetryLanes) {
        var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
        if (isRootDehydrated(root2)) {
          var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
          rootWorkInProgress.flags |= ForceClientRender;
          {
            errorHydratingContainer(root2.containerInfo);
          }
        }
        var exitStatus = renderRootSync(root2, errorRetryLanes);
        if (exitStatus !== RootErrored) {
          var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
          workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
          if (errorsFromSecondAttempt !== null) {
            queueRecoverableErrors(errorsFromSecondAttempt);
          }
        }
        return exitStatus;
      }
      function queueRecoverableErrors(errors2) {
        if (workInProgressRootRecoverableErrors === null) {
          workInProgressRootRecoverableErrors = errors2;
        } else {
          workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors2);
        }
      }
      function finishConcurrentRender(root2, exitStatus, lanes) {
        switch (exitStatus) {
          case RootInProgress:
          case RootFatalErrored: {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          case RootErrored: {
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspended: {
            markRootSuspended$1(root2, lanes);
            if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
            !shouldForceFlushFallbacksInDEV()) {
              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
              if (msUntilTimeout > 10) {
                var nextLanes = getNextLanes(root2, NoLanes);
                if (nextLanes !== NoLanes) {
                  break;
                }
                var suspendedLanes = root2.suspendedLanes;
                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                  requestEventTime();
                  markRootPinged(root2, suspendedLanes);
                  break;
                }
                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                break;
              }
            }
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspendedWithDelay: {
            markRootSuspended$1(root2, lanes);
            if (includesOnlyTransitions(lanes)) {
              break;
            }
            if (!shouldForceFlushFallbacksInDEV()) {
              var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
              var eventTimeMs = mostRecentEventTime;
              var timeElapsedMs = now() - eventTimeMs;
              var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
              if (_msUntilTimeout > 10) {
                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                break;
              }
            }
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootCompleted: {
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          default: {
            throw new Error("Unknown root exit status.");
          }
        }
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        var node = finishedWork;
        while (true) {
          if (node.flags & StoreConsistency) {
            var updateQueue = node.updateQueue;
            if (updateQueue !== null) {
              var checks = updateQueue.stores;
              if (checks !== null) {
                for (var i2 = 0; i2 < checks.length; i2++) {
                  var check = checks[i2];
                  var getSnapshot = check.getSnapshot;
                  var renderedValue = check.value;
                  try {
                    if (!objectIs(getSnapshot(), renderedValue)) {
                      return false;
                    }
                  } catch (error2) {
                    return false;
                  }
                }
              }
            }
          }
          var child = node.child;
          if (node.subtreeFlags & StoreConsistency && child !== null) {
            child.return = node;
            node = child;
            continue;
          }
          if (node === finishedWork) {
            return true;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return true;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return true;
      }
      function markRootSuspended$1(root2, suspendedLanes) {
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
        markRootSuspended(root2, suspendedLanes);
      }
      function performSyncWorkOnRoot(root2) {
        {
          syncNestedUpdateFlag();
        }
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        flushPassiveEffects();
        var lanes = getNextLanes(root2, NoLanes);
        if (!includesSomeLane(lanes, SyncLane)) {
          ensureRootIsScheduled(root2, now());
          return null;
        }
        var exitStatus = renderRootSync(root2, lanes);
        if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
          }
        }
        if (exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          prepareFreshStack(root2, NoLanes);
          markRootSuspended$1(root2, lanes);
          ensureRootIsScheduled(root2, now());
          throw fatalError;
        }
        if (exitStatus === RootDidNotComplete) {
          throw new Error("Root did not complete. This is a bug in React.");
        }
        var finishedWork = root2.current.alternate;
        root2.finishedWork = finishedWork;
        root2.finishedLanes = lanes;
        commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
        ensureRootIsScheduled(root2, now());
        return null;
      }
      function flushRoot(root2, lanes) {
        if (lanes !== NoLanes) {
          markRootEntangled(root2, mergeLanes(lanes, SyncLane));
          ensureRootIsScheduled(root2, now());
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            resetRenderTimer();
            flushSyncCallbacks();
          }
        }
      }
      function batchedUpdates$1(fn, a2) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
          return fn(a2);
        } finally {
          executionContext = prevExecutionContext;
          if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function discreteUpdates(fn, a2, b, c2, d) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          return fn(a2, b, c2, d);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          if (executionContext === NoContext) {
            resetRenderTimer();
          }
        }
      }
      function flushSync(fn) {
        if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
          flushPassiveEffects();
        }
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        var previousPriority = getCurrentUpdatePriority();
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          if (fn) {
            return fn();
          } else {
            return void 0;
          }
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          executionContext = prevExecutionContext;
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushSyncCallbacks();
          }
        }
      }
      function isAlreadyRendering() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext;
      }
      function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
        subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
      }
      function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current;
        pop(subtreeRenderLanesCursor, fiber);
      }
      function prepareFreshStack(root2, lanes) {
        root2.finishedWork = null;
        root2.finishedLanes = NoLanes;
        var timeoutHandle = root2.timeoutHandle;
        if (timeoutHandle !== noTimeout) {
          root2.timeoutHandle = noTimeout;
          cancelTimeout(timeoutHandle);
        }
        if (workInProgress !== null) {
          var interruptedWork = workInProgress.return;
          while (interruptedWork !== null) {
            var current22 = interruptedWork.alternate;
            unwindInterruptedWork(current22, interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }
        workInProgressRoot = root2;
        var rootWorkInProgress = createWorkInProgress(root2.current, null);
        workInProgress = rootWorkInProgress;
        workInProgressRootRenderLanes = subtreeRenderLanes = lanes;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressRootFatalError = null;
        workInProgressRootSkippedLanes = NoLanes;
        workInProgressRootInterleavedUpdatedLanes = NoLanes;
        workInProgressRootPingedLanes = NoLanes;
        workInProgressRootConcurrentErrors = null;
        workInProgressRootRecoverableErrors = null;
        finishQueueingConcurrentUpdates();
        {
          ReactStrictModeWarnings.discardPendingWarnings();
        }
        return rootWorkInProgress;
      }
      function handleError(root2, thrownValue) {
        do {
          var erroredWork = workInProgress;
          try {
            resetContextDependencies();
            resetHooksAfterThrow();
            resetCurrentFiber();
            ReactCurrentOwner$2.current = null;
            if (erroredWork === null || erroredWork.return === null) {
              workInProgressRootExitStatus = RootFatalErrored;
              workInProgressRootFatalError = thrownValue;
              workInProgress = null;
              return;
            }
            if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
            }
            if (enableSchedulingProfiler) {
              markComponentRenderStopped();
              if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                var wakeable = thrownValue;
                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
              } else {
                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
              }
            }
            throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
            completeUnitOfWork(erroredWork);
          } catch (yetAnotherThrownValue) {
            thrownValue = yetAnotherThrownValue;
            if (workInProgress === erroredWork && erroredWork !== null) {
              erroredWork = erroredWork.return;
              workInProgress = erroredWork;
            } else {
              erroredWork = workInProgress;
            }
            continue;
          }
          return;
        } while (true);
      }
      function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
        if (prevDispatcher === null) {
          return ContextOnlyDispatcher;
        } else {
          return prevDispatcher;
        }
      }
      function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
      }
      function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
      }
      function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
      }
      function renderDidSuspend() {
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootSuspended;
        }
      }
      function renderDidSuspendDelayIfPossible() {
        if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
        }
        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
          markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
        }
      }
      function renderDidError(error2) {
        if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
          workInProgressRootExitStatus = RootErrored;
        }
        if (workInProgressRootConcurrentErrors === null) {
          workInProgressRootConcurrentErrors = [error2];
        } else {
          workInProgressRootConcurrentErrors.push(error2);
        }
      }
      function renderHasNotSuspendedYet() {
        return workInProgressRootExitStatus === RootInProgress;
      }
      function renderRootSync(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root2, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          prepareFreshStack(root2, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopSync();
            break;
          } catch (thrownValue) {
            handleError(root2, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        if (workInProgress !== null) {
          throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        }
        {
          markRenderStopped();
        }
        workInProgressRoot = null;
        workInProgressRootRenderLanes = NoLanes;
        return workInProgressRootExitStatus;
      }
      function workLoopSync() {
        while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
        }
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root2, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          resetRenderTimer();
          prepareFreshStack(root2, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopConcurrent();
            break;
          } catch (thrownValue) {
            handleError(root2, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        popDispatcher(prevDispatcher);
        executionContext = prevExecutionContext;
        if (workInProgress !== null) {
          {
            markRenderYielded();
          }
          return RootInProgress;
        } else {
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
      }
      function workLoopConcurrent() {
        while (workInProgress !== null && !shouldYield()) {
          performUnitOfWork(workInProgress);
        }
      }
      function performUnitOfWork(unitOfWork) {
        var current22 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          startProfilerTimer(unitOfWork);
          next = beginWork$1(current22, unitOfWork, subtreeRenderLanes);
          stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
        } else {
          next = beginWork$1(current22, unitOfWork, subtreeRenderLanes);
        }
        resetCurrentFiber();
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        if (next === null) {
          completeUnitOfWork(unitOfWork);
        } else {
          workInProgress = next;
        }
        ReactCurrentOwner$2.current = null;
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          var current22 = completedWork.alternate;
          var returnFiber = completedWork.return;
          if ((completedWork.flags & Incomplete) === NoFlags) {
            setCurrentFiber(completedWork);
            var next = void 0;
            if ((completedWork.mode & ProfileMode) === NoMode) {
              next = completeWork(current22, completedWork, subtreeRenderLanes);
            } else {
              startProfilerTimer(completedWork);
              next = completeWork(current22, completedWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
            }
            resetCurrentFiber();
            if (next !== null) {
              workInProgress = next;
              return;
            }
          } else {
            var _next = unwindWork(current22, completedWork);
            if (_next !== null) {
              _next.flags &= HostEffectMask;
              workInProgress = _next;
              return;
            }
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              var actualDuration = completedWork.actualDuration;
              var child = completedWork.child;
              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
            }
            if (returnFiber !== null) {
              returnFiber.flags |= Incomplete;
              returnFiber.subtreeFlags = NoFlags;
              returnFiber.deletions = null;
            } else {
              workInProgressRootExitStatus = RootDidNotComplete;
              workInProgress = null;
              return;
            }
          }
          var siblingFiber = completedWork.sibling;
          if (siblingFiber !== null) {
            workInProgress = siblingFiber;
            return;
          }
          completedWork = returnFiber;
          workInProgress = completedWork;
        } while (completedWork !== null);
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootCompleted;
        }
      }
      function commitRoot(root2, recoverableErrors, transitions) {
        var previousUpdateLanePriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
        } finally {
          ReactCurrentBatchConfig$3.transition = prevTransition;
          setCurrentUpdatePriority(previousUpdateLanePriority);
        }
        return null;
      }
      function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
        do {
          flushPassiveEffects();
        } while (rootWithPendingPassiveEffects !== null);
        flushRenderPhaseStrictModeWarningsInDEV();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var finishedWork = root2.finishedWork;
        var lanes = root2.finishedLanes;
        {
          markCommitStarted(lanes);
        }
        if (finishedWork === null) {
          {
            markCommitStopped();
          }
          return null;
        } else {
          {
            if (lanes === NoLanes) {
              error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
            }
          }
        }
        root2.finishedWork = null;
        root2.finishedLanes = NoLanes;
        if (finishedWork === root2.current) {
          throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        }
        root2.callbackNode = null;
        root2.callbackPriority = NoLane;
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root2, remainingLanes);
        if (root2 === workInProgressRoot) {
          workInProgressRoot = null;
          workInProgress = null;
          workInProgressRootRenderLanes = NoLanes;
        }
        if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            pendingPassiveTransitions = transitions;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
        var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        if (subtreeHasEffects || rootHasEffect) {
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          ReactCurrentBatchConfig$3.transition = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(DiscreteEventPriority);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          ReactCurrentOwner$2.current = null;
          commitBeforeMutationEffects(root2, finishedWork);
          {
            recordCommitTime();
          }
          commitMutationEffects(root2, finishedWork, lanes);
          resetAfterCommit(root2.containerInfo);
          root2.current = finishedWork;
          {
            markLayoutEffectsStarted(lanes);
          }
          commitLayoutEffects(finishedWork, root2, lanes);
          {
            markLayoutEffectsStopped();
          }
          requestPaint();
          executionContext = prevExecutionContext;
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
        } else {
          root2.current = finishedWork;
          {
            recordCommitTime();
          }
        }
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects) {
          rootDoesHavePassiveEffects = false;
          rootWithPendingPassiveEffects = root2;
          pendingPassiveEffectsLanes = lanes;
        } else {
          {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
          }
        }
        remainingLanes = root2.pendingLanes;
        if (remainingLanes === NoLanes) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }
        {
          if (!rootDidHavePassiveEffects) {
            commitDoubleInvokeEffectsInDEV(root2.current, false);
          }
        }
        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
        {
          if (isDevToolsPresent) {
            root2.memoizedUpdaters.clear();
          }
        }
        {
          onCommitRoot$1();
        }
        ensureRootIsScheduled(root2, now());
        if (recoverableErrors !== null) {
          var onRecoverableError = root2.onRecoverableError;
          for (var i2 = 0; i2 < recoverableErrors.length; i2++) {
            var recoverableError = recoverableErrors[i2];
            var componentStack = recoverableError.stack;
            var digest = recoverableError.digest;
            onRecoverableError(recoverableError.value, {
              componentStack,
              digest
            });
          }
        }
        if (hasUncaughtError) {
          hasUncaughtError = false;
          var error$1 = firstUncaughtError;
          firstUncaughtError = null;
          throw error$1;
        }
        if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
          flushPassiveEffects();
        }
        remainingLanes = root2.pendingLanes;
        if (includesSomeLane(remainingLanes, SyncLane)) {
          {
            markNestedUpdateScheduled();
          }
          if (root2 === rootWithNestedUpdates) {
            nestedUpdateCount++;
          } else {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = root2;
          }
        } else {
          nestedUpdateCount = 0;
        }
        flushSyncCallbacks();
        {
          markCommitStopped();
        }
        return null;
      }
      function flushPassiveEffects() {
        if (rootWithPendingPassiveEffects !== null) {
          var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
          var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(priority);
            return flushPassiveEffectsImpl();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          }
        }
        return false;
      }
      function enqueuePendingPassiveProfilerEffect(fiber) {
        {
          pendingPassiveProfilerEffects.push(fiber);
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
      }
      function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null) {
          return false;
        }
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root2 = rootWithPendingPassiveEffects;
        var lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Cannot flush passive effects while already rendering.");
        }
        {
          isFlushingPassiveEffects = true;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        {
          markPassiveEffectsStarted(lanes);
        }
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountEffects(root2.current);
        commitPassiveMountEffects(root2, root2.current, lanes, transitions);
        {
          var profilerEffects = pendingPassiveProfilerEffects;
          pendingPassiveProfilerEffects = [];
          for (var i2 = 0; i2 < profilerEffects.length; i2++) {
            var _fiber = profilerEffects[i2];
            commitPassiveEffectDurations(root2, _fiber);
          }
        }
        {
          markPassiveEffectsStopped();
        }
        {
          commitDoubleInvokeEffectsInDEV(root2.current, true);
        }
        executionContext = prevExecutionContext;
        flushSyncCallbacks();
        {
          if (didScheduleUpdateDuringPassiveEffects) {
            if (root2 === rootWithPassiveNestedUpdates) {
              nestedPassiveUpdateCount++;
            } else {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = root2;
            }
          } else {
            nestedPassiveUpdateCount = 0;
          }
          isFlushingPassiveEffects = false;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        onPostCommitRoot(root2);
        {
          var stateNode = root2.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
        }
        return true;
      }
      function isAlreadyFailedLegacyErrorBoundary(instance2) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance2);
      }
      function markLegacyErrorBoundaryAsFailed(instance2) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance2]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance2);
        }
      }
      function prepareToThrowUncaughtError(error2) {
        if (!hasUncaughtError) {
          hasUncaughtError = true;
          firstUncaughtError = error2;
        }
      }
      var onUncaughtError = prepareToThrowUncaughtError;
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        var root2 = enqueueUpdate(rootFiber, update, SyncLane);
        var eventTime = requestEventTime();
        if (root2 !== null) {
          markRootUpdated(root2, SyncLane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
        {
          reportUncaughtErrorInDEV(error$1);
          setIsRunningInsertionEffect(false);
        }
        if (sourceFiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
          return;
        }
        var fiber = null;
        {
          fiber = nearestMountedAncestor;
        }
        while (fiber !== null) {
          if (fiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
            return;
          } else if (fiber.tag === ClassComponent) {
            var ctor = fiber.type;
            var instance2 = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError === "function" || typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2)) {
              var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
              var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
              var root2 = enqueueUpdate(fiber, update, SyncLane);
              var eventTime = requestEventTime();
              if (root2 !== null) {
                markRootUpdated(root2, SyncLane, eventTime);
                ensureRootIsScheduled(root2, eventTime);
              }
              return;
            }
          }
          fiber = fiber.return;
        }
        {
          error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
        }
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        if (pingCache !== null) {
          pingCache.delete(wakeable);
        }
        var eventTime = requestEventTime();
        markRootPinged(root2, pingedLanes);
        warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
        if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
          if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
            prepareFreshStack(root2, NoLanes);
          } else {
            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
          }
        }
        ensureRootIsScheduled(root2, eventTime);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        if (retryLane === NoLane) {
          retryLane = requestRetryLane(boundaryFiber);
        }
        var eventTime = requestEventTime();
        var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        if (root2 !== null) {
          markRootUpdated(root2, retryLane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState;
        var retryLane = NoLane;
        if (suspenseState !== null) {
          retryLane = suspenseState.retryLane;
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane;
        var retryCache;
        switch (boundaryFiber.tag) {
          case SuspenseComponent:
            retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            break;
          case SuspenseListComponent:
            retryCache = boundaryFiber.stateNode;
            break;
          default:
            throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
        }
        if (retryCache !== null) {
          retryCache.delete(wakeable);
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
      }
      function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          rootWithNestedUpdates = null;
          throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        }
        {
          if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
            error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
          }
        }
      }
      function flushRenderPhaseStrictModeWarningsInDEV() {
        {
          ReactStrictModeWarnings.flushLegacyContextWarning();
          {
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          }
        }
      }
      function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
        {
          setCurrentFiber(fiber);
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
          }
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
          }
          resetCurrentFiber();
        }
      }
      function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
        {
          var current22 = firstChild;
          var subtreeRoot = null;
          while (current22 !== null) {
            var primarySubtreeFlag = current22.subtreeFlags & fiberFlags;
            if (current22 !== subtreeRoot && current22.child !== null && primarySubtreeFlag !== NoFlags) {
              current22 = current22.child;
            } else {
              if ((current22.flags & fiberFlags) !== NoFlags) {
                invokeEffectFn(current22);
              }
              if (current22.sibling !== null) {
                current22 = current22.sibling;
              } else {
                current22 = subtreeRoot = current22.return;
              }
            }
          }
        }
      }
      var didWarnStateUpdateForNotYetMountedComponent = null;
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        {
          if ((executionContext & RenderContext) !== NoContext) {
            return;
          }
          if (!(fiber.mode & ConcurrentMode)) {
            return;
          }
          var tag = fiber.tag;
          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
            return;
          }
          var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
              return;
            }
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
          } else {
            didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
          }
          var previousFiber = current2;
          try {
            setCurrentFiber(fiber);
            error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          } finally {
            if (previousFiber) {
              setCurrentFiber(fiber);
            } else {
              resetCurrentFiber();
            }
          }
        }
      }
      var beginWork$1;
      {
        var dummyFiber = null;
        beginWork$1 = function(current22, unitOfWork, lanes) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
          try {
            return beginWork(current22, unitOfWork, lanes);
          } catch (originalError) {
            if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
              throw originalError;
            }
            resetContextDependencies();
            resetHooksAfterThrow();
            unwindInterruptedWork(current22, unitOfWork);
            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
            if (unitOfWork.mode & ProfileMode) {
              startProfilerTimer(unitOfWork);
            }
            invokeGuardedCallback(null, beginWork, null, current22, unitOfWork, lanes);
            if (hasCaughtError()) {
              var replayError = clearCaughtError();
              if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                originalError._suppressLogging = true;
              }
            }
            throw originalError;
          }
        };
      }
      var didWarnAboutUpdateInRender = false;
      var didWarnAboutUpdateInRenderForAnotherComponent;
      {
        didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      }
      function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        {
          if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                var dedupeKey = renderingComponentName;
                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                  didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                  var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                  error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                }
                break;
              }
              case ClassComponent: {
                if (!didWarnAboutUpdateInRender) {
                  error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                  didWarnAboutUpdateInRender = true;
                }
                break;
              }
            }
          }
        }
      }
      function restorePendingUpdaters(root2, lanes) {
        {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root2.memoizedUpdaters;
            memoizedUpdaters.forEach(function(schedulingFiber) {
              addFiberToLanesMap(root2, schedulingFiber, lanes);
            });
          }
        }
      }
      var fakeActCallbackNode = {};
      function scheduleCallback$1(priorityLevel, callback) {
        {
          var actQueue = ReactCurrentActQueue$1.current;
          if (actQueue !== null) {
            actQueue.push(callback);
            return fakeActCallbackNode;
          } else {
            return scheduleCallback(priorityLevel, callback);
          }
        }
      }
      function cancelCallback$1(callbackNode) {
        if (callbackNode === fakeActCallbackNode) {
          return;
        }
        return cancelCallback(callbackNode);
      }
      function shouldForceFlushFallbacksInDEV() {
        return ReactCurrentActQueue$1.current !== null;
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        {
          if (fiber.mode & ConcurrentMode) {
            if (!isConcurrentActEnvironment()) {
              return;
            }
          } else {
            if (!isLegacyActEnvironment()) {
              return;
            }
            if (executionContext !== NoContext) {
              return;
            }
            if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
              return;
            }
          }
          if (ReactCurrentActQueue$1.current === null) {
            var previousFiber = current2;
            try {
              setCurrentFiber(fiber);
              error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
      }
      function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
        {
          if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
            error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
          }
        }
      }
      function setIsRunningInsertionEffect(isRunning) {
        {
          isRunningInsertionEffect = isRunning;
        }
      }
      var resolveFamily = null;
      var failedBoundaries = null;
      var setRefreshHandler = function(handler) {
        {
          resolveFamily = handler;
        }
      };
      function resolveFunctionForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === void 0) {
            return type;
          }
          return family.current;
        }
      }
      function resolveClassForHotReloading(type) {
        return resolveFunctionForHotReloading(type);
      }
      function resolveForwardRefForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === void 0) {
            if (type !== null && type !== void 0 && typeof type.render === "function") {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = {
                  $$typeof: REACT_FORWARD_REF_TYPE,
                  render: currentRender
                };
                if (type.displayName !== void 0) {
                  syntheticType.displayName = type.displayName;
                }
                return syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        {
          if (resolveFamily === null) {
            return false;
          }
          var prevType = fiber.elementType;
          var nextType = element.type;
          var needsCompareFamilies = false;
          var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case ClassComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              }
              break;
            }
            case FunctionComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case ForwardRef: {
              if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case MemoComponent:
            case SimpleMemoComponent: {
              if ($$typeofNextType === REACT_MEMO_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            default:
              return false;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
              return true;
            }
          }
          return false;
        }
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        {
          if (resolveFamily === null) {
            return;
          }
          if (typeof WeakSet !== "function") {
            return;
          }
          if (failedBoundaries === null) {
            failedBoundaries = /* @__PURE__ */ new WeakSet();
          }
          failedBoundaries.add(fiber);
        }
      }
      var scheduleRefresh = function(root2, update) {
        {
          if (resolveFamily === null) {
            return;
          }
          var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
          flushPassiveEffects();
          flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
          });
        }
      };
      var scheduleRoot = function(root2, element) {
        {
          if (root2.context !== emptyContextObject) {
            return;
          }
          flushPassiveEffects();
          flushSync(function() {
            updateContainer(element, root2, null, null);
          });
        }
      };
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          if (resolveFamily === null) {
            throw new Error("Expected resolveFamily to be set during hot reload.");
          }
          var needsRender = false;
          var needsRemount = false;
          if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            if (family !== void 0) {
              if (staleFamilies.has(family)) {
                needsRemount = true;
              } else if (updatedFamilies.has(family)) {
                if (tag === ClassComponent) {
                  needsRemount = true;
                } else {
                  needsRender = true;
                }
              }
            }
          }
          if (failedBoundaries !== null) {
            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
              needsRemount = true;
            }
          }
          if (needsRemount) {
            fiber._debugNeedsRemount = true;
          }
          if (needsRemount || needsRender) {
            var _root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (_root2 !== null) {
              scheduleUpdateOnFiber(_root2, fiber, SyncLane, NoTimestamp);
            }
          }
          if (child !== null && !needsRemount) {
            scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
          }
          if (sibling !== null) {
            scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
          }
        }
      }
      var findHostInstancesForRefresh = function(root2, families) {
        {
          var hostInstances = /* @__PURE__ */ new Set();
          var types = new Set(families.map(function(family) {
            return family.current;
          }));
          findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
          return hostInstances;
        }
      };
      function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
        {
          var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          var didMatch = false;
          if (candidateType !== null) {
            if (types.has(candidateType)) {
              didMatch = true;
            }
          }
          if (didMatch) {
            findHostInstancesForFiberShallowly(fiber, hostInstances);
          } else {
            if (child !== null) {
              findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
            }
          }
          if (sibling !== null) {
            findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
          }
        }
      }
      function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
          if (foundHostInstances) {
            return;
          }
          var node = fiber;
          while (true) {
            switch (node.tag) {
              case HostComponent:
                hostInstances.add(node.stateNode);
                return;
              case HostPortal:
                hostInstances.add(node.stateNode.containerInfo);
                return;
              case HostRoot:
                hostInstances.add(node.stateNode.containerInfo);
                return;
            }
            if (node.return === null) {
              throw new Error("Expected to reach root first.");
            }
            node = node.return;
          }
        }
      }
      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var node = fiber;
          var foundHostInstances = false;
          while (true) {
            if (node.tag === HostComponent) {
              foundHostInstances = true;
              hostInstances.add(node.stateNode);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === fiber) {
              return foundHostInstances;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === fiber) {
                return foundHostInstances;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return false;
      }
      var hasBadMapPolyfill;
      {
        hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e2) {
          hasBadMapPolyfill = true;
        }
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.dependencies = null;
        this.mode = mode;
        this.flags = NoFlags;
        this.subtreeFlags = NoFlags;
        this.deletions = null;
        this.lanes = NoLanes;
        this.childLanes = NoLanes;
        this.alternate = null;
        {
          this.actualDuration = Number.NaN;
          this.actualStartTime = Number.NaN;
          this.selfBaseDuration = Number.NaN;
          this.treeBaseDuration = Number.NaN;
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }
        {
          this._debugSource = null;
          this._debugOwner = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }
      var createFiber = function(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };
      function shouldConstruct$1(Component) {
        var prototype2 = Component.prototype;
        return !!(prototype2 && prototype2.isReactComponent);
      }
      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
      }
      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== void 0 && Component !== null) {
          var $$typeof = Component.$$typeof;
          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }
          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }
        return IndeterminateComponent;
      }
      function createWorkInProgress(current22, pendingProps) {
        var workInProgress2 = current22.alternate;
        if (workInProgress2 === null) {
          workInProgress2 = createFiber(current22.tag, pendingProps, current22.key, current22.mode);
          workInProgress2.elementType = current22.elementType;
          workInProgress2.type = current22.type;
          workInProgress2.stateNode = current22.stateNode;
          {
            workInProgress2._debugSource = current22._debugSource;
            workInProgress2._debugOwner = current22._debugOwner;
            workInProgress2._debugHookTypes = current22._debugHookTypes;
          }
          workInProgress2.alternate = current22;
          current22.alternate = workInProgress2;
        } else {
          workInProgress2.pendingProps = pendingProps;
          workInProgress2.type = current22.type;
          workInProgress2.flags = NoFlags;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          {
            workInProgress2.actualDuration = 0;
            workInProgress2.actualStartTime = -1;
          }
        }
        workInProgress2.flags = current22.flags & StaticMask;
        workInProgress2.childLanes = current22.childLanes;
        workInProgress2.lanes = current22.lanes;
        workInProgress2.child = current22.child;
        workInProgress2.memoizedProps = current22.memoizedProps;
        workInProgress2.memoizedState = current22.memoizedState;
        workInProgress2.updateQueue = current22.updateQueue;
        var currentDependencies = current22.dependencies;
        workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        };
        workInProgress2.sibling = current22.sibling;
        workInProgress2.index = current22.index;
        workInProgress2.ref = current22.ref;
        {
          workInProgress2.selfBaseDuration = current22.selfBaseDuration;
          workInProgress2.treeBaseDuration = current22.treeBaseDuration;
        }
        {
          workInProgress2._debugNeedsRemount = current22._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case FunctionComponent:
            case SimpleMemoComponent:
              workInProgress2.type = resolveFunctionForHotReloading(current22.type);
              break;
            case ClassComponent:
              workInProgress2.type = resolveClassForHotReloading(current22.type);
              break;
            case ForwardRef:
              workInProgress2.type = resolveForwardRefForHotReloading(current22.type);
              break;
          }
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= StaticMask | Placement;
        var current22 = workInProgress2.alternate;
        if (current22 === null) {
          workInProgress2.childLanes = NoLanes;
          workInProgress2.lanes = renderLanes2;
          workInProgress2.child = null;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.memoizedProps = null;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.dependencies = null;
          workInProgress2.stateNode = null;
          {
            workInProgress2.selfBaseDuration = 0;
            workInProgress2.treeBaseDuration = 0;
          }
        } else {
          workInProgress2.childLanes = current22.childLanes;
          workInProgress2.lanes = current22.lanes;
          workInProgress2.child = current22.child;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          workInProgress2.memoizedProps = current22.memoizedProps;
          workInProgress2.memoizedState = current22.memoizedState;
          workInProgress2.updateQueue = current22.updateQueue;
          workInProgress2.type = current22.type;
          var currentDependencies = current22.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          {
            workInProgress2.selfBaseDuration = current22.selfBaseDuration;
            workInProgress2.treeBaseDuration = current22.treeBaseDuration;
          }
        }
        return workInProgress2;
      }
      function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
        var mode;
        if (tag === ConcurrentRoot) {
          mode = ConcurrentMode;
          if (isStrictMode === true) {
            mode |= StrictLegacyMode;
            {
              mode |= StrictEffectsMode;
            }
          }
        } else {
          mode = NoMode;
        }
        if (isDevToolsPresent) {
          mode |= ProfileMode;
        }
        return createFiber(HostRoot, null, null, mode);
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            fiberTag = ClassComponent;
            {
              resolvedType = resolveClassForHotReloading(resolvedType);
            }
          } else {
            {
              resolvedType = resolveFunctionForHotReloading(resolvedType);
            }
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = Mode;
              mode |= StrictLegacyMode;
              if ((mode & ConcurrentMode) !== NoMode) {
                mode |= StrictEffectsMode;
              }
              break;
            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_LIST_TYPE:
              return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
            case REACT_OFFSCREEN_TYPE:
              return createFiberFromOffscreen(pendingProps, mode, lanes, key);
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_SCOPE_TYPE:
            case REACT_CACHE_TYPE:
            case REACT_TRACING_MARKER_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            default: {
              if (typeof type === "object" && type !== null) {
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    break getTag;
                  case REACT_CONTEXT_TYPE:
                    fiberTag = ContextConsumer;
                    break getTag;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef;
                    {
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    }
                    break getTag;
                  case REACT_MEMO_TYPE:
                    fiberTag = MemoComponent;
                    break getTag;
                  case REACT_LAZY_TYPE:
                    fiberTag = LazyComponent;
                    resolvedType = null;
                    break getTag;
                }
              }
              var info = "";
              {
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
            }
          }
        }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.lanes = lanes;
        {
          fiber._debugOwner = owner;
        }
        return fiber;
      }
      function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        {
          if (typeof pendingProps.id !== "string") {
            error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.lanes = lanes;
        {
          fiber.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
          };
        }
        return fiber;
      }
      function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        fiber.elementType = REACT_SUSPENSE_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
        fiber.elementType = REACT_OFFSCREEN_TYPE;
        fiber.lanes = lanes;
        var primaryChildInstance = {
          isHidden: false
        };
        fiber.stateNode = primaryChildInstance;
        return fiber;
      }
      function createFiberFromText(content2, mode, lanes) {
        var fiber = createFiber(HostText, content2, null, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode);
        fiber.elementType = "DELETED";
        return fiber;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiber(DehydratedFragment, null, null, NoMode);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.lanes = lanes;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          // Used by persistent updates
          implementation: portal.implementation
        };
        return fiber;
      }
      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoMode);
        }
        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.dependencies = source.dependencies;
        target.mode = source.mode;
        target.flags = source.flags;
        target.subtreeFlags = source.subtreeFlags;
        target.deletions = source.deletions;
        target.lanes = source.lanes;
        target.childLanes = source.childLanes;
        target.alternate = source.alternate;
        {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugNeedsRemount = source._debugNeedsRemount;
        target._debugHookTypes = source._debugHookTypes;
        return target;
      }
      function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
        this.tag = tag;
        this.containerInfo = containerInfo;
        this.pendingChildren = null;
        this.current = null;
        this.pingCache = null;
        this.finishedWork = null;
        this.timeoutHandle = noTimeout;
        this.context = null;
        this.pendingContext = null;
        this.callbackNode = null;
        this.callbackPriority = NoLane;
        this.eventTimes = createLaneMap(NoLanes);
        this.expirationTimes = createLaneMap(NoTimestamp);
        this.pendingLanes = NoLanes;
        this.suspendedLanes = NoLanes;
        this.pingedLanes = NoLanes;
        this.expiredLanes = NoLanes;
        this.mutableReadLanes = NoLanes;
        this.finishedLanes = NoLanes;
        this.entangledLanes = NoLanes;
        this.entanglements = createLaneMap(NoLanes);
        this.identifierPrefix = identifierPrefix;
        this.onRecoverableError = onRecoverableError;
        {
          this.mutableSourceEagerHydrationData = null;
        }
        {
          this.effectDuration = 0;
          this.passiveEffectDuration = 0;
        }
        {
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
          for (var _i = 0; _i < TotalLanes; _i++) {
            pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
          }
        }
        {
          switch (tag) {
            case ConcurrentRoot:
              this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
              break;
            case LegacyRoot:
              this._debugRootType = hydrate2 ? "hydrate()" : "render()";
              break;
          }
        }
      }
      function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
        var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
        root2.current = uninitializedFiber;
        uninitializedFiber.stateNode = root2;
        {
          var _initialState = {
            element: initialChildren,
            isDehydrated: hydrate2,
            cache: null,
            // not enabled yet
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          uninitializedFiber.memoizedState = _initialState;
        }
        initializeUpdateQueue(uninitializedFiber);
        return root2;
      }
      var ReactVersion = "18.3.1";
      function createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        {
          checkKeyStringCoercion(key);
        }
        return {
          // This tag allow us to uniquely identify this as a React Portal
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var didWarnAboutNestedUpdates;
      var didWarnAboutFindNodeInStrictMode;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }
        var fiber = get2(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;
          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }
        return parentContext;
      }
      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get2(component);
          if (fiber === void 0) {
            if (typeof component.render === "function") {
              throw new Error("Unable to find node on an unmounted component.");
            } else {
              var keys = Object.keys(component).join(",");
              throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
            }
          }
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          if (hostFiber.mode & StrictLegacyMode) {
            var componentName = getComponentNameFromFiber(fiber) || "Component";
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;
              var previousFiber = current2;
              try {
                setCurrentFiber(hostFiber);
                if (fiber.mode & StrictLegacyMode) {
                  error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                } else {
                  error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                }
              } finally {
                if (previousFiber) {
                  setCurrentFiber(previousFiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          return hostFiber.stateNode;
        }
      }
      function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = false;
        var initialChildren = null;
        return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      }
      function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = true;
        var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        root2.context = getContextForSubtree(null);
        var current22 = root2.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current22);
        var update = createUpdate(eventTime, lane);
        update.callback = callback !== void 0 && callback !== null ? callback : null;
        enqueueUpdate(current22, update, lane);
        scheduleInitialHydrationOnRoot(root2, lane, eventTime);
        return root2;
      }
      function updateContainer(element, container, parentComponent, callback) {
        {
          onScheduleRoot(container, element);
        }
        var current$1 = container.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current$1);
        {
          markRenderScheduled(lane);
        }
        var context = getContextForSubtree(parentComponent);
        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }
        {
          if (isRendering && current2 !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current2) || "Unknown");
          }
        }
        var update = createUpdate(eventTime, lane);
        update.payload = {
          element
        };
        callback = callback === void 0 ? null : callback;
        if (callback !== null) {
          {
            if (typeof callback !== "function") {
              error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
            }
          }
          update.callback = callback;
        }
        var root2 = enqueueUpdate(current$1, update, lane);
        if (root2 !== null) {
          scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
          entangleTransitions(root2, current$1, lane);
        }
        return lane;
      }
      function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child) {
          return null;
        }
        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);
          default:
            return containerFiber.child.stateNode;
        }
      }
      function attemptSynchronousHydration$1(fiber) {
        switch (fiber.tag) {
          case HostRoot: {
            var root2 = fiber.stateNode;
            if (isRootDehydrated(root2)) {
              var lanes = getHighestPriorityPendingLanes(root2);
              flushRoot(root2, lanes);
            }
            break;
          }
          case SuspenseComponent: {
            flushSync(function() {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
              }
            });
            var retryLane = SyncLane;
            markRetryLaneIfNotHydrated(fiber, retryLane);
            break;
          }
        }
      }
      function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState !== null && suspenseState.dehydrated !== null) {
          suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        if (alternate) {
          markRetryLaneImpl(alternate, retryLane);
        }
      }
      function attemptContinuousHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = SelectiveHydrationLane;
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = requestUpdateLane(fiber);
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      var shouldErrorImpl = function(fiber) {
        return null;
      };
      function shouldError(fiber) {
        return shouldErrorImpl(fiber);
      }
      var shouldSuspendImpl = function(fiber) {
        return false;
      };
      function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
      }
      var overrideHookState = null;
      var overrideHookStateDeletePath = null;
      var overrideHookStateRenamePath = null;
      var overrideProps = null;
      var overridePropsDeletePath = null;
      var overridePropsRenamePath = null;
      var scheduleUpdate = null;
      var setErrorHandler = null;
      var setSuspenseHandler = null;
      {
        var copyWithDeleteImpl = function(obj, path, index2) {
          var key = path[index2];
          var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === path.length) {
            if (isArray2(updated)) {
              updated.splice(key, 1);
            } else {
              delete updated[key];
            }
            return updated;
          }
          updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
          return updated;
        };
        var copyWithDelete = function(obj, path) {
          return copyWithDeleteImpl(obj, path, 0);
        };
        var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
          var oldKey = oldPath[index2];
          var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === oldPath.length) {
            var newKey = newPath[index2];
            updated[newKey] = updated[oldKey];
            if (isArray2(updated)) {
              updated.splice(oldKey, 1);
            } else {
              delete updated[oldKey];
            }
          } else {
            updated[oldKey] = copyWithRenameImpl(
              // $FlowFixMe number or string is fine here
              obj[oldKey],
              oldPath,
              newPath,
              index2 + 1
            );
          }
          return updated;
        };
        var copyWithRename = function(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length) {
            warn("copyWithRename() expects paths of the same length");
            return;
          } else {
            for (var i2 = 0; i2 < newPath.length - 1; i2++) {
              if (oldPath[i2] !== newPath[i2]) {
                warn("copyWithRename() expects paths to be the same except for the deepest key");
                return;
              }
            }
          }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        };
        var copyWithSetImpl = function(obj, path, index2, value2) {
          if (index2 >= path.length) {
            return value2;
          }
          var key = path[index2];
          var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value2);
          return updated;
        };
        var copyWithSet = function(obj, path, value2) {
          return copyWithSetImpl(obj, path, 0, value2);
        };
        var findHook = function(fiber, id) {
          var currentHook2 = fiber.memoizedState;
          while (currentHook2 !== null && id > 0) {
            currentHook2 = currentHook2.next;
            id--;
          }
          return currentHook2;
        };
        overrideHookState = function(fiber, id, path, value2) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path, value2);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideProps = function(fiber, path, value2) {
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value2);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
      }
      function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      function emptyFindFiberByHostInstance(instance2) {
        return null;
      }
      function getCurrentFiberForDevTools() {
        return current2;
      }
      function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
          bundleType: devToolsConfig.bundleType,
          version: devToolsConfig.version,
          rendererPackageName: devToolsConfig.rendererPackageName,
          rendererConfig: devToolsConfig.rendererConfig,
          overrideHookState,
          overrideHookStateDeletePath,
          overrideHookStateRenamePath,
          overrideProps,
          overridePropsDeletePath,
          overridePropsRenamePath,
          setErrorHandler,
          setSuspenseHandler,
          scheduleUpdate,
          currentDispatcherRef: ReactCurrentDispatcher2,
          findHostInstanceByFiber,
          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
          // React Refresh
          findHostInstancesForRefresh,
          scheduleRefresh,
          scheduleRoot,
          setRefreshHandler,
          // Enables DevTools to append owner stacks to error messages in DEV mode.
          getCurrentFiber: getCurrentFiberForDevTools,
          // Enables DevTools to detect reconciler version rather than renderer version
          // which may not match for third party renderers.
          reconcilerVersion: ReactVersion
        });
      }
      var defaultOnRecoverableError = typeof reportError === "function" ? (
        // In modern browsers, reportError will dispatch an error event,
        // emulating an uncaught JavaScript error.
        reportError
      ) : function(error2) {
        console["error"](error2);
      };
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (root2 === null) {
          throw new Error("Cannot update an unmounted root.");
        }
        {
          if (typeof arguments[1] === "function") {
            error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          } else if (isValidContainer(arguments[1])) {
            error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
          } else if (typeof arguments[1] !== "undefined") {
            error("You passed a second argument to root.render(...) but it only accepts one argument.");
          }
          var container = root2.containerInfo;
          if (container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root2.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container) {
                error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
              }
            }
          }
        }
        updateContainer(children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        {
          if (typeof arguments[0] === "function") {
            error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          }
        }
        var root2 = this._internalRoot;
        if (root2 !== null) {
          this._internalRoot = null;
          var container = root2.containerInfo;
          {
            if (isAlreadyRendering()) {
              error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
            }
          }
          flushSync(function() {
            updateContainer(null, root2, null, null);
          });
          unmarkContainerAsRoot(container);
        }
      };
      function createRoot(container, options2) {
        if (!isValidContainer(container)) {
          throw new Error("createRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container);
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== void 0) {
          {
            if (options2.hydrate) {
              warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
            } else {
              if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
              }
            }
          }
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== void 0) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== void 0) {
            onRecoverableError = options2.onRecoverableError;
          }
          if (options2.transitionCallbacks !== void 0) {
            options2.transitionCallbacks;
          }
        }
        var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root2.current, container);
        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        listenToAllSupportedEvents(rootContainerElement);
        return new ReactDOMRoot(root2);
      }
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      function scheduleHydration(target) {
        if (target) {
          queueExplicitHydrationTarget(target);
        }
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
      function hydrateRoot(container, initialChildren, options2) {
        if (!isValidContainer(container)) {
          throw new Error("hydrateRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container);
        {
          if (initialChildren === void 0) {
            error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
          }
        }
        var hydrationCallbacks = options2 != null ? options2 : null;
        var mutableSources = options2 != null && options2.hydratedSources || null;
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== void 0) {
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== void 0) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== void 0) {
            onRecoverableError = options2.onRecoverableError;
          }
        }
        var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root2.current, container);
        listenToAllSupportedEvents(container);
        if (mutableSources) {
          for (var i2 = 0; i2 < mutableSources.length; i2++) {
            var mutableSource = mutableSources[i2];
            registerMutableSourceForHydration(root2, mutableSource);
          }
        }
        return new ReactDOMHydrationRoot(root2);
      }
      function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || false));
      }
      function isValidContainerLegacy(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
      }
      function warnIfReactDOMContainerInDEV(container) {
        {
          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
            error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
          }
          if (isContainerMarkedAsRoot(container)) {
            if (container._reactRootContainer) {
              error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
            } else {
              error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
            }
          }
        }
      }
      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var topLevelUpdateWarnings;
      {
        topLevelUpdateWarnings = function(container) {
          if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container) {
                error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
              }
            }
          }
          var isRootRenderedBySomeReact = !!container._reactRootContainer;
          var rootEl = getReactRootElementInContainer(container);
          var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
          if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
            error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
          }
          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
            error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
          }
        };
      }
      function getReactRootElementInContainer(container) {
        if (!container) {
          return null;
        }
        if (container.nodeType === DOCUMENT_NODE) {
          return container.documentElement;
        } else {
          return container.firstChild;
        }
      }
      function noopOnRecoverableError() {
      }
      function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
        if (isHydrationContainer) {
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance2 = getPublicRootInstance(root2);
              originalCallback.call(instance2);
            };
          }
          var root2 = createHydrationContainer(
            initialChildren,
            callback,
            container,
            LegacyRoot,
            null,
            // hydrationCallbacks
            false,
            // isStrictMode
            false,
            // concurrentUpdatesByDefaultOverride,
            "",
            // identifierPrefix
            noopOnRecoverableError
          );
          container._reactRootContainer = root2;
          markContainerAsRoot(root2.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          flushSync();
          return root2;
        } else {
          var rootSibling;
          while (rootSibling = container.lastChild) {
            container.removeChild(rootSibling);
          }
          if (typeof callback === "function") {
            var _originalCallback = callback;
            callback = function() {
              var instance2 = getPublicRootInstance(_root2);
              _originalCallback.call(instance2);
            };
          }
          var _root2 = createContainer(
            container,
            LegacyRoot,
            null,
            // hydrationCallbacks
            false,
            // isStrictMode
            false,
            // concurrentUpdatesByDefaultOverride,
            "",
            // identifierPrefix
            noopOnRecoverableError
          );
          container._reactRootContainer = _root2;
          markContainerAsRoot(_root2.current, container);
          var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(_rootContainerElement);
          flushSync(function() {
            updateContainer(initialChildren, _root2, parentComponent, callback);
          });
          return _root2;
        }
      }
      function warnOnInvalidCallback$1(callback, callerName) {
        {
          if (callback !== null && typeof callback !== "function") {
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        }
      }
      function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
        {
          topLevelUpdateWarnings(container);
          warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
        }
        var maybeRoot = container._reactRootContainer;
        var root2;
        if (!maybeRoot) {
          root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
        } else {
          root2 = maybeRoot;
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance2 = getPublicRootInstance(root2);
              originalCallback.call(instance2);
            };
          }
          updateContainer(children, root2, parentComponent, callback);
        }
        return getPublicRootInstance(root2);
      }
      var didWarnAboutFindDOMNode = false;
      function findDOMNode(componentOrElement) {
        {
          if (!didWarnAboutFindDOMNode) {
            didWarnAboutFindDOMNode = true;
            error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
          }
          var owner = ReactCurrentOwner$3.current;
          if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            if (!warnedAboutRefsInRender) {
              error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
            }
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }
        if (componentOrElement == null) {
          return null;
        }
        if (componentOrElement.nodeType === ELEMENT_NODE) {
          return componentOrElement;
        }
        {
          return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
        }
      }
      function hydrate(element, container, callback) {
        {
          error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
      }
      function render(element, container, callback) {
        {
          error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
      }
      function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        {
          error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(containerNode)) {
          throw new Error("Target container is not a DOM element.");
        }
        if (parentComponent == null || !has2(parentComponent)) {
          throw new Error("parentComponent must be a valid React Component");
        }
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
      }
      var didWarnAboutUnmountComponentAtNode = false;
      function unmountComponentAtNode(container) {
        {
          if (!didWarnAboutUnmountComponentAtNode) {
            didWarnAboutUnmountComponentAtNode = true;
            error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
          }
        }
        if (container._reactRootContainer) {
          {
            var rootEl = getReactRootElementInContainer(container);
            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            if (renderedByDifferentReact) {
              error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
            }
          }
          flushSync(function() {
            legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
              container._reactRootContainer = null;
              unmarkContainerAsRoot(container);
            });
          });
          return true;
        } else {
          {
            var _rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
            var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
            if (hasNonRootReactChild) {
              error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
            }
          }
          return false;
        }
      }
      setAttemptSynchronousHydration(attemptSynchronousHydration$1);
      setAttemptContinuousHydration(attemptContinuousHydration$1);
      setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
      setGetCurrentUpdatePriority(getCurrentUpdatePriority);
      setAttemptHydrationAtPriority(runWithPriority);
      {
        if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
        Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
        Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
          error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
      }
      setRestoreImplementation(restoreControlledState$3);
      setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
      function createPortal$1(children, container) {
        var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (!isValidContainer(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        return createPortal(children, container, null, key);
      }
      function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
      }
      var Internals = {
        usingClientEntryPoint: false,
        // Keep in sync with ReactTestUtils.js.
        // This is an array for better minification.
        Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
      };
      function createRoot$1(container, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
          }
        }
        return createRoot(container, options2);
      }
      function hydrateRoot$1(container, initialChildren, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
          }
        }
        return hydrateRoot(container, initialChildren, options2);
      }
      function flushSync$1(fn) {
        {
          if (isAlreadyRendering()) {
            error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
          }
        }
        return flushSync(fn);
      }
      var foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-dom"
      });
      {
        if (!foundDevTools && canUseDOM2 && window.top === window.self) {
          if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
            var protocol2 = window.location.protocol;
            if (/^(https?|file):$/.test(protocol2)) {
              console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol2 === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
            }
          }
        }
      }
      reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
      reactDom_development.createPortal = createPortal$1;
      reactDom_development.createRoot = createRoot$1;
      reactDom_development.findDOMNode = findDOMNode;
      reactDom_development.flushSync = flushSync$1;
      reactDom_development.hydrate = hydrate;
      reactDom_development.hydrateRoot = hydrateRoot$1;
      reactDom_development.render = render;
      reactDom_development.unmountComponentAtNode = unmountComponentAtNode;
      reactDom_development.unstable_batchedUpdates = batchedUpdates$1;
      reactDom_development.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
      reactDom_development.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return reactDom_development;
}
var define_process_env_default$e = {};
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  if (define_process_env_default$e.NODE_ENV !== "production") {
    throw new Error("^_^");
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
if (define_process_env_default$e.NODE_ENV === "production") {
  checkDCE();
  reactDom.exports = requireReactDom_production_min();
} else {
  reactDom.exports = requireReactDom_development();
}
var reactDomExports = reactDom.exports;
var define_process_env_default$d = {};
var m = reactDomExports;
if (define_process_env_default$d.NODE_ENV === "production") {
  client.createRoot = m.createRoot;
  client.hydrateRoot = m.hydrateRoot;
} else {
  var i$1 = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  client.createRoot = function(c2, o2) {
    i$1.usingClientEntryPoint = true;
    try {
      return m.createRoot(c2, o2);
    } finally {
      i$1.usingClientEntryPoint = false;
    }
  };
  client.hydrateRoot = function(c2, h, o2) {
    i$1.usingClientEntryPoint = true;
    try {
      return m.hydrateRoot(c2, h, o2);
    } finally {
      i$1.usingClientEntryPoint = false;
    }
  };
}
var lib = {};
var uaParser_min = { exports: {} };
(function(module, exports) {
  (function(window2, undefined$1) {
    var LIBVERSION = "1.0.40", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION2 = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
    var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
    var extend2 = function(regexes2, extensions) {
      var mergedRegexes = {};
      for (var i2 in regexes2) {
        if (extensions[i2] && extensions[i2].length % 2 === 0) {
          mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
        } else {
          mergedRegexes[i2] = regexes2[i2];
        }
      }
      return mergedRegexes;
    }, enumerize = function(arr) {
      var enums = {};
      for (var i2 = 0; i2 < arr.length; i2++) {
        enums[arr[i2].toUpperCase()] = arr[i2];
      }
      return enums;
    }, has2 = function(str1, str2) {
      return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
    }, lowerize = function(str) {
      return str.toLowerCase();
    }, majorize = function(version) {
      return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined$1;
    }, trim2 = function(str, len) {
      if (typeof str === STR_TYPE) {
        str = str.replace(/^\s\s*/, EMPTY);
        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
      }
    };
    var rgxMapper = function(ua2, arrays) {
      var i2 = 0, j, k, p2, q, matches2, match;
      while (i2 < arrays.length && !matches2) {
        var regex = arrays[i2], props = arrays[i2 + 1];
        j = k = 0;
        while (j < regex.length && !matches2) {
          if (!regex[j]) {
            break;
          }
          matches2 = regex[j++].exec(ua2);
          if (!!matches2) {
            for (p2 = 0; p2 < props.length; p2++) {
              match = matches2[++k];
              q = props[p2];
              if (typeof q === OBJ_TYPE && q.length > 0) {
                if (q.length === 2) {
                  if (typeof q[1] == FUNC_TYPE) {
                    this[q[0]] = q[1].call(this, match);
                  } else {
                    this[q[0]] = q[1];
                  }
                } else if (q.length === 3) {
                  if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                    this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                  } else {
                    this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                  }
                } else if (q.length === 4) {
                  this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                }
              } else {
                this[q] = match ? match : undefined$1;
              }
            }
          }
        }
        i2 += 2;
      }
    }, strMapper = function(str, map) {
      for (var i2 in map) {
        if (typeof map[i2] === OBJ_TYPE && map[i2].length > 0) {
          for (var j = 0; j < map[i2].length; j++) {
            if (has2(map[i2][j], str)) {
              return i2 === UNKNOWN ? undefined$1 : i2;
            }
          }
        } else if (has2(map[i2], str)) {
          return i2 === UNKNOWN ? undefined$1 : i2;
        }
      }
      return map.hasOwnProperty("*") ? map["*"] : str;
    };
    var oldSafariMap = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, windowsVersionMap = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" };
    var regexes = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION2, [NAME, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION2, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION2], [/opios[\/ ]+([\w\.]+)/i], [VERSION2, [NAME, OPERA + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [VERSION2, [NAME, OPERA + " GX"]], [/\bopr\/([\w\.]+)/i], [VERSION2, [NAME, OPERA]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [VERSION2, [NAME, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [VERSION2, [NAME, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i, /(heytap|ovi|115)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [NAME, VERSION2], [/quark(?:pc)?\/([-\w\.]+)/i], [VERSION2, [NAME, "Quark"]], [/\bddg\/([\w\.]+)/i], [VERSION2, [NAME, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION2, [NAME, "UC" + BROWSER]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [VERSION2, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION2, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION2, [NAME, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [VERSION2, [NAME, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [VERSION2, [NAME, "Smart Lenovo " + BROWSER]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION2], [/\bfocus\/([\w\.]+)/i], [VERSION2, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION2, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION2, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION2, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION2, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION2, [NAME, "MIUI" + SUFFIX_BROWSER]], [/fxios\/([\w\.-]+)/i], [VERSION2, [NAME, FIREFOX]], [/\bqihoobrowser\/?([\w\.]*)/i], [VERSION2, [NAME, "360"]], [/\b(qq)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1Browser"], VERSION2], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION2], [/samsungbrowser\/([\w\.]+)/i], [VERSION2, [NAME, SAMSUNG + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [VERSION2, [NAME, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[NAME, "Sogou Mobile"], VERSION2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [NAME, VERSION2], [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i], [NAME], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [VERSION2, NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, FACEBOOK], VERSION2], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [NAME, VERSION2], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION2, [NAME, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [VERSION2, [NAME, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION2, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION2, [NAME, "Android " + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [VERSION2, [NAME, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [VERSION2, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION2, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION2], [/(wolvic|librewolf)\/([\w\.]+)/i], [NAME, VERSION2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION2, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [NAME, [VERSION2, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [NAME, [VERSION2, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/windows (ce|mobile); ppc;/i], [[ARCHITECTURE, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i], [[ARCHITECTURE, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [/(?:honor)([-\w ]+)[;\)]/i], [MODEL, [VENDOR, "Honor"], [TYPE, MOBILE]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [/\b(opd2\d{3}a?) bui/i], [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [/(pixel c)\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]], [/(itel) ((\w+))/i], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { tablet: ["p10001l", "w7001"], "*": "mobile" }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]], [/droid.+; (a(?:015|06[35]|142p?))/i], [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(imo) (tab \w+)/i, /(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/(u304aa)/i], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [/\bsie-(\w*)/i], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [/\b(rct\w+) b/i], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [/\b(k88) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [/\btu_(1491) b/i], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [/(shield[\w ]+) b/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mitv-\w{5}) bui/i], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[VENDOR, trim2], [MODEL, trim2], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [/((pebble))app/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/(pico) (4|neo3(?: link|pro)?)/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/; (quest( \d| pro)?)/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i], [MODEL, [VENDOR, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION2, [NAME, EDGE + "HTML"]], [/(arkweb)\/([\w\.]+)/i], [NAME, VERSION2], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION2, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [NAME, VERSION2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION2, NAME]], os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION2], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [NAME, [VERSION2, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION2, strMapper, windowsVersionMap], [NAME, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION2, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, MAC_OS], [VERSION2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [VERSION2, NAME], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [NAME, VERSION2], [/\(bb(10);/i], [VERSION2, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [VERSION2, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION2, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION2, [NAME, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [VERSION2, [NAME, "watchOS"]], [/crkey\/([\d\.]+)/i], [VERSION2, [NAME, CHROME + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[NAME, CHROMIUM_OS], VERSION2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION2], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION2]] };
    var UAParser2 = function(ua2, extensions) {
      if (typeof ua2 === OBJ_TYPE) {
        extensions = ua2;
        ua2 = undefined$1;
      }
      if (!(this instanceof UAParser2)) {
        return new UAParser2(ua2, extensions).getResult();
      }
      var _navigator2 = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;
      var _ua = ua2 || (_navigator2 && _navigator2.userAgent ? _navigator2.userAgent : EMPTY);
      var _uach = _navigator2 && _navigator2.userAgentData ? _navigator2.userAgentData : undefined$1;
      var _rgxmap = extensions ? extend2(regexes, extensions) : regexes;
      var _isSelfNav = _navigator2 && _navigator2.userAgent == _ua;
      this.getBrowser = function() {
        var _browser = {};
        _browser[NAME] = undefined$1;
        _browser[VERSION2] = undefined$1;
        rgxMapper.call(_browser, _ua, _rgxmap.browser);
        _browser[MAJOR] = majorize(_browser[VERSION2]);
        if (_isSelfNav && _navigator2 && _navigator2.brave && typeof _navigator2.brave.isBrave == FUNC_TYPE) {
          _browser[NAME] = "Brave";
        }
        return _browser;
      };
      this.getCPU = function() {
        var _cpu = {};
        _cpu[ARCHITECTURE] = undefined$1;
        rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
        return _cpu;
      };
      this.getDevice = function() {
        var _device = {};
        _device[VENDOR] = undefined$1;
        _device[MODEL] = undefined$1;
        _device[TYPE] = undefined$1;
        rgxMapper.call(_device, _ua, _rgxmap.device);
        if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
          _device[TYPE] = MOBILE;
        }
        if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator2 && typeof _navigator2.standalone !== UNDEF_TYPE && _navigator2.maxTouchPoints && _navigator2.maxTouchPoints > 2) {
          _device[MODEL] = "iPad";
          _device[TYPE] = TABLET;
        }
        return _device;
      };
      this.getEngine = function() {
        var _engine = {};
        _engine[NAME] = undefined$1;
        _engine[VERSION2] = undefined$1;
        rgxMapper.call(_engine, _ua, _rgxmap.engine);
        return _engine;
      };
      this.getOS = function() {
        var _os = {};
        _os[NAME] = undefined$1;
        _os[VERSION2] = undefined$1;
        rgxMapper.call(_os, _ua, _rgxmap.os);
        if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
          _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
        }
        return _os;
      };
      this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      };
      this.getUA = function() {
        return _ua;
      };
      this.setUA = function(ua3) {
        _ua = typeof ua3 === STR_TYPE && ua3.length > UA_MAX_LENGTH ? trim2(ua3, UA_MAX_LENGTH) : ua3;
        return this;
      };
      this.setUA(_ua);
      return this;
    };
    UAParser2.VERSION = LIBVERSION;
    UAParser2.BROWSER = enumerize([NAME, VERSION2, MAJOR]);
    UAParser2.CPU = enumerize([ARCHITECTURE]);
    UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION2]);
    {
      if (module.exports) {
        exports = module.exports = UAParser2;
      }
      exports.UAParser = UAParser2;
    }
    var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
    if ($ && !$.ua) {
      var parser2 = new UAParser2();
      $.ua = parser2.getResult();
      $.ua.get = function() {
        return parser2.getUA();
      };
      $.ua.set = function(ua2) {
        parser2.setUA(ua2);
        var result = parser2.getResult();
        for (var prop in result) {
          $.ua[prop] = result[prop];
        }
      };
    }
  })(typeof window === "object" ? window : commonjsGlobal);
})(uaParser_min, uaParser_min.exports);
var uaParser_minExports = uaParser_min.exports;
Object.defineProperty(lib, "__esModule", { value: true });
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var React = reactExports;
var React__default = _interopDefault(React);
var UAParser = uaParser_minExports;
var ClientUAInstance = new UAParser();
var browser = ClientUAInstance.getBrowser();
var cpu = ClientUAInstance.getCPU();
var device = ClientUAInstance.getDevice();
var engine = ClientUAInstance.getEngine();
var os = ClientUAInstance.getOS();
var ua = ClientUAInstance.getUA();
var setUa = function setUa2(userAgentString) {
  return ClientUAInstance.setUA(userAgentString);
};
var parseUserAgent = function parseUserAgent2(userAgent) {
  if (!userAgent) {
    console.error("No userAgent string was provided");
    return;
  }
  var UserAgentInstance = new UAParser(userAgent);
  return {
    UA: UserAgentInstance,
    browser: UserAgentInstance.getBrowser(),
    cpu: UserAgentInstance.getCPU(),
    device: UserAgentInstance.getDevice(),
    engine: UserAgentInstance.getEngine(),
    os: UserAgentInstance.getOS(),
    ua: UserAgentInstance.getUA(),
    setUserAgent: function setUserAgent3(userAgentString) {
      return UserAgentInstance.setUA(userAgentString);
    }
  };
};
var UAHelper = /* @__PURE__ */ Object.freeze({
  ClientUAInstance,
  browser,
  cpu,
  device,
  engine,
  os,
  ua,
  setUa,
  parseUserAgent
});
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  return Constructor;
}
function _defineProperty$3(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var DeviceTypes = {
  Mobile: "mobile",
  Tablet: "tablet",
  SmartTv: "smarttv",
  Console: "console",
  Wearable: "wearable",
  Embedded: "embedded",
  Browser: void 0
};
var BrowserTypes = {
  Chrome: "Chrome",
  Firefox: "Firefox",
  Opera: "Opera",
  Yandex: "Yandex",
  Safari: "Safari",
  InternetExplorer: "Internet Explorer",
  Edge: "Edge",
  Chromium: "Chromium",
  Ie: "IE",
  MobileSafari: "Mobile Safari",
  EdgeChromium: "Edge Chromium",
  MIUI: "MIUI Browser",
  SamsungBrowser: "Samsung Browser"
};
var OsTypes = {
  IOS: "iOS",
  Android: "Android",
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MAC_OS: "Mac OS"
};
var InitialDeviceTypes = {
  isMobile: false,
  isTablet: false,
  isBrowser: false,
  isSmartTV: false,
  isConsole: false,
  isWearable: false
};
var checkDeviceType = function checkDeviceType2(type) {
  switch (type) {
    case DeviceTypes.Mobile:
      return {
        isMobile: true
      };
    case DeviceTypes.Tablet:
      return {
        isTablet: true
      };
    case DeviceTypes.SmartTv:
      return {
        isSmartTV: true
      };
    case DeviceTypes.Console:
      return {
        isConsole: true
      };
    case DeviceTypes.Wearable:
      return {
        isWearable: true
      };
    case DeviceTypes.Browser:
      return {
        isBrowser: true
      };
    case DeviceTypes.Embedded:
      return {
        isEmbedded: true
      };
    default:
      return InitialDeviceTypes;
  }
};
var setUserAgent = function setUserAgent2(userAgent) {
  return setUa(userAgent);
};
var setDefaults$1 = function setDefaults(p2) {
  var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
  return p2 ? p2 : d;
};
var getNavigatorInstance = function getNavigatorInstance2() {
  if (typeof window !== "undefined") {
    if (window.navigator || navigator) {
      return window.navigator || navigator;
    }
  }
  return false;
};
var isIOS13Check = function isIOS13Check2(type) {
  var nav = getNavigatorInstance();
  return nav && nav.platform && (nav.platform.indexOf(type) !== -1 || nav.platform === "MacIntel" && nav.maxTouchPoints > 1 && !window.MSStream);
};
var browserPayload = function browserPayload2(isBrowser2, browser2, engine2, os2, ua2) {
  return {
    isBrowser: isBrowser2,
    browserMajorVersion: setDefaults$1(browser2.major),
    browserFullVersion: setDefaults$1(browser2.version),
    browserName: setDefaults$1(browser2.name),
    engineName: setDefaults$1(engine2.name),
    engineVersion: setDefaults$1(engine2.version),
    osName: setDefaults$1(os2.name),
    osVersion: setDefaults$1(os2.version),
    userAgent: setDefaults$1(ua2)
  };
};
var mobilePayload = function mobilePayload2(type, device2, os2, ua2) {
  return _objectSpread2({}, type, {
    vendor: setDefaults$1(device2.vendor),
    model: setDefaults$1(device2.model),
    os: setDefaults$1(os2.name),
    osVersion: setDefaults$1(os2.version),
    ua: setDefaults$1(ua2)
  });
};
var smartTvPayload = function smartTvPayload2(isSmartTV2, engine2, os2, ua2) {
  return {
    isSmartTV: isSmartTV2,
    engineName: setDefaults$1(engine2.name),
    engineVersion: setDefaults$1(engine2.version),
    osName: setDefaults$1(os2.name),
    osVersion: setDefaults$1(os2.version),
    userAgent: setDefaults$1(ua2)
  };
};
var consolePayload = function consolePayload2(isConsole2, engine2, os2, ua2) {
  return {
    isConsole: isConsole2,
    engineName: setDefaults$1(engine2.name),
    engineVersion: setDefaults$1(engine2.version),
    osName: setDefaults$1(os2.name),
    osVersion: setDefaults$1(os2.version),
    userAgent: setDefaults$1(ua2)
  };
};
var wearablePayload = function wearablePayload2(isWearable2, engine2, os2, ua2) {
  return {
    isWearable: isWearable2,
    engineName: setDefaults$1(engine2.name),
    engineVersion: setDefaults$1(engine2.version),
    osName: setDefaults$1(os2.name),
    osVersion: setDefaults$1(os2.version),
    userAgent: setDefaults$1(ua2)
  };
};
var embeddedPayload = function embeddedPayload2(isEmbedded2, device2, engine2, os2, ua2) {
  return {
    isEmbedded: isEmbedded2,
    vendor: setDefaults$1(device2.vendor),
    model: setDefaults$1(device2.model),
    engineName: setDefaults$1(engine2.name),
    engineVersion: setDefaults$1(engine2.version),
    osName: setDefaults$1(os2.name),
    osVersion: setDefaults$1(os2.version),
    userAgent: setDefaults$1(ua2)
  };
};
function deviceDetect(userAgent) {
  var _ref = userAgent ? parseUserAgent(userAgent) : UAHelper, device2 = _ref.device, browser2 = _ref.browser, engine2 = _ref.engine, os2 = _ref.os, ua2 = _ref.ua;
  var type = checkDeviceType(device2.type);
  var isBrowser2 = type.isBrowser, isMobile2 = type.isMobile, isTablet2 = type.isTablet, isSmartTV2 = type.isSmartTV, isConsole2 = type.isConsole, isWearable2 = type.isWearable, isEmbedded2 = type.isEmbedded;
  if (isBrowser2) {
    return browserPayload(isBrowser2, browser2, engine2, os2, ua2);
  }
  if (isSmartTV2) {
    return smartTvPayload(isSmartTV2, engine2, os2, ua2);
  }
  if (isConsole2) {
    return consolePayload(isConsole2, engine2, os2, ua2);
  }
  if (isMobile2) {
    return mobilePayload(type, device2, os2, ua2);
  }
  if (isTablet2) {
    return mobilePayload(type, device2, os2, ua2);
  }
  if (isWearable2) {
    return wearablePayload(isWearable2, engine2, os2, ua2);
  }
  if (isEmbedded2) {
    return embeddedPayload(isEmbedded2, device2, engine2, os2, ua2);
  }
}
var isMobileType = function isMobileType2(_ref) {
  var type = _ref.type;
  return type === DeviceTypes.Mobile;
};
var isTabletType = function isTabletType2(_ref2) {
  var type = _ref2.type;
  return type === DeviceTypes.Tablet;
};
var isMobileAndTabletType = function isMobileAndTabletType2(_ref3) {
  var type = _ref3.type;
  return type === DeviceTypes.Mobile || type === DeviceTypes.Tablet;
};
var isSmartTVType = function isSmartTVType2(_ref4) {
  var type = _ref4.type;
  return type === DeviceTypes.SmartTv;
};
var isBrowserType = function isBrowserType2(_ref5) {
  var type = _ref5.type;
  return type === DeviceTypes.Browser;
};
var isWearableType = function isWearableType2(_ref6) {
  var type = _ref6.type;
  return type === DeviceTypes.Wearable;
};
var isConsoleType = function isConsoleType2(_ref7) {
  var type = _ref7.type;
  return type === DeviceTypes.Console;
};
var isEmbeddedType = function isEmbeddedType2(_ref8) {
  var type = _ref8.type;
  return type === DeviceTypes.Embedded;
};
var getMobileVendor = function getMobileVendor2(_ref9) {
  var vendor = _ref9.vendor;
  return setDefaults$1(vendor);
};
var getMobileModel = function getMobileModel2(_ref10) {
  var model = _ref10.model;
  return setDefaults$1(model);
};
var getDeviceType = function getDeviceType2(_ref11) {
  var type = _ref11.type;
  return setDefaults$1(type, "browser");
};
var isAndroidType = function isAndroidType2(_ref12) {
  var name2 = _ref12.name;
  return name2 === OsTypes.Android;
};
var isWindowsType = function isWindowsType2(_ref13) {
  var name2 = _ref13.name;
  return name2 === OsTypes.Windows;
};
var isMacOsType = function isMacOsType2(_ref14) {
  var name2 = _ref14.name;
  return name2 === OsTypes.MAC_OS;
};
var isWinPhoneType = function isWinPhoneType2(_ref15) {
  var name2 = _ref15.name;
  return name2 === OsTypes.WindowsPhone;
};
var isIOSType = function isIOSType2(_ref16) {
  var name2 = _ref16.name;
  return name2 === OsTypes.IOS;
};
var getOsVersion = function getOsVersion2(_ref17) {
  var version = _ref17.version;
  return setDefaults$1(version);
};
var getOsName = function getOsName2(_ref18) {
  var name2 = _ref18.name;
  return setDefaults$1(name2);
};
var isChromeType = function isChromeType2(_ref19) {
  var name2 = _ref19.name;
  return name2 === BrowserTypes.Chrome;
};
var isFirefoxType = function isFirefoxType2(_ref20) {
  var name2 = _ref20.name;
  return name2 === BrowserTypes.Firefox;
};
var isChromiumType = function isChromiumType2(_ref21) {
  var name2 = _ref21.name;
  return name2 === BrowserTypes.Chromium;
};
var isEdgeType = function isEdgeType2(_ref22) {
  var name2 = _ref22.name;
  return name2 === BrowserTypes.Edge;
};
var isYandexType = function isYandexType2(_ref23) {
  var name2 = _ref23.name;
  return name2 === BrowserTypes.Yandex;
};
var isSafariType = function isSafariType2(_ref24) {
  var name2 = _ref24.name;
  return name2 === BrowserTypes.Safari || name2 === BrowserTypes.MobileSafari;
};
var isMobileSafariType = function isMobileSafariType2(_ref25) {
  var name2 = _ref25.name;
  return name2 === BrowserTypes.MobileSafari;
};
var isOperaType = function isOperaType2(_ref26) {
  var name2 = _ref26.name;
  return name2 === BrowserTypes.Opera;
};
var isIEType = function isIEType2(_ref27) {
  var name2 = _ref27.name;
  return name2 === BrowserTypes.InternetExplorer || name2 === BrowserTypes.Ie;
};
var isMIUIType = function isMIUIType2(_ref28) {
  var name2 = _ref28.name;
  return name2 === BrowserTypes.MIUI;
};
var isSamsungBrowserType = function isSamsungBrowserType2(_ref29) {
  var name2 = _ref29.name;
  return name2 === BrowserTypes.SamsungBrowser;
};
var getBrowserFullVersion = function getBrowserFullVersion2(_ref30) {
  var version = _ref30.version;
  return setDefaults$1(version);
};
var getBrowserVersion = function getBrowserVersion2(_ref31) {
  var major = _ref31.major;
  return setDefaults$1(major);
};
var getBrowserName = function getBrowserName2(_ref32) {
  var name2 = _ref32.name;
  return setDefaults$1(name2);
};
var getEngineName = function getEngineName2(_ref33) {
  var name2 = _ref33.name;
  return setDefaults$1(name2);
};
var getEngineVersion = function getEngineVersion2(_ref34) {
  var version = _ref34.version;
  return setDefaults$1(version);
};
var isElectronType = function isElectronType2() {
  var nav = getNavigatorInstance();
  var ua2 = nav && nav.userAgent && nav.userAgent.toLowerCase();
  return typeof ua2 === "string" ? /electron/.test(ua2) : false;
};
var isEdgeChromiumType = function isEdgeChromiumType2(ua2) {
  return typeof ua2 === "string" && ua2.indexOf("Edg/") !== -1;
};
var getIOS13 = function getIOS132() {
  var nav = getNavigatorInstance();
  return nav && (/iPad|iPhone|iPod/.test(nav.platform) || nav.platform === "MacIntel" && nav.maxTouchPoints > 1) && !window.MSStream;
};
var getIPad13 = function getIPad132() {
  return isIOS13Check("iPad");
};
var getIphone13 = function getIphone132() {
  return isIOS13Check("iPhone");
};
var getIPod13 = function getIPod132() {
  return isIOS13Check("iPod");
};
var getUseragent = function getUseragent2(userAg) {
  return setDefaults$1(userAg);
};
function buildSelectorsObject(options) {
  var _ref = options ? options : UAHelper, device2 = _ref.device, browser2 = _ref.browser, os2 = _ref.os, engine2 = _ref.engine, ua2 = _ref.ua;
  return {
    isSmartTV: isSmartTVType(device2),
    isConsole: isConsoleType(device2),
    isWearable: isWearableType(device2),
    isEmbedded: isEmbeddedType(device2),
    isMobileSafari: isMobileSafariType(browser2) || getIPad13(),
    isChromium: isChromiumType(browser2),
    isMobile: isMobileAndTabletType(device2) || getIPad13(),
    isMobileOnly: isMobileType(device2),
    isTablet: isTabletType(device2) || getIPad13(),
    isBrowser: isBrowserType(device2),
    isDesktop: isBrowserType(device2),
    isAndroid: isAndroidType(os2),
    isWinPhone: isWinPhoneType(os2),
    isIOS: isIOSType(os2) || getIPad13(),
    isChrome: isChromeType(browser2),
    isFirefox: isFirefoxType(browser2),
    isSafari: isSafariType(browser2),
    isOpera: isOperaType(browser2),
    isIE: isIEType(browser2),
    osVersion: getOsVersion(os2),
    osName: getOsName(os2),
    fullBrowserVersion: getBrowserFullVersion(browser2),
    browserVersion: getBrowserVersion(browser2),
    browserName: getBrowserName(browser2),
    mobileVendor: getMobileVendor(device2),
    mobileModel: getMobileModel(device2),
    engineName: getEngineName(engine2),
    engineVersion: getEngineVersion(engine2),
    getUA: getUseragent(ua2),
    isEdge: isEdgeType(browser2) || isEdgeChromiumType(ua2),
    isYandex: isYandexType(browser2),
    deviceType: getDeviceType(device2),
    isIOS13: getIOS13(),
    isIPad13: getIPad13(),
    isIPhone13: getIphone13(),
    isIPod13: getIPod13(),
    isElectron: isElectronType(),
    isEdgeChromium: isEdgeChromiumType(ua2),
    isLegacyEdge: isEdgeType(browser2) && !isEdgeChromiumType(ua2),
    isWindows: isWindowsType(os2),
    isMacOs: isMacOsType(os2),
    isMIUI: isMIUIType(browser2),
    isSamsungBrowser: isSamsungBrowserType(browser2)
  };
}
var isSmartTV = isSmartTVType(device);
var isConsole = isConsoleType(device);
var isWearable = isWearableType(device);
var isEmbedded = isEmbeddedType(device);
var isMobileSafari = isMobileSafariType(browser) || getIPad13();
var isChromium = isChromiumType(browser);
var isMobile = isMobileAndTabletType(device) || getIPad13();
var isMobileOnly = isMobileType(device);
var isTablet = isTabletType(device) || getIPad13();
var isBrowser = isBrowserType(device);
var isDesktop = isBrowserType(device);
var isAndroid = isAndroidType(os);
var isWinPhone = isWinPhoneType(os);
var isIOS = isIOSType(os) || getIPad13();
var isChrome = isChromeType(browser);
var isFirefox = isFirefoxType(browser);
var isSafari = isSafariType(browser);
var isOpera = isOperaType(browser);
var isIE = isIEType(browser);
var osVersion = getOsVersion(os);
var osName = getOsName(os);
var fullBrowserVersion = getBrowserFullVersion(browser);
var browserVersion = getBrowserVersion(browser);
var browserName = getBrowserName(browser);
var mobileVendor = getMobileVendor(device);
var mobileModel = getMobileModel(device);
var engineName = getEngineName(engine);
var engineVersion = getEngineVersion(engine);
var getUA = getUseragent(ua);
var isEdge = isEdgeType(browser) || isEdgeChromiumType(ua);
var isYandex = isYandexType(browser);
var deviceType = getDeviceType(device);
var isIOS13 = getIOS13();
var isIPad13 = getIPad13();
var isIPhone13 = getIphone13();
var isIPod13 = getIPod13();
var isElectron = isElectronType();
var isEdgeChromium = isEdgeChromiumType(ua);
var isLegacyEdge = isEdgeType(browser) && !isEdgeChromiumType(ua);
var isWindows = isWindowsType(os);
var isMacOs = isMacOsType(os);
var isMIUI = isMIUIType(browser);
var isSamsungBrowser = isSamsungBrowserType(browser);
var getSelectorsByUserAgent = function getSelectorsByUserAgent2(userAgent) {
  if (!userAgent || typeof userAgent !== "string") {
    console.error("No valid user agent string was provided");
    return;
  }
  var _UAHelper$parseUserAg = parseUserAgent(userAgent), device2 = _UAHelper$parseUserAg.device, browser2 = _UAHelper$parseUserAg.browser, os2 = _UAHelper$parseUserAg.os, engine2 = _UAHelper$parseUserAg.engine, ua2 = _UAHelper$parseUserAg.ua;
  return buildSelectorsObject({
    device: device2,
    browser: browser2,
    os: os2,
    engine: engine2,
    ua: ua2
  });
};
var AndroidView = function AndroidView2(_ref) {
  var renderWithFragment = _ref.renderWithFragment, children = _ref.children, props = _objectWithoutProperties$1(_ref, ["renderWithFragment", "children"]);
  return isAndroid ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var BrowserView = function BrowserView2(_ref2) {
  var renderWithFragment = _ref2.renderWithFragment, children = _ref2.children, props = _objectWithoutProperties$1(_ref2, ["renderWithFragment", "children"]);
  return isBrowser ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var IEView = function IEView2(_ref3) {
  var renderWithFragment = _ref3.renderWithFragment, children = _ref3.children, props = _objectWithoutProperties$1(_ref3, ["renderWithFragment", "children"]);
  return isIE ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var IOSView = function IOSView2(_ref4) {
  var renderWithFragment = _ref4.renderWithFragment, children = _ref4.children, props = _objectWithoutProperties$1(_ref4, ["renderWithFragment", "children"]);
  return isIOS ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var MobileView = function MobileView2(_ref5) {
  var renderWithFragment = _ref5.renderWithFragment, children = _ref5.children, props = _objectWithoutProperties$1(_ref5, ["renderWithFragment", "children"]);
  return isMobile ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var TabletView = function TabletView2(_ref6) {
  var renderWithFragment = _ref6.renderWithFragment, children = _ref6.children, props = _objectWithoutProperties$1(_ref6, ["renderWithFragment", "children"]);
  return isTablet ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var WinPhoneView = function WinPhoneView2(_ref7) {
  var renderWithFragment = _ref7.renderWithFragment, children = _ref7.children, props = _objectWithoutProperties$1(_ref7, ["renderWithFragment", "children"]);
  return isWinPhone ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var MobileOnlyView = function MobileOnlyView2(_ref8) {
  var renderWithFragment = _ref8.renderWithFragment, children = _ref8.children;
  _ref8.viewClassName;
  _ref8.style;
  var props = _objectWithoutProperties$1(_ref8, ["renderWithFragment", "children", "viewClassName", "style"]);
  return isMobileOnly ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var SmartTVView = function SmartTVView2(_ref9) {
  var renderWithFragment = _ref9.renderWithFragment, children = _ref9.children, props = _objectWithoutProperties$1(_ref9, ["renderWithFragment", "children"]);
  return isSmartTV ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var ConsoleView = function ConsoleView2(_ref10) {
  var renderWithFragment = _ref10.renderWithFragment, children = _ref10.children, props = _objectWithoutProperties$1(_ref10, ["renderWithFragment", "children"]);
  return isConsole ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var WearableView = function WearableView2(_ref11) {
  var renderWithFragment = _ref11.renderWithFragment, children = _ref11.children, props = _objectWithoutProperties$1(_ref11, ["renderWithFragment", "children"]);
  return isWearable ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var CustomView = function CustomView2(_ref12) {
  var renderWithFragment = _ref12.renderWithFragment, children = _ref12.children;
  _ref12.viewClassName;
  _ref12.style;
  var condition = _ref12.condition, props = _objectWithoutProperties$1(_ref12, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
  return condition ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
function withOrientationChange(WrappedComponent) {
  return /* @__PURE__ */ function(_React$Component) {
    _inherits(_class, _React$Component);
    function _class(props) {
      var _this;
      _classCallCheck(this, _class);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
      _this.isEventListenerAdded = false;
      _this.handleOrientationChange = _this.handleOrientationChange.bind(_assertThisInitialized$1(_this));
      _this.onOrientationChange = _this.onOrientationChange.bind(_assertThisInitialized$1(_this));
      _this.onPageLoad = _this.onPageLoad.bind(_assertThisInitialized$1(_this));
      _this.state = {
        isLandscape: false,
        isPortrait: false
      };
      return _this;
    }
    _createClass$1(_class, [{
      key: "handleOrientationChange",
      value: function handleOrientationChange() {
        if (!this.isEventListenerAdded) {
          this.isEventListenerAdded = true;
        }
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        this.setState({
          isPortrait: orientation === 0,
          isLandscape: orientation === 90
        });
      }
    }, {
      key: "onOrientationChange",
      value: function onOrientationChange() {
        this.handleOrientationChange();
      }
    }, {
      key: "onPageLoad",
      value: function onPageLoad() {
        this.handleOrientationChange();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if ((typeof window === "undefined" ? "undefined" : _typeof$3(window)) !== void 0 && isMobile) {
          if (!this.isEventListenerAdded) {
            this.handleOrientationChange();
            window.addEventListener("load", this.onPageLoad, false);
          } else {
            window.removeEventListener("load", this.onPageLoad, false);
          }
          window.addEventListener("resize", this.onOrientationChange, false);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        window.removeEventListener("resize", this.onOrientationChange, false);
      }
    }, {
      key: "render",
      value: function render() {
        return React__default.createElement(WrappedComponent, _extends$1({}, this.props, {
          isLandscape: this.state.isLandscape,
          isPortrait: this.state.isPortrait
        }));
      }
    }]);
    return _class;
  }(React__default.Component);
}
function useMobileOrientation() {
  var _useState = React.useState(function() {
    var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
    return {
      isPortrait: orientation === 0,
      isLandscape: orientation === 90,
      orientation: orientation === 0 ? "portrait" : "landscape"
    };
  }), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
  var handleOrientationChange = React.useCallback(function() {
    var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
    var next = {
      isPortrait: orientation === 0,
      isLandscape: orientation === 90,
      orientation: orientation === 0 ? "portrait" : "landscape"
    };
    state.orientation !== next.orientation && setState(next);
  }, [state.orientation]);
  React.useEffect(function() {
    if ((typeof window === "undefined" ? "undefined" : _typeof$3(window)) !== void 0 && isMobile) {
      handleOrientationChange();
      window.addEventListener("load", handleOrientationChange, false);
      window.addEventListener("resize", handleOrientationChange, false);
    }
    return function() {
      window.removeEventListener("resize", handleOrientationChange, false);
      window.removeEventListener("load", handleOrientationChange, false);
    };
  }, [handleOrientationChange]);
  return state;
}
function useDeviceData(userAgent) {
  var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
  return parseUserAgent(hookUserAgent);
}
function useDeviceSelectors(userAgent) {
  var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
  var deviceData = useDeviceData(hookUserAgent);
  var selectors = buildSelectorsObject(deviceData);
  return [selectors, deviceData];
}
lib.AndroidView = AndroidView;
lib.BrowserTypes = BrowserTypes;
lib.BrowserView = BrowserView;
lib.ConsoleView = ConsoleView;
lib.CustomView = CustomView;
lib.IEView = IEView;
lib.IOSView = IOSView;
lib.MobileOnlyView = MobileOnlyView;
lib.MobileView = MobileView;
lib.OsTypes = OsTypes;
lib.SmartTVView = SmartTVView;
lib.TabletView = TabletView;
lib.WearableView = WearableView;
lib.WinPhoneView = WinPhoneView;
lib.browserName = browserName;
lib.browserVersion = browserVersion;
lib.deviceDetect = deviceDetect;
lib.deviceType = deviceType;
lib.engineName = engineName;
lib.engineVersion = engineVersion;
lib.fullBrowserVersion = fullBrowserVersion;
lib.getSelectorsByUserAgent = getSelectorsByUserAgent;
lib.getUA = getUA;
lib.isAndroid = isAndroid;
lib.isBrowser = isBrowser;
lib.isChrome = isChrome;
lib.isChromium = isChromium;
lib.isConsole = isConsole;
lib.isDesktop = isDesktop;
lib.isEdge = isEdge;
lib.isEdgeChromium = isEdgeChromium;
lib.isElectron = isElectron;
lib.isEmbedded = isEmbedded;
lib.isFirefox = isFirefox;
lib.isIE = isIE;
lib.isIOS = isIOS;
lib.isIOS13 = isIOS13;
lib.isIPad13 = isIPad13;
lib.isIPhone13 = isIPhone13;
lib.isIPod13 = isIPod13;
lib.isLegacyEdge = isLegacyEdge;
lib.isMIUI = isMIUI;
lib.isMacOs = isMacOs;
var isMobile_1 = lib.isMobile = isMobile;
lib.isMobileOnly = isMobileOnly;
lib.isMobileSafari = isMobileSafari;
lib.isOpera = isOpera;
lib.isSafari = isSafari;
lib.isSamsungBrowser = isSamsungBrowser;
lib.isSmartTV = isSmartTV;
lib.isTablet = isTablet;
lib.isWearable = isWearable;
lib.isWinPhone = isWinPhone;
lib.isWindows = isWindows;
lib.isYandex = isYandex;
lib.mobileModel = mobileModel;
lib.mobileVendor = mobileVendor;
lib.osName = osName;
lib.osVersion = osVersion;
lib.parseUserAgent = parseUserAgent;
lib.setUserAgent = setUserAgent;
lib.useDeviceData = useDeviceData;
lib.useDeviceSelectors = useDeviceSelectors;
lib.useMobileOrientation = useMobileOrientation;
lib.withOrientationChange = withOrientationChange;
var StatusRenderAssistant = /* @__PURE__ */ ((StatusRenderAssistant2) => {
  StatusRenderAssistant2["INITIAL"] = "INITIAL";
  StatusRenderAssistant2["LOADING"] = "LOADING";
  StatusRenderAssistant2["ERROR"] = "ERROR";
  StatusRenderAssistant2["PROCESSING"] = "PROCESSING";
  StatusRenderAssistant2["SUCCESS"] = "SUCCESS";
  return StatusRenderAssistant2;
})(StatusRenderAssistant || {});
var CallStatusInfo = /* @__PURE__ */ ((CallStatusInfo2) => {
  CallStatusInfo2["ConnectionEstablish"] = "ConnectionEstablish";
  CallStatusInfo2["WaitingCall"] = "WaitingCall";
  CallStatusInfo2["listeningCall"] = "listeningCall";
  CallStatusInfo2["holdCall"] = "holdCall";
  CallStatusInfo2["processingEndCall"] = "processingEndCall";
  CallStatusInfo2["endCall"] = "endCall";
  CallStatusInfo2["callForwarding"] = "callForwarding";
  CallStatusInfo2["inTransit"] = "inTransit";
  return CallStatusInfo2;
})(CallStatusInfo || {});
const initPropsBtn = {
  accept: {
    isDisabled: false,
    isLoading: false
  },
  reject: {
    isDisabled: false,
    isLoading: false
  }
};
var ColorToken = /* @__PURE__ */ ((ColorToken2) => {
  ColorToken2["PRIMARY"] = "primary";
  ColorToken2["SECONDARY"] = "secondary";
  ColorToken2["SUCCESS"] = "success";
  ColorToken2["GRAY"] = "gray";
  ColorToken2["WHITE"] = "white";
  ColorToken2["BLACK"] = "black";
  ColorToken2["YELLOW"] = "yellow";
  ColorToken2["ORANGE"] = "orange";
  ColorToken2["RED"] = "red";
  ColorToken2["GREEN"] = "green";
  ColorToken2["BLUE"] = "blue";
  ColorToken2["INDIGO"] = "indigo";
  ColorToken2["PURPLE"] = "purple";
  ColorToken2["PINK"] = "pink";
  ColorToken2["TEAL"] = "teal";
  ColorToken2["CYAN"] = "Cyan";
  return ColorToken2;
})(ColorToken || {});
var AppEventType = /* @__PURE__ */ ((AppEventType2) => {
  AppEventType2["READY"] = "ready";
  AppEventType2["DISPLAY_CHANGED"] = "display_changed";
  AppEventType2["BUBBLE_HIDDEN"] = "bubble_hidden";
  AppEventType2["BUBBLE_SHOWN"] = "bubble_shown";
  AppEventType2["LOGGED_IN"] = "logged_in";
  AppEventType2["LOGGED_OUT"] = "logged_out";
  AppEventType2["TOKEN_EXPIRED"] = "token_expired";
  AppEventType2["ERROR"] = "error";
  AppEventType2["PERMISSION_DENIED"] = "permission_denied";
  AppEventType2["NETWORK_ERROR"] = "network_error";
  AppEventType2["DISCONNECTED"] = "disconnected";
  AppEventType2["CONNECTED"] = "connected";
  AppEventType2["DISCONNECTED_WEB_SOCKET"] = "disconnected_web_socket";
  AppEventType2["CONNECTED_WEB_SOCKET"] = "connected_web_socket";
  AppEventType2["AUTO_CONNECT"] = "auto_connect";
  AppEventType2["NOT_AUTO_CONNECT"] = "not_auto_connect";
  return AppEventType2;
})(AppEventType || {});
var InteractionEventType = /* @__PURE__ */ ((InteractionEventType2) => {
  InteractionEventType2["NEW_CONVERSATION"] = "new_conversation";
  InteractionEventType2["NEW_MESSAGE"] = "new_message";
  InteractionEventType2["CLOSE_CONVERSATION"] = "close_conversation";
  InteractionEventType2["MESSAGE_RECEIVED"] = "message_received";
  InteractionEventType2["MESSAGE_SENT"] = "message_sent";
  InteractionEventType2["MESSAGE_DELIVERED"] = "message_delivered";
  InteractionEventType2["MESSAGE_READ"] = "message_read";
  InteractionEventType2["CONVERSATION_ENDED"] = "conversation_ended";
  return InteractionEventType2;
})(InteractionEventType || {});
var USER_ACTION = /* @__PURE__ */ ((USER_ACTION2) => {
  USER_ACTION2["HANGUP"] = "hangup";
  USER_ACTION2["HOLD"] = "hold";
  USER_ACTION2["UNHOLD"] = "unhold";
  USER_ACTION2["MUTE"] = "mute";
  USER_ACTION2["UNMUTE"] = "unmute";
  USER_ACTION2["TRANSFER"] = "transfer";
  USER_ACTION2["TRANSFER_ACCEPTED"] = "transfer_accepted";
  USER_ACTION2["TRANSFER_REFUSE"] = "transfer_refuse";
  return USER_ACTION2;
})(USER_ACTION || {});
const ERR_NETWORK = "NETWORK_ERROR";
const CONFIG_URL = "https://crm-dev-v2.metechvn.com";
const PAGE_SIZE = {
  SM: 20
};
const DATE_FORMAT = {
  HH_MM_SS: "HH:mm:ss",
  HH_MM_DD_MM_YY_HH_MM_SS: "DD/MM/YY HH:mm:ss"
};
const relativeTimeText = {
  s: "vài giây",
  m: "1 phút ",
  h: "1 giờ ",
  d: "1 ngày",
  M: "1 tháng",
  y: "1 năm"
};
const fb_message = "FB_MESSAGE";
const zl_message = "ZL_MESSAGE";
const phoneContact = "VOICE";
const channelCall = "CALL";
const internetCall = "LIVE_CONNECT";
const EVENT_ABLY_NAME = {
  INBOUND_CALL: "INIT",
  OFFER_CALL: "OFFER",
  ANSWER_CALL: "ANSWER",
  REJECT_CALL: "REJECT",
  END_CALL: "HANGUP",
  CLOSE: "CLOSE_CONVERSATION",
  MESSAGE_TRANSFERED: "MESSAGE_TRANSFERED",
  ASSIGN_CONVERSATION: "ASSIGN_CONVERSATION",
  NEW_CONVERSATION: "NEW_CONVERSATION",
  TRANSFER_CONVERSATION: "TRANSFER_CONVERSATION",
  START_CONVERSATION: "START_CONVERSATION",
  TRANSFER_FAILED: "TRANSFER_FAIL",
  TRANSFER_RINGING: "TRANSFER_RINGING",
  TRANSFER_ANSWER: "TRANSFER_ANSWER",
  TRANSFER_ACCEPTED: "TRANSFER_ACCEPTED"
};
const MessengerForm = {
  AGENT: "AGENT",
  CUSTOMER: "CUSTOMER",
  BOT: "BOT"
};
const CONVERSATION_STATE = {
  CLOSE: "CLOSE"
};
const WRAP_UP_TIME = 30;
const PROCESSING_END_CALL_TIME = 60;
const ListCalls = [channelCall, internetCall];
const CLOSE_MODE = {
  MANUAL: "MANUAL"
};
const DIRECTION = {
  OUTBOUND: "OUTBOUND",
  INBOUND: "INBOUND",
  INTERNAL: "INTERNAL",
  ATTENDED_TRANSFER: "ATTENDED_TRANSFER"
};
const Map_Msg_Form = {
  OUTBOUND: {
    caller: MessengerForm.AGENT,
    callee: MessengerForm.CUSTOMER
  },
  INBOUND: {
    caller: MessengerForm.CUSTOMER,
    callee: MessengerForm.AGENT
  }
};
const EVT_EMITTER = {
  CLEAR_ALL_FLITTER: "CLEAR_ALL_FLITTER",
  LOGIN_SDK: "LOGIN_SDK",
  LOGIN_CRM: "LOGIN_CRM",
  LOGOUT_CRM: "LOGOUT_CRM",
  LOGOUT_SDK: "LOGOUT_SDK",
  BUBBLE: "BUBBLE",
  CALL_INTERNAL: "CALL_INTERNAL",
  UN_REGISTER: "UN_REGISTER"
};
const key_redux = {
  auth: "auth"
};
const Event_SDK = {
  AppEvent: "AppEvent",
  CallEvent: "CallEvent",
  AgentStatusEvent: "AgentStatusEvent",
  InteractionEvent: "InteractionEvent",
  GuestEvent: "GuestEvent"
};
const Map_event_name = {
  CLOSE_CONVERSATION: InteractionEventType.CLOSE_CONVERSATION,
  READ_CONVERSATION: InteractionEventType.MESSAGE_READ,
  NEW_CONVERSATION: InteractionEventType.NEW_CONVERSATION,
  NEW_MESSAGE: InteractionEventType.NEW_MESSAGE,
  MESSAGE_RECEIVED: InteractionEventType.MESSAGE_RECEIVED,
  MESSAGE_SENT: InteractionEventType.MESSAGE_SENT,
  MESSAGE_DELIVERED: InteractionEventType.MESSAGE_DELIVERED,
  MESSAGE_READ: InteractionEventType.MESSAGE_READ,
  CONVERSATION_ENDED: InteractionEventType.CONVERSATION_ENDED
};
const conversationStateClient = {
  open: "OPEN",
  close: "CLOSE",
  interactive: "INTERACTIVE"
};
const Agents_Status = [
  {
    changeTime: "0",
    cloudAgentId: 2,
    cloudAgentName: "tiendoan",
    cloudTenantId: 4,
    reasonCode: "READY",
    reasonCodeId: 1001,
    reasonName: "Ready",
    statusName: "READY"
  },
  {
    changeTime: "0",
    cloudAgentId: 2,
    cloudAgentName: "tiendoan",
    cloudTenantId: 4,
    reasonCode: "BẬN",
    reasonCodeId: 1,
    reasonName: "Bận",
    statusName: "NOT_READY"
  },
  {
    changeTime: "0",
    cloudAgentId: 2,
    cloudAgentName: "tiendoan",
    cloudTenantId: 4,
    reasonCode: "VẮNG_MẶT",
    reasonCodeId: 2,
    reasonName: "Vắng mặt",
    statusName: "NOT_READY"
  },
  {
    changeTime: "0",
    cloudAgentId: 2,
    cloudAgentName: "tiendoan",
    cloudTenantId: 4,
    reasonCode: "NOT_READY",
    reasonCodeId: 1e3,
    reasonName: "Not Ready",
    statusName: "NOT_READY"
  }
];
/* @__PURE__ */ new Map([
  ["READY", ColorToken.GREEN],
  ["NOT_READY", ColorToken.RED],
  [ERR_NETWORK, ColorToken.RED],
  ["SOCKET_DISCONNECTED", ColorToken.RED]
]);
({
  [StatusRenderAssistant.PROCESSING]: "creating"
});
const send_message = "send_message";
const CALL_TYPE = {
  VIDEO: "VIDEO",
  VOICE: "VOICE"
};
var define_process_env_default$c = {};
function formatProdErrorMessage$1(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString$1 = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString$1()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString$1()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString$1()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject$2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate$1(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate$1(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf$1(val) {
  let typeOfVal = typeof val;
  if (define_process_env_default$c.NODE_ENV !== "production") {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore$1(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf$1(reducer)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf$1(enhancer)}'`);
    }
    return enhancer(createStore$1)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(4) : `Expected the listener to be a function. Instead, received: '${kindOf$1(listener)}'`);
    }
    if (isDispatching) {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$2(action)) {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf$1(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf$1(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf$1(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(11) : `Expected the observer to be an object. Instead, received: '${kindOf$1(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store2;
}
function warning$1(message2) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message2);
  }
  try {
    throw new Error(message2);
  } catch (e2) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject$2(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf$1(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach((key) => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE)
    return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState2 = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i2 = 0; i2 < reducerKeys.length; i2++) {
    const key = reducerKeys[i2];
    if (define_process_env_default$c.NODE_ENV !== "production") {
      if (typeof reducers[key] === "undefined") {
        warning$1(`No reducer provided for key "${key}"`);
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (define_process_env_default$c.NODE_ENV !== "production") {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (define_process_env_default$c.NODE_ENV !== "production") {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning$1(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i2 = 0; i2 < finalReducerKeys.length; i2++) {
      const key = finalReducerKeys[i2];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState) => {
    const store2 = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(define_process_env_default$c.NODE_ENV === "production" ? formatProdErrorMessage$1(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store2.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store2.dispatch);
    return {
      ...store2,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject$2(action) && "type" in action && typeof action.type === "string";
}
var define_process_env_default$b = {};
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = define_process_env_default$b.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (define_process_env_default$b.NODE_ENV !== "production") {
    const e2 = errors[error];
    const msg = typeof e2 === "function" ? e2.apply(null, args) : e2;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf$1 = Object.getPrototypeOf;
function isDraft(value2) {
  return !!value2 && !!value2[DRAFT_STATE];
}
function isDraftable(value2) {
  var _a;
  if (!value2)
    return false;
  return isPlainObject$1(value2) || Array.isArray(value2) || !!value2[DRAFTABLE] || !!((_a = value2.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value2) || isSet(value2);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject$1(value2) {
  if (!value2 || typeof value2 !== "object")
    return false;
  const proto = getPrototypeOf$1(value2);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value2) {
  const t2 = getArchtype(thing);
  if (t2 === 2)
    thing.set(propOrOldValue, value2);
  else if (t2 === 3) {
    thing.add(value2);
  } else
    thing[propOrOldValue] = value2;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain2 = isPlainObject$1(base);
  if (strict === true || strict === "class_only" && !isPlain2) {
    const descriptors2 = Object.getOwnPropertyDescriptors(base);
    delete descriptors2[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors2);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const desc = descriptors2[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors2[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf$1(base), descriptors2);
  } else {
    const proto = getPrototypeOf$1(base);
    if (proto !== null && isPlain2) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value2]) => freeze(value2, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value2, path) {
  if (isFrozen(value2))
    return value2;
  const state = value2[DRAFT_STATE];
  if (!state) {
    each(
      value2,
      (key, childValue) => finalizeProperty(rootScope, state, value2, key, childValue, path)
    );
    return value2;
  }
  if (state.scope_ !== rootScope)
    return value2;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (define_process_env_default$b.NODE_ENV !== "production" && childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value2, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value2, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray2 = Array.isArray(base);
  const state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray2) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value2 = source[prop];
    if (state.finalized_ || !isDraftable(value2)) {
      return value2;
    }
    if (value2 === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value2, state);
    }
    return value2;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value2) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value2);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value2) {
        state.copy_[prop] = value2;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value2, current2) && (value2 !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value2 && // special case: handle new props with value 'undefined'
    (value2 !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value2) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value2;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf$1(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (define_process_env_default$b.NODE_ENV !== "production" && isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value2) {
  if (define_process_env_default$b.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value2, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf$1(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf$1(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p2 = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
          patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p2, ip) => {
        patches = p2;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value2) {
    this.autoFreeze_ = value2;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value2) {
    this.useStrictShallowCopy_ = value2;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i2 > -1) {
      patches = patches.slice(i2 + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value2, parent) {
  const draft = isMap(value2) ? getPlugin("MapSet").proxyMap_(value2, parent) : isSet(value2) ? getPlugin("MapSet").proxySet_(value2, parent) : createProxyProxy(value2, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value2) {
  if (!isDraft(value2))
    die(10, value2);
  return currentImpl(value2);
}
function currentImpl(value2) {
  if (!isDraftable(value2) || isFrozen(value2))
    return value2;
  const state = value2[DRAFT_STATE];
  let copy2;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy2 = shallowCopy(value2, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy2 = shallowCopy(value2, true);
  }
  each(copy2, (key, childValue) => {
    set(copy2, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy2;
}
var immer = new Immer2();
var produce = immer.produce;
immer.produceWithPatches.bind(
  immer
);
immer.setAutoFreeze.bind(immer);
immer.setUseStrictShallowCopy.bind(immer);
immer.applyPatches.bind(immer);
immer.createDraft.bind(immer);
immer.finishDraft.bind(immer);
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;
var define_process_env_default$a = {};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var hasMatchFunction = (v) => {
  return v && typeof v.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(0) : "prepareAction did not return an object");
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options = {}) {
  if (define_process_env_default$a.NODE_ENV === "production") {
    return () => (next) => (action) => next(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options;
  return () => (next) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next(action);
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn) {
      const started = Date.now();
      try {
        return fn();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map, key, compute) {
  if (map.has(key)) return map.get(key);
  return map.set(key, compute(key)).get(key);
}
function isImmutableDefault(value2) {
  return typeof value2 !== "object" || value2 == null || Object.isFrozen(value2);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (let key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (let key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key in keysToDetect) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware(options = {}) {
  if (define_process_env_default$a.NODE_ENV === "production") {
    return () => (next) => (action) => next(action);
  } else {
    let stringify2 = function(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
    }, getSerialize2 = function(serializer, decycler) {
      let stack = [], keys = [];
      if (!decycler) decycler = function(_, value2) {
        if (stack[0] === value2) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value2)).join(".") + "]";
      };
      return function(key, value2) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value2)) value2 = decycler.call(this, key, value2);
        } else stack.push(value2);
        return serializer == null ? value2 : serializer.call(this, key, value2);
      };
    };
    let {
      isImmutable = isImmutableDefault,
      ignoredPaths,
      warnAfter = 32
    } = options;
    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return ({
      getState
    }) => {
      let state = getState();
      let tracker = track(state);
      let result;
      return (next) => (action) => {
        const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        const dispatchedAction = next(action);
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  }
}
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject$2(val);
}
function findNonSerializableValue(value2, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache2) {
  let foundNestedSerializable;
  if (!isSerializable(value2)) {
    return {
      keyPath: path || "<root>",
      value: value2
    };
  }
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  if (cache2 == null ? void 0 : cache2.has(value2)) return false;
  const entries = getEntries != null ? getEntries(value2) : Object.entries(value2);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache2);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache2 && isNestedFrozen(value2)) cache2.add(value2);
  return false;
}
function isNestedFrozen(value2) {
  if (!Object.isFrozen(value2)) return false;
  for (const nestedValue of Object.values(value2)) {
    if (typeof nestedValue !== "object" || nestedValue === null) continue;
    if (!isNestedFrozen(nestedValue)) return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options = {}) {
  if (define_process_env_default$a.NODE_ENV === "production") {
    return () => (next) => (action) => next(action);
  } else {
    const {
      isSerializable = isPlain,
      getEntries,
      ignoredActions = [],
      ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths = [],
      warnAfter = 32,
      ignoreState = false,
      ignoreActions = false,
      disableCache = false
    } = options;
    const cache2 = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (storeAPI) => (next) => (action) => {
      if (!isAction(action)) {
        return next(action);
      }
      const result = next(action);
      const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
        measureUtils.measureTime(() => {
          const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache2);
          if (foundActionNonSerializableValue) {
            const {
              keyPath,
              value: value2
            } = foundActionNonSerializableValue;
            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value2, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
          }
        });
      }
      if (!ignoreState) {
        measureUtils.measureTime(() => {
          const state = storeAPI.getState();
          const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache2);
          if (foundStateNonSerializableValue) {
            const {
              keyPath,
              value: value2
            } = foundStateNonSerializableValue;
            console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value2, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        });
        measureUtils.warnIfExceeded();
      }
      return result;
    };
  }
}
function isBoolean$1(x) {
  return typeof x === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk: thunk$1 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options ?? {};
  let middlewareArray = new Tuple();
  if (thunk$1) {
    if (isBoolean$1(thunk$1)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
    }
  }
  if (define_process_env_default$a.NODE_ENV !== "production") {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean$1(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean$1(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean$1(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var createQueueWithTimer = (timeout2) => {
  return (notify) => {
    setTimeout(notify, timeout2);
  };
};
var autoBatchEnhancer = (options = {
  type: "raf"
}) => (next) => (...args) => {
  const store2 = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l2) => l2());
    }
  };
  return Object.assign({}, store2, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store2.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      var _a;
      try {
        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store2.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  }
  if (define_process_env_default$a.NODE_ENV !== "production" && middleware && typeof middleware !== "function") {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
    if (define_process_env_default$a.NODE_ENV !== "production" && !Array.isArray(finalMiddleware)) {
      throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (define_process_env_default$a.NODE_ENV !== "production" && finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: define_process_env_default$a.NODE_ENV !== "production",
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (define_process_env_default$a.NODE_ENV !== "production" && enhancers && typeof enhancers !== "function") {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
  }
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (define_process_env_default$a.NODE_ENV !== "production" && !Array.isArray(storeEnhancers)) {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
  }
  if (define_process_env_default$a.NODE_ENV !== "production" && storeEnhancers.some((item) => typeof item !== "function")) {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
  }
  if (define_process_env_default$a.NODE_ENV !== "production" && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore$1(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        if (actionMatchers.length > 0) {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState2, mapOrBuilderCallback) {
  if (define_process_env_default$a.NODE_ENV !== "production") {
    if (typeof mapOrBuilderCallback === "object") {
      throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    }
  }
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = () => freezeDraftable(initialState2());
  } else {
    const frozenInitialState = freezeDraftable(initialState2);
    getInitialState = () => frozenInitialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer2
    }) => reducer2)];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers2) {
  return (action) => {
    return matchers2.some((matcher) => matches(matcher, action));
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var FulfillWithMeta = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var miniSerializeError = (value2) => {
  if (typeof value2 === "object" && value2 !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value2[property] === "string") {
        simpleError[property] = value2[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value2)
  };
};
var externalAbortMessage = "External signal was aborted";
var createAsyncThunk = /* @__PURE__ */ (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
      payload,
      error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...meta || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: (error == null ? void 0 : error.name) === "AbortError",
        condition: (error == null ? void 0 : error.name) === "ConditionError"
      }
    }));
    function actionCreator(arg, {
      signal
    } = {}) {
      return (dispatch, getState, extra) => {
        const requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        if (signal) {
          if (signal.aborted) {
            abort(externalAbortMessage);
          } else {
            signal.addEventListener("abort", () => abort(externalAbortMessage), {
              once: true
            });
          }
        }
        const promise = async function() {
          var _a, _b;
          let finalAction;
          try {
            let conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {
              getState,
              extra
            });
            if (isThenable$1(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value2, meta) => {
                return new RejectWithValue(value2, meta);
              },
              fulfillWithValue: (value2, meta) => {
                return new FulfillWithMeta(value2, meta);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err) {
            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        }();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable$1(value2) {
  return value2 !== null && typeof value2 === "object" && typeof value2.then === "function";
}
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function getType(slice, actionKey) {
  return `${slice}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  var _a;
  const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
  return function createSlice2(options) {
    const {
      name: name2,
      reducerPath = name2
    } = options;
    if (!name2) {
      throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
    }
    if (typeof process !== "undefined" && define_process_env_default$a.NODE_ENV === "development") {
      if (options.initialState === void 0) {
        console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
      }
    }
    const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name22, actionCreator) {
        context.actionCreators[name22] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name22, reducer2) {
        context.sliceCaseReducersByName[name22] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name2, reducerName),
        createNotation: typeof options.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (define_process_env_default$a.NODE_ENV !== "production") {
        if (typeof options.extraReducers === "object") {
          throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m2 of actionMatchers) {
          builder.addMatcher(m2.matcher, m2.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          } else if (define_process_env_default$a.NODE_ENV !== "production") {
            throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map = {};
          for (const [name22, selector] of Object.entries(options.selectors ?? {})) {
            map[name22] = wrapSelector(selector, selectState, getInitialState, injected);
          }
          return map;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice = {
      name: name2,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config);
        return {
          ...slice,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (define_process_env_default$a.NODE_ENV !== "production") {
        throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(define_process_env_default$a.NODE_ENV === "production" ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop$4,
    pending: pending || noop$4,
    rejected: rejected || noop$4,
    settled: settled || noop$4
  });
}
function noop$4() {
}
function formatProdErrorMessage(code) {
  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var withSelector = { exports: {} };
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React2 = reactExports;
  function is2(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = React2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value2 = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value2;
      },
      [value2]
    );
    useDebugValue(value2);
    return value2;
  };
  return useSyncExternalStoreWithSelector_production;
}
var useSyncExternalStoreWithSelector_development = {};
var hasRequiredUseSyncExternalStoreWithSelector_development;
function requireUseSyncExternalStoreWithSelector_development() {
  if (hasRequiredUseSyncExternalStoreWithSelector_development) return useSyncExternalStoreWithSelector_development;
  hasRequiredUseSyncExternalStoreWithSelector_development = 1;
  var define_process_env_default2 = {};
  /**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "production" !== define_process_env_default2.NODE_ENV && function() {
    function is2(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React2 = reactExports, objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = React2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
    useSyncExternalStoreWithSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value2 = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
      useEffect(
        function() {
          inst.hasValue = true;
          inst.value = value2;
        },
        [value2]
      );
      useDebugValue(value2);
      return value2;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
  return useSyncExternalStoreWithSelector_development;
}
var define_process_env_default$9 = {};
if (define_process_env_default$9.NODE_ENV === "production") {
  withSelector.exports = requireUseSyncExternalStoreWithSelector_production();
} else {
  withSelector.exports = requireUseSyncExternalStoreWithSelector_development();
}
var withSelectorExports = withSelector.exports;
var define_process_env_default$8 = {};
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative$1 = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!reactExports.createContext) return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(
      null
    );
    if (define_process_env_default$8.NODE_ENV !== "production") {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
function Provider(providerProps) {
  const { children, context, serverState, store: store2 } = providerProps;
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store2);
    const baseContextValue = {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    if (define_process_env_default$8.NODE_ENV === "production") {
      return baseContextValue;
    } else {
      const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
      return /* @__PURE__ */ Object.assign(baseContextValue, {
        stabilityCheck,
        identityFunctionCheck
      });
    }
  }, [store2, serverState]);
  const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context);
    if (define_process_env_default$8.NODE_ENV !== "production" && !contextValue) {
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    }
    return contextValue;
  };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store: store2 } = useReduxContext2();
    return store2;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store2 = useStore2();
    return store2.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
var refEquality = (a2, b) => a2 === b;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    if (define_process_env_default$8.NODE_ENV !== "production") {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }
      if (typeof selector !== "function") {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }
      if (typeof equalityFn !== "function") {
        throw new Error(
          `You must pass a function as an equality function to useSelector`
        );
      }
    }
    const reduxContext = useReduxContext2();
    const { store: store2, subscription, getServerState } = reduxContext;
    const firstRun = reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          if (define_process_env_default$8.NODE_ENV !== "production") {
            const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
            const { identityFunctionCheck, stabilityCheck } = reduxContext;
            const {
              identityFunctionCheck: finalIdentityFunctionCheck,
              stabilityCheck: finalStabilityCheck
            } = {
              stabilityCheck,
              identityFunctionCheck,
              ...devModeChecks
            };
            if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
              const toCompare = selector(state);
              if (!equalityFn(selected, toCompare)) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                  {
                    state,
                    selected,
                    selected2: toCompare,
                    stack
                  }
                );
              }
            }
            if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
              if (selected === state) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                  { stack }
                );
              }
            }
            if (firstRun.current) firstRun.current = false;
          }
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(
      subscription.addNestedSub,
      store2.getState,
      getServerState || store2.getState,
      wrappedSelector,
      equalityFn
    );
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = /* @__PURE__ */ createSelectorHook();
var KEY_PREFIX = "persist:";
var FLUSH = "persist/FLUSH";
var REHYDRATE = "persist/REHYDRATE";
var PAUSE = "persist/PAUSE";
var PERSIST = "persist/PERSIST";
var PURGE = "persist/PURGE";
var REGISTER = "persist/REGISTER";
var DEFAULT_VERSION = -1;
var define_process_env_default$7 = {};
function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(source, true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
  var debug = _ref.debug;
  var newState = _objectSpread$2({}, reducedState);
  if (inboundState && _typeof$2(inboundState) === "object") {
    Object.keys(inboundState).forEach(function(key) {
      if (key === "_persist") return;
      if (originalState[key] !== reducedState[key]) {
        if (define_process_env_default$7.NODE_ENV !== "production" && debug) console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
        return;
      }
      newState[key] = inboundState[key];
    });
  }
  if (define_process_env_default$7.NODE_ENV !== "production" && debug && inboundState && _typeof$2(inboundState) === "object") console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'"));
  return newState;
}
var define_process_env_default$6 = {};
function createPersistoid(config) {
  var blacklist = config.blacklist || null;
  var whitelist = config.whitelist || null;
  var transforms = config.transforms || [];
  var throttle2 = config.throttle || 0;
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  var storage = config.storage;
  var serialize;
  if (config.serialize === false) {
    serialize = function serialize2(x) {
      return x;
    };
  } else if (typeof config.serialize === "function") {
    serialize = config.serialize;
  } else {
    serialize = defaultSerialize;
  }
  var writeFailHandler = config.writeFailHandler || null;
  var lastState = {};
  var stagedState = {};
  var keysToProcess = [];
  var timeIterator = null;
  var writePromise = null;
  var update = function update2(state) {
    Object.keys(state).forEach(function(key) {
      if (!passWhitelistBlacklist(key)) return;
      if (lastState[key] === state[key]) return;
      if (keysToProcess.indexOf(key) !== -1) return;
      keysToProcess.push(key);
    });
    Object.keys(lastState).forEach(function(key) {
      if (state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0) {
        keysToProcess.push(key);
      }
    });
    if (timeIterator === null) {
      timeIterator = setInterval(processNextKey, throttle2);
    }
    lastState = state;
  };
  function processNextKey() {
    if (keysToProcess.length === 0) {
      if (timeIterator) clearInterval(timeIterator);
      timeIterator = null;
      return;
    }
    var key = keysToProcess.shift();
    var endState = transforms.reduce(function(subState, transformer) {
      return transformer.in(subState, key, lastState);
    }, lastState[key]);
    if (endState !== void 0) {
      try {
        stagedState[key] = serialize(endState);
      } catch (err) {
        console.error("redux-persist/createPersistoid: error serializing state", err);
      }
    } else {
      delete stagedState[key];
    }
    if (keysToProcess.length === 0) {
      writeStagedState();
    }
  }
  function writeStagedState() {
    Object.keys(stagedState).forEach(function(key) {
      if (lastState[key] === void 0) {
        delete stagedState[key];
      }
    });
    writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
  }
  function passWhitelistBlacklist(key) {
    if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist") return false;
    if (blacklist && blacklist.indexOf(key) !== -1) return false;
    return true;
  }
  function onWriteFail(err) {
    if (writeFailHandler) writeFailHandler(err);
    if (err && define_process_env_default$6.NODE_ENV !== "production") {
      console.error("Error storing data", err);
    }
  }
  var flush = function flush2() {
    while (keysToProcess.length !== 0) {
      processNextKey();
    }
    return writePromise || Promise.resolve();
  };
  return {
    update,
    flush
  };
}
function defaultSerialize(data) {
  return JSON.stringify(data);
}
var define_process_env_default$5 = {};
function getStoredState(config) {
  var transforms = config.transforms || [];
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  var storage = config.storage;
  var debug = config.debug;
  var deserialize;
  if (config.deserialize === false) {
    deserialize = function deserialize2(x) {
      return x;
    };
  } else if (typeof config.deserialize === "function") {
    deserialize = config.deserialize;
  } else {
    deserialize = defaultDeserialize;
  }
  return storage.getItem(storageKey).then(function(serialized) {
    if (!serialized) return void 0;
    else {
      try {
        var state = {};
        var rawState = deserialize(serialized);
        Object.keys(rawState).forEach(function(key) {
          state[key] = transforms.reduceRight(function(subState, transformer) {
            return transformer.out(subState, key, rawState);
          }, deserialize(rawState[key]));
        });
        return state;
      } catch (err) {
        if (define_process_env_default$5.NODE_ENV !== "production" && debug) console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err);
        throw err;
      }
    }
  });
}
function defaultDeserialize(serial) {
  return JSON.parse(serial);
}
var define_process_env_default$4 = {};
function purgeStoredState(config) {
  var storage = config.storage;
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  return storage.removeItem(storageKey, warnIfRemoveError);
}
function warnIfRemoveError(err) {
  if (err && define_process_env_default$4.NODE_ENV !== "production") {
    console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
  }
}
var define_process_env_default$3 = {};
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(source, true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var DEFAULT_TIMEOUT = 5e3;
function persistReducer(config, baseReducer) {
  if (define_process_env_default$3.NODE_ENV !== "production") {
    if (!config) throw new Error("config is required for persistReducer");
    if (!config.key) throw new Error("key is required in persistor config");
    if (!config.storage) throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
  }
  var version = config.version !== void 0 ? config.version : DEFAULT_VERSION;
  config.debug || false;
  var stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel1 : config.stateReconciler;
  var getStoredState$1 = config.getStoredState || getStoredState;
  var timeout2 = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT;
  var _persistoid = null;
  var _purge = false;
  var _paused = true;
  var conditionalUpdate = function conditionalUpdate2(state) {
    state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
    return state;
  };
  return function(state, action) {
    var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, ["_persist"]);
    var restState = rest;
    if (action.type === PERSIST) {
      var _sealed = false;
      var _rehydrate = function _rehydrate2(payload, err) {
        if (define_process_env_default$3.NODE_ENV !== "production" && _sealed) console.error('redux-persist: rehydrate for "'.concat(config.key, '" called after timeout.'), payload, err);
        if (!_sealed) {
          action.rehydrate(config.key, payload, err);
          _sealed = true;
        }
      };
      timeout2 && setTimeout(function() {
        !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
      }, timeout2);
      _paused = false;
      if (!_persistoid) _persistoid = createPersistoid(config);
      if (_persist) {
        return _objectSpread$1({}, baseReducer(restState, action), {
          _persist
        });
      }
      if (typeof action.rehydrate !== "function" || typeof action.register !== "function") throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
      action.register(config.key);
      getStoredState$1(config).then(function(restoredState) {
        var migrate = config.migrate || function(s2, v) {
          return Promise.resolve(s2);
        };
        migrate(restoredState, version).then(function(migratedState) {
          _rehydrate(migratedState);
        }, function(migrateErr) {
          if (define_process_env_default$3.NODE_ENV !== "production" && migrateErr) console.error("redux-persist: migration error", migrateErr);
          _rehydrate(void 0, migrateErr);
        });
      }, function(err) {
        _rehydrate(void 0, err);
      });
      return _objectSpread$1({}, baseReducer(restState, action), {
        _persist: {
          version,
          rehydrated: false
        }
      });
    } else if (action.type === PURGE) {
      _purge = true;
      action.result(purgeStoredState(config));
      return _objectSpread$1({}, baseReducer(restState, action), {
        _persist
      });
    } else if (action.type === FLUSH) {
      action.result(_persistoid && _persistoid.flush());
      return _objectSpread$1({}, baseReducer(restState, action), {
        _persist
      });
    } else if (action.type === PAUSE) {
      _paused = true;
    } else if (action.type === REHYDRATE) {
      if (_purge) return _objectSpread$1({}, restState, {
        _persist: _objectSpread$1({}, _persist, {
          rehydrated: true
        })
        // @NOTE if key does not match, will continue to default else below
      });
      if (action.key === config.key) {
        var reducedState = baseReducer(restState, action);
        var inboundState = action.payload;
        var reconciledRest = stateReconciler !== false && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
        var _newState = _objectSpread$1({}, reconciledRest, {
          _persist: _objectSpread$1({}, _persist, {
            rehydrated: true
          })
        });
        return conditionalUpdate(_newState);
      }
    }
    if (!_persist) return baseReducer(state, action);
    var newState = baseReducer(restState, action);
    if (newState === restState) return state;
    return conditionalUpdate(_objectSpread$1({}, newState, {
      _persist
    }));
  };
}
var define_process_env_default$2 = {};
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(source, true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var initialState$7 = {
  registry: [],
  bootstrapped: false
};
var persistorReducer = function persistorReducer2() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState$7;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  switch (action.type) {
    case REGISTER:
      return _objectSpread({}, state, {
        registry: [].concat(_toConsumableArray(state.registry), [action.key])
      });
    case REHYDRATE:
      var firstIndex = state.registry.indexOf(action.key);
      var registry = _toConsumableArray(state.registry);
      registry.splice(firstIndex, 1);
      return _objectSpread({}, state, {
        registry,
        bootstrapped: registry.length === 0
      });
    default:
      return state;
  }
};
function persistStore(store2, options, cb) {
  if (define_process_env_default$2.NODE_ENV !== "production") {
    var optionsToTest = {};
    var bannedKeys = ["blacklist", "whitelist", "transforms", "storage", "keyPrefix", "migrate"];
    bannedKeys.forEach(function(k) {
      if (!!optionsToTest[k]) console.error('redux-persist: invalid option passed to persistStore: "'.concat(k, '". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.'));
    });
  }
  var _pStore = createStore$1(persistorReducer, initialState$7, void 0);
  var register = function register2(key) {
    _pStore.dispatch({
      type: REGISTER,
      key
    });
  };
  var rehydrate = function rehydrate2(key, payload, err) {
    var rehydrateAction = {
      type: REHYDRATE,
      payload,
      err,
      key
      // dispatch to `store` to rehydrate and `persistor` to track result
    };
    store2.dispatch(rehydrateAction);
    _pStore.dispatch(rehydrateAction);
  };
  var persistor = _objectSpread({}, _pStore, {
    purge: function purge() {
      var results = [];
      store2.dispatch({
        type: PURGE,
        result: function result(purgeResult) {
          results.push(purgeResult);
        }
      });
      return Promise.all(results);
    },
    flush: function flush() {
      var results = [];
      store2.dispatch({
        type: FLUSH,
        result: function result(flushResult) {
          results.push(flushResult);
        }
      });
      return Promise.all(results);
    },
    pause: function pause() {
      store2.dispatch({
        type: PAUSE
      });
    },
    persist: function persist() {
      store2.dispatch({
        type: PERSIST,
        register,
        rehydrate
      });
    }
  });
  {
    persistor.persist();
  }
  return persistor;
}
var createWebStorage$1 = {};
var getStorage$2 = {};
var define_process_env_default$1 = {};
getStorage$2.__esModule = true;
getStorage$2.default = getStorage$1;
function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function noop$3() {
}
var noopStorage = {
  getItem: noop$3,
  setItem: noop$3,
  removeItem: noop$3
};
function hasStorage(storageType) {
  if ((typeof self === "undefined" ? "undefined" : _typeof$1(self)) !== "object" || !(storageType in self)) {
    return false;
  }
  try {
    var storage = self[storageType];
    var testKey = "redux-persist ".concat(storageType, " test");
    storage.setItem(testKey, "test");
    storage.getItem(testKey);
    storage.removeItem(testKey);
  } catch (e2) {
    if (define_process_env_default$1.NODE_ENV !== "production") console.warn("redux-persist ".concat(storageType, " test failed, persistence will be disabled."));
    return false;
  }
  return true;
}
function getStorage$1(type) {
  var storageType = "".concat(type, "Storage");
  if (hasStorage(storageType)) return self[storageType];
  else {
    if (define_process_env_default$1.NODE_ENV !== "production") {
      console.error("redux-persist failed to create sync storage. falling back to noop storage.");
    }
    return noopStorage;
  }
}
createWebStorage$1.__esModule = true;
createWebStorage$1.default = createWebStorage;
var _getStorage = _interopRequireDefault$1(getStorage$2);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function createWebStorage(type) {
  var storage = (0, _getStorage.default)(type);
  return {
    getItem: function getItem(key) {
      return new Promise(function(resolve, reject) {
        resolve(storage.getItem(key));
      });
    },
    setItem: function setItem(key, item) {
      return new Promise(function(resolve, reject) {
        resolve(storage.setItem(key, item));
      });
    },
    removeItem: function removeItem(key) {
      return new Promise(function(resolve, reject) {
        resolve(storage.removeItem(key));
      });
    }
  };
}
var default_1 = void 0;
var _createWebStorage = _interopRequireDefault(createWebStorage$1);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var _default = (0, _createWebStorage.default)("local");
default_1 = _default;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
let _nodeId;
let _clockseq;
let _lastMSecs = 0;
let _lastNSecs = 0;
function v1(options, buf, offset) {
  let i2 = 0;
  const b = new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i2++] = tl >>> 24 & 255;
  b[i2++] = tl >>> 16 & 255;
  b[i2++] = tl >>> 8 & 255;
  b[i2++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i2++] = tmh >>> 8 & 255;
  b[i2++] = tmh & 255;
  b[i2++] = tmh >>> 24 & 15 | 16;
  b[i2++] = tmh >>> 16 & 255;
  b[i2++] = clockseq >>> 8 | 128;
  b[i2++] = clockseq & 255;
  for (let n2 = 0; n2 < 6; ++n2) {
    b[i2 + n2] = node[n2];
  }
  return unsafeStringify(b);
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
var cryptoJs = { exports: {} };
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core.exports;
  hasRequiredCore = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require$$0;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance2 = this.extend();
              instance2.init.apply(instance2, arguments);
              return instance2;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message2, cfg) {
              return new hasher.init(cfg).finalize(message2);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message2, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message2);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  })(core);
  return core.exports;
}
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core) return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C2.x64 = {};
        C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            var words = clone2.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words[i2] = words[i2].clone();
            }
            return clone2;
          }
        });
      })();
      return CryptoJS;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays) return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16) return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64) return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var encBase64url = { exports: {} };
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url) return encBase64url.exports;
  hasRequiredEncBase64url = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  })(encBase64url);
  return encBase64url.exports;
}
var md5 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5.exports;
  hasRequiredMd5 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a2 = H[0];
            var b = H[1];
            var c2 = H[2];
            var d = H[3];
            a2 = FF(a2, b, c2, d, M_offset_0, 7, T[0]);
            d = FF(d, a2, b, c2, M_offset_1, 12, T[1]);
            c2 = FF(c2, d, a2, b, M_offset_2, 17, T[2]);
            b = FF(b, c2, d, a2, M_offset_3, 22, T[3]);
            a2 = FF(a2, b, c2, d, M_offset_4, 7, T[4]);
            d = FF(d, a2, b, c2, M_offset_5, 12, T[5]);
            c2 = FF(c2, d, a2, b, M_offset_6, 17, T[6]);
            b = FF(b, c2, d, a2, M_offset_7, 22, T[7]);
            a2 = FF(a2, b, c2, d, M_offset_8, 7, T[8]);
            d = FF(d, a2, b, c2, M_offset_9, 12, T[9]);
            c2 = FF(c2, d, a2, b, M_offset_10, 17, T[10]);
            b = FF(b, c2, d, a2, M_offset_11, 22, T[11]);
            a2 = FF(a2, b, c2, d, M_offset_12, 7, T[12]);
            d = FF(d, a2, b, c2, M_offset_13, 12, T[13]);
            c2 = FF(c2, d, a2, b, M_offset_14, 17, T[14]);
            b = FF(b, c2, d, a2, M_offset_15, 22, T[15]);
            a2 = GG(a2, b, c2, d, M_offset_1, 5, T[16]);
            d = GG(d, a2, b, c2, M_offset_6, 9, T[17]);
            c2 = GG(c2, d, a2, b, M_offset_11, 14, T[18]);
            b = GG(b, c2, d, a2, M_offset_0, 20, T[19]);
            a2 = GG(a2, b, c2, d, M_offset_5, 5, T[20]);
            d = GG(d, a2, b, c2, M_offset_10, 9, T[21]);
            c2 = GG(c2, d, a2, b, M_offset_15, 14, T[22]);
            b = GG(b, c2, d, a2, M_offset_4, 20, T[23]);
            a2 = GG(a2, b, c2, d, M_offset_9, 5, T[24]);
            d = GG(d, a2, b, c2, M_offset_14, 9, T[25]);
            c2 = GG(c2, d, a2, b, M_offset_3, 14, T[26]);
            b = GG(b, c2, d, a2, M_offset_8, 20, T[27]);
            a2 = GG(a2, b, c2, d, M_offset_13, 5, T[28]);
            d = GG(d, a2, b, c2, M_offset_2, 9, T[29]);
            c2 = GG(c2, d, a2, b, M_offset_7, 14, T[30]);
            b = GG(b, c2, d, a2, M_offset_12, 20, T[31]);
            a2 = HH(a2, b, c2, d, M_offset_5, 4, T[32]);
            d = HH(d, a2, b, c2, M_offset_8, 11, T[33]);
            c2 = HH(c2, d, a2, b, M_offset_11, 16, T[34]);
            b = HH(b, c2, d, a2, M_offset_14, 23, T[35]);
            a2 = HH(a2, b, c2, d, M_offset_1, 4, T[36]);
            d = HH(d, a2, b, c2, M_offset_4, 11, T[37]);
            c2 = HH(c2, d, a2, b, M_offset_7, 16, T[38]);
            b = HH(b, c2, d, a2, M_offset_10, 23, T[39]);
            a2 = HH(a2, b, c2, d, M_offset_13, 4, T[40]);
            d = HH(d, a2, b, c2, M_offset_0, 11, T[41]);
            c2 = HH(c2, d, a2, b, M_offset_3, 16, T[42]);
            b = HH(b, c2, d, a2, M_offset_6, 23, T[43]);
            a2 = HH(a2, b, c2, d, M_offset_9, 4, T[44]);
            d = HH(d, a2, b, c2, M_offset_12, 11, T[45]);
            c2 = HH(c2, d, a2, b, M_offset_15, 16, T[46]);
            b = HH(b, c2, d, a2, M_offset_2, 23, T[47]);
            a2 = II(a2, b, c2, d, M_offset_0, 6, T[48]);
            d = II(d, a2, b, c2, M_offset_7, 10, T[49]);
            c2 = II(c2, d, a2, b, M_offset_14, 15, T[50]);
            b = II(b, c2, d, a2, M_offset_5, 21, T[51]);
            a2 = II(a2, b, c2, d, M_offset_12, 6, T[52]);
            d = II(d, a2, b, c2, M_offset_3, 10, T[53]);
            c2 = II(c2, d, a2, b, M_offset_10, 15, T[54]);
            b = II(b, c2, d, a2, M_offset_1, 21, T[55]);
            a2 = II(a2, b, c2, d, M_offset_8, 6, T[56]);
            d = II(d, a2, b, c2, M_offset_15, 10, T[57]);
            c2 = II(c2, d, a2, b, M_offset_6, 15, T[58]);
            b = II(b, c2, d, a2, M_offset_13, 21, T[59]);
            a2 = II(a2, b, c2, d, M_offset_4, 6, T[60]);
            d = II(d, a2, b, c2, M_offset_11, 10, T[61]);
            c2 = II(c2, d, a2, b, M_offset_2, 15, T[62]);
            b = II(b, c2, d, a2, M_offset_9, 21, T[63]);
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF(a2, b, c2, d, x, s2, t2) {
          var n2 = a2 + (b & c2 | ~b & d) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        function GG(a2, b, c2, d, x, s2, t2) {
          var n2 = a2 + (b & d | c2 & ~d) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        function HH(a2, b, c2, d, x, s2, t2) {
          var n2 = a2 + (b ^ c2 ^ d) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        function II(a2, b, c2, d, x, s2, t2) {
          var n2 = a2 + (c2 ^ (b | ~d)) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        C2.MD5 = Hasher._createHelper(MD52);
        C2.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5);
  return md5.exports;
}
var sha1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1.exports;
  hasRequiredSha1 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a2 = H[0];
            var b = H[1];
            var c2 = H[2];
            var d = H[3];
            var e2 = H[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                W[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a2 << 5 | a2 >>> 27) + e2 + W[i2];
              if (i2 < 20) {
                t2 += (b & c2 | ~b & d) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b ^ c2 ^ d) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b & c2 | b & d | c2 & d) - 1894007588;
              } else {
                t2 += (b ^ c2 ^ d) - 899497514;
              }
              e2 = d;
              d = c2;
              c2 = b << 30 | b >>> 2;
              b = a2;
              a2 = t2;
            }
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C2.SHA1 = Hasher._createHelper(SHA1);
        C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  })(sha1);
  return sha1.exports;
}
var sha256 = { exports: {} };
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256.exports;
  hasRequiredSha256 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b = H2[1];
            var c2 = H2[2];
            var d = H2[3];
            var e2 = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e2 & f ^ ~e2 & g;
              var maj = a2 & b ^ a2 & c2 ^ b & c2;
              var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
              var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
              var t1 = h + sigma1 + ch + K[i2] + W[i2];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e2;
              e2 = d + t1 | 0;
              d = c2;
              c2 = b;
              b = a2;
              a2 = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e2 | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C2.SHA256 = Hasher._createHelper(SHA256);
        C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  })(sha256);
  return sha256.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha256());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C2.SHA224 = SHA256._createHelper(SHA224);
        C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512.exports;
  hasRequiredSha512 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W[i2] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wil;
              var Wih;
              var Wi = W[i2];
              if (i2 < 16) {
                Wih = Wi.high = M[offset + i2 * 2] | 0;
                Wil = Wi.low = M[offset + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i2];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          },
          blockSize: 1024 / 32
        });
        C2.SHA512 = Hasher._createHelper(SHA512);
        C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  })(sha512);
  return sha512.exports;
}
var sha384 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384.exports;
  hasRequiredSha384 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C2.SHA384 = SHA512._createHelper(SHA384);
        C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  })(sha384);
  return sha384.exports;
}
var sha3 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3) return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var C_algo = C2.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x + 5 * y] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M[offset + 2 * i2];
              var M2i1 = M[offset + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            var state = clone2._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = state[i2].clone();
            }
            return clone2;
          }
        });
        C2.SHA3 = Hasher._createHelper(SHA3);
        C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  })(sha3);
  return sha3.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al + M[offset + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl, cl, dl) + hl[0];
              } else if (i2 < 32) {
                t2 += f2(bl, cl, dl) + hl[1];
              } else if (i2 < 48) {
                t2 += f3(bl, cl, dl) + hl[2];
              } else if (i2 < 64) {
                t2 += f4(bl, cl, dl) + hl[3];
              } else {
                t2 += f5(bl, cl, dl) + hl[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl[i2]);
              t2 = t2 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t2;
              t2 = ar + M[offset + zr[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr[i2]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t2;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n2) {
          return x << n2 | x >>> 32 - n2;
        }
        C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac.exports;
  hasRequiredHmac = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C2.algo;
        C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  })(hmac);
  return hmac.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha256(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf) return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var MD52 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD52,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore) return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C2.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C2.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message2, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message2, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C2.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C2.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C2.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message2, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message2);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C2.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message2, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message2, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb) return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset + i2] ^= keystream[i2];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr) return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman) return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb) return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb) return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923) return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126) return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971) return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding) return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i2 = data.sigBytes - 1;
          for (var i2 = data.sigBytes - 1; i2 >= 0; i2--) {
            if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
              data.sigBytes = i2 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding) return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex) return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C2.enc;
        var Hex = C_enc.Hex;
        var C_format = C2.format;
        C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes.exports;
  hasRequiredAes = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d[i2] = i2 << 1;
            } else {
              d[i2] = i2 << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t2 = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t2 = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t2;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t2;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C2.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes) return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset;
        }
        function exchangeRL(offset, mask) {
          var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset;
        }
        C2.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C2.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4) return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S[i2] = i2;
            }
            for (var i2 = 0, j = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i2] + keyByte) % 256;
              var t2 = S[i2];
              S[i2] = S[j];
              S[j] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i2 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i2 = (i2 + 1) % 256;
            j = (j + S[i2]) % 256;
            var t2 = S[i2];
            S[i2] = S[j];
            S[j] = t2;
            keystreamWord |= S[(S[i2] + S[j]) % 256] << 24 - n2 * 8;
          }
          this._i = i2;
          this._j = j;
          return keystreamWord;
        }
        C2.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit) return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K[i2] = (K[i2] << 8 | K[i2] >>> 24) & 16711935 | (K[i2] << 24 | K[i2] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C3 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C3[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S[i2] = (S[i2] << 8 | S[i2] >>> 24) & 16711935 | (S[i2] << 24 | S[i2] >>> 8) & 4278255360;
              M[offset + i2] ^= S[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C3 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C3[i2];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C3[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i2] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C2.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy) return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C3 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C3[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S[i2] = (S[i2] << 8 | S[i2] >>> 24) & 16711935 | (S[i2] << 24 | S[i2] >>> 8) & 4278255360;
              M[offset + i2] ^= S[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C3 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C3[i2];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C3[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i2] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
var blowfish = { exports: {} };
var hasRequiredBlowfish;
function requireBlowfish() {
  if (hasRequiredBlowfish) return blowfish.exports;
  hasRequiredBlowfish = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a2 = x >> 24 & 255;
          let b = x >> 16 & 255;
          let c2 = x >> 8 & 255;
          let d = x & 255;
          let y = ctx.sbox[0][a2] + ctx.sbox[1][b];
          y = y ^ ctx.sbox[2][c2];
          y = y + ctx.sbox[3][d];
          return y;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = 0; i2 < N; ++i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = N + 1; i2 > 1; --i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i2 = 0; i2 < N + 2; i2 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i2] = Data1;
            ctx.pbox[i2 + 1] = Data2;
          }
          for (let i2 = 0; i2 < 4; i2++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i2][j] = Data1;
              ctx.sbox[i2][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          decryptBlock: function(M, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C2.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS.Blowfish;
    });
  })(blowfish);
  return blowfish.exports;
}
(function(module, exports) {
  (function(root, factory, undef) {
    {
      module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
    }
  })(commonjsGlobal, function(CryptoJS) {
    return CryptoJS;
  });
})(cryptoJs);
var cryptoJsExports = cryptoJs.exports;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f = "quarter", h = "year", d = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date()) return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h, w: o2, d: a2, D: d, h: u2, m: s2, s: i2, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D = {};
    D[g] = M;
    var p2 = "$isDayjsObject", S = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p2]);
    }, w = function t3(e3, n3, r3) {
      var i3;
      if (!e3) return g;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D[s3] && (i3 = s3), n3 && (D[s3] = n3, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1) return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g = i3), i3 || !r3 && g;
    }, O = function(t3, e3) {
      if (S(t3)) return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _(n3);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t3, e3) {
      return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m3 = M2.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3) return /* @__PURE__ */ new Date(NaN);
          if (b.u(e3)) return /* @__PURE__ */ new Date();
          if (e3 instanceof Date) return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = O(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O(t3);
      }, m3.$g = function(t3, e3, n3) {
        return b.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b.u(e3) || e3, f2 = b.p(t3), l3 = function(t4, e4) {
          var i3 = b.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $2 = function(t4, e4) {
          return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y2 = this.$W, M3 = this.$M, m4 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M3) : l3(0, M3 + 1);
          case o2:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
          case a2:
          case d:
            return $2(v2 + "Hours", 0);
          case u2:
            return $2(v2 + "Minutes", 1);
          case s2:
            return $2(v2 + "Seconds", 2);
          case i2:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f2 + "Date", n3[d] = f2 + "Date", n3[c2] = f2 + "Month", n3[h] = f2 + "FullYear", n3[u2] = f2 + "Hours", n3[s2] = f2 + "Minutes", n3[i2] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l3]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b.p(t3)]();
      }, m3.add = function(r3, f2) {
        var d2, l3 = this;
        r3 = Number(r3);
        var $2 = b.p(f2), y2 = function(t3) {
          var e3 = O(l3);
          return b.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($2 === c2) return this.set(c2, this.$M + r3);
        if ($2 === h) return this.set(h, this.$y + r3);
        if ($2 === a2) return y2(1);
        if ($2 === o2) return y2(7);
        var M3 = (d2 = {}, d2[s2] = e2, d2[u2] = n2, d2[i2] = t2, d2)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
        return b.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid()) return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f2 = n3.meridiem, h2 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, d2 = function(t4) {
          return b.s(s3 % 12 || 12, t4, "0");
        }, $2 = f2 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b.s(a3 + 1, 2, "0");
              case "MMM":
                return h2(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h2(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h2(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h2(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b.s(s3, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s3, u3, true);
              case "A":
                return $2(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b.s(e3.$s, 2, "0");
              case "SSS":
                return b.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t4) || i3.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d2, l3) {
        var $2, y2 = this, M3 = b.p(d2), m4 = O(r3), v2 = (m4.utcOffset() - this.utcOffset()) * e2, g2 = this - m4, D2 = function() {
          return b.m(y2, m4);
        };
        switch (M3) {
          case h:
            $2 = D2() / 12;
            break;
          case c2:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o2:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a2:
            $2 = (g2 - v2) / 864e5;
            break;
          case u2:
            $2 = g2 / n2;
            break;
          case s2:
            $2 = g2 / e2;
            break;
          case i2:
            $2 = g2 / t2;
            break;
          default:
            $2 = g2;
        }
        return l3 ? $2 : b.a($2);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3) return this.$L;
        var n3 = this.clone(), r3 = w(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return b.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h], ["$D", d]].forEach(function(t3) {
      k[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _, O), t3.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
      return O(1e3 * t3);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n2 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i2(r3, e3, t3, o3) {
        return n2.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n2.fromToBase = function(e3, n3, i3, d2, u2) {
        for (var f, a2, s2, l2 = i3.$locale().relativeTime || o2, h = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m2 = h.length, c2 = 0; c2 < m2; c2 += 1) {
          var y = h[c2];
          y.d && (f = d2 ? t2(e3).diff(i3, y.d, true) : i3.diff(e3, y.d, true));
          var p2 = (r2.rounding || Math.round)(Math.abs(f));
          if (s2 = f > 0, p2 <= y.r || !y.r) {
            p2 <= 1 && c2 > 0 && (y = h[c2 - 1]);
            var v = l2[y.l];
            u2 && (p2 = u2("" + p2)), a2 = "string" == typeof v ? v.replace("%d", p2) : v(p2, n3, y.l, s2);
            break;
          }
        }
        if (n3) return a2;
        var M = s2 ? l2.future : l2.past;
        return "function" == typeof M ? M(a2) : M.replace("%s", a2);
      }, n2.to = function(r3, e3) {
        return i2(r3, e3, this, true);
      }, n2.from = function(r3, e3) {
        return i2(r3, e3, this);
      };
      var d = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n2.toNow = function(r3) {
        return this.to(d(this), r3);
      }, n2.fromNow = function(r3) {
        return this.from(d(this), r3);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
var updateLocale$1 = { exports: {} };
(function(module, exports) {
  !function(e2, n2) {
    module.exports = n2();
  }(commonjsGlobal, function() {
    return function(e2, n2, t2) {
      t2.updateLocale = function(e3, n3) {
        var o2 = t2.Ls[e3];
        if (o2) return (n3 ? Object.keys(n3) : []).forEach(function(e4) {
          o2[e4] = n3[e4];
        }), o2;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
var utc$1 = { exports: {} };
(function(module, exports) {
  !function(t2, i2) {
    module.exports = i2();
  }(commonjsGlobal, function() {
    var t2 = "minute", i2 = /[+-]\d\d(?::?\d\d)?/g, e2 = /([+-]|\d\d)/g;
    return function(s2, f, n2) {
      var u2 = f.prototype;
      n2.utc = function(t3) {
        var i3 = { date: t3, utc: true, args: arguments };
        return new f(i3);
      }, u2.utc = function(i3) {
        var e3 = n2(this.toDate(), { locale: this.$L, utc: true });
        return i3 ? e3.add(this.utcOffset(), t2) : e3;
      }, u2.local = function() {
        return n2(this.toDate(), { locale: this.$L, utc: false });
      };
      var o2 = u2.parse;
      u2.parse = function(t3) {
        t3.utc && (this.$u = true), this.$utils().u(t3.$offset) || (this.$offset = t3.$offset), o2.call(this, t3);
      };
      var r2 = u2.init;
      u2.init = function() {
        if (this.$u) {
          var t3 = this.$d;
          this.$y = t3.getUTCFullYear(), this.$M = t3.getUTCMonth(), this.$D = t3.getUTCDate(), this.$W = t3.getUTCDay(), this.$H = t3.getUTCHours(), this.$m = t3.getUTCMinutes(), this.$s = t3.getUTCSeconds(), this.$ms = t3.getUTCMilliseconds();
        } else r2.call(this);
      };
      var a2 = u2.utcOffset;
      u2.utcOffset = function(s3, f2) {
        var n3 = this.$utils().u;
        if (n3(s3)) return this.$u ? 0 : n3(this.$offset) ? a2.call(this) : this.$offset;
        if ("string" == typeof s3 && (s3 = function(t3) {
          void 0 === t3 && (t3 = "");
          var s4 = t3.match(i2);
          if (!s4) return null;
          var f3 = ("" + s4[0]).match(e2) || ["-", 0, 0], n4 = f3[0], u4 = 60 * +f3[1] + +f3[2];
          return 0 === u4 ? 0 : "+" === n4 ? u4 : -u4;
        }(s3), null === s3)) return this;
        var u3 = Math.abs(s3) <= 16 ? 60 * s3 : s3, o3 = this;
        if (f2) return o3.$offset = u3, o3.$u = 0 === s3, o3;
        if (0 !== s3) {
          var r3 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o3 = this.local().add(u3 + r3, t2)).$offset = u3, o3.$x.$localOffset = r3;
        } else o3 = this.utc();
        return o3;
      };
      var h = u2.format;
      u2.format = function(t3) {
        var i3 = t3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i3);
      }, u2.valueOf = function() {
        var t3 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * t3;
      }, u2.isUTC = function() {
        return !!this.$u;
      }, u2.toISOString = function() {
        return this.toDate().toISOString();
      }, u2.toString = function() {
        return this.toDate().toUTCString();
      };
      var l2 = u2.toDate;
      u2.toDate = function(t3) {
        return "s" === t3 && this.$offset ? n2(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l2.call(this);
      };
      var c2 = u2.diff;
      u2.diff = function(t3, i3, e3) {
        if (t3 && this.$u === t3.$u) return c2.call(this, t3, i3, e3);
        var s3 = this.local(), f2 = n2(t3).local();
        return c2.call(s3, f2, i3, e3);
      };
    };
  });
})(utc$1);
var utcExports = utc$1.exports;
const utc = /* @__PURE__ */ getDefaultExportFromCjs(utcExports);
var timezone$1 = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e2 = {};
    return function(n2, i2, o2) {
      var r2, a2 = function(t3, n3, i3) {
        void 0 === i3 && (i3 = {});
        var o3 = new Date(t3), r3 = function(t4, n4) {
          void 0 === n4 && (n4 = {});
          var i4 = n4.timeZoneName || "short", o4 = t4 + "|" + i4, r4 = e2[o4];
          return r4 || (r4 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t4, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i4 }), e2[o4] = r4), r4;
        }(n3, i3);
        return r3.formatToParts(o3);
      }, u2 = function(e3, n3) {
        for (var i3 = a2(e3, n3), r3 = [], u3 = 0; u3 < i3.length; u3 += 1) {
          var f2 = i3[u3], s3 = f2.type, m2 = f2.value, c2 = t2[s3];
          c2 >= 0 && (r3[c2] = parseInt(m2, 10));
        }
        var d = r3[3], l2 = 24 === d ? 0 : d, h = r3[0] + "-" + r3[1] + "-" + r3[2] + " " + l2 + ":" + r3[4] + ":" + r3[5] + ":000", v = +e3;
        return (o2.utc(h).valueOf() - (v -= v % 1e3)) / 6e4;
      }, f = i2.prototype;
      f.tz = function(t3, e3) {
        void 0 === t3 && (t3 = r2);
        var n3, i3 = this.utcOffset(), a3 = this.toDate(), u3 = a3.toLocaleString("en-US", { timeZone: t3 }), f2 = Math.round((a3 - new Date(u3)) / 1e3 / 60), s3 = 15 * -Math.round(a3.getTimezoneOffset() / 15) - f2;
        if (!Number(s3)) n3 = this.utcOffset(0, e3);
        else if (n3 = o2(u3, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(s3, true), e3) {
          var m2 = n3.utcOffset();
          n3 = n3.add(i3 - m2, "minute");
        }
        return n3.$x.$timezone = t3, n3;
      }, f.offsetName = function(t3) {
        var e3 = this.$x.$timezone || o2.tz.guess(), n3 = a2(this.valueOf(), e3, { timeZoneName: t3 }).find(function(t4) {
          return "timezonename" === t4.type.toLowerCase();
        });
        return n3 && n3.value;
      };
      var s2 = f.startOf;
      f.startOf = function(t3, e3) {
        if (!this.$x || !this.$x.$timezone) return s2.call(this, t3, e3);
        var n3 = o2(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
        return s2.call(n3, t3, e3).tz(this.$x.$timezone, true);
      }, o2.tz = function(t3, e3, n3) {
        var i3 = n3 && e3, a3 = n3 || e3 || r2, f2 = u2(+o2(), a3);
        if ("string" != typeof t3) return o2(t3).tz(a3);
        var s3 = function(t4, e4, n4) {
          var i4 = t4 - 60 * e4 * 1e3, o3 = u2(i4, n4);
          if (e4 === o3) return [i4, e4];
          var r3 = u2(i4 -= 60 * (o3 - e4) * 1e3, n4);
          return o3 === r3 ? [i4, o3] : [t4 - 60 * Math.min(o3, r3) * 1e3, Math.max(o3, r3)];
        }(o2.utc(t3, i3).valueOf(), f2, a3), m2 = s3[0], c2 = s3[1], d = o2(m2).utcOffset(c2);
        return d.$x.$timezone = a3, d;
      }, o2.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o2.tz.setDefault = function(t3) {
        r2 = t3;
      };
    };
  });
})(timezone$1);
var timezoneExports = timezone$1.exports;
const timezone = /* @__PURE__ */ getDefaultExportFromCjs(timezoneExports);
var duration$2 = { exports: {} };
(function(module, exports) {
  !function(t2, s2) {
    module.exports = s2();
  }(commonjsGlobal, function() {
    var t2, s2, n2 = 1e3, i2 = 6e4, e2 = 36e5, r2 = 864e5, o2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u2 = 31536e6, d = 2628e6, a2 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h = { years: u2, months: d, days: r2, hours: e2, minutes: i2, seconds: n2, milliseconds: 1, weeks: 6048e5 }, c2 = function(t3) {
      return t3 instanceof g;
    }, f = function(t3, s3, n3) {
      return new g(t3, n3, s3.$l);
    }, m2 = function(t3) {
      return s2.p(t3) + "s";
    }, l2 = function(t3) {
      return t3 < 0;
    }, $ = function(t3) {
      return l2(t3) ? Math.ceil(t3) : Math.floor(t3);
    }, y = function(t3) {
      return Math.abs(t3);
    }, v = function(t3, s3) {
      return t3 ? l2(t3) ? { negative: true, format: "" + y(t3) + s3 } : { negative: false, format: "" + t3 + s3 } : { negative: false, format: "" };
    }, g = function() {
      function l3(t3, s3, n3) {
        var i3 = this;
        if (this.$d = {}, this.$l = n3, void 0 === t3 && (this.$ms = 0, this.parseFromMilliseconds()), s3) return f(t3 * h[m2(s3)], this);
        if ("number" == typeof t3) return this.$ms = t3, this.parseFromMilliseconds(), this;
        if ("object" == typeof t3) return Object.keys(t3).forEach(function(s4) {
          i3.$d[m2(s4)] = t3[s4];
        }), this.calMilliseconds(), this;
        if ("string" == typeof t3) {
          var e3 = t3.match(a2);
          if (e3) {
            var r3 = e3.slice(2).map(function(t4) {
              return null != t4 ? Number(t4) : 0;
            });
            return this.$d.years = r3[0], this.$d.months = r3[1], this.$d.weeks = r3[2], this.$d.days = r3[3], this.$d.hours = r3[4], this.$d.minutes = r3[5], this.$d.seconds = r3[6], this.calMilliseconds(), this;
          }
        }
        return this;
      }
      var y2 = l3.prototype;
      return y2.calMilliseconds = function() {
        var t3 = this;
        this.$ms = Object.keys(this.$d).reduce(function(s3, n3) {
          return s3 + (t3.$d[n3] || 0) * h[n3];
        }, 0);
      }, y2.parseFromMilliseconds = function() {
        var t3 = this.$ms;
        this.$d.years = $(t3 / u2), t3 %= u2, this.$d.months = $(t3 / d), t3 %= d, this.$d.days = $(t3 / r2), t3 %= r2, this.$d.hours = $(t3 / e2), t3 %= e2, this.$d.minutes = $(t3 / i2), t3 %= i2, this.$d.seconds = $(t3 / n2), t3 %= n2, this.$d.milliseconds = t3;
      }, y2.toISOString = function() {
        var t3 = v(this.$d.years, "Y"), s3 = v(this.$d.months, "M"), n3 = +this.$d.days || 0;
        this.$d.weeks && (n3 += 7 * this.$d.weeks);
        var i3 = v(n3, "D"), e3 = v(this.$d.hours, "H"), r3 = v(this.$d.minutes, "M"), o3 = this.$d.seconds || 0;
        this.$d.milliseconds && (o3 += this.$d.milliseconds / 1e3, o3 = Math.round(1e3 * o3) / 1e3);
        var u3 = v(o3, "S"), d2 = t3.negative || s3.negative || i3.negative || e3.negative || r3.negative || u3.negative, a3 = e3.format || r3.format || u3.format ? "T" : "", h2 = (d2 ? "-" : "") + "P" + t3.format + s3.format + i3.format + a3 + e3.format + r3.format + u3.format;
        return "P" === h2 || "-P" === h2 ? "P0D" : h2;
      }, y2.toJSON = function() {
        return this.toISOString();
      }, y2.format = function(t3) {
        var n3 = t3 || "YYYY-MM-DDTHH:mm:ss", i3 = { Y: this.$d.years, YY: s2.s(this.$d.years, 2, "0"), YYYY: s2.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s2.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s2.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s2.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s2.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s2.s(this.$d.seconds, 2, "0"), SSS: s2.s(this.$d.milliseconds, 3, "0") };
        return n3.replace(o2, function(t4, s3) {
          return s3 || String(i3[t4]);
        });
      }, y2.as = function(t3) {
        return this.$ms / h[m2(t3)];
      }, y2.get = function(t3) {
        var s3 = this.$ms, n3 = m2(t3);
        return "milliseconds" === n3 ? s3 %= 1e3 : s3 = "weeks" === n3 ? $(s3 / h[n3]) : this.$d[n3], s3 || 0;
      }, y2.add = function(t3, s3, n3) {
        var i3;
        return i3 = s3 ? t3 * h[m2(s3)] : c2(t3) ? t3.$ms : f(t3, this).$ms, f(this.$ms + i3 * (n3 ? -1 : 1), this);
      }, y2.subtract = function(t3, s3) {
        return this.add(t3, s3, true);
      }, y2.locale = function(t3) {
        var s3 = this.clone();
        return s3.$l = t3, s3;
      }, y2.clone = function() {
        return f(this.$ms, this);
      }, y2.humanize = function(s3) {
        return t2().add(this.$ms, "ms").locale(this.$l).fromNow(!s3);
      }, y2.valueOf = function() {
        return this.asMilliseconds();
      }, y2.milliseconds = function() {
        return this.get("milliseconds");
      }, y2.asMilliseconds = function() {
        return this.as("milliseconds");
      }, y2.seconds = function() {
        return this.get("seconds");
      }, y2.asSeconds = function() {
        return this.as("seconds");
      }, y2.minutes = function() {
        return this.get("minutes");
      }, y2.asMinutes = function() {
        return this.as("minutes");
      }, y2.hours = function() {
        return this.get("hours");
      }, y2.asHours = function() {
        return this.as("hours");
      }, y2.days = function() {
        return this.get("days");
      }, y2.asDays = function() {
        return this.as("days");
      }, y2.weeks = function() {
        return this.get("weeks");
      }, y2.asWeeks = function() {
        return this.as("weeks");
      }, y2.months = function() {
        return this.get("months");
      }, y2.asMonths = function() {
        return this.as("months");
      }, y2.years = function() {
        return this.get("years");
      }, y2.asYears = function() {
        return this.as("years");
      }, l3;
    }(), p2 = function(t3, s3, n3) {
      return t3.add(s3.years() * n3, "y").add(s3.months() * n3, "M").add(s3.days() * n3, "d").add(s3.hours() * n3, "h").add(s3.minutes() * n3, "m").add(s3.seconds() * n3, "s").add(s3.milliseconds() * n3, "ms");
    };
    return function(n3, i3, e3) {
      t2 = e3, s2 = e3().$utils(), e3.duration = function(t3, s3) {
        var n4 = e3.locale();
        return f(t3, { $l: n4 }, s3);
      }, e3.isDuration = c2;
      var r3 = i3.prototype.add, o3 = i3.prototype.subtract;
      i3.prototype.add = function(t3, s3) {
        return c2(t3) ? p2(this, t3, 1) : r3.bind(this)(t3, s3);
      }, i3.prototype.subtract = function(t3, s3) {
        return c2(t3) ? p2(this, t3, -1) : o3.bind(this)(t3, s3);
      };
    };
  });
})(duration$2);
var durationExports = duration$2.exports;
const duration$1 = /* @__PURE__ */ getDefaultExportFromCjs(durationExports);
const customDayjs = dayjs;
customDayjs.extend(utc);
customDayjs.extend(timezone);
customDayjs.extend(relativeTime);
customDayjs.extend(updateLocale);
customDayjs.extend(duration$1);
customDayjs.updateLocale("en", {
  relativeTime: {
    future: "%s",
    past: "%s",
    s: relativeTimeText.s,
    m: relativeTimeText.m,
    mm: "%d phút ",
    h: relativeTimeText.h,
    hh: "%d giờ ",
    d: relativeTimeText.d,
    dd: "%d ngày",
    M: relativeTimeText.M,
    MM: "%d tháng",
    y: relativeTimeText.y,
    yy: "%d năm"
  }
});
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$1 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString$1.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray$1 = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value2 = obj[name2];
    if (!isFunction(value2)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value2, defaultValue) => {
  return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value2, key) => {
          const reducedValue = visit(value2, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError$1(message2, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each2(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null) return "";
    if (utils$1.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value2)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value2) || utils$1.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path) {
    let arr = value2;
    if (value2 && !path && typeof value2 === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils$1.isArray(value2) && isFlatArray(value2) || (utils$1.isFileList(value2) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value2))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value2, path) {
    if (utils$1.isUndefined(value2)) return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value2);
    utils$1.forEach(value2, function each2(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value2) {
  this._pairs.push([name2, value2]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value2) {
    return encoder.call(this, value2, encode$2);
  } : encode$2;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode$1;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value2, target, index) {
    let name2 = path[index++];
    if (name2 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value2];
      } else {
        target[name2] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$1.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value2, target[name2], index);
    if (result && utils$1.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name2, value2) => {
      buildPath(parsePropPath(name2), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status2) {
    return status2 >= 200 && status2 < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils$1.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value2, header, filter3, isHeaderNameFilter) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value2, header);
  }
  if (isHeaderNameFilter) {
    value2 = header;
  }
  if (!utils$1.isString(value2)) return;
  if (utils$1.isString(filter3)) {
    return value2.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value2] of header.entries()) {
        setHeader(value2, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value2 = this[key];
        if (!parser2) {
          return value2;
        }
        if (parser2 === true) {
          return parseTokens(value2);
        }
        if (utils$1.isFunction(parser2)) {
          return parser2.call(this, value2, key);
        }
        if (utils$1.isRegExp(parser2)) {
          return parser2.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value2, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils$1.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value: value2 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value2,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel$1(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function CanceledError$1(message2, config, request) {
  AxiosError$1.call(this, message2 == null ? "canceled" : message2, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value2, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value2)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && isRelativeUrl || allowAbsoluteUrls == false) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b, prop, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a2, b, prop, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a2, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b), prop, true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done2() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value2) {
        resolve(value2);
        done2();
      }, function _reject(err) {
        reject(err);
        done2();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(_config.url);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol2 + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout2) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout2 || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout2 && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout2} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout2);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done: done2, value: value2 } = await reader.read();
      if (done2) {
        break;
      }
      yield value2;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done2;
  let _onFinish = (e2) => {
    if (!done2) {
      done2 = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done3, value: value2 } = await iterator.next();
        if (done3) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value2.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value2));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout: timeout2,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout2);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError$1.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value2) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value2 });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value: value2 });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION$1 = "1.8.3";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value2, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value2, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message2, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value2]) => {
  HttpStatusCode$1[value2] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance2 = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all$1,
  Cancel: Cancel$1,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var ENUM_METHOD = /* @__PURE__ */ ((ENUM_METHOD2) => {
  ENUM_METHOD2["GET"] = "GET";
  ENUM_METHOD2["DELETE"] = "DELETE";
  ENUM_METHOD2["HEAD"] = "HEAD";
  ENUM_METHOD2["OPTIONS"] = "OPTIONS";
  ENUM_METHOD2["POST"] = "POST";
  ENUM_METHOD2["PUT"] = "PUT";
  ENUM_METHOD2["PATCH"] = "PATCH";
  ENUM_METHOD2["PURGE"] = "PURGE";
  ENUM_METHOD2["LINK"] = "LINK";
  ENUM_METHOD2["UNLINK"] = "UNLINK";
  return ENUM_METHOD2;
})(ENUM_METHOD || {});
class AxiosExternal {
  constructor(baseUrl) {
    __publicField(this, "baseUrl");
    __publicField(this, "callApiNotAuth");
    this.baseUrl = baseUrl || CONFIG_URL || "";
    this.callApiNotAuth = axios.create({
      baseURL: this.baseUrl,
      headers: {
        "Content-Type": "application/json"
      }
    });
    this.callApiNotAuth.interceptors.request.use(
      async (config) => {
        config.baseURL = config_url.base_url;
        return config;
      },
      (error) => Promise.reject(error)
    );
    this.callApiNotAuth.interceptors.response.use(
      (response) => response,
      async (error) => {
        return Promise.reject(error);
      }
    );
  }
  fetchRestful({
    body,
    method = "POST",
    init = {},
    b,
    url: url2 = ""
  }) {
    const data = {
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      },
      method,
      body,
      ...init
    };
    return fetch(`${b || CONFIG_URL}${url2}`, data);
  }
}
class ApiConfig {
  constructor() {
    __publicField(this, "base_url", "");
    __publicField(this, "api_key", "");
  }
  init(options) {
    this.base_url = options.base_url;
    this.api_key = options.api_key;
  }
  callApi({
    url: url2,
    method = ENUM_METHOD.POST,
    params,
    body,
    headers
  }) {
    const api = axios.create({
      baseURL: this.base_url,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      timeout: 15e3
      // 15 seconds timeout
    });
    const requestInterceptor = (request) => {
      if (this.api_key) {
        request.headers.Authorization = `Bearer ${this.api_key}`;
      }
      return request;
    };
    const responseInterceptor = (response) => {
      return response;
    };
    const errorInterceptor = (error) => {
      var _a;
      if (((_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) === 403) ;
      return Promise.reject(error);
    };
    api.interceptors.request.use(requestInterceptor);
    api.interceptors.response.use(responseInterceptor, errorInterceptor);
    return api.request({ url: url2, method, params, data: body }).then((response) => response).catch((error) => {
      return error;
    }).finally(() => {
    });
  }
}
const apiConfig = new ApiConfig();
const external = new AxiosExternal(CONFIG_URL);
const portLogEvent = (body) => external.callApiNotAuth.post(
  `dynamic-report/api/v2/reports/client-log`,
  body
);
function r(e2) {
  var t2, f, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f = r(e2[t2])) && (n2 && (n2 += " "), n2 += f);
  else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f = 0, n2 = ""; f < arguments.length; ) (e2 = arguments[f++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
let e = { data: "" }, t = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e, l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a = /\/\*[^]*?\*\/|  +/g, n = /\n+/g, o = (e2, t2) => {
  let r2 = "", l2 = "", a2 = "";
  for (let n2 in e2) {
    let c2 = e2[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c2 + ";" : l2 += "f" == n2[1] ? o(c2, n2) : n2 + "{" + o(c2, "k" == n2[1] ? "" : t2) + "}" : "object" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + ":" + c2 + ";");
  }
  return r2 + (t2 && a2 ? t2 + "{" + a2 + "}" : a2) + l2;
}, c = {}, s = (e2) => {
  if ("object" == typeof e2) {
    let t2 = "";
    for (let r2 in e2) t2 += r2 + s(e2[r2]);
    return t2;
  }
  return e2;
}, i = (e2, t2, r2, i2, p2) => {
  let u2 = s(e2), d = c[u2] || (c[u2] = ((e3) => {
    let t3 = 0, r3 = 11;
    for (; t3 < e3.length; ) r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
    return "go" + r3;
  })(u2));
  if (!c[d]) {
    let t3 = u2 !== e2 ? e2 : ((e3) => {
      let t4, r3, o2 = [{}];
      for (; t4 = l.exec(e3.replace(a, "")); ) t4[4] ? o2.shift() : t4[3] ? (r3 = t4[3].replace(n, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t4[1]] = t4[2].replace(n, " ").trim();
      return o2[0];
    })(e2);
    c[d] = o(p2 ? { ["@keyframes " + d]: t3 } : t3, r2 ? "" : "." + d);
  }
  let f = r2 && c.g ? c.g : null;
  return r2 && (c.g = c[d]), ((e3, t3, r3, l2) => {
    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
  })(c[d], t2, i2, f), d;
}, p = (e2, t2, r2) => e2.reduce((e3, l2, a2) => {
  let n2 = t2[a2];
  if (n2 && n2.call) {
    let e4 = n2(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n2 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l2 + (null == n2 ? "" : n2);
}, "");
function u(e2) {
  let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l2, t(r2.target), r2.g, r2.o, r2.k);
}
u.bind({ g: 1 });
u.bind({ k: 1 });
var define_process_env_default = {};
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var noOp = function noOp2() {
  return "";
};
var SnackbarContext = /* @__PURE__ */ React__default$1.createContext({
  enqueueSnackbar: noOp,
  closeSnackbar: noOp
});
var breakpoints = {
  downXs: "@media (max-width:599.95px)",
  upSm: "@media (min-width:600px)"
};
var capitalise = function capitalise2(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
var originKeyExtractor = function originKeyExtractor2(anchor) {
  return "" + capitalise(anchor.vertical) + capitalise(anchor.horizontal);
};
var isDefined = function isDefined2(value2) {
  return !!value2 || value2 === 0;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    var appear = props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props["in"]) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else if (props.unmountOnExit || props.mountOnEnter) {
      initialStatus = UNMOUNTED;
    } else {
      initialStatus = EXITED;
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref["in"];
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status2 = this.state.status;
      if (this.props["in"]) {
        if (status2 !== ENTERING && status2 !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else if (status2 === ENTERING || status2 === ENTERED) {
        nextStatus = EXITING;
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var enter = timeout2;
    var exit = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number" && typeof timeout2 !== "string") {
      exit = timeout2.exit;
      enter = timeout2.enter;
    }
    return {
      exit,
      enter
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var isAppearing = mounting;
    var timeouts = this.getTimeouts();
    if (!mounting && !enter) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        if (_this2.props.onEntered) {
          _this2.props.onEntered(_this2.node, isAppearing);
        }
      });
      return;
    }
    if (this.props.onEnter) {
      this.props.onEnter(this.node, isAppearing);
    }
    this.safeSetState({
      status: ENTERING
    }, function() {
      if (_this2.props.onEntering) {
        _this2.props.onEntering(_this2.node, isAppearing);
      }
      _this2.onTransitionEnd(timeouts.enter, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          if (_this2.props.onEntered) {
            _this2.props.onEntered(_this2.node, isAppearing);
          }
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function() {
        if (_this3.props.onExited) {
          _this3.props.onExited(_this3.node);
        }
      });
      return;
    }
    if (this.props.onExit) {
      this.props.onExit(this.node);
    }
    this.safeSetState({
      status: EXITING
    }, function() {
      if (_this3.props.onExiting) {
        _this3.props.onExiting(_this3.node);
      }
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          if (_this3.props.onExited) {
            _this3.props.onExited(_this3.node);
          }
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null && this.nextCallback.cancel) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function() {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback();
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!this.node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      this.props.addEndListener(this.node, this.nextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status2 = this.state.status;
    if (status2 === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return children(status2, childProps);
  };
  _createClass(Transition2, [{
    key: "node",
    get: function get2() {
      var _this$props$nodeRef;
      var node = (_this$props$nodeRef = this.props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current;
      if (!node) {
        throw new Error("notistack - Custom snackbar is not refForwarding");
      }
      return node;
    }
  }]);
  return Transition2;
}(React__default$1.Component);
function noop$1() {
}
Transition.defaultProps = {
  "in": false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
function setRef(ref, value2) {
  if (typeof ref === "function") {
    ref(value2);
  } else if (ref) {
    ref.current = value2;
  }
}
function useForkRef(refA, refB) {
  return reactExports.useMemo(function() {
    if (refA == null && refB == null) {
      return null;
    }
    return function(refValue) {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}
function getTransitionProps(props) {
  var timeout2 = props.timeout, _props$style = props.style, style2 = _props$style === void 0 ? {} : _props$style, mode = props.mode;
  return {
    duration: typeof timeout2 === "object" ? timeout2[mode] || 0 : timeout2,
    easing: style2.transitionTimingFunction,
    delay: style2.transitionDelay
  };
}
var defaultEasing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
var reflow = function reflow2(node) {
  node.scrollTop = node.scrollTop;
};
var formatMs = function formatMs2(milliseconds) {
  return Math.round(milliseconds) + "ms";
};
function createTransition(props, options) {
  if (props === void 0) {
    props = ["all"];
  }
  var _ref = options || {}, _ref$duration = _ref.duration, duration2 = _ref$duration === void 0 ? 300 : _ref$duration, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? defaultEasing.easeInOut : _ref$easing, _ref$delay = _ref.delay, delay = _ref$delay === void 0 ? 0 : _ref$delay;
  var properties = Array.isArray(props) ? props : [props];
  return properties.map(function(animatedProp) {
    var formattedDuration = typeof duration2 === "string" ? duration2 : formatMs(duration2);
    var formattedDelay = typeof delay === "string" ? delay : formatMs(delay);
    return animatedProp + " " + formattedDuration + " " + easing + " " + formattedDelay;
  }).join(",");
}
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}
function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc.defaultView || window;
}
function debounce$1(func, wait) {
  if (wait === void 0) {
    wait = 166;
  }
  var timeout2;
  function debounced() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var later = function later2() {
      func.apply(_this, args);
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
  }
  debounced.clear = function() {
    clearTimeout(timeout2);
  };
  return debounced;
}
function getTranslateValue(direction2, node) {
  var rect = node.getBoundingClientRect();
  var containerWindow = ownerWindow(node);
  var transform;
  if (node.fakeTransform) {
    transform = node.fakeTransform;
  } else {
    var computedStyle = containerWindow.getComputedStyle(node);
    transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  var offsetX = 0;
  var offsetY = 0;
  if (transform && transform !== "none" && typeof transform === "string") {
    var transformValues = transform.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  switch (direction2) {
    case "left":
      return "translateX(" + (containerWindow.innerWidth + offsetX - rect.left) + "px)";
    case "right":
      return "translateX(-" + (rect.left + rect.width - offsetX) + "px)";
    case "up":
      return "translateY(" + (containerWindow.innerHeight + offsetY - rect.top) + "px)";
    default:
      return "translateY(-" + (rect.top + rect.height - offsetY) + "px)";
  }
}
function setTranslateValue(direction2, node) {
  if (!node) return;
  var transform = getTranslateValue(direction2, node);
  if (transform) {
    node.style.webkitTransform = transform;
    node.style.transform = transform;
  }
}
var Slide = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var children = props.children, _props$direction = props.direction, direction2 = _props$direction === void 0 ? "down" : _props$direction, inProp = props["in"], style2 = props.style, _props$timeout = props.timeout, timeout2 = _props$timeout === void 0 ? 0 : _props$timeout, onEnter = props.onEnter, onEntered = props.onEntered, onExit = props.onExit, onExited = props.onExited, other = _objectWithoutPropertiesLoose(props, ["children", "direction", "in", "style", "timeout", "onEnter", "onEntered", "onExit", "onExited"]);
  var nodeRef = reactExports.useRef(null);
  var handleRefIntermediary = useForkRef(children.ref, nodeRef);
  var handleRef = useForkRef(handleRefIntermediary, ref);
  var handleEnter = function handleEnter2(node, isAppearing) {
    setTranslateValue(direction2, node);
    reflow(node);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  };
  var handleEntering = function handleEntering2(node) {
    var easing = (style2 === null || style2 === void 0 ? void 0 : style2.transitionTimingFunction) || defaultEasing.easeOut;
    var transitionProps = getTransitionProps({
      timeout: timeout2,
      mode: "enter",
      style: _extends({}, style2, {
        transitionTimingFunction: easing
      })
    });
    node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
    node.style.transition = createTransition("transform", transitionProps);
    node.style.webkitTransform = "none";
    node.style.transform = "none";
  };
  var handleExit = function handleExit2(node) {
    var easing = (style2 === null || style2 === void 0 ? void 0 : style2.transitionTimingFunction) || defaultEasing.sharp;
    var transitionProps = getTransitionProps({
      timeout: timeout2,
      mode: "exit",
      style: _extends({}, style2, {
        transitionTimingFunction: easing
      })
    });
    node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
    node.style.transition = createTransition("transform", transitionProps);
    setTranslateValue(direction2, node);
    if (onExit) {
      onExit(node);
    }
  };
  var handleExited = function handleExited2(node) {
    node.style.webkitTransition = "";
    node.style.transition = "";
    if (onExited) {
      onExited(node);
    }
  };
  var updatePosition = reactExports.useCallback(function() {
    if (nodeRef.current) {
      setTranslateValue(direction2, nodeRef.current);
    }
  }, [direction2]);
  reactExports.useEffect(function() {
    if (inProp || direction2 === "down" || direction2 === "right") {
      return void 0;
    }
    var handleResize = debounce$1(function() {
      if (nodeRef.current) {
        setTranslateValue(direction2, nodeRef.current);
      }
    });
    var containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return function() {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [direction2, inProp]);
  reactExports.useEffect(function() {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return reactExports.createElement(Transition, Object.assign({
    appear: true,
    nodeRef,
    onEnter: handleEnter,
    onEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    "in": inProp,
    timeout: timeout2
  }, other), function(state, childProps) {
    return reactExports.cloneElement(children, _extends({
      ref: handleRef,
      style: _extends({
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, style2, {}, children.props.style)
    }, childProps));
  });
});
Slide.displayName = "Slide";
var SvgIcon = function SvgIcon2(props) {
  return React__default$1.createElement("svg", Object.assign({
    viewBox: "0 0 24 24",
    focusable: "false",
    style: {
      fontSize: 20,
      marginInlineEnd: 8,
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0
    }
  }, props));
};
var CheckIcon = function CheckIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41\n        10.59L10 14.17L17.59 6.58L19 8L10 17Z"
  }));
};
var WarningIcon = function WarningIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"
  }));
};
var ErrorIcon = function ErrorIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,\n        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,\n        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"
  }));
};
var InfoIcon = function InfoIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,\n        0 22,12A10,10 0 0,0 12,2Z"
  }));
};
var defaultIconVariants = {
  "default": void 0,
  success: /* @__PURE__ */ React__default$1.createElement(CheckIcon, null),
  warning: /* @__PURE__ */ React__default$1.createElement(WarningIcon, null),
  error: /* @__PURE__ */ React__default$1.createElement(ErrorIcon, null),
  info: /* @__PURE__ */ React__default$1.createElement(InfoIcon, null)
};
var defaults = {
  maxSnack: 3,
  persist: false,
  hideIconVariant: false,
  disableWindowBlurListener: false,
  variant: "default",
  autoHideDuration: 5e3,
  iconVariant: defaultIconVariants,
  anchorOrigin: {
    vertical: "bottom",
    horizontal: "left"
  },
  TransitionComponent: Slide,
  transitionDuration: {
    enter: 225,
    exit: 195
  }
};
var getAutoHideDuration = function getAutoHideDuration2(optionsDuration, propsDuration) {
  var isNumberOrNull = function isNumberOrNull2(numberish) {
    return typeof numberish === "number" || numberish === null;
  };
  if (isNumberOrNull(optionsDuration)) return optionsDuration;
  if (isNumberOrNull(propsDuration)) return propsDuration;
  return defaults.autoHideDuration;
};
var getTransitionDuration = function getTransitionDuration2(optionsDuration, propsDuration) {
  var is2 = function is22(item, types) {
    return types.some(function(t2) {
      return typeof item === t2;
    });
  };
  if (is2(optionsDuration, ["string", "number"])) {
    return optionsDuration;
  }
  if (is2(optionsDuration, ["object"])) {
    return _extends({}, defaults.transitionDuration, {}, is2(propsDuration, ["object"]) && propsDuration, {}, optionsDuration);
  }
  if (is2(propsDuration, ["string", "number"])) {
    return propsDuration;
  }
  if (is2(propsDuration, ["object"])) {
    return _extends({}, defaults.transitionDuration, {}, propsDuration);
  }
  return defaults.transitionDuration;
};
var merge = function merge2(options, props) {
  return function(name2, shouldObjectMerge) {
    if (shouldObjectMerge === void 0) {
      shouldObjectMerge = false;
    }
    if (shouldObjectMerge) {
      return _extends({}, defaults[name2], {}, props[name2], {}, options[name2]);
    }
    if (name2 === "autoHideDuration") {
      return getAutoHideDuration(options.autoHideDuration, props.autoHideDuration);
    }
    if (name2 === "transitionDuration") {
      return getTransitionDuration(options.transitionDuration, props.transitionDuration);
    }
    return options[name2] || props[name2] || defaults[name2];
  };
};
function makeStyles(styles2) {
  return Object.entries(styles2).reduce(function(acc, _ref) {
    var _extends2;
    var key = _ref[0], value2 = _ref[1];
    return _extends({}, acc, (_extends2 = {}, _extends2[key] = u(value2), _extends2));
  }, {});
}
var ComponentClasses = {
  SnackbarContainer: "notistack-SnackbarContainer",
  Snackbar: "notistack-Snackbar",
  CollapseWrapper: "notistack-CollapseWrapper",
  MuiContent: "notistack-MuiContent",
  MuiContentVariant: function MuiContentVariant(variant) {
    return "notistack-MuiContent-" + variant;
  }
};
var classes = /* @__PURE__ */ makeStyles({
  root: {
    height: 0
  },
  entered: {
    height: "auto"
  }
});
var collapsedSize = "0px";
var timeout = 175;
var Collapse = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var children = props.children, inProp = props["in"], onExited = props.onExited;
  var wrapperRef = reactExports.useRef(null);
  var nodeRef = reactExports.useRef(null);
  var handleRef = useForkRef(ref, nodeRef);
  var getWrapperSize = function getWrapperSize2() {
    return wrapperRef.current ? wrapperRef.current.clientHeight : 0;
  };
  var handleEnter = function handleEnter2(node) {
    node.style.height = collapsedSize;
  };
  var handleEntering = function handleEntering2(node) {
    var wrapperSize = getWrapperSize();
    var _getTransitionProps = getTransitionProps({
      timeout,
      mode: "enter"
    }), transitionDuration = _getTransitionProps.duration, easing = _getTransitionProps.easing;
    node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
    node.style.height = wrapperSize + "px";
    node.style.transitionTimingFunction = easing || "";
  };
  var handleEntered = function handleEntered2(node) {
    node.style.height = "auto";
  };
  var handleExit = function handleExit2(node) {
    node.style.height = getWrapperSize() + "px";
  };
  var handleExiting = function handleExiting2(node) {
    reflow(node);
    var _getTransitionProps2 = getTransitionProps({
      timeout,
      mode: "exit"
    }), transitionDuration = _getTransitionProps2.duration, easing = _getTransitionProps2.easing;
    node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
    node.style.height = collapsedSize;
    node.style.transitionTimingFunction = easing || "";
  };
  return reactExports.createElement(Transition, {
    "in": inProp,
    unmountOnExit: true,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited,
    onExiting: handleExiting,
    nodeRef,
    timeout
  }, function(state, childProps) {
    return reactExports.createElement("div", Object.assign({
      ref: handleRef,
      className: clsx(classes.root, state === "entered" && classes.entered),
      style: _extends({
        pointerEvents: "all",
        overflow: "hidden",
        minHeight: collapsedSize,
        transition: createTransition("height")
      }, state === "entered" && {
        overflow: "visible"
      }, {}, state === "exited" && !inProp && {
        visibility: "hidden"
      })
    }, childProps), reactExports.createElement("div", {
      ref: wrapperRef,
      className: ComponentClasses.CollapseWrapper,
      // Hack to get children with a negative margin to not falsify the height computation.
      style: {
        display: "flex",
        width: "100%"
      }
    }, children));
  });
});
Collapse.displayName = "Collapse";
var direction = {
  right: "left",
  left: "right",
  bottom: "up",
  top: "down"
};
var getSlideDirection = function getSlideDirection2(anchorOrigin) {
  if (anchorOrigin.horizontal !== "center") {
    return direction[anchorOrigin.horizontal];
  }
  return direction[anchorOrigin.vertical];
};
var toSnackbarAnchorOrigin = function toSnackbarAnchorOrigin2(anchorOrigin) {
  return "anchorOrigin" + originKeyExtractor(anchorOrigin);
};
var keepSnackbarClassKeys = function keepSnackbarClassKeys2(classes2) {
  if (classes2 === void 0) {
    classes2 = {};
  }
  var containerClasses = {
    containerRoot: true,
    containerAnchorOriginTopCenter: true,
    containerAnchorOriginBottomCenter: true,
    containerAnchorOriginTopRight: true,
    containerAnchorOriginBottomRight: true,
    containerAnchorOriginTopLeft: true,
    containerAnchorOriginBottomLeft: true
  };
  return Object.keys(classes2).filter(function(key) {
    return !containerClasses[key];
  }).reduce(function(obj, key) {
    var _extends2;
    return _extends({}, obj, (_extends2 = {}, _extends2[key] = classes2[key], _extends2));
  }, {});
};
var noOp$1 = function noOp3() {
};
function createChainedFunction(funcs, snackbarId) {
  return funcs.reduce(function(acc, func) {
    if (func === null || func === void 0) {
      return acc;
    }
    return function chainedFunction() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argums = [].concat(args);
      if (snackbarId && argums.indexOf(snackbarId) === -1) {
        argums.push(snackbarId);
      }
      acc.apply(this, argums);
      func.apply(this, argums);
    };
  }, noOp$1);
}
var useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEventCallback(fn) {
  var ref = reactExports.useRef(fn);
  useEnhancedEffect(function() {
    ref.current = fn;
  });
  return reactExports.useCallback(function() {
    return (
      // @ts-expect-error hide `this`
      ref.current.apply(void 0, arguments)
    );
  }, []);
}
var Snackbar = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var children = props.children, className = props.className, autoHideDuration = props.autoHideDuration, _props$disableWindowB = props.disableWindowBlurListener, disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB, onClose = props.onClose, id = props.id, open = props.open, _props$SnackbarProps = props.SnackbarProps, SnackbarProps = _props$SnackbarProps === void 0 ? {} : _props$SnackbarProps;
  var timerAutoHide = reactExports.useRef();
  var handleClose = useEventCallback(function() {
    if (onClose) {
      onClose.apply(void 0, arguments);
    }
  });
  var setAutoHideTimer = useEventCallback(function(autoHideDurationParam) {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    if (timerAutoHide.current) {
      clearTimeout(timerAutoHide.current);
    }
    timerAutoHide.current = setTimeout(function() {
      handleClose(null, "timeout", id);
    }, autoHideDurationParam);
  });
  reactExports.useEffect(function() {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return function() {
      if (timerAutoHide.current) {
        clearTimeout(timerAutoHide.current);
      }
    };
  }, [open, autoHideDuration, setAutoHideTimer]);
  var handlePause = function handlePause2() {
    if (timerAutoHide.current) {
      clearTimeout(timerAutoHide.current);
    }
  };
  var handleResume = reactExports.useCallback(function() {
    if (autoHideDuration != null) {
      setAutoHideTimer(autoHideDuration * 0.5);
    }
  }, [autoHideDuration, setAutoHideTimer]);
  var handleMouseEnter = function handleMouseEnter2(event) {
    if (SnackbarProps.onMouseEnter) {
      SnackbarProps.onMouseEnter(event);
    }
    handlePause();
  };
  var handleMouseLeave = function handleMouseLeave2(event) {
    if (SnackbarProps.onMouseLeave) {
      SnackbarProps.onMouseLeave(event);
    }
    handleResume();
  };
  reactExports.useEffect(function() {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return function() {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, handleResume, open]);
  return reactExports.createElement("div", Object.assign({
    ref
  }, SnackbarProps, {
    className: clsx(ComponentClasses.Snackbar, className),
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), children);
});
Snackbar.displayName = "Snackbar";
var _root;
var classes$1 = /* @__PURE__ */ makeStyles({
  root: (_root = {
    display: "flex",
    flexWrap: "wrap",
    flexGrow: 1
  }, _root[breakpoints.upSm] = {
    flexGrow: "initial",
    minWidth: "288px"
  }, _root)
});
var SnackbarContent = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
  var className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, ["className"]);
  return React__default$1.createElement("div", Object.assign({
    ref,
    className: clsx(classes$1.root, className)
  }, props));
});
SnackbarContent.displayName = "SnackbarContent";
var classes$2 = /* @__PURE__ */ makeStyles({
  root: {
    backgroundColor: "#313131",
    fontSize: "0.875rem",
    lineHeight: 1.43,
    letterSpacing: "0.01071em",
    color: "#fff",
    alignItems: "center",
    padding: "6px 16px",
    borderRadius: "4px",
    boxShadow: "0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)"
  },
  lessPadding: {
    paddingLeft: 8 * 2.5 + "px"
  },
  "default": {
    backgroundColor: "#313131"
  },
  success: {
    backgroundColor: "#43a047"
  },
  error: {
    backgroundColor: "#d32f2f"
  },
  warning: {
    backgroundColor: "#ff9800"
  },
  info: {
    backgroundColor: "#2196f3"
  },
  message: {
    display: "flex",
    alignItems: "center",
    padding: "8px 0"
  },
  action: {
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: "16px",
    marginRight: "-8px"
  }
});
var ariaDescribedby = "notistack-snackbar";
var MaterialDesignContent = /* @__PURE__ */ reactExports.forwardRef(function(props, forwardedRef) {
  var id = props.id, message2 = props.message, componentOrFunctionAction = props.action, iconVariant = props.iconVariant, variant = props.variant, hideIconVariant = props.hideIconVariant, style2 = props.style, className = props.className;
  var icon = iconVariant[variant];
  var action = componentOrFunctionAction;
  if (typeof action === "function") {
    action = action(id);
  }
  return React__default$1.createElement(SnackbarContent, {
    ref: forwardedRef,
    role: "alert",
    "aria-describedby": ariaDescribedby,
    style: style2,
    className: clsx(ComponentClasses.MuiContent, ComponentClasses.MuiContentVariant(variant), classes$2.root, classes$2[variant], className, !hideIconVariant && icon && classes$2.lessPadding)
  }, React__default$1.createElement("div", {
    id: ariaDescribedby,
    className: classes$2.message
  }, !hideIconVariant ? icon : null, message2), action && React__default$1.createElement("div", {
    className: classes$2.action
  }, action));
});
MaterialDesignContent.displayName = "MaterialDesignContent";
var MaterialDesignContent$1 = /* @__PURE__ */ reactExports.memo(MaterialDesignContent);
var styles = /* @__PURE__ */ makeStyles({
  wrappedRoot: {
    width: "100%",
    position: "relative",
    transform: "translateX(0)",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    minWidth: "288px"
  }
});
var SnackbarItem = function SnackbarItem2(props) {
  var timeout2 = reactExports.useRef();
  var _useState = reactExports.useState(true), collapsed = _useState[0], setCollapsed = _useState[1];
  var handleClose = createChainedFunction([props.snack.onClose, props.onClose]);
  var handleEntered = function handleEntered2() {
    if (props.snack.requestClose) {
      handleClose(null, "instructed", props.snack.id);
    }
  };
  var handleExitedScreen = reactExports.useCallback(function() {
    timeout2.current = setTimeout(function() {
      setCollapsed(function(col) {
        return !col;
      });
    }, 125);
  }, []);
  reactExports.useEffect(function() {
    return function() {
      if (timeout2.current) {
        clearTimeout(timeout2.current);
      }
    };
  }, []);
  var snack = props.snack, allClasses = props.classes, _props$Component = props.Component, Component2 = _props$Component === void 0 ? MaterialDesignContent$1 : _props$Component;
  var classes2 = reactExports.useMemo(function() {
    return keepSnackbarClassKeys(allClasses);
  }, [allClasses]);
  var open = snack.open, SnackbarProps = snack.SnackbarProps, TransitionComponent = snack.TransitionComponent, TransitionProps = snack.TransitionProps, transitionDuration = snack.transitionDuration, disableWindowBlurListener = snack.disableWindowBlurListener, componentOrFunctionContent = snack.content, otherSnack = _objectWithoutPropertiesLoose(snack, ["open", "SnackbarProps", "TransitionComponent", "TransitionProps", "transitionDuration", "disableWindowBlurListener", "content", "entered", "requestClose", "onEnter", "onEntered", "onExit", "onExited"]);
  var transitionProps = _extends({
    direction: getSlideDirection(otherSnack.anchorOrigin),
    timeout: transitionDuration
  }, TransitionProps);
  var content2 = componentOrFunctionContent;
  if (typeof content2 === "function") {
    content2 = content2(otherSnack.id, otherSnack.message);
  }
  var callbacks = ["onEnter", "onEntered", "onExit", "onExited"].reduce(function(acc, cbName) {
    var _extends2;
    return _extends({}, acc, (_extends2 = {}, _extends2[cbName] = createChainedFunction([props.snack[cbName], props[cbName]], otherSnack.id), _extends2));
  }, {});
  return React__default$1.createElement(Collapse, {
    "in": collapsed,
    onExited: callbacks.onExited
  }, React__default$1.createElement(Snackbar, {
    open,
    id: otherSnack.id,
    disableWindowBlurListener,
    autoHideDuration: otherSnack.autoHideDuration,
    className: clsx(styles.wrappedRoot, classes2.root, classes2[toSnackbarAnchorOrigin(otherSnack.anchorOrigin)]),
    SnackbarProps,
    onClose: handleClose
  }, React__default$1.createElement(TransitionComponent, Object.assign({}, transitionProps, {
    appear: true,
    "in": open,
    onExit: callbacks.onExit,
    onExited: handleExitedScreen,
    onEnter: callbacks.onEnter,
    // order matters. first callbacks.onEntered to set entered: true,
    // then handleEntered to check if there's a request for closing
    onEntered: createChainedFunction([callbacks.onEntered, handleEntered], otherSnack.id)
  }), content2 || React__default$1.createElement(Component2, Object.assign({}, otherSnack)))));
};
var _root$1, _rootDense, _left, _right, _center;
var indents = {
  view: {
    "default": 20
  },
  snackbar: {
    "default": 6,
    dense: 2
  }
};
var collapseWrapper = "." + ComponentClasses.CollapseWrapper;
var xsWidthMargin = 16;
var styles$1 = /* @__PURE__ */ makeStyles({
  root: (_root$1 = {
    boxSizing: "border-box",
    display: "flex",
    maxHeight: "100%",
    position: "fixed",
    zIndex: 1400,
    height: "auto",
    width: "auto",
    transition: /* @__PURE__ */ createTransition(["top", "right", "bottom", "left", "max-width"], {
      duration: 300,
      easing: "ease"
    }),
    // container itself is invisible and should not block clicks, clicks should be passed to its children
    // a pointerEvents: all is applied in the collapse component
    pointerEvents: "none"
  }, _root$1[collapseWrapper] = {
    padding: indents.snackbar["default"] + "px 0px",
    transition: "padding 300ms ease 0ms"
  }, _root$1.maxWidth = "calc(100% - " + indents.view["default"] * 2 + "px)", _root$1[breakpoints.downXs] = {
    width: "100%",
    maxWidth: "calc(100% - " + xsWidthMargin * 2 + "px)"
  }, _root$1),
  rootDense: (_rootDense = {}, _rootDense[collapseWrapper] = {
    padding: indents.snackbar.dense + "px 0px"
  }, _rootDense),
  top: {
    top: indents.view["default"] - indents.snackbar["default"] + "px",
    flexDirection: "column"
  },
  bottom: {
    bottom: indents.view["default"] - indents.snackbar["default"] + "px",
    flexDirection: "column-reverse"
  },
  left: (_left = {
    left: indents.view["default"] + "px"
  }, _left[breakpoints.upSm] = {
    alignItems: "flex-start"
  }, _left[breakpoints.downXs] = {
    left: xsWidthMargin + "px"
  }, _left),
  right: (_right = {
    right: indents.view["default"] + "px"
  }, _right[breakpoints.upSm] = {
    alignItems: "flex-end"
  }, _right[breakpoints.downXs] = {
    right: xsWidthMargin + "px"
  }, _right),
  center: (_center = {
    left: "50%",
    transform: "translateX(-50%)"
  }, _center[breakpoints.upSm] = {
    alignItems: "center"
  }, _center)
});
var SnackbarContainer = function SnackbarContainer2(props) {
  var _props$classes = props.classes, classes2 = _props$classes === void 0 ? {} : _props$classes, anchorOrigin = props.anchorOrigin, dense = props.dense, children = props.children;
  var combinedClassname = clsx(
    ComponentClasses.SnackbarContainer,
    styles$1[anchorOrigin.vertical],
    styles$1[anchorOrigin.horizontal],
    styles$1.root,
    // root should come after others to override maxWidth
    classes2.containerRoot,
    classes2["containerAnchorOrigin" + originKeyExtractor(anchorOrigin)],
    dense && styles$1.rootDense
  );
  return React__default$1.createElement("div", {
    className: combinedClassname
  }, children);
};
var SnackbarContainer$1 = /* @__PURE__ */ reactExports.memo(SnackbarContainer);
var __DEV__ = define_process_env_default.NODE_ENV !== "production";
var messages = {
  NO_PERSIST_ALL: "Reached maxSnack while all enqueued snackbars have 'persist' flag. Notistack will dismiss the oldest snackbar anyway to allow other ones in the queue to be presented."
};
var warning = function(messageKey) {
  if (!__DEV__) return;
  var message2 = messages[messageKey];
  if (typeof console !== "undefined") {
    console.error("WARNING - notistack: " + message2);
  }
  try {
    throw new Error(message2);
  } catch (x) {
  }
};
var isOptions = function isOptions2(messageOrOptions) {
  var isMessage = typeof messageOrOptions === "string" || reactExports.isValidElement(messageOrOptions);
  return !isMessage;
};
var enqueueSnackbar;
var SnackbarProvider = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(SnackbarProvider2, _Component);
  function SnackbarProvider2(props) {
    var _this;
    _this = _Component.call(this, props) || this;
    _this.enqueueSnackbar = function(messageOrOptions, optsOrUndefined) {
      if (optsOrUndefined === void 0) {
        optsOrUndefined = {};
      }
      if (messageOrOptions === void 0 || messageOrOptions === null) {
        throw new Error("enqueueSnackbar called with invalid argument");
      }
      var opts = isOptions(messageOrOptions) ? messageOrOptions : optsOrUndefined;
      var message2 = isOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions;
      var key = opts.key, preventDuplicate = opts.preventDuplicate, options = _objectWithoutPropertiesLoose(opts, ["key", "preventDuplicate"]);
      var hasSpecifiedKey = isDefined(key);
      var id = hasSpecifiedKey ? key : (/* @__PURE__ */ new Date()).getTime() + Math.random();
      var merger = merge(options, _this.props);
      var snack = _extends({
        id
      }, options, {
        message: message2,
        open: true,
        entered: false,
        requestClose: false,
        persist: merger("persist"),
        action: merger("action"),
        content: merger("content"),
        variant: merger("variant"),
        anchorOrigin: merger("anchorOrigin"),
        disableWindowBlurListener: merger("disableWindowBlurListener"),
        autoHideDuration: merger("autoHideDuration"),
        hideIconVariant: merger("hideIconVariant"),
        TransitionComponent: merger("TransitionComponent"),
        transitionDuration: merger("transitionDuration"),
        TransitionProps: merger("TransitionProps", true),
        iconVariant: merger("iconVariant", true),
        style: merger("style", true),
        SnackbarProps: merger("SnackbarProps", true),
        className: clsx(_this.props.className, options.className)
      });
      if (snack.persist) {
        snack.autoHideDuration = void 0;
      }
      _this.setState(function(state) {
        if (preventDuplicate === void 0 && _this.props.preventDuplicate || preventDuplicate) {
          var compareFunction = function compareFunction2(item) {
            return hasSpecifiedKey ? item.id === id : item.message === message2;
          };
          var inQueue = state.queue.findIndex(compareFunction) > -1;
          var inView = state.snacks.findIndex(compareFunction) > -1;
          if (inQueue || inView) {
            return state;
          }
        }
        return _this.handleDisplaySnack(_extends({}, state, {
          queue: [].concat(state.queue, [snack])
        }));
      });
      return id;
    };
    _this.handleDisplaySnack = function(state) {
      var snacks = state.snacks;
      if (snacks.length >= _this.maxSnack) {
        return _this.handleDismissOldest(state);
      }
      return _this.processQueue(state);
    };
    _this.processQueue = function(state) {
      var queue2 = state.queue, snacks = state.snacks;
      if (queue2.length > 0) {
        return _extends({}, state, {
          snacks: [].concat(snacks, [queue2[0]]),
          queue: queue2.slice(1, queue2.length)
        });
      }
      return state;
    };
    _this.handleDismissOldest = function(state) {
      if (state.snacks.some(function(item) {
        return !item.open || item.requestClose;
      })) {
        return state;
      }
      var popped = false;
      var ignore = false;
      var persistentCount = state.snacks.reduce(function(acc, current2) {
        return acc + (current2.open && current2.persist ? 1 : 0);
      }, 0);
      if (persistentCount === _this.maxSnack) {
        define_process_env_default.NODE_ENV !== "production" ? warning("NO_PERSIST_ALL") : void 0;
        ignore = true;
      }
      var snacks = state.snacks.map(function(item) {
        if (!popped && (!item.persist || ignore)) {
          popped = true;
          if (!item.entered) {
            return _extends({}, item, {
              requestClose: true
            });
          }
          if (item.onClose) {
            item.onClose(null, "maxsnack", item.id);
          }
          if (_this.props.onClose) {
            _this.props.onClose(null, "maxsnack", item.id);
          }
          return _extends({}, item, {
            open: false
          });
        }
        return _extends({}, item);
      });
      return _extends({}, state, {
        snacks
      });
    };
    _this.handleEnteredSnack = function(node, isAppearing, key) {
      if (!isDefined(key)) {
        throw new Error("handleEnteredSnack Cannot be called with undefined key");
      }
      _this.setState(function(_ref) {
        var snacks = _ref.snacks;
        return {
          snacks: snacks.map(function(item) {
            return item.id === key ? _extends({}, item, {
              entered: true
            }) : _extends({}, item);
          })
        };
      });
    };
    _this.handleCloseSnack = function(event, reason, key) {
      if (_this.props.onClose) {
        _this.props.onClose(event, reason, key);
      }
      var shouldCloseAll = key === void 0;
      _this.setState(function(_ref2) {
        var snacks = _ref2.snacks, queue2 = _ref2.queue;
        return {
          snacks: snacks.map(function(item) {
            if (!shouldCloseAll && item.id !== key) {
              return _extends({}, item);
            }
            return item.entered ? _extends({}, item, {
              open: false
            }) : _extends({}, item, {
              requestClose: true
            });
          }),
          queue: queue2.filter(function(item) {
            return item.id !== key;
          })
        };
      });
    };
    _this.closeSnackbar = function(key) {
      var toBeClosed = _this.state.snacks.find(function(item) {
        return item.id === key;
      });
      if (isDefined(key) && toBeClosed && toBeClosed.onClose) {
        toBeClosed.onClose(null, "instructed", key);
      }
      _this.handleCloseSnack(null, "instructed", key);
    };
    _this.handleExitedSnack = function(node, key) {
      if (!isDefined(key)) {
        throw new Error("handleExitedSnack Cannot be called with undefined key");
      }
      _this.setState(function(state) {
        var newState = _this.processQueue(_extends({}, state, {
          snacks: state.snacks.filter(function(item) {
            return item.id !== key;
          })
        }));
        if (newState.queue.length === 0) {
          return newState;
        }
        return _this.handleDismissOldest(newState);
      });
    };
    enqueueSnackbar = _this.enqueueSnackbar;
    _this.closeSnackbar;
    _this.state = {
      snacks: [],
      queue: [],
      contextValue: {
        enqueueSnackbar: _this.enqueueSnackbar.bind(_assertThisInitialized(_this)),
        closeSnackbar: _this.closeSnackbar.bind(_assertThisInitialized(_this))
      }
    };
    return _this;
  }
  var _proto = SnackbarProvider2.prototype;
  _proto.render = function render() {
    var _this2 = this;
    var contextValue = this.state.contextValue;
    var _this$props = this.props, domRoot = _this$props.domRoot, children = _this$props.children, _this$props$dense = _this$props.dense, dense = _this$props$dense === void 0 ? false : _this$props$dense, _this$props$Component = _this$props.Components, Components = _this$props$Component === void 0 ? {} : _this$props$Component, classes2 = _this$props.classes;
    var categ = this.state.snacks.reduce(function(acc, current2) {
      var _extends2;
      var category = originKeyExtractor(current2.anchorOrigin);
      var existingOfCategory = acc[category] || [];
      return _extends({}, acc, (_extends2 = {}, _extends2[category] = [].concat(existingOfCategory, [current2]), _extends2));
    }, {});
    var snackbars = Object.keys(categ).map(function(origin2) {
      var snacks = categ[origin2];
      var nomineeSnack = snacks[0];
      return React__default$1.createElement(SnackbarContainer$1, {
        key: origin2,
        dense,
        anchorOrigin: nomineeSnack.anchorOrigin,
        classes: classes2
      }, snacks.map(function(snack) {
        return React__default$1.createElement(SnackbarItem, {
          key: snack.id,
          snack,
          classes: classes2,
          Component: Components[snack.variant],
          onClose: _this2.handleCloseSnack,
          onEnter: _this2.props.onEnter,
          onExit: _this2.props.onExit,
          onExited: createChainedFunction([_this2.handleExitedSnack, _this2.props.onExited], snack.id),
          onEntered: createChainedFunction([_this2.handleEnteredSnack, _this2.props.onEntered], snack.id)
        });
      }));
    });
    return React__default$1.createElement(SnackbarContext.Provider, {
      value: contextValue
    }, children, domRoot ? reactDomExports.createPortal(snackbars, domRoot) : snackbars);
  };
  _createClass(SnackbarProvider2, [{
    key: "maxSnack",
    get: function get2() {
      return this.props.maxSnack || defaults.maxSnack;
    }
  }]);
  return SnackbarProvider2;
}(reactExports.Component);
const reg_exp_images = /\.(gif|jpe?g|tiff?|png|webp|bmp)$/i;
function regex_type_file(str = "", reg_exp = reg_exp_images) {
  const regex = new RegExp(reg_exp);
  return regex.test(str);
}
function getStorage(key, defaultValue, parseJson = true) {
  try {
    const item = localStorage.getItem(key);
    if (item === null) {
      return defaultValue ?? null;
    }
    return parseJson ? JSON.parse(item) : item;
  } catch (error) {
    const item = localStorage.getItem(key);
    if (item !== null) {
      return item;
    }
    console.error(`Error getting ${key} from localStorage:`, error);
    return defaultValue ?? null;
  }
}
function setStorage(key, value2) {
  try {
    localStorage.setItem(key, JSON.stringify(value2));
    return true;
  } catch (error) {
    console.error(`Error setting ${key} in localStorage:`, error);
    return false;
  }
}
function removeStorage(key) {
  try {
    localStorage.removeItem(key);
    return true;
  } catch (error) {
    console.error(`Error removing ${key} from localStorage:`, error);
    return false;
  }
}
var StatsTusData = /* @__PURE__ */ ((StatsTusData2) => {
  StatsTusData2["NO_DATA"] = "NO_DATA";
  StatsTusData2["LOADING_DATA"] = "LOADING_DATA";
  StatsTusData2["DATA"] = "DATA";
  return StatsTusData2;
})(StatsTusData || {});
const defaultSessionChat = {
  _id: "",
  channel: "",
  conversationId: "",
  senderId: "",
  applicationId: " 0",
  applicationName: "",
  cloudTenantId: 0,
  messageStatus: "",
  messageType: "",
  messageFrom: "",
  sendFrom: "",
  text: "",
  senderName: "",
  socialMessageId: "",
  receivedTime: "",
  __v: 0
};
const STATUS_SCROLL = {
  START: "START"
};
const initialScrollConversation = {
  position: 0,
  conversationId: "",
  pushNotification: false,
  status: STATUS_SCROLL.START
};
const initialChannelMessages = {
  data: [],
  totalConversations: 0,
  success: false,
  statusCode: 0,
  hasMore: false,
  statusData: StatsTusData.LOADING_DATA
};
const ShowSession = {
  ClickFromList: "ClickFromList"
};
const Tab_Conversation = {
  assignToMe: "TAB_ASSIGN_TO_ME"
};
const axiosAuth = axios.create({
  baseURL: CONFIG_URL,
  headers: {
    "Content-Type": "application/json"
  }
});
axiosAuth.interceptors.request.use(
  async (config) => {
    var _a, _b, _c, _d;
    config.baseURL = config_url.base_url;
    const storeState = store.getState();
    const token = getStorage("token") ?? ((_a = storeState.auth) == null ? void 0 : _a.accessToken);
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    const tenantId = localStorage.getItem("tenantId") || ((_d = (_c = (_b = storeState.auth) == null ? void 0 : _b.info) == null ? void 0 : _c.tenant) == null ? void 0 : _d.id);
    if (tenantId) {
      config.headers["Abp.TenantId"] = tenantId;
    }
    return config;
  },
  (error) => Promise.reject(error)
);
axiosAuth.interceptors.response.use(
  (response) => response,
  async (error) => {
    return Promise.reject(error);
  }
);
const poseEndSession = (obj) => axiosAuth.post("/chat-acd/conversation/close", obj);
const putSeenMessage = (obj) => {
  return axiosAuth.put("/chat-acd/conversation/read-all", obj);
};
const axiosNotAuth = axios.create({
  baseURL: CONFIG_URL,
  headers: {
    "Content-Type": "application/json"
  }
});
axiosNotAuth.interceptors.request.use(
  async (config) => {
    config.baseURL = config_url.base_url;
    return config;
  },
  (error) => Promise.reject(error)
);
axiosNotAuth.interceptors.response.use(
  (response) => response,
  async (error) => {
    return Promise.reject(error);
  }
);
const openTakeCareConversation = (data) => {
  return axiosAuth.post(
    `chat-acd/conversation/start-outbound`,
    data
  );
};
const postContactDapperBySenders = (obj) => axiosNotAuth.post(
  "/contact/api/v1/contact/find-by-interaction",
  obj
);
const getAgentQueues = (params) => axiosNotAuth.get(
  `contact-center/agent/queues?agentId=${params == null ? void 0 : params.agentId}&tenantId=${params == null ? void 0 : params.tenantId}`
);
const putAgentQueues = (body) => axiosNotAuth.put("contact-center/agent/queues", body);
const postAcceptTransfer = (body) => {
  return axiosNotAuth.post(
    `workflow/${body == null ? void 0 : body.sessionId}/acceptTransfer`,
    body
  );
};
const postRefuseTransfer = (body) => {
  return axiosNotAuth.post(
    `workflow/${body == null ? void 0 : body.sessionId}/refuseTransfer`,
    body
  );
};
const postEndCall = (body) => {
  return axiosNotAuth.post(
    `workflow/${body == null ? void 0 : body.sessionId}/end`,
    body
  );
};
const getGroupsAgents = (params) => {
  return axiosNotAuth.get(
    "/contact-center/queue",
    { params }
  );
};
const getQueueAgent = (id) => {
  return axiosNotAuth.get(
    `/contact-center/queue/${id}/agents`
  );
};
const getAgentsByExtension = (params) => {
  return axiosNotAuth.get(
    `/contact-center/queue/agentsByExtension`,
    {
      params
    }
  );
};
const postTransferConversation = (body) => {
  return axiosNotAuth.post(
    `/workflow/${body == null ? void 0 : body.sessionId}/transfer`,
    body
  );
};
const postHoldCall = (body) => {
  return axiosNotAuth.post(
    `workflow/${body == null ? void 0 : body.sessionId}/hold`,
    {
      ...body ?? {},
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    }
  );
};
const postUnHoldCall = (body) => {
  return axiosNotAuth.post(
    `workflow/${body == null ? void 0 : body.sessionId}/unhold`,
    {
      ...body ?? {},
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    }
  );
};
const findSession = createAsyncThunk(
  "agent/findSessionChat",
  async (body, { rejectWithValue }) => {
    try {
      const res = await axiosAuth.post(
        "/chat-acd/message/find-by-sender",
        body,
        {
          headers: {
            // Authorization: `Bearer ${session?.accessToken}`,
          }
        }
      );
      return res.data;
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);
const updateConversationListAsync = createAsyncThunk(
  "updateConversationListAsync",
  async (body, { rejectWithValue, dispatch, getState }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    try {
      const state = getState();
      const conversationLists = ((_a = state == null ? void 0 : state.agent) == null ? void 0 : _a.conversationLists) || [];
      const findIndex = conversationLists.findIndex(
        (item) => item.senderId === (body == null ? void 0 : body.senderId) && item.applicationId === body.applicationId
      );
      if (findIndex >= 0) {
        const checkScroll = ((_b = state == null ? void 0 : state.agent) == null ? void 0 : _b.scrollConversation.position) >= 0 && ((_c = body == null ? void 0 : body.lastMessage) == null ? void 0 : _c.conversationId) === ((_e = (_d = state == null ? void 0 : state.agent) == null ? void 0 : _d.conversation) == null ? void 0 : _e.conversationId) ? false : true;
        if (!checkScroll) {
          putSeenMessage({
            applicationId: body.applicationId,
            senderId: body.senderId,
            tenantId: body == null ? void 0 : body.cloudTenantId
          });
        }
        const data = updateContactLastMessage({
          data: [...conversationLists],
          findIndex,
          unReadCount: !checkScroll ? 0 : body.unReadCount,
          payload: { ...conversationLists[findIndex], ...body }
        });
        return {
          conversationLists: sortTimeDesc(data, "lastTime"),
          unReadCount: !checkScroll ? 0 : body.unReadCount
        };
      } else {
        const contact2 = {
          ...body,
          // notSeen,
          unReadCount: body.unReadCount
        };
        if (!(contact2 == null ? void 0 : contact2.contactId) && (contact2 == null ? void 0 : contact2.senderId)) {
          const res = await postContactDapperBySenders({
            types: [0, 2, 3],
            values: [contact2 == null ? void 0 : contact2.senderId]
          });
          if ((_f = res == null ? void 0 : res.data) == null ? void 0 : _f.success) {
            if ((_h = (_g = res == null ? void 0 : res.data) == null ? void 0 : _g.data) == null ? void 0 : _h[0]) {
              contact2.contactId = (_k = (_j = (_i = res == null ? void 0 : res.data) == null ? void 0 : _i.data) == null ? void 0 : _j[0]) == null ? void 0 : _k.id;
              contact2.contactName = (_n = (_m = (_l = res == null ? void 0 : res.data) == null ? void 0 : _l.data) == null ? void 0 : _m[0]) == null ? void 0 : _n.name;
              return {
                conversationLists: [contact2, ...conversationLists],
                unReadCount: body.unReadCount
              };
            }
          }
        }
        return {
          conversationLists: [contact2, ...conversationLists],
          unReadCount: body.unReadCount
        };
      }
    } catch (error) {
      dispatch(updateConversationList(body));
      return rejectWithValue(error);
    }
  }
);
const updateViewRecentlyAsync = createAsyncThunk(
  "updateViewRecentlyAsync",
  async (body, { rejectWithValue, dispatch, getState }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    try {
      const state = getState();
      const agent2 = state == null ? void 0 : state.agent;
      const conversation2 = { ...agent2.conversation };
      const data = { ...body.data };
      if ((conversation2 == null ? void 0 : conversation2.senderId) !== (data == null ? void 0 : data.senderId) || (conversation2 == null ? void 0 : conversation2.senderId) === (data == null ? void 0 : data.senderId) && !(conversation2 == null ? void 0 : conversation2.contactId)) {
        if ((data == null ? void 0 : data.senderId) && !(data == null ? void 0 : data.contactId)) {
          const res = await postContactDapperBySenders({
            types: [0, 2, 3],
            values: [data == null ? void 0 : data.senderId]
          });
          if ((_a = res == null ? void 0 : res.data) == null ? void 0 : _a.success) {
            if ((_c = (_b = res == null ? void 0 : res.data) == null ? void 0 : _b.data) == null ? void 0 : _c[0]) {
              data.contactId = (_f = (_e = (_d = res == null ? void 0 : res.data) == null ? void 0 : _d.data) == null ? void 0 : _e[0]) == null ? void 0 : _f.id;
              data.contactName = (_i = (_h = (_g = res == null ? void 0 : res.data) == null ? void 0 : _g.data) == null ? void 0 : _h[0]) == null ? void 0 : _i.name;
              conversation2.contactId = (_l = (_k = (_j = res == null ? void 0 : res.data) == null ? void 0 : _j.data) == null ? void 0 : _k[0]) == null ? void 0 : _l.id;
              conversation2.contactName = (_o = (_n = (_m = res == null ? void 0 : res.data) == null ? void 0 : _m.data) == null ? void 0 : _n[0]) == null ? void 0 : _o.name;
            }
          }
        }
      }
      if (((_p = agent2.conversation) == null ? void 0 : _p.applicationId) === ((_q = body.data) == null ? void 0 : _q.applicationId) && ((_r = agent2.conversation) == null ? void 0 : _r.senderId) === body.data.senderId && agent2.conversation) {
        agent2.conversation.conversationId = body.data._id;
        agent2.conversation.conversationState = body.data.conversationState;
        agent2.conversation.agentPicked = (_s = body.data) == null ? void 0 : _s.agentPicked;
      }
      return {
        viewRecentlyLists: stackViewRecentList(
          agent2.viewRecentlyLists,
          data,
          body.isAdd
        ),
        conversation: conversation2
      };
    } catch (error) {
      dispatch(updateViewRecently(body));
      return rejectWithValue(error);
    }
  }
);
const defaultTabIndex = 1;
const initialState$6 = {
  conversation: {},
  cloudAgentId: 0,
  isViewChat: false,
  createSessionChat: defaultSessionChat,
  receivedMessage: defaultSessionChat,
  isReceive: false,
  scrollConversation: initialScrollConversation,
  channelMessages: initialChannelMessages,
  conversationLists: [],
  isPushNotification: false,
  unReadCount: 0,
  tabs: {
    tabIndex: defaultTabIndex,
    tabKey: Tab_Conversation.assignToMe
  },
  queueLists: [],
  viewRecentlyLists: [],
  searchInteracts: {
    openSearchInteract: false,
    search: void 0,
    activeSearchInteract: false
  },
  session: {},
  sendClient: {}
};
const AgentSlice = createSlice({
  name: "agent",
  initialState: initialState$6,
  reducers: {
    clearAgent(state) {
      state.conversation = {};
      state.cloudAgentId = 0;
      state.isViewChat = false;
      state.createSessionChat = defaultSessionChat;
      state.channelMessages = initialChannelMessages;
      state.receivedMessage = defaultSessionChat;
      state.conversationLists = [];
      state.isReceive = false;
      state.scrollConversation = {
        ...initialScrollConversation,
        position: 0
      };
      state.isPushNotification = false;
      state.unReadCount = 0;
      state.tabs = {
        tabIndex: defaultTabIndex,
        tabKey: Tab_Conversation.assignToMe
      };
      state.queueLists = [];
      state.searchInteracts = {
        openSearchInteract: false,
        search: void 0,
        activeSearchInteract: false
      };
      state.sendClient = {};
    },
    showChat(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const obj = ((_a = action.payload) == null ? void 0 : _a.senderId) === ((_b = state.conversation) == null ? void 0 : _b.senderId) && ((_c = action.payload) == null ? void 0 : _c.applicationId) === ((_d = state.conversation) == null ? void 0 : _d.applicationId) ? { ...state.conversation, ...action.payload } : action.payload;
      state.conversation = {
        ...obj,
        cloudAgentId: state.cloudAgentId,
        pageSize: PAGE_SIZE.SM,
        clickFrom: ((_e = action.payload) == null ? void 0 : _e.clickFrom) ? action.payload.clickFrom : ShowSession.ClickFromList,
        objectMessage: ((_f = action.payload) == null ? void 0 : _f.objectMessage) ? {
          ...((_g = state.conversation) == null ? void 0 : _g.objectMessage) || {},
          ...(_h = action.payload) == null ? void 0 : _h.objectMessage
        } : void 0,
        forceUpdate: {}
      };
      state.unReadCount = 0;
      state.scrollConversation.position = 0;
      state.channelMessages.totalConversations = 0;
      state.channelMessages.data = [];
      state.isViewChat = true;
      state.viewRecentlyLists = stackViewRecentList(
        state.viewRecentlyLists,
        (_i = action.payload) == null ? void 0 : _i.item,
        true
      );
    },
    // dùng thằng endChatV2  ko dùng thằng endChat trên nữa
    endChatV2(state, action) {
      var _a, _b, _c, _d, _e, _f;
      const senderId = (_a = state.conversation) == null ? void 0 : _a.senderId;
      const applicationId = (_b = state.conversation) == null ? void 0 : _b.applicationId;
      if (senderId === ((_c = action.payload) == null ? void 0 : _c.senderId) && applicationId === ((_d = action.payload) == null ? void 0 : _d.applicationId)) {
        state.isViewChat = false;
        state.conversation = {};
        state.channelMessages.data = [];
      }
      state.viewRecentlyLists = stackViewRecentList(
        state.viewRecentlyLists,
        action.payload,
        false
      );
      let arrayFilter = [];
      if (((_e = action.payload) == null ? void 0 : _e.senderId) && ((_f = action.payload) == null ? void 0 : _f.applicationId)) {
        arrayFilter = state.conversationLists.filter(
          (item) => {
            var _a2, _b2;
            return !(item.senderId === ((_a2 = action.payload) == null ? void 0 : _a2.senderId) && item.applicationId === ((_b2 = action.payload) == null ? void 0 : _b2.applicationId));
          }
        );
      } else {
        arrayFilter = state.conversationLists;
      }
      state.conversationLists = arrayFilter;
    },
    endChatSocket(state, action) {
      var _a;
      if (action.payload === ((_a = state.conversation) == null ? void 0 : _a.conversationId)) {
        state.isViewChat = false;
      }
      const filterConversation = state.conversationLists.filter(
        (item) => item.conversationId !== action.payload
      );
      state.conversationLists = filterConversation;
    },
    receivedMessageCustom(state, action) {
      state.receivedMessage = action.payload;
      state.isReceive = true;
    },
    clearReceivedMessage(state) {
      state.isReceive = false;
      state.receivedMessage = defaultSessionChat;
    },
    savePositionScroll(state, action) {
      state.scrollConversation.position = action.payload;
    },
    setSessionMessage(state, action) {
      state.channelMessages = {
        ...state.channelMessages,
        ...action.payload
      };
    },
    handleSessionNewMessage(state, action) {
      var _a, _b, _c, _d, _e, _f;
      if ((_a = state == null ? void 0 : state.conversation) == null ? void 0 : _a.conversationId) {
        const checkScroll = state.scrollConversation.position >= 0 ? false : true;
        state.conversation.scroll = checkScroll;
      }
      const data = addSessionChat({
        data: state.channelMessages.data || [],
        createObjSend: { ...action.payload, isAnimation: true },
        channel: (_b = state.conversation) == null ? void 0 : _b.channel,
        applicationId: (_c = state.conversation) == null ? void 0 : _c.applicationId,
        senderName: (_d = state.conversation) == null ? void 0 : _d.senderName
      });
      if ((data == null ? void 0 : data.length) > (((_e = state.channelMessages.data) == null ? void 0 : _e.length) || 0)) {
        state.channelMessages.totalConversations = (state.channelMessages.totalConversations || 0) + ((data == null ? void 0 : data.length) - (((_f = state.channelMessages.data) == null ? void 0 : _f.length) || 0));
      }
      state.channelMessages.data = [];
    },
    seenMessage(state) {
      var _a;
      if ((_a = state == null ? void 0 : state.conversation) == null ? void 0 : _a.conversationId) {
        state.conversation.scroll = false;
      }
    },
    setDataConversionList(state, action) {
      state.conversationLists = action.payload;
    },
    updateConversationList(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      const { conversationLists } = state;
      const findIndex = conversationLists.findIndex(
        (item) => {
          var _a2;
          return item.senderId === ((_a2 = action.payload) == null ? void 0 : _a2.senderId) && item.applicationId === action.payload.applicationId;
        }
      );
      if (findIndex >= 0) {
        const checkScroll = state.scrollConversation.position >= 0 && ((_b = (_a = action.payload) == null ? void 0 : _a.lastMessage) == null ? void 0 : _b.conversationId) === ((_c = state.conversation) == null ? void 0 : _c.conversationId) ? false : true;
        if (!checkScroll) {
          putSeenMessage({
            applicationId: action.payload.applicationId,
            senderId: action.payload.senderId,
            tenantId: (_d = action.payload) == null ? void 0 : _d.cloudTenantId
          });
        }
        const data = updateContactLastMessage({
          data: conversationLists,
          findIndex,
          unReadCount: !checkScroll ? 0 : action.payload.unReadCount,
          payload: { ...conversationLists[findIndex], ...action.payload }
        });
        if (((_e = state.conversation) == null ? void 0 : _e.senderId) === ((_f = action.payload) == null ? void 0 : _f.senderId) && ((_g = state.conversation) == null ? void 0 : _g.applicationId) === action.payload.applicationId) {
          state.unReadCount = !checkScroll ? 0 : ((_h = state.conversation) == null ? void 0 : _h.senderId) === ((_i = action.payload) == null ? void 0 : _i.senderId) && ((_j = state.conversation) == null ? void 0 : _j.applicationId) === action.payload.applicationId ? action.payload.unReadCount : 0;
        }
        state.conversationLists = sortTimeDesc(data, "lastTime");
      } else {
        const contact2 = {
          ...action.payload,
          // notSeen,
          unReadCount: action.payload.unReadCount
        };
        if (((_k = state.conversation) == null ? void 0 : _k.senderId) === ((_l = action.payload) == null ? void 0 : _l.senderId) && ((_m = state.conversation) == null ? void 0 : _m.applicationId) === action.payload.applicationId) {
          state.unReadCount = ((_n = state.conversation) == null ? void 0 : _n.senderId) === ((_o = action.payload) == null ? void 0 : _o.senderId) && ((_p = state.conversation) == null ? void 0 : _p.applicationId) === action.payload.applicationId ? action.payload.unReadCount : 0;
        }
        state.conversationLists = [contact2, ...conversationLists];
      }
    },
    updateConversationItemV2(state, action) {
      var _a, _b, _c, _d;
      const { conversationLists } = state;
      const newData = [...conversationLists];
      const findIndex = newData.findIndex(
        (item) => {
          var _a2, _b2;
          return item.applicationId === ((_a2 = action.payload) == null ? void 0 : _a2.applicationId) && item.senderId === ((_b2 = action.payload) == null ? void 0 : _b2.senderId);
        }
      );
      const obj = action.payload || {};
      if (findIndex >= 0) {
        newData[findIndex] = {
          ...newData[findIndex],
          unReadCount: 0,
          ...obj
        };
      }
      if (((_a = state.conversation) == null ? void 0 : _a.senderId) === ((_b = action.payload) == null ? void 0 : _b.senderId) && ((_c = state.conversation) == null ? void 0 : _c.applicationId) === ((_d = action.payload) == null ? void 0 : _d.applicationId)) {
        state.unReadCount = 0;
      }
      state.conversationLists = newData;
    },
    checkPushNotification(state, action) {
      state.isPushNotification = action.payload;
    },
    incrementTotalRecord(state) {
      state.channelMessages = {
        ...state.channelMessages,
        totalConversations: (state.channelMessages.totalConversations || 0) + 1
      };
    },
    handleSessionCall(state, action) {
      var _a, _b, _c, _d, _e, _f;
      if ((_a = state == null ? void 0 : state.conversation) == null ? void 0 : _a.conversationId) {
        const checkScroll = state.scrollConversation.position >= 0 ? false : true;
        state.conversation.scroll = checkScroll;
      }
      const data = addSessionCall({
        data: state.channelMessages.data || [],
        createObjSend: {
          ...action.payload,
          isAnimation: true
        },
        channel: (_b = state.conversation) == null ? void 0 : _b.channel,
        applicationId: (_c = state.conversation) == null ? void 0 : _c.applicationId,
        senderName: (_d = state.conversation) == null ? void 0 : _d.senderName
      });
      if ((data == null ? void 0 : data.length) > (((_e = state.channelMessages.data) == null ? void 0 : _e.length) || 0)) {
        state.channelMessages.totalConversations = (state.channelMessages.totalConversations || 0) + ((data == null ? void 0 : data.length) - (((_f = state.channelMessages.data) == null ? void 0 : _f.length) || 0));
      }
      state.channelMessages.data = [];
    },
    updateMessagePending(state, action) {
      state.channelMessages.data.findIndex(
        (item) => item.conversationState === conversationStateClient.open || conversationStateClient.interactive === item.conversationState
      );
    },
    changeTab(state, action) {
      state.tabs = {
        ...state.tabs,
        ...action.payload
      };
    },
    setDataQueueList(state, action) {
      state.queueLists = sortTimeAsc(
        action.payload,
        "startedTime"
      );
    },
    updateQueueList(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const { queueLists } = state;
      const findIndex = queueLists.findIndex(
        (item) => {
          var _a2;
          return item.senderId === ((_a2 = action.payload) == null ? void 0 : _a2.senderId) && item.applicationId === action.payload.applicationId;
        }
      );
      if (findIndex >= 0) {
        const data = updateContactLastMessage({
          data: queueLists,
          findIndex,
          unReadCount: action.payload.unReadCount,
          payload: action.payload
        });
        if (((_a = state.conversation) == null ? void 0 : _a.senderId) === ((_b = action.payload) == null ? void 0 : _b.senderId) && ((_c = state.conversation) == null ? void 0 : _c.applicationId) === ((_d = action.payload) == null ? void 0 : _d.applicationId)) {
          state.unReadCount = action.payload.unReadCount;
        }
        state.queueLists = sortTimeAsc(data, "startedTime");
      } else {
        const contact2 = {
          ...action.payload,
          unReadCount: action.payload.unReadCount
        };
        if (((_e = state.conversation) == null ? void 0 : _e.senderId) === ((_f = action.payload) == null ? void 0 : _f.senderId) && ((_g = state.conversation) == null ? void 0 : _g.applicationId) === ((_h = action.payload) == null ? void 0 : _h.applicationId)) {
          state.unReadCount = action.payload.unReadCount;
        }
        state.queueLists = sortTimeAsc(
          [contact2, ...queueLists],
          "startedTime"
        );
      }
    },
    removeQueueItem(state, action) {
      const filter3 = state.queueLists.filter(
        (item) => {
          var _a, _b;
          return !(item.applicationId === ((_a = action.payload) == null ? void 0 : _a.applicationId) && item.senderId === ((_b = action.payload) == null ? void 0 : _b.senderId));
        }
      );
      state.queueLists = filter3;
    },
    updateViewRecently(state, action) {
      var _a, _b, _c, _d, _e;
      if (((_a = state.conversation) == null ? void 0 : _a.applicationId) === ((_b = action.payload.data) == null ? void 0 : _b.applicationId) && ((_c = state.conversation) == null ? void 0 : _c.senderId) === action.payload.data.senderId) {
        state.conversation = {
          ...state.conversation,
          ...action.payload.data ?? {},
          conversationId: action.payload.data._id || ((_d = action.payload.data) == null ? void 0 : _d.conversationId),
          conversationState: action.payload.data.conversationState,
          agentPicked: (_e = action.payload.data) == null ? void 0 : _e.agentPicked
        };
      }
      state.viewRecentlyLists = stackViewRecentList(
        state.viewRecentlyLists,
        action.payload.data,
        action.payload.isAdd
      );
    },
    updateContact(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
      if (!((_a = action.payload) == null ? void 0 : _a.field) || ((_b = action.payload) == null ? void 0 : _b.field) === "name") {
        if (state.conversation) {
          if (((_c = state.conversation) == null ? void 0 : _c.contactId) === ((_e = (_d = action.payload) == null ? void 0 : _d.contact) == null ? void 0 : _e.id) && !((_f = action.payload) == null ? void 0 : _f.forceUpdateBySenderId)) {
            state.conversation.contactName = (_h = (_g = action.payload) == null ? void 0 : _g.contact) == null ? void 0 : _h.name;
            if (state.conversation.item) {
              state.conversation.item.contactName = (_j = (_i = action.payload) == null ? void 0 : _i.contact) == null ? void 0 : _j.name;
            }
          } else {
            if (((_k = state.conversation) == null ? void 0 : _k.senderId) === ((_l = action.payload) == null ? void 0 : _l.senderId)) {
              state.conversation.contactId = (_n = (_m = action.payload) == null ? void 0 : _m.contact) == null ? void 0 : _n.id;
              state.conversation.contactName = (_p = (_o = action.payload) == null ? void 0 : _o.contact) == null ? void 0 : _p.name;
              if (state.conversation.item) {
                state.conversation.item.contactId = (_r = (_q = action.payload) == null ? void 0 : _q.contact) == null ? void 0 : _r.id;
                state.conversation.item.contactName = (_t = (_s = action.payload) == null ? void 0 : _s.contact) == null ? void 0 : _t.name;
              }
            }
          }
        }
        const findIndexs = state.conversationLists.map((item, index) => {
          var _a2, _b2, _c2;
          if (item.contactId === ((_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.id) && !((_c2 = action.payload) == null ? void 0 : _c2.forceUpdateBySenderId)) {
            return index;
          }
          return null;
        }).filter((item) => item !== null);
        if ((findIndexs == null ? void 0 : findIndexs.length) > 0) {
          findIndexs.forEach((index) => {
            var _a2, _b2;
            state.conversationLists[index].contactName = (_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.name;
          });
        } else {
          const findIndexList = state.conversationLists.findIndex(
            (item) => {
              var _a2;
              return (item == null ? void 0 : item.senderId) === ((_a2 = action.payload) == null ? void 0 : _a2.senderId);
            }
          );
          if (findIndexList !== -1) {
            state.conversationLists[findIndexList].contactId = (_v = (_u = action.payload) == null ? void 0 : _u.contact) == null ? void 0 : _v.id;
            state.conversationLists[findIndexList].contactName = (_x = (_w = action.payload) == null ? void 0 : _w.contact) == null ? void 0 : _x.name;
          }
        }
        const findIndexViewRecentlys = state.viewRecentlyLists.map((item, index) => {
          var _a2, _b2, _c2;
          if (item.contactId === ((_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.id) && !((_c2 = action.payload) == null ? void 0 : _c2.forceUpdateBySenderId)) {
            return index;
          }
          return null;
        }).filter((item) => item !== null);
        if ((findIndexViewRecentlys == null ? void 0 : findIndexViewRecentlys.length) > 0) {
          findIndexViewRecentlys.forEach((index) => {
            var _a2, _b2;
            state.viewRecentlyLists[index].contactName = (_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.name;
          });
        } else {
          const findIndexListRecent = state.viewRecentlyLists.findIndex(
            (item) => {
              var _a2;
              return (item == null ? void 0 : item.senderId) === ((_a2 = action.payload) == null ? void 0 : _a2.senderId);
            }
          );
          if (findIndexListRecent !== -1) {
            state.viewRecentlyLists[findIndexListRecent].contactId = (_z = (_y = action.payload) == null ? void 0 : _y.contact) == null ? void 0 : _z.id;
            state.viewRecentlyLists[findIndexListRecent].contactName = (_B = (_A = action.payload) == null ? void 0 : _A.contact) == null ? void 0 : _B.name;
          }
        }
      }
    },
    updateMessageScrollToView(state, action) {
      var _a;
      const obj = ((_a = state.conversation) == null ? void 0 : _a.objectMessage) || {};
      state.conversation = {
        ...state.conversation,
        objectMessage: {
          ...obj,
          ...action.payload
        }
      };
    },
    updateContactAfterMerge(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      if (state.conversation) {
        if (((_a = state.conversation) == null ? void 0 : _a.contactId) === ((_c = (_b = action.payload) == null ? void 0 : _b.contact) == null ? void 0 : _c.id) || ((_f = (_d = action.payload) == null ? void 0 : _d.contactIdMerged) == null ? void 0 : _f.includes(
          ((_e = state.conversation) == null ? void 0 : _e.contactId) || ""
        ))) {
          state.conversation.contactId = (_h = (_g = action.payload) == null ? void 0 : _g.contact) == null ? void 0 : _h.id;
          state.conversation.contactName = (_j = (_i = action.payload) == null ? void 0 : _i.contact) == null ? void 0 : _j.name;
          if (state.conversation.item) {
            state.conversation.item.contactId = (_l = (_k = action.payload) == null ? void 0 : _k.contact) == null ? void 0 : _l.id;
            state.conversation.item.contactName = (_n = (_m = action.payload) == null ? void 0 : _m.contact) == null ? void 0 : _n.name;
          }
        }
      }
      const findIndexs = state.conversationLists.map((item, index) => {
        var _a2, _b2, _c2, _d2;
        if (item.contactId === ((_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.id) || ((_d2 = (_c2 = action.payload) == null ? void 0 : _c2.contactIdMerged) == null ? void 0 : _d2.includes(item.contactId || ""))) {
          return index;
        }
        return null;
      }).filter((item) => item !== null);
      findIndexs.forEach((index) => {
        var _a2, _b2, _c2, _d2;
        state.conversationLists[index].contactId = (_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.id;
        state.conversationLists[index].contactName = (_d2 = (_c2 = action.payload) == null ? void 0 : _c2.contact) == null ? void 0 : _d2.name;
      });
      const findIndexViewRecentlys = state.viewRecentlyLists.map((item, index) => {
        var _a2, _b2, _c2, _d2;
        if (item.contactId === ((_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.id) || ((_d2 = (_c2 = action.payload) == null ? void 0 : _c2.contactIdMerged) == null ? void 0 : _d2.includes(item.contactId || ""))) {
          return index;
        }
        return null;
      }).filter((item) => item !== null);
      findIndexViewRecentlys.forEach((index) => {
        var _a2, _b2, _c2, _d2;
        state.viewRecentlyLists[index].contactId = (_b2 = (_a2 = action.payload) == null ? void 0 : _a2.contact) == null ? void 0 : _b2.id;
        state.viewRecentlyLists[index].contactName = (_d2 = (_c2 = action.payload) == null ? void 0 : _c2.contact) == null ? void 0 : _d2.name;
      });
    },
    setViewRecentlyLists(state, action) {
      state.viewRecentlyLists = action.payload;
    },
    searchInteractsAction(state, action) {
      state.searchInteracts = {
        ...state.searchInteracts,
        ...action.payload
      };
    },
    setSessionTicket(state, action) {
      state.session = action.payload;
    },
    setSendClient(state, action) {
      state.sendClient = action.payload;
    },
    addRecordPaths(state, action) {
      var _a, _b, _c, _d, _e, _f;
      if (((_a = state.conversation) == null ? void 0 : _a.applicationId) === ((_b = action.payload) == null ? void 0 : _b.applicationId) && ((_c = state.conversation) == null ? void 0 : _c.senderId) === ((_d = action.payload) == null ? void 0 : _d.senderId) && !((_f = (_e = state.conversation) == null ? void 0 : _e.objectMessage) == null ? void 0 : _f.id)) {
        state.channelMessages.data.findIndex(
          (i2) => {
            var _a2;
            return i2._id === ((_a2 = action.payload) == null ? void 0 : _a2._id);
          }
        );
      }
    },
    updateLastMsg(state, action) {
      const { conversationLists } = state;
      const newData = [...conversationLists];
      const findIndex = newData.findIndex(
        (item) => {
          var _a, _b, _c, _d;
          return item.applicationId === ((_a = action.payload) == null ? void 0 : _a.applicationId) && item.senderId === ((_b = action.payload) == null ? void 0 : _b.senderId) && item.lastMessage._id === ((_d = (_c = action.payload) == null ? void 0 : _c.lastMessage) == null ? void 0 : _d._id);
        }
      );
      const obj = action.payload || {};
      if (findIndex >= 0) {
        newData[findIndex] = {
          ...newData[findIndex],
          ...obj,
          lastMessage: {
            ...newData[findIndex].lastMessage,
            ...obj.lastMessage || {}
          }
        };
        state.conversationLists = newData;
      }
      state.viewRecentlyLists = (state.viewRecentlyLists ?? []).map((i2) => {
        var _a, _b, _c, _d, _e, _f;
        return {
          ...i2,
          lastMessage: {
            ...i2.lastMessage,
            text: ((_a = i2.lastMessage) == null ? void 0 : _a._id) === ((_c = (_b = action.payload) == null ? void 0 : _b.lastMessage) == null ? void 0 : _c._id) ? (_e = (_d = action.payload) == null ? void 0 : _d.lastMessage) == null ? void 0 : _e.text : (_f = i2.lastMessage) == null ? void 0 : _f.text
          }
        };
      });
    }
  },
  extraReducers: (builder) => {
    builder.addCase(findSession.fulfilled, (state, action) => {
      var _a, _b;
      const { channelMessages } = state;
      if (((_a = channelMessages.data) == null ? void 0 : _a.length) <= 0 && ((_b = action.payload.data) == null ? void 0 : _b.length) <= 0) {
        channelMessages.statusData = StatsTusData.NO_DATA;
        channelMessages.hasMore = false;
      }
    });
    builder.addCase(findSession.rejected, (state, _action) => {
      var _a;
      const { channelMessages } = state;
      if (((_a = channelMessages.data) == null ? void 0 : _a.length) <= 0) {
        channelMessages.statusData = StatsTusData.NO_DATA;
        channelMessages.hasMore = false;
      }
    });
    builder.addCase(findSession.pending, (state) => {
      state.channelMessages = {
        ...state.channelMessages,
        statusData: StatsTusData.LOADING_DATA,
        hasMore: true
      };
    });
    builder.addCase(updateConversationListAsync.fulfilled, (state, action) => {
      state.unReadCount = action.payload.unReadCount;
      state.conversationLists = action.payload.conversationLists;
    });
    builder.addCase(updateViewRecentlyAsync.fulfilled, (state, action) => {
      state.conversation = action.payload.conversation;
      state.viewRecentlyLists = action.payload.viewRecentlyLists;
    });
  }
});
const persistConfig$6 = {
  key: "agent",
  storage: default_1,
  whitelist: ["viewRecentlyLists", "tabs"]
};
const {
  showChat,
  receivedMessageCustom,
  clearReceivedMessage,
  savePositionScroll,
  setSessionMessage,
  handleSessionNewMessage,
  seenMessage,
  updateConversationList,
  setDataConversionList,
  clearAgent,
  checkPushNotification,
  endChatSocket,
  incrementTotalRecord,
  handleSessionCall,
  endChatV2,
  updateConversationItemV2,
  updateContact,
  updateContactAfterMerge,
  updateMessagePending,
  changeTab,
  setDataQueueList,
  updateQueueList,
  removeQueueItem,
  updateViewRecently,
  updateMessageScrollToView,
  searchInteractsAction,
  setViewRecentlyLists,
  setSessionTicket,
  setSendClient,
  addRecordPaths,
  updateLastMsg
} = AgentSlice.actions;
const agentSlice = persistReducer(persistConfig$6, AgentSlice.reducer);
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape$1 = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape: unescape$1
};
const setDefaults2 = (options = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
};
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults2(instance2.options.react);
  }
};
const postStatusAgent = (body, header = {}) => axiosAuth.post(
  "acd-asm-chat/agent-status/change",
  body,
  {
    headers: {
      ...header
    }
  }
);
const getAgentStatusAcd = (params) => {
  return axiosAuth.get(
    "acd-asm-chat/status-reason/get-changeable-reason",
    { params }
  );
};
const getCurrentAgentStatus = (params) => axiosNotAuth.get(
  "acd-asm-chat/agent-status/current-status",
  {
    params
  }
);
const addSessionChat = ({
  data = [],
  createObjSend
}) => {
  const checkConversationState = data.some(
    (send2) => conversationStateClient.interactive === send2.conversationState
  );
  if (!checkConversationState) {
    const someItem = data.some(
      (item) => (item == null ? void 0 : item._id) === ((createObjSend == null ? void 0 : createObjSend.conversationId) || (createObjSend == null ? void 0 : createObjSend._id))
    );
    if (!someItem) {
      const initialValue = {
        _id: createObjSend == null ? void 0 : createObjSend.conversationId,
        senderId: createObjSend == null ? void 0 : createObjSend.senderId,
        senderName: createObjSend == null ? void 0 : createObjSend.senderName,
        applicationName: "Zalo Sao Thủy",
        applicationId: (createObjSend == null ? void 0 : createObjSend.applicationId) || "",
        cloudTenantId: createObjSend == null ? void 0 : createObjSend.cloudTenantId,
        channel: (createObjSend == null ? void 0 : createObjSend.channel) || "",
        conversationState: "OPEN",
        lastTime: /* @__PURE__ */ new Date() || "",
        startedTime: /* @__PURE__ */ new Date() || "",
        participants: ["5887090488509262784", 25],
        messages: [createObjSend],
        __v: 1,
        agentPicked: createObjSend == null ? void 0 : createObjSend.cloudTenantId,
        lastMessage: "64847e6b17f1e3512b9cb95f",
        closedTime: "",
        conversationId: createObjSend == null ? void 0 : createObjSend.conversationId,
        isClient: true
      };
      if (!(data == null ? void 0 : data.length)) return [initialValue];
      return [initialValue, ...data];
    }
    return data.map((item) => {
      if (item._id === (createObjSend == null ? void 0 : createObjSend.conversationId)) {
        return {
          ...item,
          conversationState: conversationStateClient.interactive,
          messages: [...item.messages, createObjSend]
        };
      }
      return item;
    });
  }
  const emptyOpen = data.findIndex(
    (send2) => send2._id === (createObjSend == null ? void 0 : createObjSend._id) && checkConversationState
  );
  if (emptyOpen >= 0) {
    return data;
  }
  return data.map((item, index) => {
    if (index === 0) {
      const checkMessageId = item.messages.some(
        (messageId) => (messageId == null ? void 0 : messageId._id) === (createObjSend == null ? void 0 : createObjSend._id) || (messageId == null ? void 0 : messageId.text) === (createObjSend == null ? void 0 : createObjSend.text) && (messageId == null ? void 0 : messageId.conversationId) === (createObjSend == null ? void 0 : createObjSend.conversationId) && (messageId == null ? void 0 : messageId.senderId) === (createObjSend == null ? void 0 : createObjSend.senderId) && (messageId == null ? void 0 : messageId._id) === (messageId == null ? void 0 : messageId.uuid) && (messageId == null ? void 0 : messageId.uuid) === (createObjSend == null ? void 0 : createObjSend.uuid)
      );
      return {
        ...item,
        messages: checkMessageId ? item.messages : [...item.messages, createObjSend],
        isClient: true
      };
    }
    return item;
  });
};
const addSessionCall = ({
  data = [],
  createObjSend
}) => {
  const checkConversationState = data.some(
    (send2) => (send2.conversationId || send2._id) === createObjSend.conversationId && conversationStateClient.close !== send2.conversationState
  );
  if (!checkConversationState) {
    const someItem = data.some(
      (item) => (item == null ? void 0 : item._id) === ((createObjSend == null ? void 0 : createObjSend.conversationId) || (createObjSend == null ? void 0 : createObjSend._id))
    );
    if (!someItem) {
      const initialValue = {
        _id: createObjSend == null ? void 0 : createObjSend.conversationId,
        senderId: createObjSend == null ? void 0 : createObjSend.senderId,
        senderName: createObjSend == null ? void 0 : createObjSend.senderName,
        applicationName: "Zalo Sao Thủy",
        applicationId: (createObjSend == null ? void 0 : createObjSend.applicationId) || "",
        cloudTenantId: createObjSend == null ? void 0 : createObjSend.cloudTenantId,
        channel: (createObjSend == null ? void 0 : createObjSend.channel) || "",
        conversationState: "OPEN",
        lastTime: /* @__PURE__ */ new Date() || "",
        startedTime: /* @__PURE__ */ new Date() || "",
        participants: ["5887090488509262784", 25],
        messages: [createObjSend],
        __v: 1,
        agentPicked: createObjSend == null ? void 0 : createObjSend.cloudTenantId,
        lastMessage: "64847e6b17f1e3512b9cb95f",
        closedTime: "",
        conversationId: createObjSend == null ? void 0 : createObjSend.conversationId,
        isClient: true
      };
      if (!(data == null ? void 0 : data.length)) return [initialValue];
      return [initialValue, ...data];
    }
    return data.map((item) => {
      if (item._id === (createObjSend == null ? void 0 : createObjSend.conversationId)) {
        return {
          ...item,
          conversationState: conversationStateClient.interactive,
          messages: [...item.messages, createObjSend]
        };
      }
      return item;
    });
  }
  const emptyOpen = data.findIndex(
    (send2) => send2._id === (createObjSend == null ? void 0 : createObjSend._id) && checkConversationState
  );
  if (emptyOpen >= 0) {
    return data;
  }
  return data.map((item, index) => {
    if (index === 0) {
      const checkMessageId = item.messages.some(
        (messageId) => (messageId == null ? void 0 : messageId._id) === (createObjSend == null ? void 0 : createObjSend._id)
      );
      return {
        ...item,
        messages: checkMessageId ? item.messages : [...item.messages, createObjSend].sort(
          (a2, b) => dayjs(a2.receivedTime).diff(b.receivedTime)
        ),
        isClient: true
      };
    }
    return item;
  });
};
const updateContactLastMessage = ({
  data,
  findIndex,
  unReadCount,
  payload
}) => {
  const obj = {
    ...payload,
    unReadCount
  };
  data.splice(findIndex, 1, obj);
  return data;
};
const stackViewRecently = (entries) => {
  sortTimeDesc(entries, "manualPickTime");
  entries.slice(0, 15);
  return entries;
};
const stackViewRecentList = (entries, item, isAdd = false) => {
  if (item) {
    let updateItem = {
      ...item
    };
    const findIndex = entries.findIndex(
      (obj) => obj.applicationId === item.applicationId && obj.senderId === item.senderId
    );
    if (isAdd) {
      updateItem = {
        ...updateItem,
        manualPickTime: /* @__PURE__ */ new Date()
      };
    }
    if ((item == null ? void 0 : item.conversationState) === CONVERSATION_STATE.CLOSE) {
      if (findIndex >= 0) {
        updateItem = {
          ...entries[findIndex],
          ...updateItem
        };
      }
    }
    if (findIndex >= 0) {
      updateItem = {
        ...entries[findIndex],
        ...updateItem
      };
      entries.splice(findIndex, 1, updateItem);
    } else if (isAdd) {
      entries.unshift(updateItem);
    }
  }
  return stackViewRecently(entries);
};
const pushEventCurrentStatus = async (params) => {
  var _a, _b, _c, _d, _e, _f, _g;
  try {
    const response = await getCurrentAgentStatus(params);
    client_socket.emit(Event_SDK.AgentStatusEvent, {
      agentId: (_a = response.data.data) == null ? void 0 : _a.cloudAgentId,
      tenantId: (_b = response.data.data) == null ? void 0 : _b.cloudTenantId,
      agentName: (_c = response.data.data) == null ? void 0 : _c.cloudAgentName,
      statusName: (_d = response.data.data) == null ? void 0 : _d.statusName,
      changeTime: (_e = response.data.data) == null ? void 0 : _e.changeTime,
      reasonCode: (_f = response.data.data) == null ? void 0 : _f.reasonCode,
      reasonCodeId: (_g = response.data.data) == null ? void 0 : _g.reasonCodeId
    });
  } catch (error) {
  }
};
const generateUUIDv4 = () => {
  return v4();
};
const Omit = (obj, ...keys) => {
  const object = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      object[key] = obj[key];
    }
  }
  return object;
};
const decryptData = (ciphertextB64, key) => {
  const eKey = cryptoJsExports.enc.Utf8.parse(
    "01234567896868686868012345678968"
  );
  const iv = cryptoJsExports.lib.WordArray.create([0, 0, 0, 0]);
  const decrypted = cryptoJsExports.AES.decrypt(ciphertextB64, eKey, { iv });
  return decrypted.toString(cryptoJsExports.enc.Utf8);
};
const sortTimeDesc = (array, key) => {
  return array.sort((a2, b) => customDayjs(b[key]).diff(customDayjs(a2[key])));
};
const sortTimeAsc = (array, key) => {
  return array.sort((a2, b) => customDayjs(a2[key]).diff(customDayjs(b[key])));
};
const alertSnackbar = () => {
  return ({
    title: title2,
    status: status2,
    duration: duration2 = 1500
  }) => {
    enqueueSnackbar({
      message: title2,
      variant: status2,
      autoHideDuration: duration2,
      anchorOrigin: { vertical: "top", horizontal: "center" }
    });
  };
};
const debounce = (func, delay) => {
  let timeout2;
  return (...args) => {
    if (timeout2) {
      clearTimeout(timeout2);
    }
    timeout2 = setTimeout(() => {
      func(...args);
      timeout2 = null;
    }, delay);
  };
};
const existChannelCall = (call = "") => ListCalls.some((i2) => i2 === call);
function config_key_redux(params) {
  return {
    key: params,
    keyPrefix: "mpt-",
    keyPrefixStorage: `mpt-${params}`
  };
}
function emitAppEvent(type) {
  client_socket.emit(Event_SDK.AppEvent, {
    type,
    message: type
  });
}
function emitInteractionEvent(type, option) {
  client_socket.emit(Event_SDK.InteractionEvent, {
    ...option,
    type
  });
}
const switchErrorAudio = (error) => {
  const snackbar = alertSnackbar();
  switch (error == null ? void 0 : error.name) {
    case "NotAllowedError":
      snackbar({
        title: "Người dùng từ chối quyền truy cập microphone.",
        status: "error"
      });
      break;
    case "NotFoundError":
      snackbar({
        title: "Không tìm thấy thiết bị microphone.",
        status: "error"
      });
      break;
    case "NotReadableError":
      snackbar({
        title: "Microphone đã bị ứng dụng khác chiếm dụng.",
        status: "error"
      });
      break;
    case "OverconstrainedError":
      snackbar({
        title: "Cấu hình yêu cầu không khả thi với microphone.",
        status: "error"
      });
      break;
    case "SecurityError":
      snackbar({
        title: "Trình duyệt chặn microphone do lý do bảo mật.",
        status: "error"
      });
      break;
    default:
      snackbar({
        title: `Lỗi không xác định:", ${error.name}, ${error.message}`,
        status: "error"
      });
  }
};
const render_hang_up = (msg) => {
  var _a, _b;
  if ((_a = Map_Msg_Form[msg.direction]) == null ? void 0 : _a[msg.hangup_side]) {
    return (_b = Map_Msg_Form[msg.direction]) == null ? void 0 : _b[msg.hangup_side];
  }
  return MessengerForm.AGENT;
};
const tabId = generateUUIDv4();
const traceLog = (msg, data = "", push = {
  isLogServer: true,
  isLogClient: true,
  tenantId: 0,
  agentId: 0,
  sessionId: "",
  sendBeacon: false
}) => {
  if (push == null ? void 0 : push.isLogClient) {
    console.log(`[${customDayjs().format(DATE_FORMAT.HH_MM_SS)}]:${msg}`, data);
  }
  if (push == null ? void 0 : push.isLogServer) {
    const browserInfo = getBrowserInfo();
    const body = {
      tenantId: push == null ? void 0 : push.tenantId,
      agentId: push == null ? void 0 : push.agentId,
      sessionId: push == null ? void 0 : push.sessionId,
      timestamp: (/* @__PURE__ */ new Date()).getTime(),
      payload: JSON.stringify({
        values: data,
        title: msg,
        tabId,
        date: customDayjs().format(DATE_FORMAT.HH_MM_DD_MM_YY_HH_MM_SS),
        device: browserInfo.platform,
        browser: browserInfo.browser,
        version: browserInfo.version,
        userAgent: browserInfo.userAgent
      })
    };
    portLogEvent(body);
    if (push == null ? void 0 : push.sendBeacon) {
      navigator.sendBeacon(
        config_url.base_url + "/dynamic-report/api/v2/reports/client-log",
        JSON.stringify(body)
      );
    }
  }
};
const ConvertSize = {
  mb: 2048
};
const calculatorSizeFile = (size, {
  fixed = 3,
  convert = ConvertSize.mb
}) => {
  return +(size / 1024 / 1024).toFixed(fixed);
};
const get_key_file = (name2) => {
  if (regex_type_file(name2, reg_exp_images)) return "image";
  return "file";
};
const getBrowserInfo = () => {
  var _a, _b, _c, _d, _e;
  const ua2 = navigator.userAgent;
  let browserName2 = "Unknown";
  let browserVersion2 = "";
  if (!ua2)
    return {
      browser: browserName2,
      version: browserVersion2,
      userAgent: ua2,
      platform: navigator.platform,
      language: navigator.language
    };
  if (/Edg\/(\d+)/.test(ua2)) {
    browserName2 = "Edge";
    browserVersion2 = ((_a = ua2.match(/Edg\/(\d+)/)) == null ? void 0 : _a[1]) || "";
  } else if (/Chrome\/(\d+)/.test(ua2)) {
    browserName2 = "Chrome";
    browserVersion2 = ((_b = ua2.match(/Chrome\/(\d+)/)) == null ? void 0 : _b[1]) || "";
  } else if (/Firefox\/(\d+)/.test(ua2)) {
    browserName2 = "Firefox";
    browserVersion2 = ((_c = ua2.match(/Firefox\/(\d+)/)) == null ? void 0 : _c[1]) || "";
  } else if (/Safari\/(\d+)/.test(ua2) && /Version\/(\d+)/.test(ua2)) {
    browserName2 = "Safari";
    browserVersion2 = ((_d = ua2.match(/Version\/(\d+)/)) == null ? void 0 : _d[1]) || "";
  } else if (/OPR\/(\d+)/.test(ua2)) {
    browserName2 = "Opera";
    browserVersion2 = ((_e = ua2.match(/OPR\/(\d+)/)) == null ? void 0 : _e[1]) || "";
  }
  return {
    browser: browserName2,
    version: browserVersion2,
    userAgent: ua2,
    platform: navigator.platform,
    language: navigator.language
  };
};
const defaultInfo = {
  tenant: {
    domainId: "",
    id: 0,
    name: "",
    tenancyName: ""
  },
  user: {
    name: "",
    surname: "",
    userName: "",
    fullName: "",
    emailAddress: "",
    phoneNumber: "",
    isUsePhone: false,
    nodeId: 0,
    enableExtension: false,
    supportApplicationIds: [],
    fsAgentId: "",
    id: 0,
    wrapUpTime: 30
  }
};
const checkIsTenantAvailable = (obj) => axiosAuth.post(
  "/api/services/app/Account/IsTenantAvailable",
  obj
);
const logout$1 = (body) => axiosAuth.post("/acd-asm-chat/agent-status/logout", body);
const postLogin = (body) => {
  return axiosAuth.post(
    "/api/TokenAuth/Authenticate",
    {
      userNameOrEmailAddress: body.username,
      password: body.password,
      tenantId: body.tenantId
    },
    {
      headers: {
        "Abp.TenantId": body.tenantId
        // Cookie: `Abp.TenantId=${body.tenantId}`,
      },
      withCredentials: true
    }
  );
};
const postLoginSSO = (body) => {
  return axiosAuth.post(
    "/api/TokenAuth/ExternalSystemAuthenticate",
    body,
    {
      withCredentials: true
    }
  );
};
const getInfoAgent = (token) => axiosAuth.get(
  "api/services/app/Session/GetCurrentLoginInformation",
  {
    headers: {
      Authorization: `Bearer ${token}`
    }
  }
);
const getConfigBaseUrl = (token) => axiosAuth.get(
  "config/EncryptedAbpUserConfiguration/GetConfiguration",
  {
    headers: {
      Authorization: `Bearer ${token}`
    }
  }
);
const getCurrentLoginInfo = createAsyncThunk(
  "auth/currentInfo",
  async (token, { rejectWithValue }) => {
    try {
      const res = await axiosAuth.get(
        "api/services/app/Session/GetCurrentLoginInformation",
        {
          headers: {
            Authorization: `Bearer ${token}`
          }
        }
      );
      return JSON.parse(decryptData(res.data.result));
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);
const loginAsyncThunk = createAsyncThunk(
  "auth/login",
  async (body, { rejectWithValue }) => {
    try {
      const response = await postLogin(body);
      return response.data;
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);
const loginSSOAsyncThunk = createAsyncThunk(
  "auth/loginSSO",
  async (body, { rejectWithValue }) => {
    try {
      const response = await postLogin(body);
      return response.data;
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);
const initialState$5 = {
  info: defaultInfo,
  switch: {
    agent_ticket: {}
  },
  accessToken: null
};
const AuthSlice = createSlice({
  name: "auth",
  initialState: initialState$5,
  reducers: {
    switchAgentTicket(state, action) {
      var _a, _b;
      state.switch.agent_ticket = {
        ...state.switch.agent_ticket,
        [`${(_a = state.info.tenant) == null ? void 0 : _a.id}_${(_b = state.info) == null ? void 0 : _b.user.id}`]: action.payload
      };
    },
    agent_logout(state) {
      state.info = {
        ...initialState$5.info
      };
      state.accessToken = null;
      localStorage.removeItem("token");
      localStorage.removeItem("tenantId");
    },
    setInfo(state, action) {
      state.info = action.payload;
    },
    syncLogin(state, action) {
      state.accessToken = action.payload ?? null;
    }
  },
  extraReducers: (builder) => {
    builder.addCase(getCurrentLoginInfo.fulfilled, (state, action) => {
      state.info = action.payload;
    });
    builder.addCase(loginAsyncThunk.fulfilled, (state, action) => {
      var _a, _b;
      state.accessToken = ((_b = (_a = action.payload) == null ? void 0 : _a.result) == null ? void 0 : _b.accessToken) || null;
    });
    builder.addCase(loginSSOAsyncThunk.fulfilled, (state, action) => {
      var _a, _b;
      state.accessToken = ((_b = (_a = action.payload) == null ? void 0 : _a.result) == null ? void 0 : _b.accessToken) || null;
    });
  }
});
const persistConfig$5 = {
  key: config_key_redux(key_redux.auth).key,
  storage: default_1,
  whitelist: ["switch", "info", "accessToken"],
  keyPrefix: config_key_redux(key_redux.auth).keyPrefix
};
const { switchAgentTicket, agent_logout, syncLogin, setInfo } = AuthSlice.actions;
const authSlice = persistReducer(persistConfig$5, AuthSlice.reducer);
const getAllUsers = createAsyncThunk(
  "users/all",
  async (_, { rejectWithValue }) => {
    try {
      const res = await axiosAuth.get(
        "api/services/app/GlobalService/GetAllUsers",
        {
          headers: {
            // Authorization: `Bearer ${session?.accessToken}`,
          }
        }
      );
      return JSON.parse(decryptData(res.data.result));
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);
const initialState$4 = {
  lists: []
};
const UsersSlice = createSlice({
  name: "users",
  initialState: initialState$4,
  reducers: {},
  extraReducers: (builder) => {
    builder.addCase(getAllUsers.fulfilled, (state, action) => {
      state.lists = action.payload;
    });
  }
});
const persistConfig$4 = {
  key: "users",
  storage: default_1,
  whitelist: []
};
const usersSlice = persistReducer(persistConfig$4, UsersSlice.reducer);
const initialState$3 = {
  disconnectFromAbly: void 0,
  unSubscribeFromChannel: void 0,
  subscribeToCustomChannel: void 0,
  publishEvent: void 0
};
const AblyRealTimeSlice = createSlice({
  name: "ably",
  initialState: initialState$3,
  reducers: {
    setAbly(state, action) {
      state.disconnectFromAbly = action.payload.disconnectFromAbly;
      state.unSubscribeFromChannel = action.payload.unSubscribeFromChannel;
      state.subscribeToCustomChannel = action.payload.subscribeToCustomChannel;
      state.publishEvent = action.payload.publishEvent;
    }
  }
});
const persistConfig$3 = {
  key: "ably",
  storage: default_1,
  whitelist: []
};
const { setAbly } = AblyRealTimeSlice.actions;
const AblyRealTimeSlice$1 = persistReducer(persistConfig$3, AblyRealTimeSlice.reducer);
const initialStateCallSlice = {
  // thông tin cuộc gọi
  callInfo: {
    conversation: {
      phoneNumber: "",
      status: CallStatusInfo.ConnectionEstablish,
      conversationId: "",
      agentPicked: 0,
      applicationId: "",
      applicationName: "",
      senderId: "",
      senderName: "",
      startedTime: "",
      cloudTenantId: 0,
      channel: "",
      participants: ["", ""],
      contactId: "",
      _id: "0",
      lastMessage: {
        applicationId: "",
        applicationName: "",
        channel: "",
        cloudTenantId: 0,
        conversationId: "",
        messageFrom: "",
        messageStatus: "",
        messageType: "",
        sendFrom: "",
        senderId: "",
        senderName: "",
        socialMessageId: "",
        text: "",
        __v: 0,
        _id: ""
      },
      autoAnswer: false
    }
  },
  isIncomingCall: false,
  sipJs: {},
  wrapUpTime: {
    time: WRAP_UP_TIME,
    processingEndCallTime: PROCESSING_END_CALL_TIME
  },
  timeCloseConversation: {},
  actionBtn: {
    mute: true,
    hold: true
  },
  autoAcceptCall: "",
  disabled: initPropsBtn,
  videoCall: {
    isOpen: false,
    isPip: false,
    isCamera: true,
    isVideoCall: false
  }
};
({
  [CallStatusInfo.ConnectionEstablish]: "ConnectionEstablish",
  [CallStatusInfo.WaitingCall]: "waitingCall",
  [CallStatusInfo.listeningCall]: "listeningCall",
  [CallStatusInfo.processingEndCall]: "processingEndCall",
  [CallStatusInfo.holdCall]: "holdCall",
  [CallStatusInfo.endCall]: "endCall",
  [CallStatusInfo.callForwarding]: "callForwarding",
  [CallStatusInfo.inTransit]: "inTransit"
});
({
  [CallStatusInfo.ConnectionEstablish]: "green.500",
  [CallStatusInfo.WaitingCall]: "green.500",
  [CallStatusInfo.listeningCall]: "blue.500",
  [CallStatusInfo.processingEndCall]: "orange.500",
  [CallStatusInfo.holdCall]: "blue.500",
  [CallStatusInfo.endCall]: "red.500",
  [CallStatusInfo.callForwarding]: "blue.500",
  [CallStatusInfo.inTransit]: "blue.500"
});
({
  [CallStatusInfo.ConnectionEstablish]: "green.50",
  [CallStatusInfo.WaitingCall]: "green.50",
  [CallStatusInfo.listeningCall]: "blue.50",
  [CallStatusInfo.processingEndCall]: "orange.50",
  [CallStatusInfo.holdCall]: "blue.50",
  [CallStatusInfo.endCall]: "red.50",
  [CallStatusInfo.callForwarding]: "blue.50",
  [CallStatusInfo.inTransit]: "50"
});
const handleEventCallAsync = createAsyncThunk(
  "handleEventCallAsync",
  async (body, { rejectWithValue, dispatch, getState }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    try {
      const state = getState();
      const stateCallConversation = (_b = (_a = state == null ? void 0 : state.call) == null ? void 0 : _a.callInfo) == null ? void 0 : _b.conversation;
      const callConversation = { ...body };
      if ((callConversation == null ? void 0 : callConversation.senderId) !== (stateCallConversation == null ? void 0 : stateCallConversation.senderId) || (callConversation == null ? void 0 : callConversation.senderId) === (stateCallConversation == null ? void 0 : stateCallConversation.senderId) && !(stateCallConversation == null ? void 0 : stateCallConversation.contactId)) {
        if (!(callConversation == null ? void 0 : callConversation.contactId) && (callConversation == null ? void 0 : callConversation.senderId)) {
          const res = await postContactDapperBySenders({
            types: [0, 2, 3],
            values: [callConversation == null ? void 0 : callConversation.senderId]
          });
          if ((_c = res == null ? void 0 : res.data) == null ? void 0 : _c.success) {
            if ((_e = (_d = res == null ? void 0 : res.data) == null ? void 0 : _d.data) == null ? void 0 : _e[0]) {
              callConversation.contactId = (_h = (_g = (_f = res == null ? void 0 : res.data) == null ? void 0 : _f.data) == null ? void 0 : _g[0]) == null ? void 0 : _h.id;
              callConversation.contactName = (_k = (_j = (_i = res == null ? void 0 : res.data) == null ? void 0 : _i.data) == null ? void 0 : _j[0]) == null ? void 0 : _k.name;
            }
          }
        }
      }
      return callConversation;
    } catch (error) {
      dispatch(handleEventCall(body));
      return rejectWithValue(error);
    }
  }
);
const CallSlice = createSlice({
  name: "call",
  initialState: initialStateCallSlice,
  reducers: {
    clearInfoCall: (state, action) => {
      var _a, _b, _c, _d, _e, _f;
      if (((_b = (_a = state.callInfo) == null ? void 0 : _a.conversation) == null ? void 0 : _b.applicationId) === ((_c = action.payload) == null ? void 0 : _c.applicationId) && ((_e = (_d = state.callInfo) == null ? void 0 : _d.conversation) == null ? void 0 : _e.senderId) === ((_f = action.payload) == null ? void 0 : _f.senderId)) {
        state.callInfo = {
          ...initialStateCallSlice.callInfo
        };
        state.videoCall = {
          isOpen: false
        };
      }
    },
    IncomingCall: (state, action) => {
      state.isIncomingCall = action.payload;
    },
    updateWrapUpTime: (state, action) => {
      state.wrapUpTime = action.payload(state.wrapUpTime);
    },
    setStatusCall: (state, action) => {
      state.callInfo = {
        ...state.callInfo,
        conversation: {
          ...state.callInfo.conversation,
          status: action.payload
        }
      };
    },
    setInfoInboundCall: (state, action) => {
      state.callInfo = {
        ...state.callInfo,
        conversation: action.payload
      };
    },
    setSipJs: (state, action) => {
      state.sipJs = {
        ...state.sipJs,
        ...action.payload
      };
    },
    handleEventCall: (state, action) => {
      state.callInfo = {
        ...state.callInfo,
        conversation: {
          ...state.callInfo.conversation,
          ...action.payload,
          conversationId: action.payload.lastMessage.conversationId,
          phoneNumber: action.payload.senderId
        }
      };
    },
    setActionBtn: (state, action) => {
      state.actionBtn = {
        ...state.actionBtn,
        ...action.payload
      };
    },
    autoAccept(state, action) {
      state.autoAcceptCall = action.payload;
    },
    closeCall(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_b = (_a = state.callInfo) == null ? void 0 : _a.conversation) == null ? void 0 : _b._id) === ((_c = action.payload) == null ? void 0 : _c._id) || ((_e = (_d = state.callInfo) == null ? void 0 : _d.conversation) == null ? void 0 : _e.conversationId) === ((_f = action.payload) == null ? void 0 : _f.conversationId)) {
        state.isIncomingCall = false;
      }
      const obj = state.timeCloseConversation || {};
      const omitTimeClose = Omit(
        obj,
        `${(_g = action.payload) == null ? void 0 : _g.applicationId}_${(_h = action.payload) == null ? void 0 : _h.senderId}`
      );
      state.timeCloseConversation = omitTimeClose;
    },
    unAssignAgent(state, action) {
      var _a, _b, _c, _d, _e, _f;
      if (((_b = (_a = state.callInfo) == null ? void 0 : _a.conversation) == null ? void 0 : _b.applicationId) === ((_c = action.payload) == null ? void 0 : _c.applicationId) && ((_e = (_d = state.callInfo) == null ? void 0 : _d.conversation) == null ? void 0 : _e.senderId) === ((_f = action.payload) == null ? void 0 : _f.senderId)) {
        state.callInfo = {
          ...state.callInfo,
          conversation: {
            ...state.callInfo.conversation,
            status: CallStatusInfo.WaitingCall
          }
        };
      }
    },
    setCloseTime(state, action) {
      var _a, _b, _c;
      const key = `${(_a = action.payload) == null ? void 0 : _a.applicationId}_${(_b = action.payload) == null ? void 0 : _b.senderId}`;
      state.timeCloseConversation = {
        ...state.timeCloseConversation,
        [key]: ((_c = action.payload) == null ? void 0 : _c.closeTime) || ""
      };
    },
    updateCallContact(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
      if (!((_a = action.payload) == null ? void 0 : _a.field) || ((_b = action.payload) == null ? void 0 : _b.field) === "name") {
        if ((_c = state == null ? void 0 : state.callInfo) == null ? void 0 : _c.conversation) {
          if (((_e = (_d = state == null ? void 0 : state.callInfo) == null ? void 0 : _d.conversation) == null ? void 0 : _e.senderId) === ((_f = action.payload) == null ? void 0 : _f.senderId) && (!((_h = (_g = state == null ? void 0 : state.callInfo) == null ? void 0 : _g.conversation) == null ? void 0 : _h.contactId) || ((_i = action.payload) == null ? void 0 : _i.forceUpdateBySenderId))) {
            state.callInfo.conversation.contactId = (_k = (_j = action.payload) == null ? void 0 : _j.contact) == null ? void 0 : _k.id;
            state.callInfo.conversation.contactName = (_m = (_l = action.payload) == null ? void 0 : _l.contact) == null ? void 0 : _m.name;
          } else {
            if (((_o = (_n = state == null ? void 0 : state.callInfo) == null ? void 0 : _n.conversation) == null ? void 0 : _o.contactId) === ((_q = (_p = action.payload) == null ? void 0 : _p.contact) == null ? void 0 : _q.id)) {
              state.callInfo.conversation.contactName = (_s = (_r = action.payload) == null ? void 0 : _r.contact) == null ? void 0 : _s.name;
            }
          }
        }
      }
    },
    updateCallContactAfterMerge(state, action) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      if ((_a = state == null ? void 0 : state.callInfo) == null ? void 0 : _a.conversation) {
        if (((_c = (_b = state == null ? void 0 : state.callInfo) == null ? void 0 : _b.conversation) == null ? void 0 : _c.contactId) === ((_e = (_d = action.payload) == null ? void 0 : _d.contact) == null ? void 0 : _e.id) || ((_i = (_f = action.payload) == null ? void 0 : _f.contactIdMerged) == null ? void 0 : _i.includes(
          ((_h = (_g = state == null ? void 0 : state.callInfo) == null ? void 0 : _g.conversation) == null ? void 0 : _h.contactId) || ""
        ))) {
          state.callInfo.conversation.contactId = (_k = (_j = action.payload) == null ? void 0 : _j.contact) == null ? void 0 : _k.id;
          state.callInfo.conversation.contactName = (_m = (_l = action.payload) == null ? void 0 : _l.contact) == null ? void 0 : _m.name;
        }
      }
    },
    disableBtn(state, action) {
      state.disabled = action.payload;
    },
    setActionVideoCall(state, action) {
      state.videoCall = {
        ...state.videoCall,
        ...action.payload
      };
    }
  },
  extraReducers: (builder) => {
    builder.addCase(handleEventCallAsync.fulfilled, (state, action) => {
      state.callInfo = {
        ...state.callInfo,
        conversation: {
          ...state.callInfo.conversation,
          ...action.payload,
          conversationId: action.payload.lastMessage.conversationId,
          phoneNumber: action.payload.senderId
        }
      };
    });
  }
});
const persistConfig$2 = {
  key: "call",
  storage: default_1,
  whitelist: []
};
const {
  IncomingCall,
  setSipJs,
  setInfoInboundCall,
  handleEventCall,
  updateWrapUpTime,
  setStatusCall,
  setActionBtn,
  autoAccept,
  closeCall,
  setCloseTime,
  updateCallContact,
  updateCallContactAfterMerge,
  unAssignAgent,
  clearInfoCall,
  disableBtn,
  setActionVideoCall
} = CallSlice.actions;
const callSlice = persistReducer(persistConfig$2, CallSlice.reducer);
const initValue = {
  text: "Xin chào, bạn cần tôi giúp gì?",
  typeMess: MessengerForm.BOT,
  messageId: v1()
};
const defaultQuickConversation = {
  isOpen: false,
  applicationId: "",
  senderId: "",
  channel: "",
  minimize: false,
  isDetailConversation: false,
  conversationId: ""
};
const initialState$2 = {
  agentStatus: {
    startTime: dayjs(),
    currentTime: dayjs(),
    diffInSeconds: dayjs().valueOf()
  },
  quickConversation: defaultQuickConversation,
  system_notify: {
    isNotifyBeacon: false,
    isOpenNotification: false
  },
  assistant_transcript: {
    isOpen: false
  },
  assistant_translation: {
    language: "vi-VN",
    disabled: false
  },
  assistant_resource: {
    data: [initValue],
    resourceId: ""
  }
};
const LayoutSlice = createSlice({
  name: "layout",
  initialState: initialState$2,
  reducers: {
    setAgentStatusTime(state, action) {
      var _a, _b;
      let diffInSeconds = (((_a = action == null ? void 0 : action.payload) == null ? void 0 : _a.currentTime) || state.agentStatus.currentTime).diff(
        ((_b = action == null ? void 0 : action.payload) == null ? void 0 : _b.startTime) || state.agentStatus.startTime,
        "seconds"
      );
      if (diffInSeconds < 0) diffInSeconds = 0;
      state.agentStatus = {
        ...state.agentStatus,
        ...action.payload,
        diffInSeconds
      };
    },
    setQuickConversation(state, action) {
      state.quickConversation = {
        ...state.quickConversation,
        ...action.payload
      };
    },
    setShowNotify(state, action) {
      state.system_notify = {
        ...state.system_notify,
        isNotifyBeacon: action.payload
      };
    },
    openNotification(state) {
      state.system_notify.isOpenNotification = true;
    },
    closeNotification(state) {
      state.system_notify.isOpenNotification = false;
    },
    setAssistantTranscript(state, action) {
      state.assistant_transcript = {
        ...state.assistant_transcript,
        ...action.payload
      };
    },
    setAssistantTranslation(state, action) {
      state.assistant_translation = {
        ...state.assistant_translation,
        ...action.payload
      };
    },
    setResourceId(state, action) {
      state.assistant_resource.resourceId = action.payload;
    },
    setAssistantResource(state, action) {
      var _a;
      if ((_a = action.payload) == null ? void 0 : _a.isClear) {
        state.assistant_resource.data = [initValue];
        state.assistant_resource.resourceId = "";
        return;
      }
      const findIndex = state.assistant_resource.data.findIndex(
        (i2) => i2.messageId === action.payload.id
      );
      if (findIndex >= 0) {
        state.assistant_resource.data[findIndex] = {
          ...state.assistant_resource.data[findIndex],
          text: state.assistant_resource.data[findIndex].text + action.payload.text,
          references: action.payload.references
        };
      } else {
        state.assistant_resource.data = [
          ...state.assistant_resource.data,
          action.payload
        ];
      }
    }
  }
});
const persistConfig$1 = {
  key: "layout",
  storage: default_1,
  whitelist: ["system_notify", "assistant_resource"]
};
const {
  setAgentStatusTime,
  setQuickConversation,
  setShowNotify,
  openNotification,
  closeNotification,
  setAssistantTranscript,
  setAssistantTranslation,
  setAssistantResource,
  setResourceId
} = LayoutSlice.actions;
const LayoutSlice$1 = persistReducer(persistConfig$1, LayoutSlice.reducer);
const getListTagSetting = (body) => axiosAuth.post("/chat-acd/tag/get-all-tag", body);
const getTagThunk = createAsyncThunk(
  "settings/getTags",
  async (params, { rejectWithValue }) => {
    var _a, _b;
    try {
      const response = await getListTagSetting(params);
      if (!((_a = response.data) == null ? void 0 : _a.success)) {
        throw new Error();
      }
      return {
        key: params.type,
        data: ((_b = response.data) == null ? void 0 : _b.data) ?? []
      };
    } catch (error) {
      return rejectWithValue({ key: params.type, data: [] });
    }
  }
);
const initialState$1 = {
  tags: {}
};
const SettingSlice = createSlice({
  name: "settings",
  initialState: initialState$1,
  reducers: {},
  extraReducers: (builder) => {
    builder.addCase(getTagThunk.fulfilled, (state, action) => {
      state.tags = {
        ...state.tags,
        [action.payload.key]: action.payload.data
      };
    });
    builder.addCase(getTagThunk.rejected, (state, action) => {
      const check = action.payload;
      if ((check == null ? void 0 : check.key) && (check == null ? void 0 : check.data)) {
        state.tags = {
          ...state.tags,
          [check.key]: check.data ?? []
        };
      }
    });
  }
});
const persistConfig = {
  key: "settings",
  storage: default_1
};
const SettingSlice$1 = persistReducer(persistConfig, SettingSlice.reducer);
const rootReducers = combineReducers({
  auth: authSlice,
  agent: agentSlice,
  users: usersSlice,
  ably: AblyRealTimeSlice$1,
  call: callSlice,
  layout: LayoutSlice$1,
  settings: SettingSlice$1
});
const store = configureStore({
  reducer: rootReducers,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware({
    serializableCheck: false
  })
});
persistStore(store);
const useAppDispatch = () => useDispatch();
const useAppSelector = useSelector;
const createStore = (reducer, initialState2) => {
  let state = initialState2;
  const listeners = [];
  const subscribe = (listener) => listeners.push(listener);
  const getState = () => state;
  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach((l2) => l2(action));
  };
  return {
    subscribe,
    getState,
    dispatch
  };
};
const local = typeof window === "undefined" ? JSON.stringify(Agents_Status[3]) : localStorage == null ? void 0 : localStorage.getItem("savedStatus");
const parse$3 = !local ? Agents_Status[3] : JSON.parse(local);
const agentStatusStore = createStore(
  (state, action) => {
    var _a;
    if (state.reasonCodeId !== action.message.reasonCodeId) {
      state = action.message;
      localStorage == null ? void 0 : localStorage.setItem("savedStatus", JSON.stringify(action.message));
      if (!((_a = action.message) == null ? void 0 : _a.isPrev)) {
        localStorage == null ? void 0 : localStorage.setItem("prevStatus", JSON.stringify(action.message));
      }
    }
    return state;
  },
  { ...parse$3, changeTime: "0" }
);
function LoginPage() {
  const dispatch = useAppDispatch();
  useAppSelector((state) => {
    var _a;
    return (_a = state.auth) == null ? void 0 : _a.info;
  });
  const [loginData, setLoginData] = reactExports.useState({
    account: "",
    password: "",
    tenantId: 0
  });
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const [loginSso, setLoginSso] = reactExports.useState(true);
  const toggleLoginMode = () => {
    setLoginSso(!loginSso);
  };
  const [tenantId, setTenantId] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (navigator.serviceWorker) {
      navigator.serviceWorker.addEventListener(
        "message",
        (event) => {
          if (event.data && event.data.type === "SET_AUTH_TOKEN") ;
        }
      );
    }
  }, []);
  reactExports.useEffect(() => {
    client_socket.on(EVT_EMITTER.LOGIN_SDK, (data) => {
      getCurrentInfo((data == null ? void 0 : data.token) ?? "");
      localStorage.setItem("tenantId", (data == null ? void 0 : data.tenantId) ?? "");
      dispatch(syncLogin(data == null ? void 0 : data.token));
    });
  }, []);
  const onLogin = async (values) => {
    var _a;
    try {
      setLoading(true);
      const response = await dispatch(
        loginAsyncThunk({
          username: values.username,
          password: values.password,
          tenantId: tenantId ?? void 0
        })
      );
      const payload = response.payload;
      if ((_a = payload == null ? void 0 : payload.result) == null ? void 0 : _a.status) {
        getCurrentInfo(payload.result.accessToken ?? "");
        emitAppEvent(AppEventType.LOGGED_IN);
      } else {
      }
    } catch (error) {
      console.error(`error: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };
  function getCurrentInfo(token) {
    localStorage.setItem("token", token);
    dispatch(getCurrentLoginInfo(token)).then((res) => {
      if (res.payload) ;
    }).finally(() => {
    });
  }
  const handleInputChange = (field, value2) => {
    setLoginData((prev) => ({
      ...prev,
      [field]: value2
    }));
  };
  const onChangeKeyword = debounce((e2) => {
    if (!e2.target.value.trim()) {
      handleInputChange("tenantId", "");
      return;
    }
    checkIsTenantAvailable({ tenancyName: e2.target.value }).then((res) => {
      var _a, _b, _c, _d;
      if ((_b = (_a = res == null ? void 0 : res.data) == null ? void 0 : _a.result) == null ? void 0 : _b.tenantId) {
        handleInputChange("tenantId", (_d = (_c = res == null ? void 0 : res.data) == null ? void 0 : _c.result) == null ? void 0 : _d.tenantId);
        localStorage.setItem("tenantId", res.data.result.tenantId + "");
        setTenantId(res.data.result.tenantId);
      } else {
        handleInputChange("tenantId", null);
      }
    }).catch((err) => {
      console.error(
        "❌ Error checking tenant availability - React Vite:",
        err
      );
    });
  }, 250);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mpt-login-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-login-card", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-login-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "🔐Call Center" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Đăng nhập để sử dụng dịch vụ" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-sso-toggle", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "mpt-switch", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: loginSso,
              onChange: toggleLoginMode
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mpt-slider" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mpt-toggle-label", children: !loginSso ? "🚀 Chế độ tích hợp SSO" : "📝 Chế độ nhập biểu mẫu" })
      ] })
    ] }),
    loginSso && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mpt-form-mode", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        className: "mpt-login-form",
        onSubmit: (e2) => {
          e2.preventDefault();
          onLogin({
            username: loginData.account,
            password: loginData.password
          });
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "tenantId", children: "Không gian làm việc" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                id: "tenantId",
                onChange: onChangeKeyword,
                className: "mpt-form-control",
                placeholder: "Nhập không gian làm việc...",
                required: (loginData == null ? void 0 : loginData.tenantId) ? false : true
              }
            ),
            (loginData == null ? void 0 : loginData.tenantId) === null && /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "form-text  text-danger", children: "Không gian làm việc không hợp lệ. Vui lòng kiểm tra lại." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "account", children: "Tài khoản" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                id: "account",
                name: "account",
                value: loginData.account,
                onChange: (e2) => handleInputChange("account", e2.target.value),
                className: "mpt-form-control",
                placeholder: "Nhập tài khoản...",
                required: loginData.account ? false : true
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-form-group position-relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "password", children: "Mật khẩu" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                id: "password",
                value: loginData.password,
                onChange: (e2) => handleInputChange("password", e2.target.value),
                name: "password",
                className: "mpt-form-control",
                placeholder: "Nhập mật khẩu...",
                required: loginData.password ? false : true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "mpt-password-toggle",
                onClick: () => setShowPassword((prev) => !prev)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "w-100 mpt-login-btn",
              children: "🚀 Đăng nhập"
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mpt-login-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Demo credentials: tenantId: demo, account: admin, password: 123456" }) })
  ] }) }) });
}
const PrivateRoute = ({ children, loginComponent: CustomLoginPage }) => {
  var _a, _b, _c, _d;
  const auth = useAppSelector((state) => state.auth);
  if (!(auth == null ? void 0 : auth.accessToken) || !((_b = (_a = auth == null ? void 0 : auth.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id) || !((_d = (_c = auth == null ? void 0 : auth.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id)) {
    return CustomLoginPage ? /* @__PURE__ */ jsxRuntimeExports.jsx(CustomLoginPage, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(LoginPage, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
const MPTSelect = ({
  options,
  value: value2,
  onChange,
  placeholder = "Chọn...",
  width = 220
}) => {
  const [open, setOpen] = reactExports.useState(false);
  const [internalValue, setInternalValue] = reactExports.useState(value2);
  const containerRef = reactExports.useRef(null);
  const selected = reactExports.useMemo(
    () => options.find((o2) => o2.value === internalValue),
    [internalValue, options]
  );
  reactExports.useEffect(() => setInternalValue(value2), [value2]);
  reactExports.useEffect(() => {
    const handleClickOutside = (e2) => {
      if (!containerRef.current) return;
      if (!containerRef.current.contains(e2.target)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const styles2 = {
    wrapper: {
      position: "relative",
      width,
      fontFamily: "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial"
    },
    control: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      padding: "10px 12px",
      borderRadius: 12,
      border: "1.5px solid #e6e9ee",
      background: "#fff",
      color: "#111827",
      cursor: "pointer",
      boxShadow: open ? "0 8px 26px rgba(111, 66, 193, 0.12), 0 0 0 3px rgba(111, 66, 193, 0.15)" : "none",
      transition: "box-shadow .15s ease, border-color .15s ease"
    },
    value: {
      fontSize: 14,
      fontWeight: 600
    },
    placeholder: {
      fontSize: 14,
      color: "#9aa3b2",
      fontWeight: 500
    },
    chevron: {
      marginLeft: 8,
      width: 16,
      height: 16,
      transform: open ? "rotate(180deg)" : "rotate(0deg)",
      transition: "transform .15s ease",
      color: "#6f42c1"
    },
    menu: {
      position: "absolute",
      top: "calc(100% + 8px)",
      left: 0,
      right: 0,
      background: "#0f172a",
      borderRadius: 12,
      border: "1px solid #1f2937",
      boxShadow: "0 16px 50px rgba(0,0,0,.14), 0 2px 10px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.02)",
      overflow: "hidden",
      zIndex: 50
    },
    option: (active, selected2) => ({
      padding: "10px 12px",
      cursor: "pointer",
      background: selected2 ? "linear-gradient(45deg, #6f42c1, #dc3545)" : active ? "#1f2937" : "#0f172a",
      color: "#ffffff",
      fontWeight: selected2 ? 700 : 500,
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between"
    }),
    tick: {
      marginLeft: 8,
      fontSize: 12,
      color: "#fff",
      background: "rgba(255,255,255,.25)",
      padding: "2px 6px",
      borderRadius: 999
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mpt-select", ref: containerRef, style: styles2.wrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "mpt-select-control",
        style: styles2.control,
        onClick: () => setOpen((s2) => !s2),
        onMouseEnter: (e2) => {
          e2.currentTarget.style.borderColor = "#b8bcd1";
        },
        onMouseLeave: (e2) => {
          e2.currentTarget.style.borderColor = "#e6e9ee";
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mpt-select-value", style: styles2.value, children: selected ? selected.label : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: styles2.placeholder, children: placeholder }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              className: "mpt-select-chevron",
              style: styles2.chevron,
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M6 9l6 6 6-6",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round"
                }
              )
            }
          )
        ]
      }
    ),
    open && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mpt-select-menu", style: styles2.menu, children: options.map((opt) => {
      const isSelected = opt.value === internalValue;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "mpt-select-option",
          style: styles2.option(false, isSelected),
          onMouseEnter: (e2) => {
            if (!isSelected) e2.currentTarget.style.background = "#1f2937";
          },
          onMouseLeave: (e2) => {
            if (!isSelected) e2.currentTarget.style.background = "#0f172a";
          },
          onClick: () => {
            setInternalValue(opt.value);
            onChange == null ? void 0 : onChange(opt.value, opt);
            setOpen(false);
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#ffffff" }, children: opt.label }),
            isSelected && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: styles2.tick, children: "✓" })
          ]
        },
        opt.value
      );
    }) })
  ] });
};
const Header = () => {
  const auth = useAppSelector((store2) => store2.auth);
  const dispatch = useAppDispatch();
  const [dataSource, setDataSource] = reactExports.useState([]);
  const [status2, setStatusName] = reactExports.useState("");
  const getAgentStatusAcd2 = (params) => {
    return axiosAuth.get(
      "acd-asm-chat/status-reason/get-changeable-reason",
      { params }
    );
  };
  const getCurrentQueue = async () => {
    var _a, _b;
    try {
      const res = await getAgentStatusAcd2({
        tenantId: (_b = (_a = auth == null ? void 0 : auth.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id
      });
      setDataSource(res.data.data ?? []);
    } catch (error) {
      setDataSource([]);
    }
  };
  reactExports.useEffect(() => {
    client_socket.on(EVT_EMITTER.LOGOUT_SDK, () => {
      dispatch(agent_logout());
    });
    client_socket.on("AgentStatusEvent", (event) => {
      setStatusName((event == null ? void 0 : event.reasonName) ?? "");
    });
    getCurrentQueue();
  }, []);
  const handleLogout = async () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    try {
      const res = await logout$1({
        cloudAgentId: (_b = (_a = auth == null ? void 0 : auth.info) == null ? void 0 : _a.user) == null ? void 0 : _b.id,
        cloudTenantId: (_d = (_c = auth == null ? void 0 : auth.info) == null ? void 0 : _c.tenant) == null ? void 0 : _d.id,
        cloudAgentName: (_f = (_e = auth == null ? void 0 : auth.info) == null ? void 0 : _e.user) == null ? void 0 : _f.userName
      });
      if (res == null ? void 0 : res.status) {
        dispatch(agent_logout());
        client_socket.emit(EVT_EMITTER.LOGOUT_CRM);
        client_socket.emit(Event_SDK.AppEvent, {
          type: AppEventType.LOGGED_OUT,
          message: "Logout"
        });
        pushEventCurrentStatus({
          cloudAgentId: (_h = (_g = auth == null ? void 0 : auth.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id,
          cloudTenantId: (_j = (_i = auth == null ? void 0 : auth.info) == null ? void 0 : _i.tenant) == null ? void 0 : _j.id,
          cloudAgentName: (_l = (_k = auth == null ? void 0 : auth.info) == null ? void 0 : _k.user) == null ? void 0 : _l.userName
        });
      }
    } catch (error) {
    }
  };
  const handleChangeStatus = (agent2) => {
    console.log("change agent");
    postStatusAgent({
      cloudAgentId: auth == null ? void 0 : auth.info.user.id,
      cloudTenantId: auth.info.tenant.id,
      cloudAgentName: `${auth.info.user.fullName} (${auth.info.user.userName})`,
      reasonCodeId: agent2 == null ? void 0 : agent2.reasonCodeId,
      statusName: agent2 == null ? void 0 : agent2.reasonCode
    }).then((msg) => {
      console.log("msg agent", msg);
    }).catch((err) => {
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: 12,
        gap: 12
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MPTSelect,
          {
            options: dataSource.map((item) => ({
              ...item,
              label: item.reasonName,
              value: item.reasonCodeId.toString()
            })),
            placeholder: "Trạng thái agent",
            onChange: (value2, record) => {
              console.log("select agent status", value2, record);
              handleChangeStatus(record);
            }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `Trạng thái agent: ${status2}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleLogout,
            className: "mpt-logout-btn",
            style: {
              background: "linear-gradient(45deg, #ef4444, #dc2626)",
              border: "none",
              color: "#fff",
              padding: "10px 16px",
              borderRadius: 10,
              fontWeight: 700,
              letterSpacing: 0.2,
              boxShadow: "0 10px 24px rgba(239, 68, 68, 0.35)",
              transition: "transform .15s ease, box-shadow .15s ease",
              cursor: "pointer"
            },
            onMouseEnter: (e2) => {
              e2.currentTarget.style.transform = "translateY(-2px)", e2.currentTarget.style.boxShadow = "0 14px 28px rgba(239,68,68,.35)";
            },
            onMouseLeave: (e2) => {
              e2.currentTarget.style.transform = "translateY(0)", e2.currentTarget.style.boxShadow = "0 10px 24px rgba(239, 68, 68, 0.35)";
            },
            children: "Đăng xuất"
          }
        )
      ]
    }
  );
};
const FooterLayout = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
};
const FooterLayout$1 = reactExports.memo(FooterLayout);
const handleAudio = async (cb) => {
  try {
    await navigator.mediaDevices.getUserMedia({ audio: true });
    cb && cb();
  } catch (error) {
    emitAppEvent(AppEventType$1.PERMISSION_DENIED);
    switchErrorAudio(error);
  }
};
const ErrorBoundaryContext = reactExports.createContext(null);
const initialState = {
  didCatch: false,
  error: null
};
class ErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = reactExports.createElement(FallbackComponent, props);
      } else if (fallback !== void 0) {
        childToRender = fallback;
      } else {
        throw error;
      }
    }
    return reactExports.createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b.length || a2.some((item, index) => !Object.is(item, b[index]));
}
const AuthLayout = () => {
  const dispatch = useAppDispatch();
  const [loading, setLoading] = reactExports.useState(true);
  const token = useAppSelector((state) => {
    var _a;
    return (_a = state.auth) == null ? void 0 : _a.accessToken;
  });
  reactExports.useEffect(() => {
    setLoading(true);
    if (token) {
      getConfigBaseUrl(token ?? "").then((res) => {
        const config = JSON.parse(
          decryptData(res.data.result)
        );
        config_url.base_url = config.BASE_URL;
        config_url.sip_url = config.SIP_URL;
        config_key.ably = config.ABLY_KEY;
        config_port.sip = (config.SIP_PORT ?? 0).toString();
        dispatch(getCurrentLoginInfo(token)).then((res2) => {
          if (res2.payload) {
            client_socket.emit(EVT_EMITTER.LOGIN_CRM, token);
          }
        }).finally(() => {
          setLoading(false);
        });
      });
      handleAudio();
    }
    return () => {
      client_socket.emit(EVT_EMITTER.UN_REGISTER);
    };
  }, [token]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Something went wrong!" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Something went wrong!" }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "body-mpt", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FooterLayout$1, {})
  ] }) });
};
const AuthLayout$1 = reactExports.memo(AuthLayout);
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        height: "100%",
        overflow: "hidden",
        width: "100%"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthLayout$1, {}) })
    }
  );
}
const App$1 = reactExports.memo(App);
function BtnCallInternal() {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const { sipJs } = useAppSelector((store2) => store2.call);
  useAppDispatch();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "BtnCall Internal" });
}
const CallHeader = () => {
  var _a;
  const { callInfo, isIncomingCall } = useAppSelector((store2) => store2.call);
  const [isOpened, setIsOpened] = reactExports.useState(false);
  reactExports.useRef(null);
  const isProcessingEndCall = isIncomingCall && ((_a = callInfo == null ? void 0 : callInfo.conversation) == null ? void 0 : _a.status) === CallStatusInfo.processingEndCall;
  reactExports.useEffect(() => {
    client_socket.on(EVT_EMITTER.CALL_INTERNAL, (data) => {
      setIsOpened(data);
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    isProcessingEndCall ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Kết thúc" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    isOpened && /* @__PURE__ */ jsxRuntimeExports.jsx(BtnCallInternal, {})
  ] }) });
};
const CallHeader$1 = reactExports.memo(CallHeader);
const isString = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a2, s2, t2) => {
  a2.forEach((m2) => {
    if (s2[m2]) t2[m2] = s2[m2];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString(object);
const getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e2 = path[path.length - 1];
  let p2 = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p2, Object);
  while (last.obj === void 0 && p2.length) {
    e2 = `${p2[p2.length - 1]}.${e2}`;
    p2 = p2.slice(0, p2.length - 1);
    last = getLastOfPath(object, p2, Object);
    if ((last == null ? void 0 : last.obj) && typeof last.obj[`${last.k}.${e2}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e2}`] = newValue;
};
const pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k)) return void 0;
  return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value2 = getPath(data, key);
  if (value2 !== void 0) {
    return value2;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape$1 = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars$1 = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars$1.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path)) return void 0;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current2 = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current2 || typeof current2 !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i2; j < tokens.length; ++j) {
      if (j !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current2[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i2 += j - i2 + 1;
        break;
      }
    }
    current2 = next;
  }
  return current2;
};
const getCleanedCode = (code) => code == null ? void 0 : code.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    var _a, _b;
    (_b = (_a = console == null ? void 0 : console[type]) == null ? void 0 : _a.apply) == null ? void 0 : _b.call(_a, console, args);
  }
};
let Logger$2 = class Logger2 {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger2(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger2(this.logger, options);
  }
};
var baseLogger = new Logger$2();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng2, ns, key) {
    var _a, _b;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng2.indexOf(".") > -1) {
      path = lng2.split(".");
    } else {
      path = [lng2, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng2.indexOf(".") > -1) {
      lng2 = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind((_b = (_a = this.data) == null ? void 0 : _a[lng2]) == null ? void 0 : _b[ns], key, keySeparator);
  }
  addResource(lng2, ns, key, value2) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng2, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng2.indexOf(".") > -1) {
      path = lng2.split(".");
      value2 = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value2);
    if (!options.silent) this.emit("added", lng2, ns, key, value2);
  }
  addResources(lng2, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources) {
      if (isString(resources[m2]) || Array.isArray(resources[m2])) this.addResource(lng2, ns, m2, resources[m2], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng2, ns, resources);
  }
  addResourceBundle(lng2, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng2, ns];
    if (lng2.indexOf(".") > -1) {
      path = lng2.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng2, ns, resources);
  }
  removeResourceBundle(lng2, ns) {
    if (this.hasResourceBundle(lng2, ns)) {
      delete this.data[lng2][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng2, ns);
  }
  hasResourceBundle(lng2, ns) {
    return this.getResource(lng2, ns) !== void 0;
  }
  getResourceBundle(lng2, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng2, ns);
  }
  getDataByLanguage(lng2) {
    return this.data[lng2];
  }
  hasLanguageSomeTranslations(lng2) {
    const data = this.getDataByLanguage(lng2);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value2, key, options, translator) {
    processors.forEach((processor) => {
      var _a;
      value2 = ((_a = this.processors[processor]) == null ? void 0 : _a.process(value2, key, options, translator)) ?? value2;
    });
    return value2;
  }
};
const checkedLoadedFor = {};
const shouldHandleAsObject = (res) => !isString(res) && typeof res !== "boolean" && typeof res !== "number";
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng2) {
    if (lng2) this.language = lng2;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key == null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return (resolved == null ? void 0 : resolved.res) !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts2 = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts2[0]) > -1) namespaces = parts2.shift();
      key = parts2.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys == null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng2 = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if ((lng2 == null ? void 0 : lng2.toLowerCase()) === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng2,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng2,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved == null ? void 0 : resolved.res;
    const resUsedKey = (resolved == null ? void 0 : resolved.usedKey) || key;
    const resExactUsedKey = (resolved == null ? void 0 : resolved.exactUsedKey) || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = options.count !== void 0 && !isString(options.count);
    const hasDefaultValue = Translator.hasDefaultValue(options);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng2, options.count, options) : "";
    const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng2, options.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
    const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            if (hasDefaultValue && !res) {
              copy2[m2] = this.translate(deepKey, {
                ...options,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m2] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m2] = this.translate(deepKey, {
                ...options,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m2] === deepKey) copy2[m2] = resForObjHndl[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng2, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send2 = (l2, k, specificDefaultValue) => {
          var _a;
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k, defaultForMissing, updateMissing, options);
          } else if ((_a = this.backendConnector) == null ? void 0 : _a.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language2) => {
              const suffixes = this.pluralResolver.getSuffixes(language2, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send2([language2], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send2(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _a, _b;
    var _this = this;
    if ((_a = this.i18nFormat) == null ? void 0 : _a.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (((_b = options == null ? void 0 : options.interpolation) == null ? void 0 : _b.skipOnVariables) !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if ((lastKey == null ? void 0 : lastKey[0]) === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && (postProcessorNames == null ? void 0 : postProcessorNames.length) && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
      const needsContextHandling = options.context !== void 0 && (isString(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        var _a, _b;
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && ((_a = this.utils) == null ? void 0 : _a.hasLoadedNamespace) && !((_b = this.utils) == null ? void 0 : _b.hasLoadedNamespace(usedNS))) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          var _a2;
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if ((_a2 = this.i18nFormat) == null ? void 0 : _a2.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    var _a;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if ((_a = this.i18nFormat) == null ? void 0 : _a.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p2 = code.split("-");
    if (p2.length === 2) return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e2) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng2, obj) {
    this.rules[lng2] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    return (rule == null ? void 0 : rule.resolvedOptions().pluralCategories.length) > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    var _a;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = ((_a = options == null ? void 0 : options.interpolation) == null ? void 0 : _a.format) || ((value2) => value2);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1$1 !== void 0 ? escape$1$1 : escape$1;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if ((existingRegExp == null ? void 0 : existingRegExp.source) === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng2, options) {
    var _a;
    let match;
    let value2;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng2, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p2 = key.split(this.formatSeparator);
      const k = p2.shift().trim();
      const f = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng2, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = (options == null ? void 0 : options.missingInterpolationHandler) || this.options.missingInterpolationHandler;
    const skipOnVariables = ((_a = options == null ? void 0 : options.interpolation) == null ? void 0 : _a.skipOnVariables) !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value2 = handleFormat(matchedVar);
        if (value2 === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value2 = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value2 = "";
          } else if (skipOnVariables) {
            value2 = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value2 = "";
          }
        } else if (!isString(value2) && !this.useRawValueToEscape) {
          value2 = makeString(value2);
        }
        const safeValue = todo.safeValue(value2);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value2.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value2;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (((matchedSingleQuotes == null ? void 0 : matchedSingleQuotes.length) ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value2 = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value2 && match[0] === str && !isString(value2)) return value2;
      if (!isString(value2)) value2 = makeString(value2);
      if (!value2) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value2 = "";
      }
      if (doReduce) {
        value2 = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value2.trim());
      }
      str = str.replace(match[0], value2);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache2 = {};
  return (val, lng2, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng2 + JSON.stringify(optForCache);
    let formatter = cache2[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng2), options);
      cache2[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng2, opt) => {
        const formatter = new Intl.NumberFormat(lng2, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng2, opt) => {
        const formatter = new Intl.NumberFormat(lng2, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng2, opt) => {
        const formatter = new Intl.DateTimeFormat(lng2, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng2, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng2, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng2, opt) => {
        const formatter = new Intl.ListFormat(lng2, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = fc;
  }
  addCached(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value2, format, lng2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      var _a;
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = ((_a = options == null ? void 0 : options.formatParams) == null ? void 0 : _a[options.interpolationkey]) || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng2;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value2);
    return result;
  }
}
const removePending = (q, name2) => {
  if (q.pending[name2] !== void 0) {
    delete q.pending[name2];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store2, services) {
    var _a, _b;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store2;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    (_b = (_a = this.backend) == null ? void 0 : _a.init) == null ? void 0 : _b.call(_a, services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng2) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name2 = `${lng2}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng2, ns)) {
          this.state[name2] = 2;
        } else if (this.state[name2] < 0) ;
        else if (this.state[name2] === 1) {
          if (pending[name2] === void 0) pending[name2] = true;
        } else {
          this.state[name2] = 1;
          hasAllNamespaces = false;
          if (pending[name2] === void 0) pending[name2] = true;
          if (toLoad[name2] === void 0) toLoad[name2] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng2] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name2, err, data) {
    const s2 = name2.split("|");
    const lng2 = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng2, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng2, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name2] = err ? -1 : 2;
    if (err && data) this.state[name2] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng2], ns);
      removePending(q, name2);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l2) => {
          if (!loaded[l2]) loaded[l2] = {};
          const loadedKeys = q.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0) loaded[l2][n2] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng2, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng2.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: lng2,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng2, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r2 = fc(lng2, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng2, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name2) => {
      this.loadOne(name2);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name2) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name2.split("|");
    const lng2 = s2[0];
    const ns = s2[1];
    this.read(lng2, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng2} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng2}`, data);
      this.loaded(name2, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    var _a, _b, _c, _d, _e;
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (((_b = (_a = this.services) == null ? void 0 : _a.utils) == null ? void 0 : _b.hasLoadedNamespace) && !((_d = (_c = this.services) == null ? void 0 : _c.utils) == null ? void 0 : _d.hasLoadedNamespace(namespace))) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if ((_e = this.backend) == null ? void 0 : _e.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r2;
          if (fc.length === 5) {
            r2 = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value2) => value2,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  var _a, _b;
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (((_b = (_a = options.supportedLngs) == null ? void 0 : _a.indexOf) == null ? void 0 : _b.call(_a, "cimode")) < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
  return options;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language2) {
    var _a, _b;
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString(language2) ? language2 : this.language;
    if (typeof language2 === "function") usedCallback = language2;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if ((usedLng == null ? void 0 : usedLng.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append2 = (lng2) => {
        if (!lng2) return;
        if (lng2 === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng2);
        lngs.forEach((l2) => {
          if (l2 === "cimode") return;
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append2(l2));
      } else {
        append2(usedLng);
      }
      (_b = (_a = this.options.preload) == null ? void 0 : _a.forEach) == null ? void 0 : _b.call(_a, (l2) => append2(l2));
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l2) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng2, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng2;
    const deferred = defer();
    this.emit("languageChanging", lng2);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done2 = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      var _a, _b;
      if (!lng2 && !lngs && this.services.languageDetector) lngs = [];
      const l2 = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language) this.translator.changeLanguage(l2);
        (_b = (_a = this.services.languageDetector) == null ? void 0 : _a.cacheUserLanguage) == null ? void 0 : _b.call(_a, l2);
      }
      this.loadResources(l2, (err) => {
        done2(err, l2);
      });
    };
    if (!lng2 && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng2 && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng2);
    }
    return deferred;
  }
  getFixedT(lng2, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString(lng2)) {
      fixedT.lng = lng2;
    } else {
      fixedT.lngs = lng2;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    var _a;
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return (_a = this.translator) == null ? void 0 : _a.translate(...args);
  }
  exists() {
    var _a;
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return (_a = this.translator) == null ? void 0 : _a.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng2 = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng2.toLowerCase() === "cimode") return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng2, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng2, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng2) => preloaded.indexOf(lng2) < 0 && this.services.languageUtils.isSupportedCode(lng2));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng2) {
    var _a, _b;
    if (!lng2) lng2 = this.resolvedLanguage || (((_a = this.languages) == null ? void 0 : _a.length) > 0 ? this.languages[0] : this.language);
    if (!lng2) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = ((_b = this.services) == null ? void 0 : _b.languageUtils) || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng2)) > -1 || lng2.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone2 = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone2.logger = clone2.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone2[m2] = this[m2];
    });
    clone2.services = {
      ...this.services
    };
    clone2.services.utils = {
      hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l2) => {
        prev[l2] = {
          ...this.store.data[l2]
        };
        return Object.keys(prev[l2]).reduce((acc, n2) => {
          acc[n2] = {
            ...prev[l2][n2]
          };
          return acc;
        }, {});
      }, {});
      clone2.store = new ResourceStore(clonedData, mergedOptions);
      clone2.services.resourceStore = clone2.store;
    }
    clone2.translator = new Translator(clone2.services, mergedOptions);
    clone2.translator.on("*", function(event) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      clone2.emit(event, ...args);
    });
    clone2.init(mergedOptions, callback);
    clone2.translator.options = mergedOptions;
    clone2.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
    };
    return clone2;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const anErrorOccurred = "Có lỗi xảy ra!";
const ConnectionEstablish = "Thiết lập kết nối";
const waitingCall = "Đang chờ";
const listeningCall = "Đang trong cuộc gọi";
const processingEndCall = "Đang hoàn thiện xử lý";
const holdCall = "Đang giữ máy";
const endCall = "Đã kết thúc";
const unableToStartNewChatSession = "Tạo phiên chat thất bại";
const createChatSession = "Tạo phiên chat thành công";
const cannel = "Hủy";
const viewSession = "Xem phiên";
const takeCare = "Chăm sóc";
const customerInteractionChannel = "Kênh tương tác khách hàng";
const chooseAnInteractionChannel = "Chọn kênh tương tác";
const noData = "Không có dữ liệu";
const createSuccessfulChatSession = "Tạo phiên chat thành công.";
const createFailedChatSession = "Tạo phiên chat thất bại.";
const interactiveSessionTransferred = "Đã chuyển nhượng phiên tương tác";
const transfer = "Chuyển nhượng";
const search = "Tìm kiếm";
const waiting = "Đang chờ";
const completeProcessing = "Hoàn thiện xử lý";
const callForwarding = "Cuộc gọi chuyển tiếp";
const confirmTransferAgent = " Bạn có chắc chắn muốn chuyển phiên chat hiện tại đến {{cloudAgentName}} không?";
const closeConversation = "Đóng phiên {{time}}";
const extendCloseTime = "Thêm thời gian ({{time}}s)";
const createdTask = "Tạo công việc";
const resultInteraction = "Kết quả tương tác";
const confirm = "Xác nhận";
const inTransit = "Đang chuyển tiếp";
const notRedirectForAgent = "Không thể chuyển được cho {{agentName}}";
const title = "Tiêu đề";
const unableToSend = "Không thể gửi được!";
const successFullCreateWord = "Tạo thành công công việc #{task}";
const areYouSureYouWantToCreateAJob = "Bạn có chắc chắn muốn tạo công việc không?";
const enterTitle = "Nhập tiêu đề";
const contact = "Liên hệ";
const choice = "Lựa chọn";
const taskContent = "Nội dung công việc";
const duration = "Thời hạn";
const assignTo = "Phân công cho";
const interactiveSession = "Phiên tương tác";
const created = "Tạo";
const done = "Hoàn thành";
const openAgain = "Mở lại";
const startDoing = "Bắt đầu làm";
const cannelJob = "Huỷ công việc";
const handlingFailure = "Xử lý thất bại";
const failure = "Thất bại";
const doing = "Đang làm";
const processingData = "Đang xử lý dữ liệu";
const status = "Trạng thái";
const content = "Nội dung";
const taskCode = "Mã công việc";
const session = "Phiên";
const save = "Lưu";
const all2 = "Tất cả";
const mine = "Của tôi";
const messageTask = "Tiêu đề: {{title}}\nNội dung: {{note}}\nPhân công cho: {{agentName}}\nThời hạn: {{time}}\nTrạng thái: {{status}}\nĐộ ưu tiên: {{priority}}";
const readSession = "Xem phiên";
const interact = "Tương tác";
const note = "Ghi chú";
const task = "Công việc";
const infomation = "Thông tin";
const work = "Hoạt động";
const featureUnderDevelopment = "Tính năng đang được phát triển";
const disconnectNetWork = "Mất kết nối";
const saveSuccessInfo = "Lưu thông tin thành công";
const textTicketNotification = "{{action}}: {{userAction}} <link>{{text}}</link>";
const seeMore = "Xem thêm";
const Transfer = "chuyển ";
const Assign = "phân công ";
const Update = "chỉnh sửa thông tin ";
const Delete = "xóa";
const ChangeStatus = "cập nhật trạng thái";
const notification_name = "{{agentAssign}} {{prefix}} {{action}} {{resource}} ";
const prefixTicket = "đã";
const home = "Trang chủ";
const unknown = "Chưa định danh";
const conversation = "Hội thoại";
const viewRecently = "Xem gần đây";
const queue = "Hàng chờ";
const assignToMe = "Gán cho tôi";
const cardHeading = "{{name}} ({{number}})";
const account = "Tài khoản";
const message = "Tin nhắn";
const phoneNumber = "Số điện thoại";
const close = "Đóng";
const seeAll = "Xem tất cả";
const filter2 = "Lọc";
const modeView = "Hiển thị";
const excel = "Xuất excel";
const operation = "Thao tác";
const assignInterationToAnotherContact = "Gán tương tác sang liên hệ khác";
const theInteractiveSessionEndedSuccess = "Phiên tương tác kết thúc thành công!";
const areYouSureYouWantToEndYourInteractiveSession = "Bạn có chắc chắn muốn kết thúc tương tác của {{senderName}}?";
const thereAreCurrentlyNoRecentViewingInteractions = "Hiện chưa có tương tác xem gần đây";
const createSuccessfulCallSession = "Tạo phiên call thành công.";
const createFailedCallSession = "Tạo phiên call thất bại.";
const newMessage = "Tin nhắn mới";
const returnToPreviousPosition = "Trở về vị trí cũ";
const youCannotReceiveNewCalls = "Không thể thực hiện cuộc gọi do đang trong cuộc gọi khác.";
const receive = "Nhận";
const success = "Thành công";
const cannotBeResolvedYet = "Chưa thể giải quyết";
const selectBusinessSuccess = "Chọn kết quả nghiệp vụ thành công!";
const youHaveNotSelectedBusinessResultYet = "Bạn chưa chọn kết quả nghiệp vụ!";
const resultBusiness = "Kết quả nghiệp vụ: {{value}}";
const notResultSearch = "Không có kết quả tìm kiếm!";
const empty$1 = "Trống";
const goBack = "Quay lại";
const completionDeadline = "Hạn hoàn thành";
const peopleHandler = "Người xử lý";
const createdTime = "Thời gian tạo";
const creator = "Người tạo";
const thisFieldCannotBeLefBlank = "Trường này không được bỏ trống.";
const equalCurrentDate = "Thời hạn phải lớn hơn hoặc bằng hạn hoàn thành";
const maxContent = "Nội dung không được quá {{max}} ký tự";
const isSaving = "Đang lưu";
const taskDetail = "Chi tiết công việc";
const historyUpdate = "Lịch sử cập nhật";
const notSelect = "Chưa chọn";
const callToHotline = "Gọi đến hotline: {{applicationName}}";
const messageOver = "Nhắn qua {{applicationName}}";
const assistantAI = "Trợ lý ảo";
const creating = "Đang tạo";
const confirmAssignInteraction = "Bạn có chắc chắn muốn gán tương tác {{fromContactName}} sang liên hệ {{toContactName}}?";
const assignInteractionSucess = "Gán tương tác {{fromContactName}} sang liên hệ {{toContactName}} thành công";
const convertAudioToText = "Chuyển ghi âm thành văn bản";
const agent = "Tổng đài viên";
const customer = "Khách hàng";
const reports = "Báo cáo";
const descriptionHold = "Giữ cuộc gọi";
const continueCall = "Tiếp tục cuộc gọi";
const turnOffMic = "Tắt mic";
const openMic = "Mở mic";
const rejectCall = "Từ chối cuộc gọi";
const byeCall = "Kết thúc cuộc gọi";
const pickUpThePhone = "Nhấc máy";
const seeRecordText = "Xem văn bản ghi âm";
const seeOriginal = "Xem bản gốc";
const seeTranslation = "Xem bản dịch";
const tooltipTranslation = "Dịch tương tác sang {{language}}";
const anErrorOccurredDuringRecording = "Có lỗi xảy ra trong quá trình thu âm!";
const anErrorOccurredWhileStoppingRecording = "Có lỗi xảy ra trong quá trình dừng thu âm!";
const lengthen = "Kéo dài";
const abbreviated = "Rút gọn";
const pleaseEnterTextToUse = "Vui lòng nhập văn bản để sử dụng";
const system = "Hệ thống";
const style = "Phong cách";
const english = "Tiếng Anh";
const vietnamese = "Tiếng Việt";
const language = "Ngôn ngữ";
const customStyle = "Phong cách khách hàng";
const formal = "Trang trọng";
const intimate = "Thân mật";
const cute = "Dễ thương";
const send = "Gửi";
const pleaseSelectValue = "Vui lòng chọn giá trị!";
const noResultsReturn = "Không có kết quả trả về!";
const searchingForDataPleaseWaitMoment = "Đang tìm kiếm dữ liệu, vui lòng đợi giây lát";
const whatSupportDoYouNeedFromMe = "Bạn cần tôi hỗ trợ gì?";
const disconnectSwitchboard = "Mất kết nối tới tổng đài";
const reportName = "Tên báo cáo";
const report_lists = "Danh sách báo cáo";
const openPictureInPicture = "Mở hình trong hình";
const orderPriority = "Độ ưu tiên";
const at = "lúc";
const updatedTicket = "đã cập nhật {{modifyField}} công việc";
const createdTicket = "đã tạo công việc";
const assignedTicket = "đã chuyển người xử lý công việc";
const TITLE = "tiêu đề";
const PRIORITY = "độ ưu tiên";
const DUE_DATE = "hạn hoàn thành";
const NOTE = "nội dung";
const STATUS = "trạng thái";
const attachment = "Tệp đính kèm";
const max_size_flex = "Tệp {{name}} đã vượt quá {{size}}{{type_size}} dung lượng!";
const last_msg_custom = "{{sender_name}} đã gửi tệp {{name}}";
const last_msg_agent = "Bạn đã gửi tệp {{name}}";
const unableToUpload = "Không thể upload";
const total_max_size_file = "Tổng dung lượng tất cả các tệp đã quá giới hạn {{max_size}}mb";
const image = "hình ảnh";
const credit = "tin";
const save_change = "Lưu thay đổi";
const not_filter = "Không có bộ lọc!";
const last_msg_custom_link = "{{sender_name}} đã gửi đường dẫn";
const last_msg_custom_audio = "{{sender_name}} đã gửi tệp ghi âm";
const login = "Đăng nhập";
const logout = "Đăng xuất";
const transfer_groups = "Chuyển nhóm";
const vi = {
  anErrorOccurred,
  ConnectionEstablish,
  waitingCall,
  listeningCall,
  processingEndCall,
  holdCall,
  endCall,
  unableToStartNewChatSession,
  createChatSession,
  cannel,
  viewSession,
  takeCare,
  customerInteractionChannel,
  chooseAnInteractionChannel,
  noData,
  createSuccessfulChatSession,
  createFailedChatSession,
  interactiveSessionTransferred,
  transfer,
  search,
  waiting,
  completeProcessing,
  callForwarding,
  confirmTransferAgent,
  closeConversation,
  extendCloseTime,
  createdTask,
  resultInteraction,
  confirm,
  inTransit,
  notRedirectForAgent,
  title,
  unableToSend,
  successFullCreateWord,
  areYouSureYouWantToCreateAJob,
  enterTitle,
  contact,
  choice,
  taskContent,
  duration,
  assignTo,
  interactiveSession,
  created,
  "new": "Mới",
  done,
  openAgain,
  startDoing,
  cannelJob,
  handlingFailure,
  failure,
  doing,
  processingData,
  status,
  content,
  taskCode,
  session,
  save,
  all: all2,
  mine,
  messageTask,
  readSession,
  interact,
  note,
  task,
  infomation,
  work,
  featureUnderDevelopment,
  disconnectNetWork,
  saveSuccessInfo,
  textTicketNotification,
  seeMore,
  Transfer,
  Assign,
  Update,
  Delete,
  ChangeStatus,
  notification_name,
  prefixTicket,
  home,
  unknown,
  conversation,
  viewRecently,
  queue,
  assignToMe,
  cardHeading,
  account,
  message,
  phoneNumber,
  close,
  seeAll,
  filter: filter2,
  modeView,
  excel,
  operation,
  assignInterationToAnotherContact,
  theInteractiveSessionEndedSuccess,
  areYouSureYouWantToEndYourInteractiveSession,
  thereAreCurrentlyNoRecentViewingInteractions,
  createSuccessfulCallSession,
  createFailedCallSession,
  newMessage,
  returnToPreviousPosition,
  youCannotReceiveNewCalls,
  receive,
  success,
  cannotBeResolvedYet,
  selectBusinessSuccess,
  youHaveNotSelectedBusinessResultYet,
  resultBusiness,
  notResultSearch,
  empty: empty$1,
  goBack,
  completionDeadline,
  peopleHandler,
  createdTime,
  creator,
  thisFieldCannotBeLefBlank,
  equalCurrentDate,
  maxContent,
  isSaving,
  taskDetail,
  historyUpdate,
  notSelect,
  callToHotline,
  messageOver,
  assistantAI,
  creating,
  confirmAssignInteraction,
  assignInteractionSucess,
  convertAudioToText,
  agent,
  customer,
  reports,
  descriptionHold,
  continueCall,
  turnOffMic,
  openMic,
  rejectCall,
  byeCall,
  pickUpThePhone,
  seeRecordText,
  seeOriginal,
  seeTranslation,
  tooltipTranslation,
  "browserDoesn'tSupportSpeechRecognition": "Trình duyệt không hỗ trợ nhận dạng giọng nói",
  anErrorOccurredDuringRecording,
  anErrorOccurredWhileStoppingRecording,
  lengthen,
  abbreviated,
  pleaseEnterTextToUse,
  system,
  style,
  english,
  vietnamese,
  language,
  customStyle,
  formal,
  intimate,
  cute,
  send,
  pleaseSelectValue,
  noResultsReturn,
  searchingForDataPleaseWaitMoment,
  whatSupportDoYouNeedFromMe,
  disconnectSwitchboard,
  reportName,
  report_lists,
  openPictureInPicture,
  "camera-off": "Tắt camera",
  "camera-on": "Mở camera",
  orderPriority,
  at,
  updatedTicket,
  createdTicket,
  assignedTicket,
  TITLE,
  PRIORITY,
  DUE_DATE,
  NOTE,
  STATUS,
  attachment,
  max_size_flex,
  last_msg_custom,
  last_msg_agent,
  unableToUpload,
  total_max_size_file,
  image,
  credit,
  save_change,
  not_filter,
  last_msg_custom_link,
  last_msg_custom_audio,
  login,
  logout,
  transfer_groups
};
const name = "Name";
const en = {
  name
};
const lng = getStorage("lang", "vi", false) ?? "vi";
const switchLangue = (ln) => {
  switch (ln) {
    case "en":
      return en;
    default: {
      return vi;
    }
  }
};
instance.use(initReactI18next).init({
  lng,
  resources: {
    [lng]: {
      translation: switchLangue(lng)
    }
  }
});
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;
    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;
    else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;
    else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value2) {
    this._a = boundAlpha(value2);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s2 + "%, " + v + "%)" : "hsva(" + h + ", " + s2 + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360), s2 = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s2 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString2(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i2 in color) {
      if (color.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color[i2];
        } else {
          newColor[i2] = convertToPercentage(color[i2]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a2 = 1;
  var s2 = null;
  var v = null;
  var l2 = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
function rgbToRgb(r2, g, b) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r2, g, b), min = Math.min(r2, g, b);
  var h, s2, l2 = (max + min) / 2;
  if (max == min) {
    h = s2 = 0;
  } else {
    var d = max - min;
    s2 = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s: s2,
    l: l2
  };
}
function hslToRgb(h, s2, l2) {
  var r2, g, b;
  h = bound01(h, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  function hue2rgb(p3, q2, t2) {
    if (t2 < 0) t2 += 1;
    if (t2 > 1) t2 -= 1;
    if (t2 < 1 / 6) return p3 + (q2 - p3) * 6 * t2;
    if (t2 < 1 / 2) return q2;
    if (t2 < 2 / 3) return p3 + (q2 - p3) * (2 / 3 - t2) * 6;
    return p3;
  }
  if (s2 === 0) {
    r2 = g = b = l2;
  } else {
    var q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q;
    r2 = hue2rgb(p2, q, h + 1 / 3);
    g = hue2rgb(p2, q, h);
    b = hue2rgb(p2, q, h - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r2, g, b), min = Math.min(r2, g, b);
  var h, s2, v = max;
  var d = max - min;
  s2 = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0;
  } else {
    switch (max) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s: s2,
    v
  };
}
function hsvToRgb(h, s2, v) {
  h = bound01(h, 360) * 6;
  s2 = bound01(s2, 100);
  v = bound01(v, 100);
  var i2 = Math.floor(h), f = h - i2, p2 = v * (1 - s2), q = v * (1 - f * s2), t2 = v * (1 - (1 - f) * s2), mod = i2 % 6, r2 = [v, q, p2, p2, t2, v][mod], g = [t2, v, v, q, p2, p2][mod], b = [p2, p2, t2, v, v, q][mod];
  return {
    r: r2 * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r2, g, b, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g, b, a2, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a2))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r2, g, b, a2) {
  var hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i2 = 1; i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h, s2 = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s: s2,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p2 = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p2 + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o2) {
  var flipped = {};
  for (var i2 in o2) {
    if (o2.hasOwnProperty(i2)) {
      flipped[o2[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function bound01(n2, max) {
  if (isOnePointZero(n2)) n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max, 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  return n2 % max / parseFloat(max);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c2) {
  return c2.length == 1 ? "0" + c2 : "" + c2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}
const DEFAULT_THRESHOLD = Math.sqrt(1.05 * 0.05) - 0.05;
const RE_HEX = /^(?:[0-9a-f]{3}){1,2}$/i;
const DEFAULT_BW = {
  black: "#000000",
  white: "#ffffff",
  threshold: DEFAULT_THRESHOLD
};
function padz(str, len = 2) {
  return (new Array(len).join("0") + str).slice(-len);
}
function hexToRgbArray(hex) {
  if (hex.slice(0, 1) === "#")
    hex = hex.slice(1);
  if (!RE_HEX.test(hex))
    throw new Error(`Invalid HEX color: "${hex}"`);
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  return [
    parseInt(hex.slice(0, 2), 16),
    parseInt(hex.slice(2, 4), 16),
    parseInt(hex.slice(4, 6), 16)
    // b
  ];
}
function toRGB(c2) {
  return { r: c2[0], g: c2[1], b: c2[2] };
}
function toRgbArray(c2) {
  if (!c2)
    throw new Error("Invalid color value");
  if (Array.isArray(c2))
    return c2;
  return typeof c2 === "string" ? hexToRgbArray(c2) : [c2.r, c2.g, c2.b];
}
function getLuminance2(c2) {
  let i2, x;
  const a2 = [];
  for (i2 = 0; i2 < c2.length; i2++) {
    x = c2[i2] / 255;
    a2[i2] = x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }
  return 0.2126 * a2[0] + 0.7152 * a2[1] + 0.0722 * a2[2];
}
function invertToBW(color, bw, asArr) {
  const options = bw === true ? DEFAULT_BW : Object.assign({}, DEFAULT_BW, bw);
  return getLuminance2(color) > options.threshold ? asArr ? hexToRgbArray(options.black) : options.black : asArr ? hexToRgbArray(options.white) : options.white;
}
function invert(color, bw = false) {
  color = toRgbArray(color);
  if (bw)
    return invertToBW(color, bw);
  return "#" + color.map((c2) => padz((255 - c2).toString(16))).join("");
}
(function(invert2) {
  function asRGB(color, bw) {
    color = toRgbArray(color);
    const list = bw ? invertToBW(color, bw, true) : color.map((c2) => 255 - c2);
    return toRGB(list);
  }
  invert2.asRGB = asRGB;
  function asRgbArray(color, bw) {
    color = toRgbArray(color);
    return bw ? invertToBW(color, bw, true) : color.map((c2) => 255 - c2);
  }
  invert2.asRgbArray = asRgbArray;
  invert2.defaultThreshold = DEFAULT_THRESHOLD;
  invert2.asRgbObject = asRGB;
})(invert || (invert = {}));
const invert$1 = invert;
function invertBgColorToTextColor(bgColor) {
  const defaultColor = "#fff";
  if (!bgColor) {
    return defaultColor;
  }
  const color = tinycolor(bgColor);
  if (color.isValid()) {
    const hexColor = color.toHexString();
    return invert$1(hexColor, {
      black: "#333",
      white: "#fff",
      threshold: 0.25
    });
  }
  return defaultColor;
}
const LogoSDK = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAACE4AAAhOAFFljFgAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAltSURBVHja7JltbKTXVcd/597nbWbszHjsfelm002bZNu8EGgRKlKgtNAvCJUvSIgvfKgq2qZN0AqkpAXRogJtWkQVoaRCASQgCW3UZkuaRNqFlrSNW2U32WRJUJrEWXaz3l3ba69nbM/L83bv4YMd22t7nKRFQpV8R/8v88y9z/mf87/nnHtHVJWf5WH4GR87BHYI7BDYIbBDYIfADoH/zxH83r++PP6BX3vXLdMXe5eMbHouQBP4oSf/EGi6/NXyaMSW7012OHahRyOxG+davP4H8EFgHri86VIlC8J6faE9/jvvPZCYJP7lsnSzWzh1CGRW0VsDWzxmNixkHnn0mcbkq9OM7qqOeq+jwHo0l1nILUJ49/LUjRgwlC+tGM/KOmvreh019aHRcL4VvPKd5xanF7t/WavGALs2vH8UiFV1f2zNo87LwaXc0Sv8KkxqQg4/NA69jLiWsFV3qiiC+bgQ/vayg9YgCGJAZA3Ar6P6xwPJxRG2yOk/P0Gv697+44mpx6OIe9ZHd12gGI4t/cLx8Eutvz880ebhiQUOr8CM7Krz0pkWPzryNKNjFlQGulQI/hoSgQpQQaRG6QKyzJPnkGVQloio3js4MoqtD5E9/QKdmQXM3mZw5rVLLHb6h6w1U5t0aCA0hvFzC5xdTN/vvdwRixCuwJiiILl6P0cff5bJE6dpvK2K+kHS0IOCvwdKllEAnss8p3oXyru3nO4VaTbg1dMsnZzAXbmP4VCYmlni/PSCq9aCT6xfyys0KyHPzSzxwmyH3dWIyJgvlUXn5iydJ88WMArUYkurMsyR+7+D9RAm4UB5C3xSKD4EKaopgXXEsRDFECe8L7DcMXBnhAEGJR0/QTrUwAaGIDD0l1Jenpgijv23Vf2DICgwHFnmegXjk20qgcWaZVKZxnd1S8dSni3veM1z6tce4OQrsxy7/wjN/RF+m5OaEN4LZpnjisPUg5b6dwOneUV2NfHfHad7bhZ/4Coky1EFG4ecOdui280xgTsEzFsR4sDw5OQCraxkKDKogqonNOFvVpORT1YrjbWUZYsce/27+O63nmLmvy9S31PDbyklBTgoxF8UqeJcQFEqqH4B+IVBupfGMHJmkv74CbLrDmKKfJX88FDM6bPznD4zT/OKeM4a96mxSsQLFzs8P9uhmYSsN0XxWAnuDmx8w1rOLQqqe8eYjYb49698jSCCaFsp6acFPug9uFJ/HuUzA0NmLcQx5SNH6dfq+LExJM/XPRaKfs6rp+fABBjjv36+07v7yckFEitY2conPlRXfnyNgAj0egy/9yZOnjjFMw88wciV20lJMJR/nkSOOJKvDDTee2T3GPrkMdJT58hvvBHT763m29djWostL831eODFeb410ebwK3NpWnqGIjuw2qgac1nVk7JE44Tg5pt44r5HmH6lRWN3bcuspCiBsbc4J/+lXn91sHSuQGdmKR85SnbNdfgkQcpy0/6IkhDTrDOzlHOxU344Lfynk0AYlBAVMJT3X162RTC9LsHBa5nXgCf+9iHCKgRRcJmUvEIjDnhtMbMvzHZvHo5suJ103DcfI3OQX3vNJu8DuKwgaAyRjDUIizKqWLk3smag550KtUD/dFfFHzdbhdx7pfq+X+T5o8c59o2nGLkyvqxCR3Y5zf3gbItO7oi2Eqn3mF1N3PHncMdPkr/nPXhjEOc2/7RwxM0riKohBn8PcNXgFCgY/A/yNP/CYnerblQEk6WUu/cSvOPtjH/1m8z8zxLVem21tNfjgKenlpho9RlJgi3DLENV/Mwl/L8dobjqKrI9e7H9/ibvq/fYJKSyZwRfuN9A+YNt208RxJV3FKXSK/2Adlo96h3Bz93E3Pk5jn3t6LlKnUWvUE8s052cH55rMxxZBjUeVCvt8j/HL/jpWbLrb0B1OSqbvV8S1WuE9Ro+Le57I+O1yD+nrjyGAREddB4QTJqSjTQJrruGqZM//odOy325kkRYEZ481yYtPUkwQKdRiLYX75MXX36wuPpqsuYYNt3sfUTQvHTBFUNIGN6l3r9zO+NR/5xz2ecda5/tDzTOY264nulXzw+99tTJv9q3L7hwfGqJF+e6NJKAQRlWqpWOnDpzp28tkF573Za6X02xUXA22TX8K/jyzq3b9XUvKcqPBWoJJCRY+WxLwGQpvjHCQvPK5vnnTzHT4zM/Or9INbQDJ4oYjPe3l6deo7dr356iOYbJ0q3tL0qixvCeuNn4C586wLTALGxAjkgf738f757ZGMVg2wgoSJ7hfunGB16q1dk3Mf8vo7H9rblUf1cHGO+0eLhoTf/TwtAo+fUj2AHGr5UKPSo++ixKgvpoi1WNkvfA5Zsk+IZnYhFw7h+tK57oqTCbOnZXwlud0i69brWBC2u4s1zKyDOHCQS2qeQS2u9nrdZns/YiNklSkMUt0Abyn/RQP+nV31b2PDUR3vG2hJv2V+fff2D4Ng+49cYtZ4hDobGn/HyO72crTfG24498XtCfvrji3DfYA2+NgODVfQx86gUCgboIsVcOVIMHG5F9NHW6FinvHxd1Xy3zkrTdwQR2u9Ci6j6n6p41UUTWXsRlOWLe+iVJMPAF+H9G/REQapFhrut46ESLMi8IEMJIPhEH5gMehi2UWha32zikP7dE1u5io3Cg8aDHVf3nQTBRSL64RNZqU9k9RtlP/y/uhXRKvbt9VdhOqUWGG/dVeffeCu/cE3NwLLlwoBZ9xEPpivyjOHdawoB8oYcvHYMrHKhzf4hX8CAquDSnPz2HCYI3lMybiICg3t2G6tLrVhhr6Xf6xFpSGw4pC0dkhNLycJyaMHOOIAooOym9mfa23lfjv6jWH1vP0EpE2m1R9HqICVDvfsIIqKDGP6CxO0wikAAJhMOWpaLP/EIXxFI4JXdK6XTVXzYO6Zy7RL7Qw0TBIOk8q8b9CYGAZRW2EpEutunPXSJI4p9KQpfU+0M4AccqxBuKtKTfy7B2s+pMFFAspfQuzGOTcGDqVHWfIlPoAf0N6CrZXOstX3YaRGdXsw7uVpy/RLFyY7ICKcH1Pd3FPrKxdRYwgWVpco68myNhiCKvY2pd1rlL1T+1fPvFJthKTO/iHFl7ERMGb34PqOGQlPI3iD6G+m9sVe1eP4EVRYls2J2CoM5TdDNUltvjddy+jLAfdF5V/2xbT1qLSzPKbp9oeAhflG+KgOz80b1DYIfADoEdAj/N+N8BANTyz4MxQcgFAAAAAElFTkSuQmCC";
function computeChatbotSize(screenWidth, screenHeight, customWidth = 0, customHeight = 0) {
  const minWidth = 430;
  const minHeight = 560;
  const maxWidth = screenWidth - 48;
  const maxHeight = screenHeight - 120;
  if (customWidth === 0 || customHeight === 0) {
    return {
      width: minWidth,
      height: minHeight
    };
  }
  return {
    width: customWidth > maxWidth ? maxWidth : customWidth,
    height: customHeight > maxHeight ? maxHeight : customHeight
  };
}
const ComponentSvg = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    viewBox: "0 0 24 24",
    color: "#dc4a41",
    focusable: "false",
    className: "chakra-icon css-qk6lof",
    height: "20px",
    width: "20px",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
      }
    )
  }
);
const MyErrorSnackbar = reactExports.forwardRef(
  function MySuccessSnackbar(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      SnackbarContent,
      {
        ref,
        style: {
          backgroundColor: "#fff",
          color: "#000",
          padding: "12px 16px",
          borderRadius: "6px",
          fontSize: 14,
          fontFamily: "Inter, sans-serif",
          boxShadow: "0 10px 15px -3px rgba(0, 0, 0, 0.1),0 4px 6px -2px rgba(0, 0, 0, 0.05)",
          fontWeight: 600,
          display: "flex",
          alignItems: "center",
          lineHeight: 0,
          border: "1px solid rgba(0, 0, 0, 0.08)",
          columnGap: 6,
          flexWrap: "nowrap"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentSvg, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                width: "max-content"
              },
              children: `${(props == null ? void 0 : props.message) ?? ""}`
            }
          )
        ]
      }
    );
  }
);
function EmbedChatBotButton(props) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [isShow, setIsShow] = reactExports.useState((props == null ? void 0 : props.isShow) ?? false);
  const [config, setConfig] = reactExports.useState({
    ChatBubbleAlign: 0
  });
  const [isError2, setIsError] = reactExports.useState(false);
  const align = (config == null ? void 0 : config.ChatBubbleAlign) === 1 ? "left" : "right";
  reactExports.useEffect(() => {
    client_socket.on(EVT_EMITTER.BUBBLE, (isShow2) => {
      setIsShow(isShow2);
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Provider_default, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SnackbarProvider,
    {
      Components: {
        error: MyErrorSnackbar
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: isShow ? "block" : "none"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MobileBg,
              {
                show: isMobile_1 && isOpen,
                onClose: () => setIsOpen(false)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChatbotBubbleSwitch,
              {
                boxShadow: "3px 3px 16px 2px #000",
                align,
                icon: config.ChatIconUrl,
                bgColor: config.ChatBubbleColor,
                open: isOpen,
                onClick: () => {
                  setIsOpen((prevBol) => {
                    return !prevBol;
                  });
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ChatContent, { open: isOpen, align })
          ]
        }
      )
    }
  ) });
}
function ChatContent({
  open,
  align = "right"
}) {
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  const { width, height } = computeChatbotSize(screenWidth, screenHeight);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        minWidth: isMobile_1 ? screenWidth : width,
        // height: isMobile ? screenHeight * 0.85 : height,
        // maxWidth: 400,
        border: "1px solid #e5e7eb",
        [align]: isMobile_1 ? 0 : 30,
        backgroundColor: "#fff",
        boxShadow: "0 0 16px rgba(0,0,0,.1)",
        position: "fixed",
        bottom: isMobile_1 ? 0 : 120,
        zIndex: 1e3,
        display: "flex",
        opacity: open ? 1 : 0,
        transform: open ? "scale(1)" : "scale(0)",
        transformOrigin: "bottom right",
        transition: "transform 0.25s,opacity 0.15s",
        width: "960px",
        height: "80%",
        borderRadius: "12px"
      },
      className: "mpt-flex-col mpt-rounded-3xl",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(App$1, {})
    }
  );
}
const switchButtonStyle = {
  userSelect: "none",
  cursor: "pointer",
  width: 56,
  height: 56,
  borderRadius: 28,
  position: "fixed",
  zIndex: 1e3,
  bottom: 48,
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  overflow: "hidden"
};
function ChatbotBubbleSwitch({
  boxShadow,
  align = "right",
  open,
  onClick,
  bgColor
}) {
  const isCall = useAppSelector(
    (store2) => {
      var _a;
      return (_a = store2.call) == null ? void 0 : _a.isIncomingCall;
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        ...switchButtonStyle,
        [align]: 48,
        backgroundColor: bgColor || "#333",
        boxShadow,
        width: !open && isCall ? "max-content" : "56px",
        padding: !open && isCall ? "0 16px" : 0
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            color: "white",
            style: {
              display: !open && isCall ? "block" : "none"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(CallHeader$1, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick,
            style: {
              boxShadow: "none"
            },
            children: open ? /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { color: invertBgColorToTextColor(bgColor) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: LogoSDK,
                style: { width: "100%", height: "100%", objectFit: "cover" }
              }
            )
          }
        )
      ]
    }
  );
}
function MobileBg({ show, onClose }) {
  if (!show) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        backgroundColor: "rgba(0,0,0, .5)",
        width: "100vw",
        height: "100vh",
        position: "fixed",
        zIndex: 2147483646,
        top: 0,
        left: 0,
        color: "green"
      },
      onClick: (e2) => {
        e2.stopPropagation();
        onClose();
      }
    }
  );
}
function Close({ color }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      viewBox: "0 0 1024 1024",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "p-id": "4184",
      width: "32",
      height: "32",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M801.645714 170.666667l51.833905 51.590095L565.150476 511.951238l288.353524 289.670095-51.833905 51.614477-288.109714-289.450667L225.426286 853.23581 173.592381 801.621333l288.329143-289.670095L173.592381 222.256762 225.426286 170.666667l288.109714 289.426285L801.645714 170.666667z",
          "p-id": "4185",
          fill: color
        }
      )
    }
  );
}
const EmbedChatBotButton$1 = reactExports.memo(EmbedChatBotButton);
const BUBBLE_CSS = `
  
`;
const BUBBLE_POSITIONS = {
  "top-left": { top: "20px", left: "20px" },
  "top-right": { top: "20px", right: "20px" },
  "bottom-left": { bottom: "20px", left: "20px" },
  "bottom-right": { bottom: "20px", right: "20px" }
};
const CONTENT_POSITIONS = {
  "top-left": { top: "90px", left: "20px" },
  "top-right": { top: "90px", right: "20px" },
  "bottom-left": { bottom: "90px", left: "20px" },
  "bottom-right": { bottom: "90px", right: "20px" }
};
class BubbleUI {
  /**
   * Creates a new BubbleUI instance
   * @param container Container element
   * @param theme Theme options
   */
  constructor(container, theme = {}) {
    __publicField(this, "container");
    __publicField(this, "bubble", null);
    __publicField(this, "content", null);
    __publicField(this, "isOpen", false);
    __publicField(this, "theme");
    __publicField(this, "position");
    this.container = container;
    this.theme = theme;
    this.position = theme.bubblePosition || "bottom-right";
  }
  /**
   * Creates and renders the bubble UI
   */
  render(mode) {
    this.bubble = createElement("div", { class: "sdk-bubble" });
    const bubblePosition = BUBBLE_POSITIONS[this.position];
    Object.entries(bubblePosition).forEach(([key, value2]) => {
      this.bubble.style[key] = value2;
    });
    if (this.theme.primaryColor) {
      this.bubble.style.setProperty("--primary-color", this.theme.primaryColor);
    }
    if (this.theme.secondaryColor) {
      this.bubble.style.setProperty(
        "--secondary-color",
        this.theme.secondaryColor
      );
    }
    client.createRoot(this.bubble).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(EmbedChatBotButton$1, { isShow: mode === "bubble" ? true : false })
    );
    this.content = this.createContentContainer();
    this.bubble.addEventListener("click", () => this.toggleContent());
    this.container.appendChild(this.bubble);
    this.container.appendChild(this.content);
  }
  /**
   * Updates the bubble UI with new content
   * @param title Content title
   * @param body Content body
   */
  updateContent(title2, body) {
    if (!this.content) return;
    const headerText = this.content.querySelector(".sdk-bubble-header-text");
    if (headerText) {
      headerText.textContent = title2;
    }
    const bodyElement = this.content.querySelector(".sdk-bubble-body");
    if (bodyElement) {
      bodyElement.innerHTML = body;
    }
  }
  /**
   * Shows the bubble UI
   */
  show() {
    if (this.bubble) {
      this.bubble.style.display = "flex";
    }
    this.openContent();
  }
  /**
   * Hides the bubble UI
   */
  hide() {
    if (this.bubble) {
      this.bubble.style.display = "none";
    }
    this.closeContent();
  }
  /**
   * Destroys the bubble UI
   */
  destroy() {
    if (this.bubble && this.bubble.parentNode) {
      this.bubble.parentNode.removeChild(this.bubble);
    }
    if (this.content && this.content.parentNode) {
      this.content.parentNode.removeChild(this.content);
    }
    this.bubble = null;
    this.content = null;
  }
  /**
   * Creates the bubble icon
   * @returns The bubble icon element
   */
  createBubbleIcon() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "sdk-bubble-icon");
    svg.setAttribute("viewBox", "0 0 24 24");
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute(
      "d",
      "M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.17L4 17.17V4h16v12z"
    );
    svg.appendChild(path);
    return svg;
  }
  /**
   * Creates the content container
   * @returns The content container element
   */
  createContentContainer() {
    const content2 = createElement("div", {
      class: "sdk-bubble-content"
    });
    const contentPosition = CONTENT_POSITIONS[this.position];
    Object.entries(contentPosition).forEach(([key, value2]) => {
      content2.style[key] = value2;
    });
    return content2;
  }
  /**
   * Toggles the content visibility
   */
  toggleContent() {
    if (this.isOpen) {
      this.closeContent();
    } else {
      this.openContent();
    }
  }
  /**
   * Opens the content
   */
  openContent() {
    if (!this.content) return;
    this.content.classList.add("active");
    this.isOpen = true;
  }
  /**
   * Closes the content
   */
  closeContent() {
    if (!this.content) return;
    this.content.classList.remove("active");
    this.isOpen = false;
  }
  /**
   * Gets the bubble CSS
   * @returns The bubble CSS
   */
  static getCSS() {
    return BUBBLE_CSS;
  }
}
function defaultMediaStreamFactory$1() {
  return (constraints) => {
    if (!constraints.audio && !constraints.video) {
      return Promise.resolve(new MediaStream());
    }
    if (navigator.mediaDevices === void 0) {
      return Promise.reject(new Error("Media devices not available in insecure contexts."));
    }
    return navigator.mediaDevices.getUserMedia.call(navigator.mediaDevices, constraints);
  };
}
function defaultPeerConnectionConfiguration$1() {
  const configuration = {
    bundlePolicy: "balanced",
    certificates: void 0,
    iceCandidatePoolSize: 0,
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
    iceTransportPolicy: "all",
    rtcpMuxPolicy: "require"
  };
  return configuration;
}
let SessionDescriptionHandler$1 = class SessionDescriptionHandler {
  /**
   * Constructor
   * @param logger - A logger
   * @param mediaStreamFactory - A factory to provide a MediaStream
   * @param options - Options passed from the SessionDescriptionHandleFactory
   */
  constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {
    logger.debug("SessionDescriptionHandler.constructor");
    this.logger = logger;
    this.mediaStreamFactory = mediaStreamFactory;
    this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;
    this._localMediaStream = new MediaStream();
    this._remoteMediaStream = new MediaStream();
    this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);
    this.initPeerConnectionEventHandlers();
  }
  /**
   * The local media stream currently being sent.
   *
   * @remarks
   * The local media stream initially has no tracks, so the presence of tracks
   * should not be assumed. Furthermore, tracks may be added or removed if the
   * local media changes - for example, on upgrade from audio only to a video session.
   * At any given time there will be at most one audio track and one video track
   * (it's possible that this restriction may not apply to sub-classes).
   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event
   * to detect when a new track becomes available:
   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
   */
  get localMediaStream() {
    return this._localMediaStream;
  }
  /**
   * The remote media stream currently being received.
   *
   * @remarks
   * The remote media stream initially has no tracks, so the presence of tracks
   * should not be assumed. Furthermore, tracks may be added or removed if the
   * remote media changes - for example, on upgrade from audio only to a video session.
   * At any given time there will be at most one audio track and one video track
   * (it's possible that this restriction may not apply to sub-classes).
   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event
   * to detect when a new track becomes available:
   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
   */
  get remoteMediaStream() {
    return this._remoteMediaStream;
  }
  /**
   * The data channel. Undefined before it is created.
   */
  get dataChannel() {
    return this._dataChannel;
  }
  /**
   * The peer connection. Undefined if peer connection has closed.
   *
   * @remarks
   * Use the peerConnectionDelegate to get access to the events associated
   * with the RTCPeerConnection. For example...
   *
   * Do NOT do this...
   * ```ts
   * peerConnection.onicecandidate = (event) => {
   *   // do something
   * };
   * ```
   * Instead, do this...
   * ```ts
   * peerConnection.peerConnectionDelegate = {
   *   onicecandidate: (event) => {
   *     // do something
   *   }
   * };
   * ```
   * While access to the underlying `RTCPeerConnection` is provided, note that
   * using methods which modify it may break the operation of this class.
   * In particular, this class depends on exclusive access to the
   * event handler properties. If you need access to the peer connection
   * events, either register for events using `addEventListener()` on
   * the `RTCPeerConnection` or set the `peerConnectionDelegate` on
   * this `SessionDescriptionHandler`.
   */
  get peerConnection() {
    return this._peerConnection;
  }
  /**
   * A delegate which provides access to the peer connection event handlers.
   *
   * @remarks
   * Use the peerConnectionDelegate to get access to the events associated
   * with the RTCPeerConnection. For example...
   *
   * Do NOT do this...
   * ```ts
   * peerConnection.onicecandidate = (event) => {
   *   // do something
   * };
   * ```
   * Instead, do this...
   * ```
   * peerConnection.peerConnectionDelegate = {
   *   onicecandidate: (event) => {
   *     // do something
   *   }
   * };
   * ```
   * Setting the peer connection event handlers directly is not supported
   * and may break this class. As this class depends on exclusive access
   * to them. This delegate is intended to provide access to the
   * RTCPeerConnection events in a fashion which is supported.
   */
  get peerConnectionDelegate() {
    return this._peerConnectionDelegate;
  }
  set peerConnectionDelegate(delegate) {
    this._peerConnectionDelegate = delegate;
  }
  // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
  static dispatchAddTrackEvent(stream, track) {
    stream.dispatchEvent(new MediaStreamTrackEvent("addtrack", { track }));
  }
  // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack
  static dispatchRemoveTrackEvent(stream, track) {
    stream.dispatchEvent(new MediaStreamTrackEvent("removetrack", { track }));
  }
  /**
   * Stop tracks and close peer connection.
   */
  close() {
    this.logger.debug("SessionDescriptionHandler.close");
    if (this._peerConnection === void 0) {
      return;
    }
    this._peerConnection.getReceivers().forEach((receiver) => {
      receiver.track && receiver.track.stop();
    });
    this._peerConnection.getSenders().forEach((sender) => {
      sender.track && sender.track.stop();
    });
    if (this._dataChannel) {
      this._dataChannel.close();
    }
    this._peerConnection.close();
    this._peerConnection = void 0;
  }
  /**
   * Helper function to enable/disable media tracks.
   * @param enable - If true enable tracks, otherwise disable tracks.
   */
  enableReceiverTracks(enable) {
    const peerConnection = this.peerConnection;
    if (!peerConnection) {
      throw new Error("Peer connection closed.");
    }
    peerConnection.getReceivers().forEach((receiver) => {
      if (receiver.track) {
        receiver.track.enabled = enable;
      }
    });
  }
  /**
   * Helper function to enable/disable media tracks.
   * @param enable - If true enable tracks, otherwise disable tracks.
   */
  enableSenderTracks(enable) {
    const peerConnection = this.peerConnection;
    if (!peerConnection) {
      throw new Error("Peer connection closed.");
    }
    peerConnection.getSenders().forEach((sender) => {
      if (sender.track) {
        sender.track.enabled = enable;
      }
    });
  }
  /**
   * Creates an offer or answer.
   * @param options - Options bucket.
   * @param modifiers - Modifiers.
   */
  getDescription(options, modifiers) {
    var _a, _b;
    this.logger.debug("SessionDescriptionHandler.getDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;
    const iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart;
    const iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === void 0 ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;
    return this.getLocalMediaStream(options).then(() => this.updateDirection(options)).then(() => this.createDataChannel(options)).then(() => this.createLocalOfferOrAnswer(options)).then((sessionDescription) => this.applyModifiers(sessionDescription, modifiers)).then((sessionDescription) => this.setLocalSessionDescription(sessionDescription)).then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout)).then(() => this.getLocalSessionDescription()).then((sessionDescription) => {
      return {
        body: sessionDescription.sdp,
        contentType: "application/sdp"
      };
    }).catch((error) => {
      this.logger.error("SessionDescriptionHandler.getDescription failed - " + error);
      throw error;
    });
  }
  /**
   * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.
   * @param contentType - The content type that is in the SIP Message.
   */
  hasDescription(contentType) {
    this.logger.debug("SessionDescriptionHandler.hasDescription");
    return contentType === "application/sdp";
  }
  /**
   * Called when ICE gathering completes and resolves any waiting promise.
   * @remarks
   * May be called prior to ICE gathering actually completing to allow the
   * session descirption handler proceed with whatever candidates have been
   * gathered up to this point in time. Use this to stop waiting on ICE to
   * complete if you are implementing your own ICE gathering completion strategy.
   */
  iceGatheringComplete() {
    this.logger.debug("SessionDescriptionHandler.iceGatheringComplete");
    if (this.iceGatheringCompleteTimeoutId !== void 0) {
      this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - clearing timeout");
      clearTimeout(this.iceGatheringCompleteTimeoutId);
      this.iceGatheringCompleteTimeoutId = void 0;
    }
    if (this.iceGatheringCompletePromise !== void 0) {
      this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - resolving promise");
      this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();
      this.iceGatheringCompletePromise = void 0;
      this.iceGatheringCompleteResolve = void 0;
      this.iceGatheringCompleteReject = void 0;
    }
  }
  /**
   * Send DTMF via RTP (RFC 4733).
   * Returns true if DTMF send is successful, false otherwise.
   * @param tones - A string containing DTMF digits.
   * @param options - Options object to be used by sendDtmf.
   */
  sendDtmf(tones, options) {
    this.logger.debug("SessionDescriptionHandler.sendDtmf");
    if (this._peerConnection === void 0) {
      this.logger.error("SessionDescriptionHandler.sendDtmf failed - peer connection closed");
      return false;
    }
    const senders = this._peerConnection.getSenders();
    if (senders.length === 0) {
      this.logger.error("SessionDescriptionHandler.sendDtmf failed - no senders");
      return false;
    }
    const dtmfSender = senders[0].dtmf;
    if (!dtmfSender) {
      this.logger.error("SessionDescriptionHandler.sendDtmf failed - no DTMF sender");
      return false;
    }
    const duration2 = options === null || options === void 0 ? void 0 : options.duration;
    const interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;
    try {
      dtmfSender.insertDTMF(tones, duration2, interToneGap);
    } catch (e2) {
      this.logger.error(e2.toString());
      return false;
    }
    this.logger.log("SessionDescriptionHandler.sendDtmf sent via RTP: " + tones.toString());
    return true;
  }
  /**
   * Sets an offer or answer.
   * @param sdp - The session description.
   * @param options - Options bucket.
   * @param modifiers - Modifiers.
   */
  setDescription(sdp, options, modifiers) {
    this.logger.debug("SessionDescriptionHandler.setDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;
    const type = this._peerConnection.signalingState === "have-local-offer" ? "answer" : "offer";
    return this.getLocalMediaStream(options).then(() => this.applyModifiers({ sdp, type }, modifiers)).then((sessionDescription) => this.setRemoteSessionDescription(sessionDescription)).catch((error) => {
      this.logger.error("SessionDescriptionHandler.setDescription failed - " + error);
      throw error;
    });
  }
  /**
   * Applies modifiers to SDP prior to setting the local or remote description.
   * @param sdp - SDP to modify.
   * @param modifiers - Modifiers to apply.
   */
  applyModifiers(sdp, modifiers) {
    this.logger.debug("SessionDescriptionHandler.applyModifiers");
    if (!modifiers || modifiers.length === 0) {
      return Promise.resolve(sdp);
    }
    return modifiers.reduce((cur, next) => cur.then(next), Promise.resolve(sdp)).then((modified) => {
      this.logger.debug("SessionDescriptionHandler.applyModifiers - modified sdp");
      if (!modified.sdp || !modified.type) {
        throw new Error("Invalid SDP.");
      }
      return { sdp: modified.sdp, type: modified.type };
    });
  }
  /**
   * Create a data channel.
   * @remarks
   * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.
   * Only creates a data channel if creating a local offer.
   * Only if one does not already exist.
   * @param options - Session description handler options.
   */
  createDataChannel(options) {
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {
      return Promise.resolve();
    }
    if (this._dataChannel) {
      return Promise.resolve();
    }
    switch (this._peerConnection.signalingState) {
      case "stable":
        this.logger.debug("SessionDescriptionHandler.createDataChannel - creating data channel");
        try {
          this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || "", options === null || options === void 0 ? void 0 : options.dataChannelOptions);
          if (this.onDataChannel) {
            this.onDataChannel(this._dataChannel);
          }
          return Promise.resolve();
        } catch (error) {
          return Promise.reject(error);
        }
      case "have-remote-offer":
        return Promise.resolve();
      case "have-local-offer":
      case "have-local-pranswer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
  }
  /**
   * Depending on current signaling state, create a local offer or answer.
   * @param options - Session description handler options.
   */
  createLocalOfferOrAnswer(options) {
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    switch (this._peerConnection.signalingState) {
      case "stable":
        this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer");
        return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);
      case "have-remote-offer":
        this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer");
        return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);
      case "have-local-offer":
      case "have-local-pranswer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
  }
  /**
   * Get a media stream from the media stream factory and set the local media stream.
   * @param options - Session description handler options.
   */
  getLocalMediaStream(options) {
    this.logger.debug("SessionDescriptionHandler.getLocalMediaStream");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    let constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints);
    if (this.localMediaStreamConstraints) {
      constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;
      constraints.video = constraints.video || this.localMediaStreamConstraints.video;
      if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {
        return Promise.resolve();
      }
    } else {
      if (constraints.audio === void 0 && constraints.video === void 0) {
        constraints = { audio: true };
      }
    }
    this.localMediaStreamConstraints = constraints;
    return this.mediaStreamFactory(constraints, this, options).then((mediaStream) => this.setLocalMediaStream(mediaStream));
  }
  /**
   * Sets the peer connection's sender tracks and local media stream tracks.
   *
   * @remarks
   * Only the first audio and video tracks of the provided MediaStream are utilized.
   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.
   *
   * @param stream - Media stream containing tracks to be utilized.
   */
  setLocalMediaStream(stream) {
    this.logger.debug("SessionDescriptionHandler.setLocalMediaStream");
    if (!this._peerConnection) {
      throw new Error("Peer connection undefined.");
    }
    const pc = this._peerConnection;
    const localStream = this._localMediaStream;
    const trackUpdates = [];
    const updateTrack = (newTrack) => {
      const kind = newTrack.kind;
      if (kind !== "audio" && kind !== "video") {
        throw new Error(`Unknown new track kind ${kind}.`);
      }
      const sender = pc.getSenders().find((sender2) => sender2.track && sender2.track.kind === kind);
      if (sender) {
        trackUpdates.push(new Promise((resolve) => {
          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);
          resolve();
        }).then(() => sender.replaceTrack(newTrack).then(() => {
          const oldTrack = localStream.getTracks().find((localTrack) => localTrack.kind === kind);
          if (oldTrack) {
            oldTrack.stop();
            localStream.removeTrack(oldTrack);
            SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);
          }
          localStream.addTrack(newTrack);
          SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);
        }).catch((error) => {
          this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);
          throw error;
        })));
      } else {
        trackUpdates.push(new Promise((resolve) => {
          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);
          resolve();
        }).then(() => {
          try {
            pc.addTrack(newTrack, localStream);
          } catch (error) {
            this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);
            throw error;
          }
          localStream.addTrack(newTrack);
          SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);
        }));
      }
    };
    const audioTracks = stream.getAudioTracks();
    if (audioTracks.length) {
      updateTrack(audioTracks[0]);
    }
    const videoTracks = stream.getVideoTracks();
    if (videoTracks.length) {
      updateTrack(videoTracks[0]);
    }
    return trackUpdates.reduce((p2, x) => p2.then(() => x), Promise.resolve());
  }
  /**
   * Gets the peer connection's local session description.
   */
  getLocalSessionDescription() {
    this.logger.debug("SessionDescriptionHandler.getLocalSessionDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    const sdp = this._peerConnection.localDescription;
    if (!sdp) {
      return Promise.reject(new Error("Failed to get local session description"));
    }
    return Promise.resolve(sdp);
  }
  /**
   * Sets the peer connection's local session description.
   * @param sessionDescription - sessionDescription The session description.
   */
  setLocalSessionDescription(sessionDescription) {
    this.logger.debug("SessionDescriptionHandler.setLocalSessionDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    return this._peerConnection.setLocalDescription(sessionDescription);
  }
  /**
   * Sets the peer connection's remote session description.
   * @param sessionDescription - The session description.
   */
  setRemoteSessionDescription(sessionDescription) {
    this.logger.debug("SessionDescriptionHandler.setRemoteSessionDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    const sdp = sessionDescription.sdp;
    let type;
    switch (this._peerConnection.signalingState) {
      case "stable":
        type = "offer";
        break;
      case "have-local-offer":
        type = "answer";
        break;
      case "have-local-pranswer":
      case "have-remote-offer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
    if (!sdp) {
      this.logger.error("SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp");
      return Promise.reject(new Error("SDP is undefined"));
    }
    return this._peerConnection.setRemoteDescription({ sdp, type });
  }
  /**
   * Sets a remote media stream track.
   *
   * @remarks
   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.
   *
   * @param track - Media stream track to be utilized.
   */
  setRemoteTrack(track) {
    this.logger.debug("SessionDescriptionHandler.setRemoteTrack");
    const remoteStream = this._remoteMediaStream;
    if (remoteStream.getTrackById(track.id)) {
      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);
    } else if (track.kind === "audio") {
      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);
      remoteStream.getAudioTracks().forEach((track2) => {
        track2.stop();
        remoteStream.removeTrack(track2);
        SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track2);
      });
      remoteStream.addTrack(track);
      SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);
    } else if (track.kind === "video") {
      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);
      remoteStream.getVideoTracks().forEach((track2) => {
        track2.stop();
        remoteStream.removeTrack(track2);
        SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track2);
      });
      remoteStream.addTrack(track);
      SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);
    }
  }
  /**
   * Depending on the current signaling state and the session hold state, update transceiver direction.
   * @param options - Session description handler options.
   */
  updateDirection(options) {
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    switch (this._peerConnection.signalingState) {
      case "stable":
        this.logger.debug("SessionDescriptionHandler.updateDirection - setting offer direction");
        {
          const directionToOffer = (currentDirection) => {
            switch (currentDirection) {
              case "inactive":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";
              case "recvonly":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";
              case "sendonly":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";
              case "sendrecv":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";
              case "stopped":
                return "stopped";
              default:
                throw new Error("Should never happen");
            }
          };
          this._peerConnection.getTransceivers().forEach((transceiver) => {
            if (transceiver.direction) {
              const offerDirection = directionToOffer(transceiver.direction);
              if (transceiver.direction !== offerDirection) {
                transceiver.direction = offerDirection;
              }
            }
          });
        }
        break;
      case "have-remote-offer":
        this.logger.debug("SessionDescriptionHandler.updateDirection - setting answer direction");
        {
          const offeredDirection = (() => {
            const description = this._peerConnection.remoteDescription;
            if (!description) {
              throw new Error("Failed to read remote offer");
            }
            const searchResult = /a=sendrecv\r\n|a=sendonly\r\n|a=recvonly\r\n|a=inactive\r\n/.exec(description.sdp);
            if (searchResult) {
              switch (searchResult[0]) {
                case "a=inactive\r\n":
                  return "inactive";
                case "a=recvonly\r\n":
                  return "recvonly";
                case "a=sendonly\r\n":
                  return "sendonly";
                case "a=sendrecv\r\n":
                  return "sendrecv";
                default:
                  throw new Error("Should never happen");
              }
            }
            return "sendrecv";
          })();
          const answerDirection = (() => {
            switch (offeredDirection) {
              case "inactive":
                return "inactive";
              case "recvonly":
                return "sendonly";
              case "sendonly":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";
              case "sendrecv":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";
              default:
                throw new Error("Should never happen");
            }
          })();
          this._peerConnection.getTransceivers().forEach((transceiver) => {
            if (transceiver.direction) {
              if (transceiver.direction !== "stopped" && transceiver.direction !== answerDirection) {
                transceiver.direction = answerDirection;
              }
            }
          });
        }
        break;
      case "have-local-offer":
      case "have-local-pranswer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
    return Promise.resolve();
  }
  /**
   * Wait for ICE gathering to complete.
   * @param restart - If true, waits if current state is "complete" (waits for transition to "complete").
   * @param timeout - Milliseconds after which waiting times out. No timeout if 0.
   */
  waitForIceGatheringComplete(restart = false, timeout2 = 0) {
    this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete");
    if (this._peerConnection === void 0) {
      return Promise.reject("Peer connection closed.");
    }
    if (!restart && this._peerConnection.iceGatheringState === "complete") {
      this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - already complete");
      return Promise.resolve();
    }
    if (this.iceGatheringCompletePromise !== void 0) {
      this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise");
      this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error("Promise superseded."));
      this.iceGatheringCompletePromise = void 0;
      this.iceGatheringCompleteResolve = void 0;
      this.iceGatheringCompleteReject = void 0;
    }
    this.iceGatheringCompletePromise = new Promise((resolve, reject) => {
      this.iceGatheringCompleteResolve = resolve;
      this.iceGatheringCompleteReject = reject;
      if (timeout2 > 0) {
        this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in " + timeout2);
        this.iceGatheringCompleteTimeoutId = setTimeout(() => {
          this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout");
          this.iceGatheringComplete();
        }, timeout2);
      }
    });
    return this.iceGatheringCompletePromise;
  }
  /**
   * Initializes the peer connection event handlers
   */
  initPeerConnectionEventHandlers() {
    this.logger.debug("SessionDescriptionHandler.initPeerConnectionEventHandlers");
    if (!this._peerConnection)
      throw new Error("Peer connection undefined.");
    const peerConnection = this._peerConnection;
    peerConnection.onconnectionstatechange = (event) => {
      var _a;
      const newState = peerConnection.connectionState;
      this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {
        this._peerConnectionDelegate.onconnectionstatechange(event);
      }
    };
    peerConnection.ondatachannel = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.ondatachannel`);
      this._dataChannel = event.channel;
      if (this.onDataChannel) {
        this.onDataChannel(this._dataChannel);
      }
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {
        this._peerConnectionDelegate.ondatachannel(event);
      }
    };
    peerConnection.onicecandidate = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onicecandidate`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {
        this._peerConnectionDelegate.onicecandidate(event);
      }
    };
    peerConnection.onicecandidateerror = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onicecandidateerror`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {
        this._peerConnectionDelegate.onicecandidateerror(event);
      }
    };
    peerConnection.oniceconnectionstatechange = (event) => {
      var _a;
      const newState = peerConnection.iceConnectionState;
      this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {
        this._peerConnectionDelegate.oniceconnectionstatechange(event);
      }
    };
    peerConnection.onicegatheringstatechange = (event) => {
      var _a;
      const newState = peerConnection.iceGatheringState;
      this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);
      if (newState === "complete") {
        this.iceGatheringComplete();
      }
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {
        this._peerConnectionDelegate.onicegatheringstatechange(event);
      }
    };
    peerConnection.onnegotiationneeded = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onnegotiationneeded`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {
        this._peerConnectionDelegate.onnegotiationneeded(event);
      }
    };
    peerConnection.onsignalingstatechange = (event) => {
      var _a;
      const newState = peerConnection.signalingState;
      this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {
        this._peerConnectionDelegate.onsignalingstatechange(event);
      }
    };
    peerConnection.ontrack = (event) => {
      var _a;
      const kind = event.track.kind;
      const enabled = event.track.enabled ? "enabled" : "disabled";
      this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);
      this.setRemoteTrack(event.track);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {
        this._peerConnectionDelegate.ontrack(event);
      }
    };
  }
};
function defaultSessionDescriptionHandlerFactory$1(mediaStreamFactory) {
  return (session2, options) => {
    if (mediaStreamFactory === void 0) {
      mediaStreamFactory = defaultMediaStreamFactory$1();
    }
    const iceGatheringTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) !== void 0 ? options === null || options === void 0 ? void 0 : options.iceGatheringTimeout : 5e3;
    const sessionDescriptionHandlerConfiguration = {
      iceGatheringTimeout,
      peerConnectionConfiguration: Object.assign(Object.assign({}, defaultPeerConnectionConfiguration$1()), options === null || options === void 0 ? void 0 : options.peerConnectionConfiguration)
    };
    const logger = session2.userAgent.getLogger("sip.SessionDescriptionHandler");
    return new SessionDescriptionHandler$1(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration);
  };
}
function defaultManagedSessionFactory() {
  return (sessionManager, session2) => {
    return { session: session2, held: false, muted: false };
  };
}
let Parameters$1 = class Parameters {
  constructor(parameters) {
    this.parameters = {};
    for (const param in parameters) {
      if (parameters.hasOwnProperty(param)) {
        this.setParam(param, parameters[param]);
      }
    }
  }
  setParam(key, value2) {
    if (key) {
      this.parameters[key.toLowerCase()] = typeof value2 === "undefined" || value2 === null ? null : value2.toString();
    }
  }
  getParam(key) {
    if (key) {
      return this.parameters[key.toLowerCase()];
    }
  }
  hasParam(key) {
    return !!(key && this.parameters[key.toLowerCase()] !== void 0);
  }
  deleteParam(key) {
    key = key.toLowerCase();
    if (this.hasParam(key)) {
      const value2 = this.parameters[key];
      delete this.parameters[key];
      return value2;
    }
  }
  clearParams() {
    this.parameters = {};
  }
};
let NameAddrHeader$1 = class NameAddrHeader extends Parameters$1 {
  /**
   * Constructor
   * @param uri -
   * @param displayName -
   * @param parameters -
   */
  constructor(uri, displayName, parameters) {
    super(parameters);
    this.uri = uri;
    this._displayName = displayName;
  }
  get friendlyName() {
    return this.displayName || this.uri.aor;
  }
  get displayName() {
    return this._displayName;
  }
  set displayName(value2) {
    this._displayName = value2;
  }
  clone() {
    return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
  }
  toString() {
    let body = this.displayName || this.displayName === "0" ? '"' + this.displayName + '" ' : "";
    body += "<" + this.uri.toString() + ">";
    for (const parameter in this.parameters) {
      if (this.parameters.hasOwnProperty(parameter)) {
        body += ";" + parameter;
        if (this.parameters[parameter] !== null) {
          body += "=" + this.parameters[parameter];
        }
      }
    }
    return body;
  }
};
let URI$1 = class URI extends Parameters$1 {
  /**
   * Constructor
   * @param scheme -
   * @param user -
   * @param host -
   * @param port -
   * @param parameters -
   * @param headers -
   */
  constructor(scheme = "sip", user, host, port, parameters, headers) {
    super(parameters || {});
    this.headers = {};
    if (!host) {
      throw new TypeError('missing or invalid "host" parameter');
    }
    for (const header in headers) {
      if (headers.hasOwnProperty(header)) {
        this.setHeader(header, headers[header]);
      }
    }
    this.raw = {
      scheme,
      user,
      host,
      port
    };
    this.normal = {
      scheme: scheme.toLowerCase(),
      user,
      host: host.toLowerCase(),
      port
    };
  }
  get scheme() {
    return this.normal.scheme;
  }
  set scheme(value2) {
    this.raw.scheme = value2;
    this.normal.scheme = value2.toLowerCase();
  }
  get user() {
    return this.normal.user;
  }
  set user(value2) {
    this.normal.user = this.raw.user = value2;
  }
  get host() {
    return this.normal.host;
  }
  set host(value2) {
    this.raw.host = value2;
    this.normal.host = value2.toLowerCase();
  }
  get aor() {
    return this.normal.user + "@" + this.normal.host;
  }
  get port() {
    return this.normal.port;
  }
  set port(value2) {
    this.normal.port = this.raw.port = value2 === 0 ? value2 : value2;
  }
  setHeader(name2, value2) {
    this.headers[this.headerize(name2)] = value2 instanceof Array ? value2 : [value2];
  }
  getHeader(name2) {
    if (name2) {
      return this.headers[this.headerize(name2)];
    }
  }
  hasHeader(name2) {
    return !!name2 && !!this.headers.hasOwnProperty(this.headerize(name2));
  }
  deleteHeader(header) {
    header = this.headerize(header);
    if (this.headers.hasOwnProperty(header)) {
      const value2 = this.headers[header];
      delete this.headers[header];
      return value2;
    }
  }
  clearHeaders() {
    this.headers = {};
  }
  clone() {
    return new URI(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
  }
  toRaw() {
    return this._toString(this._raw);
  }
  toString() {
    return this._toString(this._normal);
  }
  get _normal() {
    return this.normal;
  }
  get _raw() {
    return this.raw;
  }
  _toString(uri) {
    let uriString = uri.scheme + ":";
    if (!uri.scheme.toLowerCase().match("^sips?$")) {
      uriString += "//";
    }
    if (uri.user) {
      uriString += this.escapeUser(uri.user) + "@";
    }
    uriString += uri.host;
    if (uri.port || uri.port === 0) {
      uriString += ":" + uri.port;
    }
    for (const parameter in this.parameters) {
      if (this.parameters.hasOwnProperty(parameter)) {
        uriString += ";" + parameter;
        if (this.parameters[parameter] !== null) {
          uriString += "=" + this.parameters[parameter];
        }
      }
    }
    const headers = [];
    for (const header in this.headers) {
      if (this.headers.hasOwnProperty(header)) {
        for (const idx in this.headers[header]) {
          if (this.headers[header].hasOwnProperty(idx)) {
            headers.push(header + "=" + this.headers[header][idx]);
          }
        }
      }
    }
    if (headers.length > 0) {
      uriString += "?" + headers.join("&");
    }
    return uriString;
  }
  /*
   * Hex-escape a SIP URI user.
   * @private
   * @param {String} user
   */
  escapeUser(user) {
    let decodedUser;
    try {
      decodedUser = decodeURIComponent(user);
    } catch (error) {
      throw error;
    }
    return encodeURIComponent(decodedUser).replace(/%3A/ig, ":").replace(/%2B/ig, "+").replace(/%3F/ig, "?").replace(/%2F/ig, "/");
  }
  headerize(str) {
    const exceptions = {
      "Call-Id": "Call-ID",
      "Cseq": "CSeq",
      "Min-Se": "Min-SE",
      "Rack": "RAck",
      "Rseq": "RSeq",
      "Www-Authenticate": "WWW-Authenticate"
    };
    const name2 = str.toLowerCase().replace(/_/g, "-").split("-");
    const parts2 = name2.length;
    let hname = "";
    for (let part = 0; part < parts2; part++) {
      if (part !== 0) {
        hname += "-";
      }
      hname += name2[part].charAt(0).toUpperCase() + name2[part].substring(1);
    }
    if (exceptions[hname]) {
      hname = exceptions[hname];
    }
    return hname;
  }
};
function equivalentURI$1(a2, b) {
  if (a2.scheme !== b.scheme) {
    return false;
  }
  if (a2.user !== b.user || a2.host !== b.host || a2.port !== b.port) {
    return false;
  }
  function compareParameters(a3, b2) {
    const parameterKeysA = Object.keys(a3.parameters);
    const parameterKeysB = Object.keys(b2.parameters);
    const intersection = parameterKeysA.filter((x) => parameterKeysB.includes(x));
    if (!intersection.every((key) => a3.parameters[key] === b2.parameters[key])) {
      return false;
    }
    if (!["user", "ttl", "method", "transport"].every((key) => a3.hasParam(key) && b2.hasParam(key) || !a3.hasParam(key) && !b2.hasParam(key))) {
      return false;
    }
    if (!["maddr"].every((key) => a3.hasParam(key) && b2.hasParam(key) || !a3.hasParam(key) && !b2.hasParam(key))) {
      return false;
    }
    return true;
  }
  if (!compareParameters(a2, b)) {
    return false;
  }
  const headerKeysA = Object.keys(a2.headers);
  const headerKeysB = Object.keys(b.headers);
  if (headerKeysA.length !== 0 || headerKeysB.length !== 0) {
    if (headerKeysA.length !== headerKeysB.length) {
      return false;
    }
    const intersection = headerKeysA.filter((x) => headerKeysB.includes(x));
    if (intersection.length !== headerKeysB.length) {
      return false;
    }
    if (!intersection.every((key) => a2.headers[key].length && b.headers[key].length && a2.headers[key][0] === b.headers[key][0])) {
      return false;
    }
  }
  return true;
}
function peg$padEnd(str, targetLength, padString) {
  padString = padString || " ";
  if (str.length > targetLength) {
    return str;
  }
  targetLength -= str.length;
  padString += padString.repeat(targetLength);
  return str + padString.slice(0, targetLength);
}
let SyntaxError$1 = class SyntaxError extends Error {
  constructor(message2, expected, found, location2) {
    super();
    this.message = message2;
    this.expected = expected;
    this.found = found;
    this.location = location2;
    this.name = "SyntaxError";
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(this, SyntaxError.prototype);
    } else {
      this.__proto__ = SyntaxError.prototype;
    }
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, SyntaxError);
    }
  }
  static buildMessage(expected, found) {
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
    }
    function describeExpectation(expectation) {
      switch (expectation.type) {
        case "literal":
          return '"' + literalEscape(expectation.text) + '"';
        case "class":
          const escapedParts = expectation.parts.map((part) => {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }
    function describeExpected(expected1) {
      const descriptions = expected1.map(describeExpectation);
      let i2;
      let j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i2 = 1, j = 1; i2 < descriptions.length; i2++) {
          if (descriptions[i2 - 1] !== descriptions[i2]) {
            descriptions[j] = descriptions[i2];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found1) {
      return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }
  format(sources) {
    let str = "Error: " + this.message;
    if (this.location) {
      let src = null;
      let k;
      for (k = 0; k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      let s2 = this.location.start;
      let loc = this.location.source + ":" + s2.line + ":" + s2.column;
      if (src) {
        let e2 = this.location.end;
        let filler = peg$padEnd("", s2.line.toString().length, " ");
        let line = src[s2.line - 1];
        let last = s2.line === e2.line ? e2.column : line.length + 1;
        str += "\n --> " + loc + "\n" + filler + " |\n" + s2.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", last - s2.column, "^");
      } else {
        str += "\n at " + loc;
      }
    }
    return str;
  }
};
function peg$parse$1(input, options) {
  options = options !== void 0 ? options : {};
  const peg$FAILED = {};
  const peg$source = options.grammarSource;
  const peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 };
  let peg$startRuleIndex = 119;
  const peg$consts = [
    "\r\n",
    peg$literalExpectation("\r\n", false),
    /^[0-9]/,
    peg$classExpectation([["0", "9"]], false, false),
    /^[a-zA-Z]/,
    peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
    /^[0-9a-fA-F]/,
    peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
    /^[\0-\xFF]/,
    peg$classExpectation([["\0", "ÿ"]], false, false),
    /^["]/,
    peg$classExpectation(['"'], false, false),
    " ",
    peg$literalExpectation(" ", false),
    "	",
    peg$literalExpectation("	", false),
    /^[a-zA-Z0-9]/,
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
    ";",
    peg$literalExpectation(";", false),
    "/",
    peg$literalExpectation("/", false),
    "?",
    peg$literalExpectation("?", false),
    ":",
    peg$literalExpectation(":", false),
    "@",
    peg$literalExpectation("@", false),
    "&",
    peg$literalExpectation("&", false),
    "=",
    peg$literalExpectation("=", false),
    "+",
    peg$literalExpectation("+", false),
    "$",
    peg$literalExpectation("$", false),
    ",",
    peg$literalExpectation(",", false),
    "-",
    peg$literalExpectation("-", false),
    "_",
    peg$literalExpectation("_", false),
    ".",
    peg$literalExpectation(".", false),
    "!",
    peg$literalExpectation("!", false),
    "~",
    peg$literalExpectation("~", false),
    "*",
    peg$literalExpectation("*", false),
    "'",
    peg$literalExpectation("'", false),
    "(",
    peg$literalExpectation("(", false),
    ")",
    peg$literalExpectation(")", false),
    "%",
    peg$literalExpectation("%", false),
    function() {
      return " ";
    },
    function() {
      return ":";
    },
    /^[!-~]/,
    peg$classExpectation([["!", "~"]], false, false),
    /^[\x80-\uFFFF]/,
    peg$classExpectation([["", "￿"]], false, false),
    /^[\x80-\xBF]/,
    peg$classExpectation([["", "¿"]], false, false),
    /^[a-f]/,
    peg$classExpectation([["a", "f"]], false, false),
    "`",
    peg$literalExpectation("`", false),
    "<",
    peg$literalExpectation("<", false),
    ">",
    peg$literalExpectation(">", false),
    "\\",
    peg$literalExpectation("\\", false),
    "[",
    peg$literalExpectation("[", false),
    "]",
    peg$literalExpectation("]", false),
    "{",
    peg$literalExpectation("{", false),
    "}",
    peg$literalExpectation("}", false),
    function() {
      return "*";
    },
    function() {
      return "/";
    },
    function() {
      return "=";
    },
    function() {
      return "(";
    },
    function() {
      return ")";
    },
    function() {
      return ">";
    },
    function() {
      return "<";
    },
    function() {
      return ",";
    },
    function() {
      return ";";
    },
    function() {
      return ":";
    },
    function() {
      return '"';
    },
    /^[!-']/,
    peg$classExpectation([["!", "'"]], false, false),
    /^[*-[]/,
    peg$classExpectation([["*", "["]], false, false),
    /^[\]-~]/,
    peg$classExpectation([["]", "~"]], false, false),
    function(contents) {
      return contents;
    },
    /^[#-[]/,
    peg$classExpectation([["#", "["]], false, false),
    /^[\0-\t]/,
    peg$classExpectation([["\0", "	"]], false, false),
    /^[\v-\f]/,
    peg$classExpectation([["\v", "\f"]], false, false),
    /^[\x0E-\x7F]/,
    peg$classExpectation([["", ""]], false, false),
    function() {
      options = options || { data: {} };
      options.data.uri = new URI$1(options.data.scheme, options.data.user, options.data.host, options.data.port);
      delete options.data.scheme;
      delete options.data.user;
      delete options.data.host;
      delete options.data.host_type;
      delete options.data.port;
    },
    function() {
      options = options || { data: {} };
      options.data.uri = new URI$1(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
      delete options.data.scheme;
      delete options.data.user;
      delete options.data.host;
      delete options.data.host_type;
      delete options.data.port;
      delete options.data.uri_params;
      if (options.startRule === "SIP_URI") {
        options.data = options.data.uri;
      }
    },
    "sips",
    peg$literalExpectation("sips", true),
    "sip",
    peg$literalExpectation("sip", true),
    function(uri_scheme) {
      options = options || { data: {} };
      options.data.scheme = uri_scheme;
    },
    function() {
      options = options || { data: {} };
      options.data.user = decodeURIComponent(text().slice(0, -1));
    },
    function() {
      options = options || { data: {} };
      options.data.password = text();
    },
    function() {
      options = options || { data: {} };
      options.data.host = text();
      return options.data.host;
    },
    function() {
      options = options || { data: {} };
      options.data.host_type = "domain";
      return text();
    },
    /^[a-zA-Z0-9_\-]/,
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
    /^[a-zA-Z0-9\-]/,
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
    function() {
      options = options || { data: {} };
      options.data.host_type = "IPv6";
      return text();
    },
    "::",
    peg$literalExpectation("::", false),
    function() {
      options = options || { data: {} };
      options.data.host_type = "IPv6";
      return text();
    },
    function() {
      options = options || { data: {} };
      options.data.host_type = "IPv4";
      return text();
    },
    "25",
    peg$literalExpectation("25", false),
    /^[0-5]/,
    peg$classExpectation([["0", "5"]], false, false),
    "2",
    peg$literalExpectation("2", false),
    /^[0-4]/,
    peg$classExpectation([["0", "4"]], false, false),
    "1",
    peg$literalExpectation("1", false),
    /^[1-9]/,
    peg$classExpectation([["1", "9"]], false, false),
    function(port) {
      options = options || { data: {} };
      port = parseInt(port.join(""));
      options.data.port = port;
      return port;
    },
    "transport=",
    peg$literalExpectation("transport=", true),
    "udp",
    peg$literalExpectation("udp", true),
    "tcp",
    peg$literalExpectation("tcp", true),
    "sctp",
    peg$literalExpectation("sctp", true),
    "tls",
    peg$literalExpectation("tls", true),
    function(transport) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["transport"] = transport.toLowerCase();
    },
    "user=",
    peg$literalExpectation("user=", true),
    "phone",
    peg$literalExpectation("phone", true),
    "ip",
    peg$literalExpectation("ip", true),
    function(user) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["user"] = user.toLowerCase();
    },
    "method=",
    peg$literalExpectation("method=", true),
    function(method) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["method"] = method;
    },
    "ttl=",
    peg$literalExpectation("ttl=", true),
    function(ttl) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      options.data.params["ttl"] = ttl;
    },
    "maddr=",
    peg$literalExpectation("maddr=", true),
    function(maddr) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["maddr"] = maddr;
    },
    "lr",
    peg$literalExpectation("lr", true),
    function() {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["lr"] = void 0;
    },
    function(param, value2) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      if (value2 === null) {
        value2 = void 0;
      } else {
        value2 = value2[1];
      }
      options.data.uri_params[param.toLowerCase()] = value2;
    },
    function(hname, hvalue) {
      hname = hname.join("").toLowerCase();
      hvalue = hvalue.join("");
      options = options || { data: {} };
      if (!options.data.uri_headers)
        options.data.uri_headers = {};
      if (!options.data.uri_headers[hname]) {
        options.data.uri_headers[hname] = [hvalue];
      } else {
        options.data.uri_headers[hname].push(hvalue);
      }
    },
    function() {
      options = options || { data: {} };
      if (options.startRule === "Refer_To") {
        options.data.uri = new URI$1(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
        delete options.data.scheme;
        delete options.data.user;
        delete options.data.host;
        delete options.data.host_type;
        delete options.data.port;
        delete options.data.uri_params;
      }
    },
    "//",
    peg$literalExpectation("//", false),
    function() {
      options = options || { data: {} };
      options.data.scheme = text();
    },
    peg$literalExpectation("SIP", true),
    function() {
      options = options || { data: {} };
      options.data.sip_version = text();
    },
    "INVITE",
    peg$literalExpectation("INVITE", false),
    "ACK",
    peg$literalExpectation("ACK", false),
    "VXACH",
    peg$literalExpectation("VXACH", false),
    "OPTIONS",
    peg$literalExpectation("OPTIONS", false),
    "BYE",
    peg$literalExpectation("BYE", false),
    "CANCEL",
    peg$literalExpectation("CANCEL", false),
    "REGISTER",
    peg$literalExpectation("REGISTER", false),
    "SUBSCRIBE",
    peg$literalExpectation("SUBSCRIBE", false),
    "NOTIFY",
    peg$literalExpectation("NOTIFY", false),
    "REFER",
    peg$literalExpectation("REFER", false),
    "PUBLISH",
    peg$literalExpectation("PUBLISH", false),
    function() {
      options = options || { data: {} };
      options.data.method = text();
      return options.data.method;
    },
    function(status_code) {
      options = options || { data: {} };
      options.data.status_code = parseInt(status_code.join(""));
    },
    function() {
      options = options || { data: {} };
      options.data.reason_phrase = text();
    },
    function() {
      options = options || { data: {} };
      options.data = text();
    },
    function() {
      var idx, length;
      options = options || { data: {} };
      length = options.data.multi_header.length;
      for (idx = 0; idx < length; idx++) {
        if (options.data.multi_header[idx].parsed === null) {
          options.data = null;
          break;
        }
      }
      if (options.data !== null) {
        options.data = options.data.multi_header;
      } else {
        options.data = -1;
      }
    },
    function() {
      var header;
      options = options || { data: {} };
      if (!options.data.multi_header)
        options.data.multi_header = [];
      try {
        header = new NameAddrHeader$1(options.data.uri, options.data.displayName, options.data.params);
        delete options.data.uri;
        delete options.data.displayName;
        delete options.data.params;
      } catch (e2) {
        header = null;
      }
      options.data.multi_header.push({
        "position": peg$currPos,
        "offset": location2().start.offset,
        "parsed": header
      });
    },
    function(displayName) {
      displayName = text().trim();
      if (displayName[0] === '"') {
        displayName = displayName.substring(1, displayName.length - 1);
      }
      options = options || { data: {} };
      options.data.displayName = displayName;
    },
    "q",
    peg$literalExpectation("q", true),
    function(q) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      options.data.params["q"] = q;
    },
    "expires",
    peg$literalExpectation("expires", true),
    function(expires) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      options.data.params["expires"] = expires;
    },
    function(delta_seconds) {
      return parseInt(delta_seconds.join(""));
    },
    "0",
    peg$literalExpectation("0", false),
    function() {
      return parseFloat(text());
    },
    function(param, value2) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      if (value2 === null) {
        value2 = void 0;
      } else {
        value2 = value2[1];
      }
      options.data.params[param.toLowerCase()] = value2;
    },
    "render",
    peg$literalExpectation("render", true),
    "session",
    peg$literalExpectation("session", true),
    "icon",
    peg$literalExpectation("icon", true),
    "alert",
    peg$literalExpectation("alert", true),
    function() {
      options = options || { data: {} };
      if (options.startRule === "Content_Disposition") {
        options.data.type = text().toLowerCase();
      }
    },
    "handling",
    peg$literalExpectation("handling", true),
    "optional",
    peg$literalExpectation("optional", true),
    "required",
    peg$literalExpectation("required", true),
    function(length) {
      options = options || { data: {} };
      options.data = parseInt(length.join(""));
    },
    function() {
      options = options || { data: {} };
      options.data = text();
    },
    "text",
    peg$literalExpectation("text", true),
    "image",
    peg$literalExpectation("image", true),
    "audio",
    peg$literalExpectation("audio", true),
    "video",
    peg$literalExpectation("video", true),
    "application",
    peg$literalExpectation("application", true),
    "message",
    peg$literalExpectation("message", true),
    "multipart",
    peg$literalExpectation("multipart", true),
    "x-",
    peg$literalExpectation("x-", true),
    function(cseq_value) {
      options = options || { data: {} };
      options.data.value = parseInt(cseq_value.join(""));
    },
    function(expires) {
      options = options || { data: {} };
      options.data = expires;
    },
    function(event_type) {
      options = options || { data: {} };
      options.data.event = event_type.toLowerCase();
    },
    function() {
      options = options || { data: {} };
      var tag = options.data.tag;
      options.data = new NameAddrHeader$1(options.data.uri, options.data.displayName, options.data.params);
      if (tag) {
        options.data.setParam("tag", tag);
      }
    },
    "tag",
    peg$literalExpectation("tag", true),
    function(tag) {
      options = options || { data: {} };
      options.data.tag = tag;
    },
    function(forwards) {
      options = options || { data: {} };
      options.data = parseInt(forwards.join(""));
    },
    function(min_expires) {
      options = options || { data: {} };
      options.data = min_expires;
    },
    function() {
      options = options || { data: {} };
      options.data = new NameAddrHeader$1(options.data.uri, options.data.displayName, options.data.params);
    },
    "digest",
    peg$literalExpectation("Digest", true),
    "realm",
    peg$literalExpectation("realm", true),
    function(realm) {
      options = options || { data: {} };
      options.data.realm = realm;
    },
    "domain",
    peg$literalExpectation("domain", true),
    "nonce",
    peg$literalExpectation("nonce", true),
    function(nonce) {
      options = options || { data: {} };
      options.data.nonce = nonce;
    },
    "opaque",
    peg$literalExpectation("opaque", true),
    function(opaque) {
      options = options || { data: {} };
      options.data.opaque = opaque;
    },
    "stale",
    peg$literalExpectation("stale", true),
    "true",
    peg$literalExpectation("true", true),
    function() {
      options = options || { data: {} };
      options.data.stale = true;
    },
    "false",
    peg$literalExpectation("false", true),
    function() {
      options = options || { data: {} };
      options.data.stale = false;
    },
    "algorithm",
    peg$literalExpectation("algorithm", true),
    "md5",
    peg$literalExpectation("MD5", true),
    "md5-sess",
    peg$literalExpectation("MD5-sess", true),
    function(algorithm) {
      options = options || { data: {} };
      options.data.algorithm = algorithm.toUpperCase();
    },
    "qop",
    peg$literalExpectation("qop", true),
    "auth-int",
    peg$literalExpectation("auth-int", true),
    "auth",
    peg$literalExpectation("auth", true),
    function(qop_value) {
      options = options || { data: {} };
      options.data.qop || (options.data.qop = []);
      options.data.qop.push(qop_value.toLowerCase());
    },
    function(rack_value) {
      options = options || { data: {} };
      options.data.value = parseInt(rack_value.join(""));
    },
    function() {
      var idx, length;
      options = options || { data: {} };
      length = options.data.multi_header.length;
      for (idx = 0; idx < length; idx++) {
        if (options.data.multi_header[idx].parsed === null) {
          options.data = null;
          break;
        }
      }
      if (options.data !== null) {
        options.data = options.data.multi_header;
      } else {
        options.data = -1;
      }
    },
    function() {
      var header;
      options = options || { data: {} };
      if (!options.data.multi_header)
        options.data.multi_header = [];
      try {
        header = new NameAddrHeader$1(options.data.uri, options.data.displayName, options.data.params);
        delete options.data.uri;
        delete options.data.displayName;
        delete options.data.params;
      } catch (e2) {
        header = null;
      }
      options.data.multi_header.push({
        "position": peg$currPos,
        "offset": location2().start.offset,
        "parsed": header
      });
    },
    function() {
      options = options || { data: {} };
      options.data = new NameAddrHeader$1(options.data.uri, options.data.displayName, options.data.params);
    },
    function() {
      options = options || { data: {} };
      if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
        options.data = -1;
      }
    },
    function() {
      options = options || { data: {} };
      options.data = {
        call_id: options.data
      };
    },
    "from-tag",
    peg$literalExpectation("from-tag", true),
    function(from_tag) {
      options = options || { data: {} };
      options.data.replaces_from_tag = from_tag;
    },
    "to-tag",
    peg$literalExpectation("to-tag", true),
    function(to_tag) {
      options = options || { data: {} };
      options.data.replaces_to_tag = to_tag;
    },
    "early-only",
    peg$literalExpectation("early-only", true),
    function() {
      options = options || { data: {} };
      options.data.early_only = true;
    },
    function(head, r2) {
      return r2;
    },
    function(head, tail) {
      return list(head, tail);
    },
    function(value2) {
      options = options || { data: {} };
      if (options.startRule === "Require") {
        options.data = value2 || [];
      }
    },
    function(rseq_value) {
      options = options || { data: {} };
      options.data.value = parseInt(rseq_value.join(""));
    },
    "active",
    peg$literalExpectation("active", true),
    "pending",
    peg$literalExpectation("pending", true),
    "terminated",
    peg$literalExpectation("terminated", true),
    function() {
      options = options || { data: {} };
      options.data.state = text();
    },
    "reason",
    peg$literalExpectation("reason", true),
    function(reason) {
      options = options || { data: {} };
      if (typeof reason !== "undefined")
        options.data.reason = reason;
    },
    function(expires) {
      options = options || { data: {} };
      if (typeof expires !== "undefined")
        options.data.expires = expires;
    },
    "retry_after",
    peg$literalExpectation("retry_after", true),
    function(retry_after) {
      options = options || { data: {} };
      if (typeof retry_after !== "undefined")
        options.data.retry_after = retry_after;
    },
    "deactivated",
    peg$literalExpectation("deactivated", true),
    "probation",
    peg$literalExpectation("probation", true),
    "rejected",
    peg$literalExpectation("rejected", true),
    "timeout",
    peg$literalExpectation("timeout", true),
    "giveup",
    peg$literalExpectation("giveup", true),
    "noresource",
    peg$literalExpectation("noresource", true),
    "invariant",
    peg$literalExpectation("invariant", true),
    function(value2) {
      options = options || { data: {} };
      if (options.startRule === "Supported") {
        options.data = value2 || [];
      }
    },
    function() {
      options = options || { data: {} };
      var tag = options.data.tag;
      options.data = new NameAddrHeader$1(options.data.uri, options.data.displayName, options.data.params);
      if (tag) {
        options.data.setParam("tag", tag);
      }
    },
    "ttl",
    peg$literalExpectation("ttl", true),
    function(via_ttl_value) {
      options = options || { data: {} };
      options.data.ttl = via_ttl_value;
    },
    "maddr",
    peg$literalExpectation("maddr", true),
    function(via_maddr) {
      options = options || { data: {} };
      options.data.maddr = via_maddr;
    },
    "received",
    peg$literalExpectation("received", true),
    function(via_received) {
      options = options || { data: {} };
      options.data.received = via_received;
    },
    "branch",
    peg$literalExpectation("branch", true),
    function(via_branch) {
      options = options || { data: {} };
      options.data.branch = via_branch;
    },
    "rport",
    peg$literalExpectation("rport", true),
    function(response_port) {
      options = options || { data: {} };
      if (typeof response_port !== "undefined")
        options.data.rport = response_port.join("");
    },
    function(via_protocol) {
      options = options || { data: {} };
      options.data.protocol = via_protocol;
    },
    peg$literalExpectation("UDP", true),
    peg$literalExpectation("TCP", true),
    peg$literalExpectation("TLS", true),
    peg$literalExpectation("SCTP", true),
    function(via_transport) {
      options = options || { data: {} };
      options.data.transport = via_transport;
    },
    function() {
      options = options || { data: {} };
      options.data.host = text();
    },
    function(via_sent_by_port) {
      options = options || { data: {} };
      options.data.port = parseInt(via_sent_by_port.join(""));
    },
    function(ttl) {
      return parseInt(ttl.join(""));
    },
    function(deltaSeconds) {
      options = options || { data: {} };
      if (options.startRule === "Session_Expires") {
        options.data.deltaSeconds = deltaSeconds;
      }
    },
    "refresher",
    peg$literalExpectation("refresher", false),
    "uas",
    peg$literalExpectation("uas", false),
    "uac",
    peg$literalExpectation("uac", false),
    function(endpoint) {
      options = options || { data: {} };
      if (options.startRule === "Session_Expires") {
        options.data.refresher = endpoint;
      }
    },
    function(deltaSeconds) {
      options = options || { data: {} };
      if (options.startRule === "Min_SE") {
        options.data = deltaSeconds;
      }
    },
    "stuns",
    peg$literalExpectation("stuns", true),
    "stun",
    peg$literalExpectation("stun", true),
    function(scheme) {
      options = options || { data: {} };
      options.data.scheme = scheme;
    },
    function(host) {
      options = options || { data: {} };
      options.data.host = host;
    },
    "?transport=",
    peg$literalExpectation("?transport=", false),
    "turns",
    peg$literalExpectation("turns", true),
    "turn",
    peg$literalExpectation("turn", true),
    function(transport) {
      options = options || { data: {} };
      options.data.transport = transport;
    },
    function() {
      options = options || { data: {} };
      options.data = text();
    },
    "Referred-By",
    peg$literalExpectation("Referred-By", false),
    "b",
    peg$literalExpectation("b", false),
    "cid",
    peg$literalExpectation("cid", false)
  ];
  const peg$bytecode = [
    peg$decode('2 ""6 7!'),
    peg$decode('4"""5!7#'),
    peg$decode('4$""5!7%'),
    peg$decode(`4&""5!7'`),
    peg$decode(";'.# &;("),
    peg$decode('4(""5!7)'),
    peg$decode('4*""5!7+'),
    peg$decode('2,""6,7-'),
    peg$decode('2.""6.7/'),
    peg$decode('40""5!71'),
    peg$decode('22""6273. &24""6475.} &26""6677.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'),
    peg$decode(";).# &;,"),
    peg$decode('2F""6F7G.} &2H""6H7I.q &2J""6J7K.e &2L""6L7M.Y &2N""6N7O.M &2P""6P7Q.A &2R""6R7S.5 &2T""6T7U.) &2V""6V7W'),
    peg$decode(`%%2X""6X7Y/5#;#/,$;#/#$+#)(#'#("'#&'#/"!&,)`),
    peg$decode(`%%$;$0#*;$&/,#; /#$+")("'#&'#." &"/=#$;$/&#0#*;$&&&#/'$8":Z" )("'#&'#`),
    peg$decode(';.." &"'),
    peg$decode(`%$;'.# &;(0)*;'.# &;(&/?#28""6879/0$;//'$8#:[# )(#'#("'#&'#`),
    peg$decode(`%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+")("'#&'#0=*%$;.0#*;.&/,#;2/#$+")("'#&'#&/#$+")("'#&'#/"!&,)`),
    peg$decode('4\\""5!7].# &;3'),
    peg$decode('4^""5!7_'),
    peg$decode('4`""5!7a'),
    peg$decode(';!.) &4b""5!7c'),
    peg$decode('%$;). &2F""6F7G. &2J""6J7K.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O/#0*;). &2F""6F7G. &2J""6J7K.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O&&&#/"!&,)'),
    peg$decode('%$;). &2F""6F7G.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O/#0*;). &2F""6F7G.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O&&&#/"!&,)'),
    peg$decode(`2T""6T7U.ã &2V""6V7W.× &2f""6f7g.Ë &2h""6h7i.¿ &2:""6:7;.³ &2D""6D7E.§ &22""6273. &28""6879. &2j""6j7k. &;&.} &24""6475.q &2l""6l7m.e &2n""6n7o.Y &26""6677.M &2>""6>7?.A &2p""6p7q.5 &2r""6r7s.) &;'.# &;(`),
    peg$decode('%$;).ī &2F""6F7G.ğ &2J""6J7K.ē &2L""6L7M.ć &2X""6X7Y.û &2P""6P7Q.ï &2H""6H7I.ã &2@""6@7A.× &2d""6d7e.Ë &2R""6R7S.¿ &2N""6N7O.³ &2T""6T7U.§ &2V""6V7W. &2f""6f7g. &2h""6h7i. &28""6879.w &2j""6j7k.k &;&.e &24""6475.Y &2l""6l7m.M &2n""6n7o.A &26""6677.5 &2p""6p7q.) &2r""6r7s/Ĵ#0ı*;).ī &2F""6F7G.ğ &2J""6J7K.ē &2L""6L7M.ć &2X""6X7Y.û &2P""6P7Q.ï &2H""6H7I.ã &2@""6@7A.× &2d""6d7e.Ë &2R""6R7S.¿ &2N""6N7O.³ &2T""6T7U.§ &2V""6V7W. &2f""6f7g. &2h""6h7i. &28""6879.w &2j""6j7k.k &;&.e &24""6475.Y &2l""6l7m.M &2n""6n7o.A &26""6677.5 &2p""6p7q.) &2r""6r7s&&&#/"!&,)'),
    peg$decode(`%;//?#2P""6P7Q/0$;//'$8#:t# )(#'#("'#&'#`),
    peg$decode(`%;//?#24""6475/0$;//'$8#:u# )(#'#("'#&'#`),
    peg$decode(`%;//?#2>""6>7?/0$;//'$8#:v# )(#'#("'#&'#`),
    peg$decode(`%;//?#2T""6T7U/0$;//'$8#:w# )(#'#("'#&'#`),
    peg$decode(`%;//?#2V""6V7W/0$;//'$8#:x# )(#'#("'#&'#`),
    peg$decode(`%2h""6h7i/0#;//'$8":y" )("'#&'#`),
    peg$decode(`%;//6#2f""6f7g/'$8":z" )("'#&'#`),
    peg$decode(`%;//?#2D""6D7E/0$;//'$8#:{# )(#'#("'#&'#`),
    peg$decode(`%;//?#22""6273/0$;//'$8#:|# )(#'#("'#&'#`),
    peg$decode(`%;//?#28""6879/0$;//'$8#:}# )(#'#("'#&'#`),
    peg$decode(`%;//0#;&/'$8":~" )("'#&'#`),
    peg$decode(`%;&/0#;//'$8":~" )("'#&'#`),
    peg$decode(`%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#("'#&'#`),
    peg$decode('4""5!7.A &4""5!7.5 &4""5!7.) &;3.# &;.'),
    peg$decode(`%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#("'#&'#/"!&,)`),
    peg$decode(`%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/"!&,)/1$;&/($8$:$!!)($'#(#'#("'#&'#`),
    peg$decode(';..G &2L""6L7M.; &4""5!7./ &4""5!7.# &;3'),
    peg$decode(`%2j""6j7k/J#4""5!7.5 &4""5!7.) &4""5!7/#$+")("'#&'#`),
    peg$decode(`%;N/M#28""6879/>$;O." &"/0$;S/'$8$:$ )($'#(#'#("'#&'#`),
    peg$decode(`%;N/d#28""6879/U$;O." &"/G$;S/>$;_/5$;l." &"/'$8&:& )(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(`%3""5$7.) &3""5#7/' 8!:!! )`),
    peg$decode(`%;P/]#%28""6879/,#;R/#$+")("'#&'#." &"/6$2:""6:7;/'$8#:# )(#'#("'#&'#`),
    peg$decode("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"),
    peg$decode('2<""6<7=.q &2>""6>7?.e &2@""6@7A.Y &2B""6B7C.M &2D""6D7E.A &22""6273.5 &26""6677.) &24""6475'),
    peg$decode('%$;+._ &;-.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E0e*;+._ &;-.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E&/& 8!:! )'),
    peg$decode(`%;T/J#%28""6879/,#;^/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode("%;U.) &;\\.# &;X/& 8!:! )"),
    peg$decode(`%$%;V/2#2J""6J7K/#$+")("'#&'#0<*%;V/2#2J""6J7K/#$+")("'#&'#&/D#;W/;$2J""6J7K." &"/'$8#:# )(#'#("'#&'#`),
    peg$decode('$4""5!7/,#0)*4""5!7&&&#'),
    peg$decode(`%4$""5!7%/?#$4""5!70)*4""5!7&/#$+")("'#&'#`),
    peg$decode(`%2l""6l7m/?#;Y/6$2n""6n7o/'$8#:# )(#'#("'#&'#`),
    peg$decode(`%%;Z/³#28""6879/¤$;Z/$28""6879/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.ސ &%2""67/¤#;Z/$28""6879/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.۹ &%2""67/#;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.ٺ &%2""67/t#;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#.ؓ &%2""67/\\#;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+&)(&'#(%'#($'#(#'#("'#&'#.ׄ &%2""67/D#;Z/;$28""6879/,$;[/#$+$)($'#(#'#("'#&'#.֍ &%2""67/,#;[/#$+")("'#&'#.ծ &%2""67/,#;Z/#$+")("'#&'#.Տ &%;Z/#2""67/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.Ӈ &%;Z/ª#%28""6879/,#;Z/#$+")("'#&'#." &"/$2""67/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.а &%;Z/¹#%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/k$2""67/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.Ί &%;Z/È#%28""6879/,#;Z/#$+")("'#&'#." &"/¡$%28""6879/,#;Z/#$+")("'#&'#." &"/z$%28""6879/,#;Z/#$+")("'#&'#." &"/S$2""67/D$;Z/;$28""6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#.˕ &%;Z/×#%28""6879/,#;Z/#$+")("'#&'#." &"/°$%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/b$%28""6879/,#;Z/#$+")("'#&'#." &"/;$2""67/,$;[/#$+')(''#(&'#(%'#($'#(#'#("'#&'#.ȑ &%;Z/þ#%28""6879/,#;Z/#$+")("'#&'#." &"/×$%28""6879/,#;Z/#$+")("'#&'#." &"/°$%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/b$%28""6879/,#;Z/#$+")("'#&'#." &"/;$2""67/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#.Ħ &%;Z/Ĝ#%28""6879/,#;Z/#$+")("'#&'#." &"/õ$%28""6879/,#;Z/#$+")("'#&'#." &"/Î$%28""6879/,#;Z/#$+")("'#&'#." &"/§$%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/Y$%28""6879/,#;Z/#$+")("'#&'#." &"/2$2""67/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#/& 8!: ! )`),
    peg$decode(`%;#/M#;#." &"/?$;#." &"/1$;#." &"/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%;Z/;#28""6879/,$;Z/#$+#)(#'#("'#&'#.# &;\\`),
    peg$decode(`%;]/o#2J""6J7K/\`$;]/W$2J""6J7K/H$;]/?$2J""6J7K/0$;]/'$8':¡' )(''#(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(`%2¢""6¢7£/2#4¤""5!7¥/#$+")("'#&'#. &%2¦""6¦7§/;#4¨""5!7©/,$;!/#$+#)(#'#("'#&'#.j &%2ª""6ª7«/5#;!/,$;!/#$+#)(#'#("'#&'#.B &%4¬""5!7­/,#;!/#$+")("'#&'#.# &;!`),
    peg$decode(`%%;!." &"/[#;!." &"/M$;!." &"/?$;!." &"/1$;!." &"/#$+%)(%'#($'#(#'#("'#&'#/' 8!:®!! )`),
    peg$decode(`$%22""6273/,#;\`/#$+")("'#&'#0<*%22""6273/,#;\`/#$+")("'#&'#&`),
    peg$decode(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"),
    peg$decode(`%3¯""5*7°/a#3±""5#7².G &3³""5#7´.; &3µ""5$7¶./ &3·""5#7¸.# &;6/($8":¹"! )("'#&'#`),
    peg$decode(`%3º""5%7»/I#3¼""5%7½./ &3¾""5"7¿.# &;6/($8":À"! )("'#&'#`),
    peg$decode(`%3Á""5'7Â/1#;/($8":Ã"! )("'#&'#`),
    peg$decode(`%3Ä""5$7Å/1#;ð/($8":Æ"! )("'#&'#`),
    peg$decode(`%3Ç""5&7È/1#;T/($8":É"! )("'#&'#`),
    peg$decode(`%3Ê""5"7Ë/N#%2>""6>7?/,#;6/#$+")("'#&'#." &"/'$8":Ì" )("'#&'#`),
    peg$decode(`%;h/P#%2>""6>7?/,#;i/#$+")("'#&'#." &"/)$8":Í""! )("'#&'#`),
    peg$decode('%$;j/&#0#*;j&&&#/"!&,)'),
    peg$decode('%$;j/&#0#*;j&&&#/"!&,)'),
    peg$decode(";k.) &;+.# &;-"),
    peg$decode('2l""6l7m.e &2n""6n7o.Y &24""6475.M &28""6879.A &2<""6<7=.5 &2@""6@7A.) &2B""6B7C'),
    peg$decode(`%26""6677/n#;m/e$$%2<""6<7=/,#;m/#$+")("'#&'#0<*%2<""6<7=/,#;m/#$+")("'#&'#&/#$+#)(#'#("'#&'#`),
    peg$decode(`%;n/A#2>""6>7?/2$;o/)$8#:Î#"" )(#'#("'#&'#`),
    peg$decode("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"),
    peg$decode("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"),
    peg$decode('2l""6l7m.e &2n""6n7o.Y &24""6475.M &26""6677.A &28""6879.5 &2@""6@7A.) &2B""6B7C'),
    peg$decode(";.# &;r"),
    peg$decode(`%;/G#;'/>$;s/5$;'/,$;/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode(";M.# &;t"),
    peg$decode(`%;/E#28""6879/6$;u.# &;x/'$8#:Ï# )(#'#("'#&'#`),
    peg$decode(`%;v.# &;w/J#%26""6677/,#;/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode(`%2Ð""6Ð7Ñ/:#;/1$;w." &"/#$+#)(#'#("'#&'#`),
    peg$decode(`%24""6475/,#;{/#$+")("'#&'#`),
    peg$decode(`%;z/3#$;y0#*;y&/#$+")("'#&'#`),
    peg$decode(";*.) &;+.# &;-"),
    peg$decode(';+. &;-. &22""6273.} &26""6677.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'),
    peg$decode(`%;|/e#$%24""6475/,#;|/#$+")("'#&'#0<*%24""6475/,#;|/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%$;~0#*;~&/e#$%22""6273/,#;}/#$+")("'#&'#0<*%22""6273/,#;}/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode("$;~0#*;~&"),
    peg$decode(';+.w &;-.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'),
    peg$decode(`%%;"/#$;".G &;!.A &2@""6@7A.5 &2F""6F7G.) &2J""6J7K0M*;".G &;!.A &2@""6@7A.5 &2F""6F7G.) &2J""6J7K&/#$+")("'#&'#/& 8!:Ò! )`),
    peg$decode(";.# &;"),
    peg$decode(`%%;O/2#2:""6:7;/#$+")("'#&'#." &"/,#;S/#$+")("'#&'#." &"`),
    peg$decode('$;+. &;-.} &2B""6B7C.q &2D""6D7E.e &22""6273.Y &28""6879.M &2:""6:7;.A &2<""6<7=.5 &2>""6>7?.) &2@""6@7A/#0*;+. &;-.} &2B""6B7C.q &2D""6D7E.e &22""6273.Y &28""6879.M &2:""6:7;.A &2<""6<7=.5 &2>""6>7?.) &2@""6@7A&&&#'),
    peg$decode("$;y0#*;y&"),
    peg$decode(`%3""5#7Ó/q#24""6475/b$$;!/&#0#*;!&&&#/L$2J""6J7K/=$$;!/&#0#*;!&&&#/'$8%:Ô% )(%'#($'#(#'#("'#&'#`),
    peg$decode('2Õ""6Õ7Ö'),
    peg$decode('2×""6×7Ø'),
    peg$decode('2Ù""6Ù7Ú'),
    peg$decode('2Û""6Û7Ü'),
    peg$decode('2Ý""6Ý7Þ'),
    peg$decode('2ß""6ß7à'),
    peg$decode('2á""6á7â'),
    peg$decode('2ã""6ã7ä'),
    peg$decode('2å""6å7æ'),
    peg$decode('2ç""6ç7è'),
    peg$decode('2é""6é7ê'),
    peg$decode("%;.Y &;.S &;.M &;.G &;.A &;.; &;.5 &;./ &;.) &;.# &;6/& 8!:ë! )"),
    peg$decode(`%;/G#;'/>$;/5$;'/,$;/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode("%;/' 8!:ì!! )"),
    peg$decode(`%;!/5#;!/,$;!/#$+#)(#'#("'#&'#`),
    peg$decode("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:í! )"),
    peg$decode(`%;¶/Y#$%;A/,#;¶/#$+")("'#&'#06*%;A/,#;¶/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;9/N#%2:""6:7;/,#;9/#$+")("'#&'#." &"/'$8":î" )("'#&'#`),
    peg$decode(`%;:.c &%;/Y#$%;A/,#;/#$+")("'#&'#06*%;A/,#;/#$+")("'#&'#&/#$+")("'#&'#/& 8!:ï! )`),
    peg$decode(`%;L.# &;/]#$%;B/,#;/#$+")("'#&'#06*%;B/,#;/#$+")("'#&'#&/'$8":ð" )("'#&'#`),
    peg$decode(`%;." &"/>#;@/5$;M/,$;?/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%%;6/Y#$%;./,#;6/#$+")("'#&'#06*%;./,#;6/#$+")("'#&'#&/#$+")("'#&'#.# &;H/' 8!:ñ!! )`),
    peg$decode(";.) &;.# &; "),
    peg$decode(`%3ò""5!7ó/:#;</1$;/($8#:ô#! )(#'#("'#&'#`),
    peg$decode(`%3õ""5'7ö/:#;</1$;/($8#:÷#! )(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ø!! )"),
    peg$decode(`%2ù""6ù7ú/o#%2J""6J7K/M#;!." &"/?$;!." &"/1$;!." &"/#$+$)($'#(#'#("'#&'#." &"/'$8":û" )("'#&'#`),
    peg$decode(`%;6/J#%;</,#;¡/#$+")("'#&'#." &"/)$8":ü""! )("'#&'#`),
    peg$decode(";6.) &;T.# &;H"),
    peg$decode(`%;£/Y#$%;B/,#;¤/#$+")("'#&'#06*%;B/,#;¤/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%3ý""5&7þ.G &3ÿ""5'7Ā.; &3ā""5$7Ă./ &3ă""5%7Ą.# &;6/& 8!:ą! )`),
    peg$decode(";¥.# &; "),
    peg$decode(`%3Ć""5(7ć/M#;</D$3Ĉ""5(7ĉ./ &3Ċ""5(7ċ.# &;6/#$+#)(#'#("'#&'#`),
    peg$decode(`%;6/Y#$%;A/,#;6/#$+")("'#&'#06*%;A/,#;6/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:Č!! )"),
    peg$decode("%;©/& 8!:č! )"),
    peg$decode(`%;ª/k#;;/b$;¯/Y$$%;B/,#;°/#$+")("'#&'#06*%;B/,#;°/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(";«.# &;¬"),
    peg$decode('3Ď""5$7ď.S &3Đ""5%7đ.G &3Ē""5%7ē.; &3Ĕ""5%7ĕ./ &3Ė""5+7ė.# &;­'),
    peg$decode(`3Ę""5'7ę./ &3Ě""5)7ě.# &;­`),
    peg$decode(";6.# &;®"),
    peg$decode(`%3Ĝ""5"7ĝ/,#;6/#$+")("'#&'#`),
    peg$decode(";­.# &;6"),
    peg$decode(`%;6/5#;</,$;±/#$+#)(#'#("'#&'#`),
    peg$decode(";6.# &;H"),
    peg$decode(`%;³/5#;./,$;/#$+#)(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:Ğ!! )"),
    peg$decode("%;/' 8!:ğ!! )"),
    peg$decode(`%;¶/^#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/($8":Ġ"!!)("'#&'#`),
    peg$decode(`%%;7/e#$%2J""6J7K/,#;7/#$+")("'#&'#0<*%2J""6J7K/,#;7/#$+")("'#&'#&/#$+")("'#&'#/"!&,)`),
    peg$decode(`%;L.# &;/]#$%;B/,#;¸/#$+")("'#&'#06*%;B/,#;¸/#$+")("'#&'#&/'$8":ġ" )("'#&'#`),
    peg$decode(";¹.# &; "),
    peg$decode(`%3Ģ""5#7ģ/:#;</1$;6/($8#:Ĥ#! )(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ĥ!! )"),
    peg$decode("%;/' 8!:Ħ!! )"),
    peg$decode(`%$;0#*;&/x#;@/o$;M/f$;?/]$$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/'$8%:ħ% )(%'#($'#(#'#("'#&'#`),
    peg$decode(";¾"),
    peg$decode(`%3Ĩ""5&7ĩ/k#;./b$;Á/Y$$%;A/,#;Á/#$+")("'#&'#06*%;A/,#;Á/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#.# &;¿`),
    peg$decode(`%;6/k#;./b$;À/Y$$%;A/,#;À/#$+")("'#&'#06*%;A/,#;À/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%;6/;#;</2$;6.# &;H/#$+#)(#'#("'#&'#`),
    peg$decode(";Â.G &;Ä.A &;Æ.; &;È.5 &;É./ &;Ê.) &;Ë.# &;À"),
    peg$decode(`%3Ī""5%7ī/5#;</,$;Ã/#$+#)(#'#("'#&'#`),
    peg$decode("%;I/' 8!:Ĭ!! )"),
    peg$decode(`%3ĭ""5&7Į/#;</$;D/$;Å/|$$%$;'/&#0#*;'&&&#/,#;Å/#$+")("'#&'#0C*%$;'/&#0#*;'&&&#/,#;Å/#$+")("'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(";t.# &;w"),
    peg$decode(`%3į""5%7İ/5#;</,$;Ç/#$+#)(#'#("'#&'#`),
    peg$decode("%;I/' 8!:ı!! )"),
    peg$decode(`%3Ĳ""5&7ĳ/:#;</1$;I/($8#:Ĵ#! )(#'#("'#&'#`),
    peg$decode(`%3ĵ""5%7Ķ/]#;</T$%3ķ""5$7ĸ/& 8!:Ĺ! ).4 &%3ĺ""5%7Ļ/& 8!:ļ! )/#$+#)(#'#("'#&'#`),
    peg$decode(`%3Ľ""5)7ľ/R#;</I$3Ŀ""5#7ŀ./ &3Ł""5(7ł.# &;6/($8#:Ń#! )(#'#("'#&'#`),
    peg$decode(`%3ń""5#7Ņ/#;</$;D/$%;Ì/e#$%2D""6D7E/,#;Ì/#$+")("'#&'#0<*%2D""6D7E/,#;Ì/#$+")("'#&'#&/#$+")("'#&'#/,$;E/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode(`%3ņ""5(7Ň./ &3ň""5$7ŉ.# &;6/' 8!:Ŋ!! )`),
    peg$decode(`%;6/Y#$%;A/,#;6/#$+")("'#&'#06*%;A/,#;6/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;Ï/G#;./>$;Ï/5$;./,$;/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ŋ!! )"),
    peg$decode(`%;Ñ/]#$%;A/,#;Ñ/#$+")("'#&'#06*%;A/,#;Ñ/#$+")("'#&'#&/'$8":Ō" )("'#&'#`),
    peg$decode(`%;/]#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/'$8":ō" )("'#&'#`),
    peg$decode(`%;L.O &;.I &%;@." &"/:#;t/1$;?." &"/#$+#)(#'#("'#&'#/]#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/'$8":Ŏ" )("'#&'#`),
    peg$decode(`%;Ô/]#$%;B/,#;Õ/#$+")("'#&'#06*%;B/,#;Õ/#$+")("'#&'#&/'$8":ŏ" )("'#&'#`),
    peg$decode("%;/& 8!:Ő! )"),
    peg$decode(`%3ő""5(7Œ/:#;</1$;6/($8#:œ#! )(#'#("'#&'#.g &%3Ŕ""5&7ŕ/:#;</1$;6/($8#:Ŗ#! )(#'#("'#&'#.: &%3ŗ""5*7Ř/& 8!:ř! ).# &; `),
    peg$decode(`%%;6/k#$%;A/2#;6/)$8":Ś""$ )("'#&'#0<*%;A/2#;6/)$8":Ś""$ )("'#&'#&/)$8":ś""! )("'#&'#." &"/' 8!:Ŝ!! )`),
    peg$decode(`%;Ø/Y#$%;A/,#;Ø/#$+")("'#&'#06*%;A/,#;Ø/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;/Y#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ŝ!! )"),
    peg$decode(`%;Û/Y#$%;B/,#;Ü/#$+")("'#&'#06*%;B/,#;Ü/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%3Ş""5&7ş.; &3Š""5'7š./ &3Ţ""5*7ţ.# &;6/& 8!:Ť! )`),
    peg$decode(`%3ť""5&7Ŧ/:#;</1$;Ý/($8#:ŧ#! )(#'#("'#&'#.} &%3õ""5'7ö/:#;</1$;/($8#:Ũ#! )(#'#("'#&'#.P &%3ũ""5+7Ū/:#;</1$;/($8#:ū#! )(#'#("'#&'#.# &; `),
    peg$decode(`3Ŭ""5+7ŭ.k &3Ů""5)7ů._ &3Ű""5(7ű.S &3Ų""5'7ų.G &3Ŵ""5&7ŵ.; &3Ŷ""5*7ŷ./ &3Ÿ""5)7Ź.# &;6`),
    peg$decode(';1." &"'),
    peg$decode(`%%;6/k#$%;A/2#;6/)$8":Ś""$ )("'#&'#0<*%;A/2#;6/)$8":Ś""$ )("'#&'#&/)$8":ś""! )("'#&'#." &"/' 8!:ź!! )`),
    peg$decode(`%;L.# &;/]#$%;B/,#;á/#$+")("'#&'#06*%;B/,#;á/#$+")("'#&'#&/'$8":Ż" )("'#&'#`),
    peg$decode(";¹.# &; "),
    peg$decode(`%;ã/Y#$%;A/,#;ã/#$+")("'#&'#06*%;A/,#;ã/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;ê/k#;./b$;í/Y$$%;B/,#;ä/#$+")("'#&'#06*%;B/,#;ä/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(";å.; &;æ.5 &;ç./ &;è.) &;é.# &; "),
    peg$decode(`%3ż""5#7Ž/:#;</1$;ð/($8#:ž#! )(#'#("'#&'#`),
    peg$decode(`%3ſ""5%7ƀ/:#;</1$;T/($8#:Ɓ#! )(#'#("'#&'#`),
    peg$decode(`%3Ƃ""5(7ƃ/F#;</=$;\\.) &;Y.# &;X/($8#:Ƅ#! )(#'#("'#&'#`),
    peg$decode(`%3ƅ""5&7Ɔ/:#;</1$;6/($8#:Ƈ#! )(#'#("'#&'#`),
    peg$decode(`%3ƈ""5%7Ɖ/A#;</8$$;!0#*;!&/($8#:Ɗ#! )(#'#("'#&'#`),
    peg$decode(`%;ë/G#;;/>$;6/5$;;/,$;ì/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode(`%3""5#7Ó.# &;6/' 8!:Ƌ!! )`),
    peg$decode(`%3±""5#7ƌ.G &3³""5#7ƍ.; &3·""5#7Ǝ./ &3µ""5$7Ə.# &;6/' 8!:Ɛ!! )`),
    peg$decode(`%;î/D#%;C/,#;ï/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode("%;U.) &;\\.# &;X/& 8!:Ƒ! )"),
    peg$decode(`%%;!." &"/[#;!." &"/M$;!." &"/?$;!." &"/1$;!." &"/#$+%)(%'#($'#(#'#("'#&'#/' 8!:ƒ!! )`),
    peg$decode(`%%;!/?#;!." &"/1$;!." &"/#$+#)(#'#("'#&'#/' 8!:Ɠ!! )`),
    peg$decode(";¾"),
    peg$decode(`%;/^#$%;B/,#;ó/#$+")("'#&'#06*%;B/,#;ó/#$+")("'#&'#&/($8":Ɣ"!!)("'#&'#`),
    peg$decode(";ô.# &; "),
    peg$decode(`%2ƕ""6ƕ7Ɩ/L#;</C$2Ɨ""6Ɨ7Ƙ.) &2ƙ""6ƙ7ƚ/($8#:ƛ#! )(#'#("'#&'#`),
    peg$decode(`%;/^#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/($8":Ɯ"!!)("'#&'#`),
    peg$decode(`%;6/5#;0/,$;÷/#$+#)(#'#("'#&'#`),
    peg$decode("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"),
    peg$decode("$;%0#*;%&"),
    peg$decode(`%;ú/;#28""6879/,$;û/#$+#)(#'#("'#&'#`),
    peg$decode(`%3Ɲ""5%7ƞ.) &3Ɵ""5$7Ơ/' 8!:ơ!! )`),
    peg$decode(`%;ü/J#%28""6879/,#;^/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode("%;\\.) &;X.# &;/' 8!:Ƣ!! )"),
    peg$decode(';".S &;!.M &2F""6F7G.A &2J""6J7K.5 &2H""6H7I.) &2N""6N7O'),
    peg$decode('2L""6L7M. &2B""6B7C. &2<""6<7=.} &2R""6R7S.q &2T""6T7U.e &2V""6V7W.Y &2P""6P7Q.M &2@""6@7A.A &2D""6D7E.5 &22""6273.) &2>""6>7?'),
    peg$decode(`%;Ā/b#28""6879/S$;û/J$%2ƣ""6ƣ7Ƥ/,#;ì/#$+")("'#&'#." &"/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%3ƥ""5%7Ʀ.) &3Ƨ""5$7ƨ/' 8!:ơ!! )`),
    peg$decode(`%3±""5#7².6 &3³""5#7´.* &$;+0#*;+&/' 8!:Ʃ!! )`),
    peg$decode(`%;Ą/#2F""6F7G/x$;ă/o$2F""6F7G/\`$;ă/W$2F""6F7G/H$;ă/?$2F""6F7G/0$;ą/'$8):ƪ) )()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(`%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%;ă/,#;ă/#$+")("'#&'#`),
    peg$decode(`%;ă/5#;ă/,$;ă/#$+#)(#'#("'#&'#`),
    peg$decode(`%;q/T#$;m0#*;m&/D$%; /,#;ø/#$+")("'#&'#." &"/#$+#)(#'#("'#&'#`),
    peg$decode(`%2ƫ""6ƫ7Ƭ.) &2ƭ""6ƭ7Ʈ/w#;0/n$;Ĉ/e$$%;B/2#;ĉ.# &; /#$+")("'#&'#0<*%;B/2#;ĉ.# &; /#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(";.# &;L"),
    peg$decode(`%2Ư""6Ư7ư/5#;</,$;Ċ/#$+#)(#'#("'#&'#`),
    peg$decode(`%;D/S#;,/J$2:""6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#("'#&'#`)
  ];
  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected = [];
  let peg$silentFails = 0;
  let peg$result;
  if (options.startRule !== void 0) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
    }
    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }
  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }
  function location2() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }
  function peg$literalExpectation(text1, ignoreCase) {
    return { type: "literal", text: text1, ignoreCase };
  }
  function peg$classExpectation(parts2, inverted, ignoreCase) {
    return { type: "class", parts: parts2, inverted, ignoreCase };
  }
  function peg$endExpectation() {
    return { type: "end" };
  }
  function peg$computePosDetails(pos) {
    let details = peg$posDetailsCache[pos];
    let p2;
    if (details) {
      return details;
    } else {
      p2 = pos - 1;
      while (!peg$posDetailsCache[p2]) {
        p2--;
      }
      details = peg$posDetailsCache[p2];
      details = {
        line: details.line,
        column: details.column
      };
      while (p2 < pos) {
        if (input.charCodeAt(p2) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p2++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos) {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);
    return {
      source: peg$source,
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }
  function peg$fail(expected1) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected1);
  }
  function peg$buildStructuredError(expected1, found, location1) {
    return new SyntaxError$1(SyntaxError$1.buildMessage(expected1, found), expected1, found, location1);
  }
  function peg$decode(s2) {
    return s2.split("").map((ch) => ch.charCodeAt(0) - 32);
  }
  function peg$parseRule(index) {
    const bc = peg$bytecode[index];
    let ip = 0;
    const ips = [];
    let end = bc.length;
    const ends = [];
    const stack = [];
    let params;
    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;
          case 1:
            stack.push(void 0);
            ip++;
            break;
          case 2:
            stack.push(null);
            ip++;
            break;
          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;
          case 4:
            stack.push([]);
            ip++;
            break;
          case 5:
            stack.push(peg$currPos);
            ip++;
            break;
          case 6:
            stack.pop();
            ip++;
            break;
          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;
          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;
          case 9:
            stack.splice(-2, 1);
            ip++;
            break;
          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;
          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;
          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;
          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);
              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }
            break;
          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }
            break;
          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }
            break;
          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }
            break;
          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;
          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += peg$consts[bc[ip + 1]].length;
            ip += 2;
            break;
          case 23:
            stack.push(peg$FAILED);
            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]]);
            }
            ip += 2;
            break;
          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;
          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;
          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]).map(function(p2) {
              return stack[stack.length - 1 - p2];
            });
            stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
            ip += 4 + bc[ip + 3];
            break;
          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;
          case 28:
            peg$silentFails++;
            ip++;
            break;
          case 29:
            peg$silentFails--;
            ip++;
            break;
          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }
      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }
    return stack[0];
  }
  options.data = {};
  function list(head, tail) {
    return [head].concat(tail);
  }
  peg$result = peg$parseRule(peg$startRuleIndex);
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}
const parse$2 = peg$parse$1;
var Grammar$1;
(function(Grammar2) {
  function parse2(input, startRule) {
    const options = { startRule };
    try {
      parse$2(input, options);
    } catch (e2) {
      options.data = -1;
    }
    return options.data;
  }
  Grammar2.parse = parse2;
  function nameAddrHeaderParse(nameAddrHeader) {
    const parsedNameAddrHeader = Grammar2.parse(nameAddrHeader, "Name_Addr_Header");
    return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : void 0;
  }
  Grammar2.nameAddrHeaderParse = nameAddrHeaderParse;
  function URIParse(uri) {
    const parsedUri = Grammar2.parse(uri, "SIP_URI");
    return parsedUri !== -1 ? parsedUri : void 0;
  }
  Grammar2.URIParse = URIParse;
})(Grammar$1 = Grammar$1 || (Grammar$1 = {}));
const REASON_PHRASE$1 = {
  100: "Trying",
  180: "Ringing",
  181: "Call Is Being Forwarded",
  182: "Queued",
  183: "Session Progress",
  199: "Early Dialog Terminated",
  200: "OK",
  202: "Accepted",
  204: "No Notification",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Moved Temporarily",
  305: "Use Proxy",
  380: "Alternative Service",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  410: "Gone",
  412: "Conditional Request Failed",
  413: "Request Entity Too Large",
  414: "Request-URI Too Long",
  415: "Unsupported Media Type",
  416: "Unsupported URI Scheme",
  417: "Unknown Resource-Priority",
  420: "Bad Extension",
  421: "Extension Required",
  422: "Session Interval Too Small",
  423: "Interval Too Brief",
  428: "Use Identity Header",
  429: "Provide Referrer Identity",
  430: "Flow Failed",
  433: "Anonymity Disallowed",
  436: "Bad Identity-Info",
  437: "Unsupported Certificate",
  438: "Invalid Identity Header",
  439: "First Hop Lacks Outbound Support",
  440: "Max-Breadth Exceeded",
  469: "Bad Info Package",
  470: "Consent Needed",
  478: "Unresolvable Destination",
  480: "Temporarily Unavailable",
  481: "Call/Transaction Does Not Exist",
  482: "Loop Detected",
  483: "Too Many Hops",
  484: "Address Incomplete",
  485: "Ambiguous",
  486: "Busy Here",
  487: "Request Terminated",
  488: "Not Acceptable Here",
  489: "Bad Event",
  491: "Request Pending",
  493: "Undecipherable",
  494: "Security Agreement Required",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Server Time-out",
  505: "Version Not Supported",
  513: "Message Too Large",
  580: "Precondition Failure",
  600: "Busy Everywhere",
  603: "Decline",
  604: "Does Not Exist Anywhere",
  606: "Not Acceptable"
};
function createRandomToken$1(size, base = 32) {
  let token = "";
  for (let i2 = 0; i2 < size; i2++) {
    const r2 = Math.floor(Math.random() * base);
    token += r2.toString(base);
  }
  return token;
}
function getReasonPhrase$1(code) {
  return REASON_PHRASE$1[code] || "";
}
function newTag$1() {
  return createRandomToken$1(10);
}
function headerize$1(str) {
  const exceptions = {
    "Call-Id": "Call-ID",
    Cseq: "CSeq",
    "Min-Se": "Min-SE",
    Rack: "RAck",
    Rseq: "RSeq",
    "Www-Authenticate": "WWW-Authenticate"
  };
  const name2 = str.toLowerCase().replace(/_/g, "-").split("-");
  const parts2 = name2.length;
  let hname = "";
  for (let part = 0; part < parts2; part++) {
    if (part !== 0) {
      hname += "-";
    }
    hname += name2[part].charAt(0).toUpperCase() + name2[part].substring(1);
  }
  if (exceptions[hname]) {
    hname = exceptions[hname];
  }
  return hname;
}
function utf8Length$2(str) {
  return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
}
let IncomingMessage$1 = class IncomingMessage {
  constructor() {
    this.headers = {};
  }
  /**
   * Insert a header of the given name and value into the last position of the
   * header array.
   * @param name - header name
   * @param value - header value
   */
  addHeader(name2, value2) {
    const header = { raw: value2 };
    name2 = headerize$1(name2);
    if (this.headers[name2]) {
      this.headers[name2].push(header);
    } else {
      this.headers[name2] = [header];
    }
  }
  /**
   * Get the value of the given header name at the given position.
   * @param name - header name
   * @returns Returns the specified header, undefined if header doesn't exist.
   */
  getHeader(name2) {
    const header = this.headers[headerize$1(name2)];
    if (header) {
      if (header[0]) {
        return header[0].raw;
      }
    } else {
      return;
    }
  }
  /**
   * Get the header/s of the given name.
   * @param name - header name
   * @returns Array - with all the headers of the specified name.
   */
  getHeaders(name2) {
    const header = this.headers[headerize$1(name2)];
    const result = [];
    if (!header) {
      return [];
    }
    for (const headerPart of header) {
      result.push(headerPart.raw);
    }
    return result;
  }
  /**
   * Verify the existence of the given header.
   * @param name - header name
   * @returns true if header with given name exists, false otherwise
   */
  hasHeader(name2) {
    return !!this.headers[headerize$1(name2)];
  }
  /**
   * Parse the given header on the given index.
   * @param name - header name
   * @param idx - header index
   * @returns Parsed header object, undefined if the
   *   header is not present or in case of a parsing error.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseHeader(name2, idx = 0) {
    name2 = headerize$1(name2);
    if (!this.headers[name2]) {
      return;
    } else if (idx >= this.headers[name2].length) {
      return;
    }
    const header = this.headers[name2][idx];
    const value2 = header.raw;
    if (header.parsed) {
      return header.parsed;
    }
    const parsed = Grammar$1.parse(value2, name2.replace(/-/g, "_"));
    if (parsed === -1) {
      this.headers[name2].splice(idx, 1);
      return;
    } else {
      header.parsed = parsed;
      return parsed;
    }
  }
  /**
   * Message Header attribute selector. Alias of parseHeader.
   * @param name - header name
   * @param idx - header index
   * @returns Parsed header object, undefined if the
   *   header is not present or in case of a parsing error.
   *
   * @example
   * message.s('via',3).port
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  s(name2, idx = 0) {
    return this.parseHeader(name2, idx);
  }
  /**
   * Replace the value of the given header by the value.
   * @param name - header name
   * @param value - header value
   */
  setHeader(name2, value2) {
    this.headers[headerize$1(name2)] = [{ raw: value2 }];
  }
  toString() {
    return this.data;
  }
};
let IncomingRequestMessage$1 = class IncomingRequestMessage extends IncomingMessage$1 {
  constructor() {
    super();
  }
};
let IncomingResponseMessage$1 = class IncomingResponseMessage extends IncomingMessage$1 {
  constructor() {
    super();
  }
};
let OutgoingRequestMessage$1 = class OutgoingRequestMessage {
  constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {
    this.headers = {};
    this.extraHeaders = [];
    this.options = OutgoingRequestMessage.getDefaultOptions();
    if (options) {
      this.options = Object.assign(Object.assign({}, this.options), options);
      if (this.options.optionTags && this.options.optionTags.length) {
        this.options.optionTags = this.options.optionTags.slice();
      }
      if (this.options.routeSet && this.options.routeSet.length) {
        this.options.routeSet = this.options.routeSet.slice();
      }
    }
    if (extraHeaders && extraHeaders.length) {
      this.extraHeaders = extraHeaders.slice();
    }
    if (body) {
      this.body = {
        body: body.content,
        contentType: body.contentType
      };
    }
    this.method = method;
    this.ruri = ruri.clone();
    this.fromURI = fromURI.clone();
    this.fromTag = this.options.fromTag ? this.options.fromTag : newTag$1();
    this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);
    this.toURI = toURI.clone();
    this.toTag = this.options.toTag;
    this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);
    this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken$1(15);
    this.cseq = this.options.cseq;
    this.setHeader("route", this.options.routeSet);
    this.setHeader("via", "");
    this.setHeader("to", this.to.toString());
    this.setHeader("from", this.from.toString());
    this.setHeader("cseq", this.cseq + " " + this.method);
    this.setHeader("call-id", this.callId);
    this.setHeader("max-forwards", "70");
  }
  /** Get a copy of the default options. */
  static getDefaultOptions() {
    return {
      callId: "",
      callIdPrefix: "",
      cseq: 1,
      toDisplayName: "",
      toTag: "",
      fromDisplayName: "",
      fromTag: "",
      forceRport: false,
      hackViaTcp: false,
      optionTags: ["outbound"],
      routeSet: [],
      userAgentString: "sip.js",
      viaHost: ""
    };
  }
  static makeNameAddrHeader(uri, displayName, tag) {
    const parameters = {};
    if (tag) {
      parameters.tag = tag;
    }
    return new NameAddrHeader$1(uri, displayName, parameters);
  }
  /**
   * Get the value of the given header name at the given position.
   * @param name - header name
   * @returns Returns the specified header, undefined if header doesn't exist.
   */
  getHeader(name2) {
    const header = this.headers[headerize$1(name2)];
    if (header) {
      if (header[0]) {
        return header[0];
      }
    } else {
      const regexp = new RegExp("^\\s*" + name2 + "\\s*:", "i");
      for (const exHeader of this.extraHeaders) {
        if (regexp.test(exHeader)) {
          return exHeader.substring(exHeader.indexOf(":") + 1).trim();
        }
      }
    }
    return;
  }
  /**
   * Get the header/s of the given name.
   * @param name - header name
   * @returns Array with all the headers of the specified name.
   */
  getHeaders(name2) {
    const result = [];
    const headerArray = this.headers[headerize$1(name2)];
    if (headerArray) {
      for (const headerPart of headerArray) {
        result.push(headerPart);
      }
    } else {
      const regexp = new RegExp("^\\s*" + name2 + "\\s*:", "i");
      for (const exHeader of this.extraHeaders) {
        if (regexp.test(exHeader)) {
          result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
        }
      }
    }
    return result;
  }
  /**
   * Verify the existence of the given header.
   * @param name - header name
   * @returns true if header with given name exists, false otherwise
   */
  hasHeader(name2) {
    if (this.headers[headerize$1(name2)]) {
      return true;
    } else {
      const regexp = new RegExp("^\\s*" + name2 + "\\s*:", "i");
      for (const extraHeader of this.extraHeaders) {
        if (regexp.test(extraHeader)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Replace the the given header by the given value.
   * @param name - header name
   * @param value - header value
   */
  setHeader(name2, value2) {
    this.headers[headerize$1(name2)] = value2 instanceof Array ? value2 : [value2];
  }
  /**
   * The Via header field indicates the transport used for the transaction
   * and identifies the location where the response is to be sent.  A Via
   * header field value is added only after the transport that will be
   * used to reach the next hop has been selected (which may involve the
   * usage of the procedures in [4]).
   *
   * When the UAC creates a request, it MUST insert a Via into that
   * request.  The protocol name and protocol version in the header field
   * MUST be SIP and 2.0, respectively.  The Via header field value MUST
   * contain a branch parameter.  This parameter is used to identify the
   * transaction created by that request.  This parameter is used by both
   * the client and the server.
   * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
   * @param branchParameter - The branch parameter.
   * @param transport - The sent protocol transport.
   */
  setViaHeader(branch, transport) {
    if (this.options.hackViaTcp) {
      transport = "TCP";
    }
    let via = "SIP/2.0/" + transport;
    via += " " + this.options.viaHost + ";branch=" + branch;
    if (this.options.forceRport) {
      via += ";rport";
    }
    this.setHeader("via", via);
    this.branch = branch;
  }
  toString() {
    let msg = "";
    msg += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";
    for (const header in this.headers) {
      if (this.headers[header]) {
        for (const headerPart of this.headers[header]) {
          msg += header + ": " + headerPart + "\r\n";
        }
      }
    }
    for (const header of this.extraHeaders) {
      msg += header.trim() + "\r\n";
    }
    msg += "Supported: " + this.options.optionTags.join(", ") + "\r\n";
    msg += "User-Agent: " + this.options.userAgentString + "\r\n";
    if (this.body) {
      if (typeof this.body === "string") {
        msg += "Content-Length: " + utf8Length$2(this.body) + "\r\n\r\n";
        msg += this.body;
      } else {
        if (this.body.body && this.body.contentType) {
          msg += "Content-Type: " + this.body.contentType + "\r\n";
          msg += "Content-Length: " + utf8Length$2(this.body.body) + "\r\n\r\n";
          msg += this.body.body;
        } else {
          msg += "Content-Length: 0\r\n\r\n";
        }
      }
    } else {
      msg += "Content-Length: 0\r\n\r\n";
    }
    return msg;
  }
};
function contentTypeToContentDisposition$1(contentType) {
  if (contentType === "application/sdp") {
    return "session";
  } else {
    return "render";
  }
}
function fromBodyLegacy$1(bodyLegacy) {
  const content2 = typeof bodyLegacy === "string" ? bodyLegacy : bodyLegacy.body;
  const contentType = typeof bodyLegacy === "string" ? "application/sdp" : bodyLegacy.contentType;
  const contentDisposition = contentTypeToContentDisposition$1(contentType);
  const body = { contentDisposition, contentType, content: content2 };
  return body;
}
function isBody$1(body) {
  return body && typeof body.content === "string" && typeof body.contentType === "string" && body.contentDisposition === void 0 ? true : typeof body.contentDisposition === "string";
}
function getBody$1(message2) {
  let contentDisposition;
  let contentType;
  let content2;
  if (message2 instanceof IncomingRequestMessage$1) {
    if (message2.body) {
      const parse2 = message2.parseHeader("Content-Disposition");
      contentDisposition = parse2 ? parse2.type : void 0;
      contentType = message2.parseHeader("Content-Type");
      content2 = message2.body;
    }
  }
  if (message2 instanceof IncomingResponseMessage$1) {
    if (message2.body) {
      const parse2 = message2.parseHeader("Content-Disposition");
      contentDisposition = parse2 ? parse2.type : void 0;
      contentType = message2.parseHeader("Content-Type");
      content2 = message2.body;
    }
  }
  if (message2 instanceof OutgoingRequestMessage$1) {
    if (message2.body) {
      contentDisposition = message2.getHeader("Content-Disposition");
      contentType = message2.getHeader("Content-Type");
      if (typeof message2.body === "string") {
        if (!contentType) {
          throw new Error("Header content type header does not equal body content type.");
        }
        content2 = message2.body;
      } else {
        if (contentType && contentType !== message2.body.contentType) {
          throw new Error("Header content type header does not equal body content type.");
        }
        contentType = message2.body.contentType;
        content2 = message2.body.body;
      }
    }
  }
  if (isBody$1(message2)) {
    contentDisposition = message2.contentDisposition;
    contentType = message2.contentType;
    content2 = message2.content;
  }
  if (!content2) {
    return void 0;
  }
  if (contentType && !contentDisposition) {
    contentDisposition = contentTypeToContentDisposition$1(contentType);
  }
  if (!contentDisposition) {
    throw new Error("Content disposition undefined.");
  }
  if (!contentType) {
    throw new Error("Content type undefined.");
  }
  return {
    contentDisposition,
    contentType,
    content: content2
  };
}
var SessionState$3;
(function(SessionState2) {
  SessionState2["Initial"] = "Initial";
  SessionState2["Early"] = "Early";
  SessionState2["AckWait"] = "AckWait";
  SessionState2["Confirmed"] = "Confirmed";
  SessionState2["Terminated"] = "Terminated";
})(SessionState$3 = SessionState$3 || (SessionState$3 = {}));
var SignalingState$1;
(function(SignalingState2) {
  SignalingState2["Initial"] = "Initial";
  SignalingState2["HaveLocalOffer"] = "HaveLocalOffer";
  SignalingState2["HaveRemoteOffer"] = "HaveRemoteOffer";
  SignalingState2["Stable"] = "Stable";
  SignalingState2["Closed"] = "Closed";
})(SignalingState$1 = SignalingState$1 || (SignalingState$1 = {}));
const T1$1 = 500;
const T2$1 = 4e3;
const T4$1 = 5e3;
const Timers$1 = {
  T1: T1$1,
  T2: T2$1,
  TIMER_B: 64 * T1$1,
  TIMER_D: 0 * T1$1,
  TIMER_F: 64 * T1$1,
  TIMER_H: 64 * T1$1,
  TIMER_I: 0 * T4$1,
  TIMER_J: 0 * T1$1,
  TIMER_K: 0 * T4$1,
  TIMER_L: 64 * T1$1,
  TIMER_M: 64 * T1$1,
  TIMER_N: 64 * T1$1,
  PROVISIONAL_RESPONSE_INTERVAL: 6e4
  // See RFC 3261 Section 13.3.1.1
};
let Exception$1 = class Exception extends Error {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
let TransactionStateError$1 = class TransactionStateError extends Exception$1 {
  constructor(message2) {
    super(message2 ? message2 : "Transaction state error.");
  }
};
class Cancel {
  /** @internal */
  constructor(incomingCancelRequest) {
    this.incomingCancelRequest = incomingCancelRequest;
  }
  /** Incoming CANCEL request message. */
  get request() {
    return this.incomingCancelRequest;
  }
}
let ContentTypeUnsupportedError$1 = class ContentTypeUnsupportedError extends Exception$1 {
  constructor(message2) {
    super(message2 ? message2 : "Unsupported content type.");
  }
};
let SessionDescriptionHandlerError$1 = class SessionDescriptionHandlerError extends Exception$1 {
  constructor(message2) {
    super(message2 ? message2 : "Unspecified session description handler error.");
  }
};
let SessionTerminatedError$1 = class SessionTerminatedError extends Exception$1 {
  constructor() {
    super("The session has terminated.");
  }
};
var C$1;
(function(C2) {
  C2.ACK = "ACK";
  C2.BYE = "BYE";
  C2.CANCEL = "CANCEL";
  C2.INFO = "INFO";
  C2.INVITE = "INVITE";
  C2.MESSAGE = "MESSAGE";
  C2.NOTIFY = "NOTIFY";
  C2.OPTIONS = "OPTIONS";
  C2.REGISTER = "REGISTER";
  C2.UPDATE = "UPDATE";
  C2.SUBSCRIBE = "SUBSCRIBE";
  C2.PUBLISH = "PUBLISH";
  C2.REFER = "REFER";
  C2.PRACK = "PRACK";
})(C$1 = C$1 || (C$1 = {}));
const AllowedMethods$1 = [
  C$1.ACK,
  C$1.BYE,
  C$1.CANCEL,
  C$1.INFO,
  C$1.INVITE,
  C$1.MESSAGE,
  C$1.NOTIFY,
  C$1.OPTIONS,
  C$1.PRACK,
  C$1.REFER,
  C$1.REGISTER,
  C$1.SUBSCRIBE
];
let Ack$1 = class Ack {
  /** @internal */
  constructor(incomingAckRequest) {
    this.incomingAckRequest = incomingAckRequest;
  }
  /** Incoming ACK request message. */
  get request() {
    return this.incomingAckRequest.message;
  }
};
let Bye$1 = class Bye {
  /** @internal */
  constructor(incomingByeRequest) {
    this.incomingByeRequest = incomingByeRequest;
  }
  /** Incoming BYE request message. */
  get request() {
    return this.incomingByeRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingByeRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingByeRequest.reject(options);
    return Promise.resolve();
  }
};
let EmitterImpl$1 = class EmitterImpl {
  constructor() {
    this.listeners = new Array();
  }
  /**
   * Sets up a function that will be called whenever the target changes.
   * @param listener - Callback function.
   * @param options - An options object that specifies characteristics about the listener.
   *                  If once true, indicates that the listener should be invoked at most once after being added.
   *                  If once true, the listener would be automatically removed when invoked.
   */
  addListener(listener, options) {
    const onceWrapper = (data) => {
      this.removeListener(onceWrapper);
      listener(data);
    };
    (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);
  }
  /**
   * Emit change.
   * @param data - Data to emit.
   */
  emit(data) {
    this.listeners.slice().forEach((listener) => listener(data));
  }
  /**
   * Removes all listeners previously registered with addListener.
   */
  removeAllListeners() {
    this.listeners = [];
  }
  /**
   * Removes a listener previously registered with addListener.
   * @param listener - Callback function.
   */
  removeListener(listener) {
    this.listeners = this.listeners.filter((l2) => l2 !== listener);
  }
  /**
   * Registers a listener.
   * @param listener - Callback function.
   * @deprecated Use addListener.
   */
  on(listener) {
    return this.addListener(listener);
  }
  /**
   * Unregisters a listener.
   * @param listener - Callback function.
   * @deprecated Use removeListener.
   */
  off(listener) {
    return this.removeListener(listener);
  }
  /**
   * Registers a listener then unregisters the listener after one event emission.
   * @param listener - Callback function.
   * @deprecated Use addListener.
   */
  once(listener) {
    return this.addListener(listener, { once: true });
  }
};
let RequestPendingError$1 = class RequestPendingError extends Exception$1 {
  /** @internal */
  constructor(message2) {
    super(message2 ? message2 : "Request pending.");
  }
};
let Info$1 = class Info {
  /** @internal */
  constructor(incomingInfoRequest) {
    this.incomingInfoRequest = incomingInfoRequest;
  }
  /** Incoming MESSAGE request message. */
  get request() {
    return this.incomingInfoRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingInfoRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingInfoRequest.reject(options);
    return Promise.resolve();
  }
};
let Message$1 = class Message {
  /** @internal */
  constructor(incomingMessageRequest) {
    this.incomingMessageRequest = incomingMessageRequest;
  }
  /** Incoming MESSAGE request message. */
  get request() {
    return this.incomingMessageRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingMessageRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingMessageRequest.reject(options);
    return Promise.resolve();
  }
};
let Notification$1 = class Notification {
  /** @internal */
  constructor(incomingNotifyRequest) {
    this.incomingNotifyRequest = incomingNotifyRequest;
  }
  /** Incoming NOTIFY request message. */
  get request() {
    return this.incomingNotifyRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingNotifyRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingNotifyRequest.reject(options);
    return Promise.resolve();
  }
};
let Referral$1 = class Referral {
  /** @internal */
  constructor(incomingReferRequest, session2) {
    this.incomingReferRequest = incomingReferRequest;
    this.session = session2;
  }
  get referTo() {
    const referTo = this.incomingReferRequest.message.parseHeader("refer-to");
    if (!(referTo instanceof NameAddrHeader$1)) {
      throw new Error("Failed to parse Refer-To header.");
    }
    return referTo;
  }
  get referredBy() {
    return this.incomingReferRequest.message.getHeader("referred-by");
  }
  get replaces() {
    const value2 = this.referTo.uri.getHeader("replaces");
    if (value2 instanceof Array) {
      return value2[0];
    }
    return value2;
  }
  /** Incoming REFER request message. */
  get request() {
    return this.incomingReferRequest.message;
  }
  /** Accept the request. */
  accept(options = { statusCode: 202 }) {
    this.incomingReferRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingReferRequest.reject(options);
    return Promise.resolve();
  }
  /**
   * Creates an inviter which may be used to send an out of dialog INVITE request.
   *
   * @remarks
   * This a helper method to create an Inviter which will execute the referral
   * of the `Session` which was referred. The appropriate headers are set and
   * the referred `Session` is linked to the new `Session`. Note that only a
   * single instance of the `Inviter` will be created and returned (if called
   * more than once a reference to the same `Inviter` will be returned every time).
   *
   * @param options - Options bucket.
   * @param modifiers - Session description handler modifiers.
   */
  makeInviter(options) {
    if (this.inviter) {
      return this.inviter;
    }
    const targetURI = this.referTo.uri.clone();
    targetURI.clearHeaders();
    options = options || {};
    const extraHeaders = (options.extraHeaders || []).slice();
    const replaces = this.replaces;
    if (replaces) {
      extraHeaders.push("Replaces: " + decodeURIComponent(replaces));
    }
    const referredBy = this.referredBy;
    if (referredBy) {
      extraHeaders.push("Referred-By: " + referredBy);
    }
    options.extraHeaders = extraHeaders;
    this.inviter = this.session.userAgent._makeInviter(targetURI, options);
    this.inviter._referred = this.session;
    this.session._referral = this.inviter;
    return this.inviter;
  }
};
var SessionState$2;
(function(SessionState2) {
  SessionState2["Initial"] = "Initial";
  SessionState2["Establishing"] = "Establishing";
  SessionState2["Established"] = "Established";
  SessionState2["Terminating"] = "Terminating";
  SessionState2["Terminated"] = "Terminated";
})(SessionState$2 = SessionState$2 || (SessionState$2 = {}));
let Session$1 = class Session {
  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @internal
   */
  constructor(userAgent, options = {}) {
    this.pendingReinvite = false;
    this.pendingReinviteAck = false;
    this._state = SessionState$2.Initial;
    this.delegate = options.delegate;
    this._stateEventEmitter = new EmitterImpl$1();
    this._userAgent = userAgent;
  }
  /**
   * Destructor.
   */
  dispose() {
    this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`);
    delete this.userAgent._sessions[this.id];
    if (this._sessionDescriptionHandler) {
      this._sessionDescriptionHandler.close();
    }
    switch (this.state) {
      case SessionState$2.Initial:
        break;
      case SessionState$2.Establishing:
        break;
      case SessionState$2.Established:
        return new Promise((resolve) => {
          this._bye({
            // wait for the response to the BYE before resolving
            onAccept: () => resolve(),
            onRedirect: () => resolve(),
            onReject: () => resolve()
          });
        });
      case SessionState$2.Terminating:
        break;
      case SessionState$2.Terminated:
        break;
      default:
        throw new Error("Unknown state.");
    }
    return Promise.resolve();
  }
  /**
   * The asserted identity of the remote user.
   */
  get assertedIdentity() {
    return this._assertedIdentity;
  }
  /**
   * The confirmed session dialog.
   */
  get dialog() {
    return this._dialog;
  }
  /**
   * A unique identifier for this session.
   */
  get id() {
    return this._id;
  }
  /**
   * The session being replace by this one.
   */
  get replacee() {
    return this._replacee;
  }
  /**
   * Session description handler.
   * @remarks
   * If `this` is an instance of `Invitation`,
   * `sessionDescriptionHandler` will be defined when the session state changes to "established".
   * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,
   * `sessionDescriptionHandler` will be defined when the session state changes to "establishing".
   * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,
   * `sessionDescriptionHandler` will be defined when the session state changes to "established".
   * Otherwise `undefined`.
   */
  get sessionDescriptionHandler() {
    return this._sessionDescriptionHandler;
  }
  /**
   * Session description handler factory.
   */
  get sessionDescriptionHandlerFactory() {
    return this.userAgent.configuration.sessionDescriptionHandlerFactory;
  }
  /**
   * SDH modifiers for the initial INVITE transaction.
   * @remarks
   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().
   */
  get sessionDescriptionHandlerModifiers() {
    return this._sessionDescriptionHandlerModifiers || [];
  }
  set sessionDescriptionHandlerModifiers(modifiers) {
    this._sessionDescriptionHandlerModifiers = modifiers.slice();
  }
  /**
   * SDH options for the initial INVITE transaction.
   * @remarks
   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().
   */
  get sessionDescriptionHandlerOptions() {
    return this._sessionDescriptionHandlerOptions || {};
  }
  set sessionDescriptionHandlerOptions(options) {
    this._sessionDescriptionHandlerOptions = Object.assign({}, options);
  }
  /**
   * SDH modifiers for re-INVITE transactions.
   * @remarks
   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Session.invite().
   */
  get sessionDescriptionHandlerModifiersReInvite() {
    return this._sessionDescriptionHandlerModifiersReInvite || [];
  }
  set sessionDescriptionHandlerModifiersReInvite(modifiers) {
    this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();
  }
  /**
   * SDH options for re-INVITE transactions.
   * @remarks
   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Session.invite().
   */
  get sessionDescriptionHandlerOptionsReInvite() {
    return this._sessionDescriptionHandlerOptionsReInvite || {};
  }
  set sessionDescriptionHandlerOptionsReInvite(options) {
    this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);
  }
  /**
   * Session state.
   */
  get state() {
    return this._state;
  }
  /**
   * Session state change emitter.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * The user agent.
   */
  get userAgent() {
    return this._userAgent;
  }
  /**
   * End the {@link Session}. Sends a BYE.
   * @param options - Options bucket. See {@link SessionByeOptions} for details.
   */
  bye(options = {}) {
    let message2 = "Session.bye() may only be called if established session.";
    switch (this.state) {
      case SessionState$2.Initial:
        if (typeof this.cancel === "function") {
          message2 += " However Inviter.invite() has not yet been called.";
          message2 += " Perhaps you should have called Inviter.cancel()?";
        } else if (typeof this.reject === "function") {
          message2 += " However Invitation.accept() has not yet been called.";
          message2 += " Perhaps you should have called Invitation.reject()?";
        }
        break;
      case SessionState$2.Establishing:
        if (typeof this.cancel === "function") {
          message2 += " However a dialog does not yet exist.";
          message2 += " Perhaps you should have called Inviter.cancel()?";
        } else if (typeof this.reject === "function") {
          message2 += " However Invitation.accept() has not yet been called (or not yet resolved).";
          message2 += " Perhaps you should have called Invitation.reject()?";
        }
        break;
      case SessionState$2.Established: {
        const requestDelegate = options.requestDelegate;
        const requestOptions = this.copyRequestOptions(options.requestOptions);
        return this._bye(requestDelegate, requestOptions);
      }
      case SessionState$2.Terminating:
        message2 += " However this session is already terminating.";
        if (typeof this.cancel === "function") {
          message2 += " Perhaps you have already called Inviter.cancel()?";
        } else if (typeof this.reject === "function") {
          message2 += " Perhaps you have already called Session.bye()?";
        }
        break;
      case SessionState$2.Terminated:
        message2 += " However this session is already terminated.";
        break;
      default:
        throw new Error("Unknown state");
    }
    this.logger.error(message2);
    return Promise.reject(new Error(`Invalid session state ${this.state}`));
  }
  /**
   * Share {@link Info} with peer. Sends an INFO.
   * @param options - Options bucket. See {@link SessionInfoOptions} for details.
   */
  info(options = {}) {
    if (this.state !== SessionState$2.Established) {
      const message2 = "Session.info() may only be called if established session.";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const requestDelegate = options.requestDelegate;
    const requestOptions = this.copyRequestOptions(options.requestOptions);
    return this._info(requestDelegate, requestOptions);
  }
  /**
   * Renegotiate the session. Sends a re-INVITE.
   * @param options - Options bucket. See {@link SessionInviteOptions} for details.
   */
  invite(options = {}) {
    this.logger.log("Session.invite");
    if (this.state !== SessionState$2.Established) {
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    if (this.pendingReinvite) {
      return Promise.reject(new RequestPendingError$1("Reinvite in progress. Please wait until complete, then try again."));
    }
    this.pendingReinvite = true;
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;
    }
    const delegate = {
      onAccept: (response) => {
        const body = getBody$1(response.message);
        if (!body) {
          this.logger.error("Received 2xx response to re-INVITE without a session description");
          this.ackAndBye(response, 400, "Missing session description");
          this.stateTransition(SessionState$2.Terminated);
          this.pendingReinvite = false;
          return;
        }
        if (options.withoutSdp) {
          const answerOptions = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
          };
          this.setOfferAndGetAnswer(body, answerOptions).then((answerBody) => {
            response.ack({ body: answerBody });
          }).catch((error) => {
            this.logger.error("Failed to handle offer in 2xx response to re-INVITE");
            this.logger.error(error.message);
            if (this.state === SessionState$2.Terminated) {
              response.ack();
            } else {
              this.ackAndBye(response, 488, "Bad Media Description");
              this.stateTransition(SessionState$2.Terminated);
            }
          }).then(() => {
            this.pendingReinvite = false;
            if (options.requestDelegate && options.requestDelegate.onAccept) {
              options.requestDelegate.onAccept(response);
            }
          });
        } else {
          const answerOptions = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
          };
          this.setAnswer(body, answerOptions).then(() => {
            response.ack();
          }).catch((error) => {
            this.logger.error("Failed to handle answer in 2xx response to re-INVITE");
            this.logger.error(error.message);
            if (this.state !== SessionState$2.Terminated) {
              this.ackAndBye(response, 488, "Bad Media Description");
              this.stateTransition(SessionState$2.Terminated);
            } else {
              response.ack();
            }
          }).then(() => {
            this.pendingReinvite = false;
            if (options.requestDelegate && options.requestDelegate.onAccept) {
              options.requestDelegate.onAccept(response);
            }
          });
        }
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onProgress: (response) => {
        return;
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onRedirect: (response) => {
        return;
      },
      onReject: (response) => {
        this.logger.warn("Received a non-2xx response to re-INVITE");
        this.pendingReinvite = false;
        if (options.withoutSdp) {
          if (options.requestDelegate && options.requestDelegate.onReject) {
            options.requestDelegate.onReject(response);
          }
        } else {
          this.rollbackOffer().catch((error) => {
            this.logger.error("Failed to rollback offer on non-2xx response to re-INVITE");
            this.logger.error(error.message);
            if (this.state !== SessionState$2.Terminated) {
              if (!this.dialog) {
                throw new Error("Dialog undefined.");
              }
              const extraHeaders = [];
              extraHeaders.push("Reason: " + this.getReasonHeaderValue(500, "Internal Server Error"));
              this.dialog.bye(void 0, { extraHeaders });
              this.stateTransition(SessionState$2.Terminated);
            }
          }).then(() => {
            if (options.requestDelegate && options.requestDelegate.onReject) {
              options.requestDelegate.onReject(response);
            }
          });
        }
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onTrying: (response) => {
        return;
      }
    };
    const requestOptions = options.requestOptions || {};
    requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();
    requestOptions.extraHeaders.push("Allow: " + AllowedMethods$1.toString());
    requestOptions.extraHeaders.push("Contact: " + this._contact);
    if (options.withoutSdp) {
      if (!this.dialog) {
        this.pendingReinvite = false;
        throw new Error("Dialog undefined.");
      }
      return Promise.resolve(this.dialog.invite(delegate, requestOptions));
    }
    const offerOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
    };
    return this.getOffer(offerOptions).then((offerBody) => {
      if (!this.dialog) {
        this.pendingReinvite = false;
        throw new Error("Dialog undefined.");
      }
      requestOptions.body = offerBody;
      return this.dialog.invite(delegate, requestOptions);
    }).catch((error) => {
      this.logger.error(error.message);
      this.logger.error("Failed to send re-INVITE");
      this.pendingReinvite = false;
      throw error;
    });
  }
  /**
   * Deliver a {@link Message}. Sends a MESSAGE.
   * @param options - Options bucket. See {@link SessionMessageOptions} for details.
   */
  message(options = {}) {
    if (this.state !== SessionState$2.Established) {
      const message2 = "Session.message() may only be called if established session.";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const requestDelegate = options.requestDelegate;
    const requestOptions = this.copyRequestOptions(options.requestOptions);
    return this._message(requestDelegate, requestOptions);
  }
  /**
   * Proffer a {@link Referral}. Send a REFER.
   * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.
   * @param options - Options bucket. See {@link SessionReferOptions} for details.
   */
  refer(referTo, options = {}) {
    if (this.state !== SessionState$2.Established) {
      const message2 = "Session.refer() may only be called if established session.";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    if (referTo instanceof Session && !referTo.dialog) {
      const message2 = "Session.refer() may only be called with session which is established. You are perhaps attempting to attended transfer to a target for which there is not dialog yet established. Perhaps you are attempting a 'semi-attended' tansfer? Regardless, this is not supported. The recommended approached is to check to see if the target Session is in the Established state before calling refer(); if the state is not Established you may proceed by falling back using a URI as the target (blind transfer).";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const requestDelegate = options.requestDelegate;
    const requestOptions = this.copyRequestOptions(options.requestOptions);
    requestOptions.extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) : this.referExtraHeaders(this.referToString(referTo));
    return this._refer(options.onNotify, requestDelegate, requestOptions);
  }
  /**
   * Send BYE.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _bye(delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    const dialog = this.dialog;
    switch (dialog.sessionState) {
      case SessionState$3.Initial:
        throw new Error(`Invalid dialog state ${dialog.sessionState}`);
      case SessionState$3.Early:
        throw new Error(`Invalid dialog state ${dialog.sessionState}`);
      case SessionState$3.AckWait: {
        this.stateTransition(SessionState$2.Terminating);
        return new Promise((resolve) => {
          dialog.delegate = {
            // When ACK shows up, say BYE.
            onAck: () => {
              const request = dialog.bye(delegate, options);
              this.stateTransition(SessionState$2.Terminated);
              resolve(request);
              return Promise.resolve();
            },
            // Or the server transaction times out before the ACK arrives.
            onAckTimeout: () => {
              const request = dialog.bye(delegate, options);
              this.stateTransition(SessionState$2.Terminated);
              resolve(request);
            }
          };
        });
      }
      case SessionState$3.Confirmed: {
        const request = dialog.bye(delegate, options);
        this.stateTransition(SessionState$2.Terminated);
        return Promise.resolve(request);
      }
      case SessionState$3.Terminated:
        throw new Error(`Invalid dialog state ${dialog.sessionState}`);
      default:
        throw new Error("Unrecognized state.");
    }
  }
  /**
   * Send INFO.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _info(delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    return Promise.resolve(this.dialog.info(delegate, options));
  }
  /**
   * Send MESSAGE.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _message(delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    return Promise.resolve(this.dialog.message(delegate, options));
  }
  /**
   * Send REFER.
   * @param onNotify - Notification callback.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _refer(onNotify, delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    this.onNotify = onNotify;
    return Promise.resolve(this.dialog.refer(delegate, options));
  }
  /**
   * Send ACK and then BYE. There are unrecoverable errors which can occur
   * while handling dialog forming and in-dialog INVITE responses and when
   * they occur we ACK the response and send a BYE.
   * Note that the BYE is sent in the dialog associated with the response
   * which is not necessarily `this.dialog`. And, accordingly, the
   * session state is not transitioned to terminated and session is not closed.
   * @param inviteResponse - The response causing the error.
   * @param statusCode - Status code for he reason phrase.
   * @param reasonPhrase - Reason phrase for the BYE.
   * @internal
   */
  ackAndBye(response, statusCode, reasonPhrase) {
    response.ack();
    const extraHeaders = [];
    if (statusCode) {
      extraHeaders.push("Reason: " + this.getReasonHeaderValue(statusCode, reasonPhrase));
    }
    response.session.bye(void 0, { extraHeaders });
  }
  /**
   * Handle in dialog ACK request.
   * @internal
   */
  onAckRequest(request) {
    this.logger.log("Session.onAckRequest");
    if (this.state !== SessionState$2.Established && this.state !== SessionState$2.Terminating) {
      this.logger.error(`ACK received while in state ${this.state}, dropping request`);
      return Promise.resolve();
    }
    const dialog = this.dialog;
    if (!dialog) {
      throw new Error("Dialog undefined.");
    }
    const answerOptions = {
      sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers
    };
    if (this.delegate && this.delegate.onAck) {
      const ack = new Ack$1(request);
      this.delegate.onAck(ack);
    }
    this.pendingReinviteAck = false;
    switch (dialog.signalingState) {
      case SignalingState$1.Initial: {
        this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);
        const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
        dialog.bye(void 0, { extraHeaders });
        this.stateTransition(SessionState$2.Terminated);
        return Promise.resolve();
      }
      case SignalingState$1.Stable: {
        const body = getBody$1(request.message);
        if (!body) {
          return Promise.resolve();
        }
        if (body.contentDisposition === "render") {
          this._renderbody = body.content;
          this._rendertype = body.contentType;
          return Promise.resolve();
        }
        if (body.contentDisposition !== "session") {
          return Promise.resolve();
        }
        return this.setAnswer(body, answerOptions).catch((error) => {
          this.logger.error(error.message);
          const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
          dialog.bye(void 0, { extraHeaders });
          this.stateTransition(SessionState$2.Terminated);
        });
      }
      case SignalingState$1.HaveLocalOffer: {
        this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);
        const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
        dialog.bye(void 0, { extraHeaders });
        this.stateTransition(SessionState$2.Terminated);
        return Promise.resolve();
      }
      case SignalingState$1.HaveRemoteOffer: {
        this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);
        const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
        dialog.bye(void 0, { extraHeaders });
        this.stateTransition(SessionState$2.Terminated);
        return Promise.resolve();
      }
      case SignalingState$1.Closed:
        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);
      default:
        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);
    }
  }
  /**
   * Handle in dialog BYE request.
   * @internal
   */
  onByeRequest(request) {
    this.logger.log("Session.onByeRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`BYE received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onBye) {
      const bye = new Bye$1(request);
      this.delegate.onBye(bye);
    } else {
      request.accept();
    }
    this.stateTransition(SessionState$2.Terminated);
  }
  /**
   * Handle in dialog INFO request.
   * @internal
   */
  onInfoRequest(request) {
    this.logger.log("Session.onInfoRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`INFO received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onInfo) {
      const info = new Info$1(request);
      this.delegate.onInfo(info);
    } else {
      request.accept();
    }
  }
  /**
   * Handle in dialog INVITE request.
   * @internal
   */
  onInviteRequest(request) {
    this.logger.log("Session.onInviteRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`INVITE received while in state ${this.state}, dropping request`);
      return;
    }
    this.pendingReinviteAck = true;
    const extraHeaders = ["Contact: " + this._contact];
    if (request.message.hasHeader("P-Asserted-Identity")) {
      const header = request.message.getHeader("P-Asserted-Identity");
      if (!header) {
        throw new Error("Header undefined.");
      }
      this._assertedIdentity = Grammar$1.nameAddrHeaderParse(header);
    }
    const options = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
    };
    this.generateResponseOfferAnswerInDialog(options).then((body) => {
      const outgoingResponse = request.accept({ statusCode: 200, extraHeaders, body });
      if (this.delegate && this.delegate.onInvite) {
        this.delegate.onInvite(request.message, outgoingResponse.message, 200);
      }
    }).catch((error) => {
      this.logger.error(error.message);
      this.logger.error("Failed to handle to re-INVITE request");
      if (!this.dialog) {
        throw new Error("Dialog undefined.");
      }
      this.logger.error(this.dialog.signalingState);
      if (this.dialog.signalingState === SignalingState$1.Stable) {
        const outgoingResponse = request.reject({ statusCode: 488 });
        if (this.delegate && this.delegate.onInvite) {
          this.delegate.onInvite(request.message, outgoingResponse.message, 488);
        }
        return;
      }
      this.rollbackOffer().then(() => {
        const outgoingResponse = request.reject({ statusCode: 488 });
        if (this.delegate && this.delegate.onInvite) {
          this.delegate.onInvite(request.message, outgoingResponse.message, 488);
        }
      }).catch((errorRollback) => {
        this.logger.error(errorRollback.message);
        this.logger.error("Failed to rollback offer on re-INVITE request");
        const outgoingResponse = request.reject({ statusCode: 488 });
        if (this.state !== SessionState$2.Terminated) {
          if (!this.dialog) {
            throw new Error("Dialog undefined.");
          }
          const extraHeadersBye = [];
          extraHeadersBye.push("Reason: " + this.getReasonHeaderValue(500, "Internal Server Error"));
          this.dialog.bye(void 0, { extraHeaders: extraHeadersBye });
          this.stateTransition(SessionState$2.Terminated);
        }
        if (this.delegate && this.delegate.onInvite) {
          this.delegate.onInvite(request.message, outgoingResponse.message, 488);
        }
      });
    });
  }
  /**
   * Handle in dialog MESSAGE request.
   * @internal
   */
  onMessageRequest(request) {
    this.logger.log("Session.onMessageRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onMessage) {
      const message2 = new Message$1(request);
      this.delegate.onMessage(message2);
    } else {
      request.accept();
    }
  }
  /**
   * Handle in dialog NOTIFY request.
   * @internal
   */
  onNotifyRequest(request) {
    this.logger.log("Session.onNotifyRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.onNotify) {
      const notification = new Notification$1(request);
      this.onNotify(notification);
      return;
    }
    if (this.delegate && this.delegate.onNotify) {
      const notification = new Notification$1(request);
      this.delegate.onNotify(notification);
    } else {
      request.accept();
    }
  }
  /**
   * Handle in dialog PRACK request.
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onPrackRequest(request) {
    this.logger.log("Session.onPrackRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`PRACK received while in state ${this.state}, dropping request`);
      return;
    }
    throw new Error("Unimplemented.");
  }
  /**
   * Handle in dialog REFER request.
   * @internal
   */
  onReferRequest(request) {
    this.logger.log("Session.onReferRequest");
    if (this.state !== SessionState$2.Established) {
      this.logger.error(`REFER received while in state ${this.state}, dropping request`);
      return;
    }
    if (!request.message.hasHeader("refer-to")) {
      this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting.");
      request.reject();
      return;
    }
    const referral = new Referral$1(request, this);
    if (this.delegate && this.delegate.onRefer) {
      this.delegate.onRefer(referral);
    } else {
      this.logger.log("No delegate available to handle REFER, automatically accepting and following.");
      referral.accept().then(() => referral.makeInviter(this._referralInviterOptions).invite()).catch((error) => {
        this.logger.error(error.message);
      });
    }
  }
  /**
   * Generate an offer or answer for a response to an INVITE request.
   * If a remote offer was provided in the request, set the remote
   * description and get a local answer. If a remote offer was not
   * provided, generates a local offer.
   * @internal
   */
  generateResponseOfferAnswer(request, options) {
    if (this.dialog) {
      return this.generateResponseOfferAnswerInDialog(options);
    }
    const body = getBody$1(request.message);
    if (!body || body.contentDisposition !== "session") {
      return this.getOffer(options);
    } else {
      return this.setOfferAndGetAnswer(body, options);
    }
  }
  /**
   * Generate an offer or answer for a response to an INVITE request
   * when a dialog (early or otherwise) has already been established.
   * This method may NOT be called if a dialog has yet to be established.
   * @internal
   */
  generateResponseOfferAnswerInDialog(options) {
    if (!this.dialog) {
      throw new Error("Dialog undefined.");
    }
    switch (this.dialog.signalingState) {
      case SignalingState$1.Initial:
        return this.getOffer(options);
      case SignalingState$1.HaveLocalOffer:
        return Promise.resolve(void 0);
      case SignalingState$1.HaveRemoteOffer:
        if (!this.dialog.offer) {
          throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);
        }
        return this.setOfferAndGetAnswer(this.dialog.offer, options);
      case SignalingState$1.Stable:
        if (this.state !== SessionState$2.Established) {
          return Promise.resolve(void 0);
        }
        return this.getOffer(options);
      case SignalingState$1.Closed:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      default:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
    }
  }
  /**
   * Get local offer.
   * @internal
   */
  getOffer(options) {
    const sdh = this.setupSessionDescriptionHandler();
    const sdhOptions = options.sessionDescriptionHandlerOptions;
    const sdhModifiers = options.sessionDescriptionHandlerModifiers;
    try {
      return sdh.getDescription(sdhOptions, sdhModifiers).then((bodyAndContentType) => fromBodyLegacy$1(bodyAndContentType)).catch((error) => {
        this.logger.error("Session.getOffer: SDH getDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.getOffer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.getOffer: SDH getDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * Rollback local/remote offer.
   * @internal
   */
  rollbackOffer() {
    const sdh = this.setupSessionDescriptionHandler();
    if (sdh.rollbackDescription === void 0) {
      return Promise.resolve();
    }
    try {
      return sdh.rollbackDescription().catch((error) => {
        this.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.rollbackOffer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * Set remote answer.
   * @internal
   */
  setAnswer(answer, options) {
    const sdh = this.setupSessionDescriptionHandler();
    const sdhOptions = options.sessionDescriptionHandlerOptions;
    const sdhModifiers = options.sessionDescriptionHandlerModifiers;
    try {
      if (!sdh.hasDescription(answer.contentType)) {
        return Promise.reject(new ContentTypeUnsupportedError$1());
      }
    } catch (error) {
      this.logger.error("Session.setAnswer: SDH hasDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
    try {
      return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch((error) => {
        this.logger.error("Session.setAnswer: SDH setDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.setAnswer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.setAnswer: SDH setDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * Set remote offer and get local answer.
   * @internal
   */
  setOfferAndGetAnswer(offer, options) {
    const sdh = this.setupSessionDescriptionHandler();
    const sdhOptions = options.sessionDescriptionHandlerOptions;
    const sdhModifiers = options.sessionDescriptionHandlerModifiers;
    try {
      if (!sdh.hasDescription(offer.contentType)) {
        return Promise.reject(new ContentTypeUnsupportedError$1());
      }
    } catch (error) {
      this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
    try {
      return sdh.setDescription(offer.content, sdhOptions, sdhModifiers).then(() => sdh.getDescription(sdhOptions, sdhModifiers)).then((bodyAndContentType) => fromBodyLegacy$1(bodyAndContentType)).catch((error) => {
        this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.setOfferAndGetAnswer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * SDH for confirmed dialog.
   * @internal
   */
  setSessionDescriptionHandler(sdh) {
    if (this._sessionDescriptionHandler) {
      throw new Error("Session description handler defined.");
    }
    this._sessionDescriptionHandler = sdh;
  }
  /**
   * SDH for confirmed dialog.
   * @internal
   */
  setupSessionDescriptionHandler() {
    var _a;
    if (this._sessionDescriptionHandler) {
      return this._sessionDescriptionHandler;
    }
    this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);
    if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {
      this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);
    }
    return this._sessionDescriptionHandler;
  }
  /**
   * Transition session state.
   * @internal
   */
  stateTransition(newState) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case SessionState$2.Initial:
        if (newState !== SessionState$2.Establishing && newState !== SessionState$2.Established && newState !== SessionState$2.Terminating && newState !== SessionState$2.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState$2.Establishing:
        if (newState !== SessionState$2.Established && newState !== SessionState$2.Terminating && newState !== SessionState$2.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState$2.Established:
        if (newState !== SessionState$2.Terminating && newState !== SessionState$2.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState$2.Terminating:
        if (newState !== SessionState$2.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState$2.Terminated:
        invalidTransition();
        break;
      default:
        throw new Error("Unrecognized state.");
    }
    this._state = newState;
    this.logger.log(`Session ${this.id} transitioned to state ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === SessionState$2.Terminated) {
      this.dispose();
    }
  }
  copyRequestOptions(requestOptions = {}) {
    const extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : void 0;
    const body = requestOptions.body ? {
      contentDisposition: requestOptions.body.contentDisposition || "render",
      contentType: requestOptions.body.contentType || "text/plain",
      content: requestOptions.body.content || ""
    } : void 0;
    return {
      extraHeaders,
      body
    };
  }
  getReasonHeaderValue(code, reason) {
    const cause = code;
    let text = getReasonPhrase$1(code);
    if (!text && reason) {
      text = reason;
    }
    return "SIP;cause=" + cause + ';text="' + text + '"';
  }
  referExtraHeaders(referTo) {
    const extraHeaders = [];
    extraHeaders.push("Referred-By: <" + this.userAgent.configuration.uri + ">");
    extraHeaders.push("Contact: " + this._contact);
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());
    extraHeaders.push("Refer-To: " + referTo);
    return extraHeaders;
  }
  referToString(target) {
    let referTo;
    if (target instanceof URI$1) {
      referTo = target.toString();
    } else {
      if (!target.dialog) {
        throw new Error("Dialog undefined.");
      }
      const displayName = target.remoteIdentity.friendlyName;
      const remoteTarget = target.dialog.remoteTarget.toString();
      const callId = target.dialog.callId;
      const remoteTag = target.dialog.remoteTag;
      const localTag = target.dialog.localTag;
      const replaces = encodeURIComponent(`${callId};to-tag=${remoteTag};from-tag=${localTag}`);
      referTo = `"${displayName}" <${remoteTarget}?Replaces=${replaces}>`;
    }
    return referTo;
  }
};
var SIPExtension$1;
(function(SIPExtension2) {
  SIPExtension2["Required"] = "Required";
  SIPExtension2["Supported"] = "Supported";
  SIPExtension2["Unsupported"] = "Unsupported";
})(SIPExtension$1 = SIPExtension$1 || (SIPExtension$1 = {}));
const UserAgentRegisteredOptionTags$1 = {
  "100rel": true,
  "199": true,
  answermode: true,
  "early-session": true,
  eventlist: true,
  explicitsub: true,
  "from-change": true,
  "geolocation-http": true,
  "geolocation-sip": true,
  gin: true,
  gruu: true,
  histinfo: true,
  ice: true,
  join: true,
  "multiple-refer": true,
  norefersub: true,
  nosub: true,
  outbound: true,
  path: true,
  policy: true,
  precondition: true,
  pref: true,
  privacy: true,
  "recipient-list-invite": true,
  "recipient-list-message": true,
  "recipient-list-subscribe": true,
  replaces: true,
  "resource-priority": true,
  "sdp-anat": true,
  "sec-agree": true,
  tdialog: true,
  timer: true,
  uui: true
  // RFC 7433
};
let Invitation$1 = class Invitation extends Session$1 {
  /** @internal */
  constructor(userAgent, incomingInviteRequest) {
    super(userAgent);
    this.incomingInviteRequest = incomingInviteRequest;
    this.disposed = false;
    this.expiresTimer = void 0;
    this.isCanceled = false;
    this.rel100 = "none";
    this.rseq = Math.floor(Math.random() * 1e4);
    this.userNoAnswerTimer = void 0;
    this.waitingForPrack = false;
    this.logger = userAgent.getLogger("sip.Invitation");
    const incomingRequestMessage = this.incomingInviteRequest.message;
    const requireHeader = incomingRequestMessage.getHeader("require");
    if (requireHeader && requireHeader.toLowerCase().includes("100rel")) {
      this.rel100 = "required";
    }
    const supportedHeader = incomingRequestMessage.getHeader("supported");
    if (supportedHeader && supportedHeader.toLowerCase().includes("100rel")) {
      this.rel100 = "supported";
    }
    incomingRequestMessage.toTag = incomingInviteRequest.toTag;
    if (typeof incomingRequestMessage.toTag !== "string") {
      throw new TypeError("toTag should have been a string.");
    }
    this.userNoAnswerTimer = setTimeout(() => {
      incomingInviteRequest.reject({ statusCode: 480 });
      this.stateTransition(SessionState$2.Terminated);
    }, this.userAgent.configuration.noAnswerTimeout ? this.userAgent.configuration.noAnswerTimeout * 1e3 : 6e4);
    if (incomingRequestMessage.hasHeader("expires")) {
      const expires = Number(incomingRequestMessage.getHeader("expires") || 0) * 1e3;
      this.expiresTimer = setTimeout(() => {
        if (this.state === SessionState$2.Initial) {
          incomingInviteRequest.reject({ statusCode: 487 });
          this.stateTransition(SessionState$2.Terminated);
        }
      }, expires);
    }
    const assertedIdentity = this.request.getHeader("P-Asserted-Identity");
    if (assertedIdentity) {
      this._assertedIdentity = Grammar$1.nameAddrHeaderParse(assertedIdentity);
    }
    this._contact = this.userAgent.contact.toString();
    const contentDisposition = incomingRequestMessage.parseHeader("Content-Disposition");
    if (contentDisposition && contentDisposition.type === "render") {
      this._renderbody = incomingRequestMessage.body;
      this._rendertype = incomingRequestMessage.getHeader("Content-Type");
    }
    this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag;
    this.userAgent._sessions[this._id] = this;
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    if (this.expiresTimer) {
      clearTimeout(this.expiresTimer);
      this.expiresTimer = void 0;
    }
    if (this.userNoAnswerTimer) {
      clearTimeout(this.userNoAnswerTimer);
      this.userNoAnswerTimer = void 0;
    }
    this.prackNeverArrived();
    switch (this.state) {
      case SessionState$2.Initial:
        return this.reject().then(() => super.dispose());
      case SessionState$2.Establishing:
        return this.reject().then(() => super.dispose());
      case SessionState$2.Established:
        return super.dispose();
      case SessionState$2.Terminating:
        return super.dispose();
      case SessionState$2.Terminated:
        return super.dispose();
      default:
        throw new Error("Unknown state.");
    }
  }
  /**
   * If true, a first provisional response after the 100 Trying
   * will be sent automatically. This is false it the UAC required
   * reliable provisional responses (100rel in Require header) or
   * the user agent configuration has specified to not send an
   * initial response, otherwise it is true. The provisional is sent by
   * calling `progress()` without any options.
   */
  get autoSendAnInitialProvisionalResponse() {
    return this.rel100 !== "required" && this.userAgent.configuration.sendInitialProvisionalResponse;
  }
  /**
   * Initial incoming INVITE request message body.
   */
  get body() {
    return this.incomingInviteRequest.message.body;
  }
  /**
   * The identity of the local user.
   */
  get localIdentity() {
    return this.request.to;
  }
  /**
   * The identity of the remote user.
   */
  get remoteIdentity() {
    return this.request.from;
  }
  /**
   * Initial incoming INVITE request message.
   */
  get request() {
    return this.incomingInviteRequest.message;
  }
  /**
   * Accept the invitation.
   *
   * @remarks
   * Accept the incoming INVITE request to start a Session.
   * Replies to the INVITE request with a 200 Ok response.
   * Resolves once the response sent, otherwise rejects.
   *
   * This method may reject for a variety of reasons including
   * the receipt of a CANCEL request before `accept` is able
   * to construct a response.
   * @param options - Options bucket.
   */
  accept(options = {}) {
    this.logger.log("Invitation.accept");
    if (this.state !== SessionState$2.Initial) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    this.stateTransition(SessionState$2.Establishing);
    return this.sendAccept(options).then(({ message: message2, session: session2 }) => {
      session2.delegate = {
        onAck: (ackRequest) => this.onAckRequest(ackRequest),
        onAckTimeout: () => this.onAckTimeout(),
        onBye: (byeRequest) => this.onByeRequest(byeRequest),
        onInfo: (infoRequest) => this.onInfoRequest(infoRequest),
        onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),
        onMessage: (messageRequest) => this.onMessageRequest(messageRequest),
        onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),
        onPrack: (prackRequest) => this.onPrackRequest(prackRequest),
        onRefer: (referRequest) => this.onReferRequest(referRequest)
      };
      this._dialog = session2;
      this.stateTransition(SessionState$2.Established);
      if (this._replacee) {
        this._replacee._bye();
      }
    }).catch((error) => this.handleResponseError(error));
  }
  /**
   * Indicate progress processing the invitation.
   *
   * @remarks
   * Report progress to the the caller.
   * Replies to the INVITE request with a 1xx provisional response.
   * Resolves once the response sent, otherwise rejects.
   * @param options - Options bucket.
   */
  progress(options = {}) {
    this.logger.log("Invitation.progress");
    if (this.state !== SessionState$2.Initial) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    const statusCode = options.statusCode || 180;
    if (statusCode < 100 || statusCode > 199) {
      throw new TypeError("Invalid statusCode: " + statusCode);
    }
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    if (this.waitingForPrack) {
      this.logger.warn("Unexpected call for progress while waiting for prack, ignoring");
      return Promise.resolve();
    }
    if (options.statusCode === 100) {
      return this.sendProgressTrying().then(() => {
        return;
      }).catch((error) => this.handleResponseError(error));
    }
    if (!(this.rel100 === "required") && !(this.rel100 === "supported" && options.rel100) && !(this.rel100 === "supported" && this.userAgent.configuration.sipExtension100rel === SIPExtension$1.Required)) {
      return this.sendProgress(options).then(() => {
        return;
      }).catch((error) => this.handleResponseError(error));
    }
    return this.sendProgressReliableWaitForPrack(options).then(() => {
      return;
    }).catch((error) => this.handleResponseError(error));
  }
  /**
   * Reject the invitation.
   *
   * @remarks
   * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.
   * Resolves once the response sent, otherwise rejects.
   *
   * The expectation is that this method is used to reject an INVITE request.
   * That is indeed the case - a call to `progress` followed by `reject` is
   * a typical way to "decline" an incoming INVITE request. However it may
   * also be called after calling `accept` (but only before it completes)
   * which will reject the call and cause `accept` to reject.
   * @param options - Options bucket.
   */
  reject(options = {}) {
    this.logger.log("Invitation.reject");
    if (this.state !== SessionState$2.Initial && this.state !== SessionState$2.Establishing) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    const statusCode = options.statusCode || 480;
    const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase$1(statusCode);
    const extraHeaders = options.extraHeaders || [];
    if (statusCode < 300 || statusCode > 699) {
      throw new TypeError("Invalid statusCode: " + statusCode);
    }
    const body = options.body ? fromBodyLegacy$1(options.body) : void 0;
    statusCode < 400 ? this.incomingInviteRequest.redirect([], { statusCode, reasonPhrase, extraHeaders, body }) : this.incomingInviteRequest.reject({ statusCode, reasonPhrase, extraHeaders, body });
    this.stateTransition(SessionState$2.Terminated);
    return Promise.resolve();
  }
  /**
   * Handle CANCEL request.
   *
   * @param message - CANCEL message.
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _onCancel(message2) {
    this.logger.log("Invitation._onCancel");
    if (this.state !== SessionState$2.Initial && this.state !== SessionState$2.Establishing) {
      this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onCancel) {
      const cancel = new Cancel(message2);
      this.delegate.onCancel(cancel);
    }
    this.isCanceled = true;
    this.incomingInviteRequest.reject({ statusCode: 487 });
    this.stateTransition(SessionState$2.Terminated);
  }
  /**
   * Helper function to handle offer/answer in a PRACK.
   */
  handlePrackOfferAnswer(request) {
    if (!this.dialog) {
      throw new Error("Dialog undefined.");
    }
    const body = getBody$1(request.message);
    if (!body || body.contentDisposition !== "session") {
      return Promise.resolve(void 0);
    }
    const options = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    switch (this.dialog.signalingState) {
      case SignalingState$1.Initial:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      case SignalingState$1.Stable:
        return this.setAnswer(body, options).then(() => void 0);
      case SignalingState$1.HaveLocalOffer:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      case SignalingState$1.HaveRemoteOffer:
        return this.setOfferAndGetAnswer(body, options);
      case SignalingState$1.Closed:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      default:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
    }
  }
  /**
   * A handler for errors which occur while attempting to send 1xx and 2xx responses.
   * In all cases, an attempt is made to reject the request if it is still outstanding.
   * And while there are a variety of things which can go wrong and we log something here
   * for all errors, there are a handful of common exceptions we pay some extra attention to.
   * @param error - The error which occurred.
   */
  handleResponseError(error) {
    let statusCode = 480;
    if (error instanceof Error) {
      this.logger.error(error.message);
    } else {
      this.logger.error(error);
    }
    if (error instanceof ContentTypeUnsupportedError$1) {
      this.logger.error("A session description handler occurred while sending response (content type unsupported");
      statusCode = 415;
    } else if (error instanceof SessionDescriptionHandlerError$1) {
      this.logger.error("A session description handler occurred while sending response");
    } else if (error instanceof SessionTerminatedError$1) {
      this.logger.error("Session ended before response could be formulated and sent (while waiting for PRACK)");
    } else if (error instanceof TransactionStateError$1) {
      this.logger.error("Session changed state before response could be formulated and sent");
    }
    if (this.state === SessionState$2.Initial || this.state === SessionState$2.Establishing) {
      try {
        this.incomingInviteRequest.reject({ statusCode });
        this.stateTransition(SessionState$2.Terminated);
      } catch (e2) {
        this.logger.error("An error occurred attempting to reject the request while handling another error");
        throw e2;
      }
    }
    if (this.isCanceled) {
      this.logger.warn("An error occurred while attempting to formulate and send a response to an incoming INVITE. However a CANCEL was received and processed while doing so which can (and often does) result in errors occurring as the session terminates in the meantime. Said error is being ignored.");
      return;
    }
    throw error;
  }
  /**
   * Callback for when ACK for a 2xx response is never received.
   * @param session - Session the ACK never arrived for.
   */
  onAckTimeout() {
    this.logger.log("Invitation.onAckTimeout");
    if (!this.dialog) {
      throw new Error("Dialog undefined.");
    }
    this.logger.log("No ACK received for an extended period of time, terminating session");
    this.dialog.bye();
    this.stateTransition(SessionState$2.Terminated);
  }
  /**
   * A version of `accept` which resolves a session when the 200 Ok response is sent.
   * @param options - Options bucket.
   */
  sendAccept(options = {}) {
    const responseOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    const extraHeaders = options.extraHeaders || [];
    if (this.waitingForPrack) {
      return this.waitForArrivalOfPrack().then(() => clearTimeout(this.userNoAnswerTimer)).then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)).then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body, extraHeaders }));
    }
    clearTimeout(this.userNoAnswerTimer);
    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body, extraHeaders }));
  }
  /**
   * A version of `progress` which resolves when the provisional response is sent.
   * @param options - Options bucket.
   */
  sendProgress(options = {}) {
    const statusCode = options.statusCode || 180;
    const reasonPhrase = options.reasonPhrase;
    const extraHeaders = (options.extraHeaders || []).slice();
    const body = options.body ? fromBodyLegacy$1(options.body) : void 0;
    if (statusCode === 183 && !body) {
      return this.sendProgressWithSDP(options);
    }
    try {
      const progressResponse = this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });
      this._dialog = progressResponse.session;
      return Promise.resolve(progressResponse);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  /**
   * A version of `progress` which resolves when the provisional response with sdp is sent.
   * @param options - Options bucket.
   */
  sendProgressWithSDP(options = {}) {
    const responseOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    const statusCode = options.statusCode || 183;
    const reasonPhrase = options.reasonPhrase;
    const extraHeaders = (options.extraHeaders || []).slice();
    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((body) => this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body })).then((progressResponse) => {
      this._dialog = progressResponse.session;
      return progressResponse;
    });
  }
  /**
   * A version of `progress` which resolves when the reliable provisional response is sent.
   * @param options - Options bucket.
   */
  sendProgressReliable(options = {}) {
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.extraHeaders.push("Require: 100rel");
    options.extraHeaders.push("RSeq: " + Math.floor(Math.random() * 1e4));
    return this.sendProgressWithSDP(options);
  }
  /**
   * A version of `progress` which resolves when the reliable provisional response is acknowledged.
   * @param options - Options bucket.
   */
  sendProgressReliableWaitForPrack(options = {}) {
    const responseOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    const statusCode = options.statusCode || 183;
    const reasonPhrase = options.reasonPhrase;
    const extraHeaders = (options.extraHeaders || []).slice();
    extraHeaders.push("Require: 100rel");
    extraHeaders.push("RSeq: " + this.rseq++);
    let body;
    return new Promise((resolve, reject) => {
      this.waitingForPrack = true;
      this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((offerAnswer) => {
        body = offerAnswer;
        return this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });
      }).then((progressResponse) => {
        this._dialog = progressResponse.session;
        let prackRequest;
        let prackResponse;
        progressResponse.session.delegate = {
          onPrack: (request) => {
            prackRequest = request;
            clearTimeout(prackWaitTimeoutTimer);
            clearTimeout(rel1xxRetransmissionTimer);
            if (!this.waitingForPrack) {
              return;
            }
            this.waitingForPrack = false;
            this.handlePrackOfferAnswer(prackRequest).then((prackResponseBody) => {
              try {
                prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });
                this.prackArrived();
                resolve({ prackRequest, prackResponse, progressResponse });
              } catch (error) {
                reject(error);
              }
            }).catch((error) => reject(error));
          }
        };
        const prackWaitTimeout = () => {
          if (!this.waitingForPrack) {
            return;
          }
          this.waitingForPrack = false;
          this.logger.warn("No PRACK received, rejecting INVITE.");
          clearTimeout(rel1xxRetransmissionTimer);
          this.reject({ statusCode: 504 }).then(() => reject(new SessionTerminatedError$1())).catch((error) => reject(error));
        };
        const prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers$1.T1 * 64);
        const rel1xxRetransmission = () => {
          try {
            this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });
          } catch (error) {
            this.waitingForPrack = false;
            reject(error);
            return;
          }
          rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout2 *= 2);
        };
        let timeout2 = Timers$1.T1;
        let rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout2);
      }).catch((error) => {
        this.waitingForPrack = false;
        reject(error);
      });
    });
  }
  /**
   * A version of `progress` which resolves when a 100 Trying provisional response is sent.
   */
  sendProgressTrying() {
    try {
      const progressResponse = this.incomingInviteRequest.trying();
      return Promise.resolve(progressResponse);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  /**
   * When attempting to accept the INVITE, an invitation waits
   * for any outstanding PRACK to arrive before sending the 200 Ok.
   * It will be waiting on this Promise to resolve which lets it know
   * the PRACK has arrived and it may proceed to send the 200 Ok.
   */
  waitForArrivalOfPrack() {
    if (this.waitingForPrackPromise) {
      throw new Error("Already waiting for PRACK");
    }
    this.waitingForPrackPromise = new Promise((resolve, reject) => {
      this.waitingForPrackResolve = resolve;
      this.waitingForPrackReject = reject;
    });
    return this.waitingForPrackPromise;
  }
  /**
   * Here we are resolving the promise which in turn will cause
   * the accept to proceed (it may still fail for other reasons, but...).
   */
  prackArrived() {
    if (this.waitingForPrackResolve) {
      this.waitingForPrackResolve();
    }
    this.waitingForPrackPromise = void 0;
    this.waitingForPrackResolve = void 0;
    this.waitingForPrackReject = void 0;
  }
  /**
   * Here we are rejecting the promise which in turn will cause
   * the accept to fail and the session to transition to "terminated".
   */
  prackNeverArrived() {
    if (this.waitingForPrackReject) {
      this.waitingForPrackReject(new SessionTerminatedError$1());
    }
    this.waitingForPrackPromise = void 0;
    this.waitingForPrackResolve = void 0;
    this.waitingForPrackReject = void 0;
  }
};
let Inviter$1 = class Inviter extends Session$1 {
  /**
   * Constructs a new instance of the `Inviter` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param options - Options bucket. See {@link InviterOptions} for details.
   */
  constructor(userAgent, targetURI, options = {}) {
    super(userAgent, options);
    this.disposed = false;
    this.earlyMedia = false;
    this.earlyMediaSessionDescriptionHandlers = /* @__PURE__ */ new Map();
    this.isCanceled = false;
    this.inviteWithoutSdp = false;
    this.logger = userAgent.getLogger("sip.Inviter");
    this.earlyMedia = options.earlyMedia !== void 0 ? options.earlyMedia : this.earlyMedia;
    this.fromTag = newTag$1();
    this.inviteWithoutSdp = options.inviteWithoutSdp !== void 0 ? options.inviteWithoutSdp : this.inviteWithoutSdp;
    const inviterOptions = Object.assign({}, options);
    inviterOptions.params = Object.assign({}, options.params);
    const anonymous = options.anonymous || false;
    const contact2 = userAgent.contact.toString({
      anonymous,
      // Do not add ;ob in initial forming dialog requests if the
      // registration over the current connection got a GRUU URI.
      outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu
    });
    if (anonymous && userAgent.configuration.uri) {
      inviterOptions.params.fromDisplayName = "Anonymous";
      inviterOptions.params.fromUri = "sip:anonymous@anonymous.invalid";
    }
    let fromURI = userAgent.userAgentCore.configuration.aor;
    if (inviterOptions.params.fromUri) {
      fromURI = typeof inviterOptions.params.fromUri === "string" ? Grammar$1.URIParse(inviterOptions.params.fromUri) : inviterOptions.params.fromUri;
    }
    if (!fromURI) {
      throw new TypeError("Invalid from URI: " + inviterOptions.params.fromUri);
    }
    let toURI = targetURI;
    if (inviterOptions.params.toUri) {
      toURI = typeof inviterOptions.params.toUri === "string" ? Grammar$1.URIParse(inviterOptions.params.toUri) : inviterOptions.params.toUri;
    }
    if (!toURI) {
      throw new TypeError("Invalid to URI: " + inviterOptions.params.toUri);
    }
    const messageOptions = Object.assign({}, inviterOptions.params);
    messageOptions.fromTag = this.fromTag;
    const extraHeaders = (inviterOptions.extraHeaders || []).slice();
    if (anonymous && userAgent.configuration.uri) {
      extraHeaders.push("P-Preferred-Identity: " + userAgent.configuration.uri.toString());
      extraHeaders.push("Privacy: id");
    }
    extraHeaders.push("Contact: " + contact2);
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());
    if (userAgent.configuration.sipExtension100rel === SIPExtension$1.Required) {
      extraHeaders.push("Require: 100rel");
    }
    if (userAgent.configuration.sipExtensionReplaces === SIPExtension$1.Required) {
      extraHeaders.push("Require: replaces");
    }
    inviterOptions.extraHeaders = extraHeaders;
    const body = void 0;
    this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C$1.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body);
    this._contact = contact2;
    this._referralInviterOptions = inviterOptions;
    this._renderbody = options.renderbody;
    this._rendertype = options.rendertype;
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    if (options.sessionDescriptionHandlerModifiersReInvite) {
      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;
    }
    if (options.sessionDescriptionHandlerOptionsReInvite) {
      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;
    }
    this._id = this.outgoingRequestMessage.callId + this.fromTag;
    this.userAgent._sessions[this._id] = this;
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    this.disposeEarlyMedia();
    switch (this.state) {
      case SessionState$2.Initial:
        return this.cancel().then(() => super.dispose());
      case SessionState$2.Establishing:
        return this.cancel().then(() => super.dispose());
      case SessionState$2.Established:
        return super.dispose();
      case SessionState$2.Terminating:
        return super.dispose();
      case SessionState$2.Terminated:
        return super.dispose();
      default:
        throw new Error("Unknown state.");
    }
  }
  /**
   * Initial outgoing INVITE request message body.
   */
  get body() {
    return this.outgoingRequestMessage.body;
  }
  /**
   * The identity of the local user.
   */
  get localIdentity() {
    return this.outgoingRequestMessage.from;
  }
  /**
   * The identity of the remote user.
   */
  get remoteIdentity() {
    return this.outgoingRequestMessage.to;
  }
  /**
   * Initial outgoing INVITE request message.
   */
  get request() {
    return this.outgoingRequestMessage;
  }
  /**
   * Cancels the INVITE request.
   *
   * @remarks
   * Sends a CANCEL request.
   * Resolves once the response sent, otherwise rejects.
   *
   * After sending a CANCEL request the expectation is that a 487 final response
   * will be received for the INVITE. However a 200 final response to the INVITE
   * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before
   * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect
   * is that this method will terminate the session regardless of the race.
   * @param options - Options bucket.
   */
  cancel(options = {}) {
    this.logger.log("Inviter.cancel");
    if (this.state !== SessionState$2.Initial && this.state !== SessionState$2.Establishing) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    this.isCanceled = true;
    this.stateTransition(SessionState$2.Terminating);
    function getCancelReason(code, reason) {
      if (code && code < 200 || code > 699) {
        throw new TypeError("Invalid statusCode: " + code);
      } else if (code) {
        const cause = code;
        const text = getReasonPhrase$1(code) || reason;
        return "SIP;cause=" + cause + ';text="' + text + '"';
      }
    }
    if (this.outgoingInviteRequest) {
      let cancelReason;
      if (options.statusCode && options.reasonPhrase) {
        cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);
      }
      this.outgoingInviteRequest.cancel(cancelReason, options);
    } else {
      this.logger.warn("Canceled session before INVITE was sent");
      this.stateTransition(SessionState$2.Terminated);
    }
    return Promise.resolve();
  }
  /**
   * Sends the INVITE request.
   *
   * @remarks
   * TLDR...
   *  1) Only one offer/answer exchange permitted during initial INVITE.
   *  2) No "early media" if the initial offer is in an INVITE (default behavior).
   *  3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
   *
   * 1) Only one offer/answer exchange permitted during initial INVITE.
   *
   * Our implementation replaces the following bullet point...
   *
   * o  After having sent or received an answer to the first offer, the
   *    UAC MAY generate subsequent offers in requests based on rules
   *    specified for that method, but only if it has received answers
   *    to any previous offers, and has not sent any offers to which it
   *    hasn't gotten an answer.
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   *
   * ...with...
   *
   * o  After having sent or received an answer to the first offer, the
   *    UAC MUST NOT generate subsequent offers in requests based on rules
   *    specified for that method.
   *
   * ...which in combination with this bullet point...
   *
   * o  Once the UAS has sent or received an answer to the initial
   *    offer, it MUST NOT generate subsequent offers in any responses
   *    to the initial INVITE.  This means that a UAS based on this
   *    specification alone can never generate subsequent offers until
   *    completion of the initial transaction.
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   *
   * ...ensures that EXACTLY ONE offer/answer exchange will occur
   * during an initial out of dialog INVITE request made by our UAC.
   *
   *
   * 2) No "early media" if the initial offer is in an INVITE (default behavior).
   *
   * While our implementation adheres to the following bullet point...
   *
   * o  If the initial offer is in an INVITE, the answer MUST be in a
   *    reliable non-failure message from UAS back to UAC which is
   *    correlated to that INVITE.  For this specification, that is
   *    only the final 2xx response to that INVITE.  That same exact
   *    answer MAY also be placed in any provisional responses sent
   *    prior to the answer.  The UAC MUST treat the first session
   *    description it receives as the answer, and MUST ignore any
   *    session descriptions in subsequent responses to the initial
   *    INVITE.
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   *
   * We have made the following implementation decision with regard to early media...
   *
   * o  If the initial offer is in the INVITE, the answer from the
   *    UAS back to the UAC will establish a media session only
   *    only after the final 2xx response to that INVITE is received.
   *
   * The reason for this decision is rooted in a restriction currently
   * inherent in WebRTC. Specifically, while a SIP INVITE request with an
   * initial offer may fork resulting in more than one provisional answer,
   * there is currently no easy/good way to to "fork" an offer generated
   * by a peer connection. In particular, a WebRTC offer currently may only
   * be matched with one answer and we have no good way to know which
   * "provisional answer" is going to be the "final answer". So we have
   * decided to punt and not create any "early media" sessions in this case.
   *
   * The upshot is that if you want "early media", you must not put the
   * initial offer in the INVITE. Instead, force the UAS to provide the
   * initial offer by sending an INVITE without an offer. In the WebRTC
   * case this allows us to create a unique peer connection with a unique
   * answer for every provisional offer with "early media" on all of them.
   *
   *
   * 3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
   *
   * The default behavior may be altered and "early media" utilized if the
   * initial offer is in the an INVITE by setting the `earlyMedia` options.
   * However in that case the INVITE request MUST NOT fork. This allows for
   * "early media" in environments where the forking behavior of the SIP
   * servers being utilized is configured to disallow forking.
   */
  invite(options = {}) {
    this.logger.log("Inviter.invite");
    if (this.state !== SessionState$2.Initial) {
      return super.invite(options);
    }
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    if (options.withoutSdp || this.inviteWithoutSdp) {
      if (this._renderbody && this._rendertype) {
        this.outgoingRequestMessage.body = { contentType: this._rendertype, body: this._renderbody };
      }
      this.stateTransition(SessionState$2.Establishing);
      return Promise.resolve(this.sendInvite(options));
    }
    const offerOptions = {
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
    };
    return this.getOffer(offerOptions).then((body) => {
      this.outgoingRequestMessage.body = { body: body.content, contentType: body.contentType };
      this.stateTransition(SessionState$2.Establishing);
      return this.sendInvite(options);
    }).catch((error) => {
      this.logger.log(error.message);
      if (this.state !== SessionState$2.Terminated) {
        this.stateTransition(SessionState$2.Terminated);
      }
      throw error;
    });
  }
  /**
   * 13.2.1 Creating the Initial INVITE
   *
   * Since the initial INVITE represents a request outside of a dialog,
   * its construction follows the procedures of Section 8.1.1.  Additional
   * processing is required for the specific case of INVITE.
   *
   * An Allow header field (Section 20.5) SHOULD be present in the INVITE.
   * It indicates what methods can be invoked within a dialog, on the UA
   * sending the INVITE, for the duration of the dialog.  For example, a
   * UA capable of receiving INFO requests within a dialog [34] SHOULD
   * include an Allow header field listing the INFO method.
   *
   * A Supported header field (Section 20.37) SHOULD be present in the
   * INVITE.  It enumerates all the extensions understood by the UAC.
   *
   * An Accept (Section 20.1) header field MAY be present in the INVITE.
   * It indicates which Content-Types are acceptable to the UA, in both
   * the response received by it, and in any subsequent requests sent to
   * it within dialogs established by the INVITE.  The Accept header field
   * is especially useful for indicating support of various session
   * description formats.
   *
   * The UAC MAY add an Expires header field (Section 20.19) to limit the
   * validity of the invitation.  If the time indicated in the Expires
   * header field is reached and no final answer for the INVITE has been
   * received, the UAC core SHOULD generate a CANCEL request for the
   * INVITE, as per Section 9.
   *
   * A UAC MAY also find it useful to add, among others, Subject (Section
   * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)
   * header fields.  They all contain information related to the INVITE.
   *
   * The UAC MAY choose to add a message body to the INVITE.  Section
   * 8.1.1.10 deals with how to construct the header fields -- Content-
   * Type among others -- needed to describe the message body.
   *
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   */
  sendInvite(options = {}) {
    this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {
      onAccept: (inviteResponse) => {
        if (this.dialog) {
          this.logger.log("Additional confirmed dialog, sending ACK and BYE");
          this.ackAndBye(inviteResponse);
          return;
        }
        if (this.isCanceled) {
          this.logger.log("Canceled session accepted, sending ACK and BYE");
          this.ackAndBye(inviteResponse);
          this.stateTransition(SessionState$2.Terminated);
          return;
        }
        this.notifyReferer(inviteResponse);
        this.onAccept(inviteResponse).then(() => {
          this.disposeEarlyMedia();
        }).catch(() => {
          this.disposeEarlyMedia();
        }).then(() => {
          if (options.requestDelegate && options.requestDelegate.onAccept) {
            options.requestDelegate.onAccept(inviteResponse);
          }
        });
      },
      onProgress: (inviteResponse) => {
        if (this.isCanceled) {
          return;
        }
        this.notifyReferer(inviteResponse);
        this.onProgress(inviteResponse).catch(() => {
          this.disposeEarlyMedia();
        }).then(() => {
          if (options.requestDelegate && options.requestDelegate.onProgress) {
            options.requestDelegate.onProgress(inviteResponse);
          }
        });
      },
      onRedirect: (inviteResponse) => {
        this.notifyReferer(inviteResponse);
        this.onRedirect(inviteResponse);
        if (options.requestDelegate && options.requestDelegate.onRedirect) {
          options.requestDelegate.onRedirect(inviteResponse);
        }
      },
      onReject: (inviteResponse) => {
        this.notifyReferer(inviteResponse);
        this.onReject(inviteResponse);
        if (options.requestDelegate && options.requestDelegate.onReject) {
          options.requestDelegate.onReject(inviteResponse);
        }
      },
      onTrying: (inviteResponse) => {
        this.notifyReferer(inviteResponse);
        this.onTrying(inviteResponse);
        if (options.requestDelegate && options.requestDelegate.onTrying) {
          options.requestDelegate.onTrying(inviteResponse);
        }
      }
    });
    return this.outgoingInviteRequest;
  }
  disposeEarlyMedia() {
    this.earlyMediaSessionDescriptionHandlers.forEach((sessionDescriptionHandler) => {
      sessionDescriptionHandler.close();
    });
    this.earlyMediaSessionDescriptionHandlers.clear();
  }
  notifyReferer(response) {
    if (!this._referred) {
      return;
    }
    if (!(this._referred instanceof Session$1)) {
      throw new Error("Referred session not instance of session");
    }
    if (!this._referred.dialog) {
      return;
    }
    if (!response.message.statusCode) {
      throw new Error("Status code undefined.");
    }
    if (!response.message.reasonPhrase) {
      throw new Error("Reason phrase undefined.");
    }
    const statusCode = response.message.statusCode;
    const reasonPhrase = response.message.reasonPhrase;
    const body = `SIP/2.0 ${statusCode} ${reasonPhrase}`.trim();
    const outgoingNotifyRequest = this._referred.dialog.notify(void 0, {
      extraHeaders: ["Event: refer", "Subscription-State: terminated"],
      body: {
        contentDisposition: "render",
        contentType: "message/sipfrag",
        content: body
      }
    });
    outgoingNotifyRequest.delegate = {
      onReject: () => {
        this._referred = void 0;
      }
    };
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 2xx response.
   */
  onAccept(inviteResponse) {
    this.logger.log("Inviter.onAccept");
    if (this.state !== SessionState$2.Establishing) {
      this.logger.error(`Accept received while in state ${this.state}, dropping response`);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const response = inviteResponse.message;
    const session2 = inviteResponse.session;
    if (response.hasHeader("P-Asserted-Identity")) {
      this._assertedIdentity = Grammar$1.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
    }
    session2.delegate = {
      onAck: (ackRequest) => this.onAckRequest(ackRequest),
      onBye: (byeRequest) => this.onByeRequest(byeRequest),
      onInfo: (infoRequest) => this.onInfoRequest(infoRequest),
      onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),
      onMessage: (messageRequest) => this.onMessageRequest(messageRequest),
      onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),
      onPrack: (prackRequest) => this.onPrackRequest(prackRequest),
      onRefer: (referRequest) => this.onReferRequest(referRequest)
    };
    this._dialog = session2;
    switch (session2.signalingState) {
      case SignalingState$1.Initial:
        this.logger.error("Received 2xx response to INVITE without a session description");
        this.ackAndBye(inviteResponse, 400, "Missing session description");
        this.stateTransition(SessionState$2.Terminated);
        return Promise.reject(new Error("Bad Media Description"));
      case SignalingState$1.HaveLocalOffer:
        this.logger.error("Received 2xx response to INVITE without a session description");
        this.ackAndBye(inviteResponse, 400, "Missing session description");
        this.stateTransition(SessionState$2.Terminated);
        return Promise.reject(new Error("Bad Media Description"));
      case SignalingState$1.HaveRemoteOffer: {
        if (!this._dialog.offer) {
          throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);
        }
        const options = {
          sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
          sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
        };
        return this.setOfferAndGetAnswer(this._dialog.offer, options).then((body) => {
          inviteResponse.ack({ body });
          this.stateTransition(SessionState$2.Established);
        }).catch((error) => {
          this.ackAndBye(inviteResponse, 488, "Invalid session description");
          this.stateTransition(SessionState$2.Terminated);
          throw error;
        });
      }
      case SignalingState$1.Stable: {
        if (this.earlyMediaSessionDescriptionHandlers.size > 0) {
          const sdh = this.earlyMediaSessionDescriptionHandlers.get(session2.id);
          if (!sdh) {
            throw new Error("Session description handler undefined.");
          }
          this.setSessionDescriptionHandler(sdh);
          this.earlyMediaSessionDescriptionHandlers.delete(session2.id);
          inviteResponse.ack();
          this.stateTransition(SessionState$2.Established);
          return Promise.resolve();
        }
        if (this.earlyMediaDialog) {
          if (this.earlyMediaDialog !== session2) {
            if (this.earlyMedia) {
              const message2 = "You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly the end point which accepted the INVITE (confirmed dialog) does not match the end point with which early media has been setup (early dialog) and thus this session is unable to proceed. In accordance with the SIP specifications, the SIP servers your end point is connected to determine if an INVITE forks and the forking behavior of those servers cannot be controlled by this library. If you wish to use early media with this library you must configure those servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow this library to function with any INVITE requests which do fork.";
              this.logger.error(message2);
            }
            const error = new Error("Early media dialog does not equal confirmed dialog, terminating session");
            this.logger.error(error.message);
            this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
            this.stateTransition(SessionState$2.Terminated);
            return Promise.reject(error);
          }
          inviteResponse.ack();
          this.stateTransition(SessionState$2.Established);
          return Promise.resolve();
        }
        const answer = session2.answer;
        if (!answer) {
          throw new Error("Answer is undefined.");
        }
        const options = {
          sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
          sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
        };
        return this.setAnswer(answer, options).then(() => {
          let ackOptions;
          if (this._renderbody && this._rendertype) {
            ackOptions = {
              body: { contentDisposition: "render", contentType: this._rendertype, content: this._renderbody }
            };
          }
          inviteResponse.ack(ackOptions);
          this.stateTransition(SessionState$2.Established);
        }).catch((error) => {
          this.logger.error(error.message);
          this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
          this.stateTransition(SessionState$2.Terminated);
          throw error;
        });
      }
      case SignalingState$1.Closed:
        return Promise.reject(new Error("Terminated."));
      default:
        throw new Error("Unknown session signaling state.");
    }
  }
  /**
   * Handle provisional response to initial INVITE.
   * @param inviteResponse - 1xx response.
   */
  onProgress(inviteResponse) {
    var _a;
    this.logger.log("Inviter.onProgress");
    if (this.state !== SessionState$2.Establishing) {
      this.logger.error(`Progress received while in state ${this.state}, dropping response`);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    if (!this.outgoingInviteRequest) {
      throw new Error("Outgoing INVITE request undefined.");
    }
    const response = inviteResponse.message;
    const session2 = inviteResponse.session;
    if (response.hasHeader("P-Asserted-Identity")) {
      this._assertedIdentity = Grammar$1.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
    }
    const requireHeader = response.getHeader("require");
    const rseqHeader = response.getHeader("rseq");
    const rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : void 0;
    const responseReliable = !!rseq;
    const extraHeaders = [];
    if (responseReliable) {
      extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
    }
    switch (session2.signalingState) {
      case SignalingState$1.Initial:
        if (responseReliable) {
          this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.");
          inviteResponse.prack({ extraHeaders });
        }
        return Promise.resolve();
      case SignalingState$1.HaveLocalOffer:
        if (responseReliable) {
          inviteResponse.prack({ extraHeaders });
        }
        return Promise.resolve();
      case SignalingState$1.HaveRemoteOffer:
        if (!responseReliable) {
          this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response.");
          return Promise.resolve();
        }
        {
          const sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});
          if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {
            this.delegate.onSessionDescriptionHandler(sdh, true);
          }
          this.earlyMediaSessionDescriptionHandlers.set(session2.id, sdh);
          return sdh.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(() => sdh.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)).then((description) => {
            const body = {
              contentDisposition: "session",
              contentType: description.contentType,
              content: description.body
            };
            inviteResponse.prack({ extraHeaders, body });
          }).catch((error) => {
            this.stateTransition(SessionState$2.Terminated);
            throw error;
          });
        }
      case SignalingState$1.Stable:
        if (responseReliable) {
          inviteResponse.prack({ extraHeaders });
        }
        if (this.earlyMedia && !this.earlyMediaDialog) {
          this.earlyMediaDialog = session2;
          const answer = session2.answer;
          if (!answer) {
            throw new Error("Answer is undefined.");
          }
          const options = {
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
          };
          return this.setAnswer(answer, options).catch((error) => {
            this.stateTransition(SessionState$2.Terminated);
            throw error;
          });
        }
        return Promise.resolve();
      case SignalingState$1.Closed:
        return Promise.reject(new Error("Terminated."));
      default:
        throw new Error("Unknown session signaling state.");
    }
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 3xx response.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onRedirect(inviteResponse) {
    this.logger.log("Inviter.onRedirect");
    if (this.state !== SessionState$2.Establishing && this.state !== SessionState$2.Terminating) {
      this.logger.error(`Redirect received while in state ${this.state}, dropping response`);
      return;
    }
    this.stateTransition(SessionState$2.Terminated);
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 4xx, 5xx, or 6xx response.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onReject(inviteResponse) {
    this.logger.log("Inviter.onReject");
    if (this.state !== SessionState$2.Establishing && this.state !== SessionState$2.Terminating) {
      this.logger.error(`Reject received while in state ${this.state}, dropping response`);
      return;
    }
    this.stateTransition(SessionState$2.Terminated);
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 100 response.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onTrying(inviteResponse) {
    this.logger.log("Inviter.onTrying");
    if (this.state !== SessionState$2.Establishing) {
      this.logger.error(`Trying received while in state ${this.state}, dropping response`);
      return;
    }
  }
};
let Messager$1 = class Messager {
  /**
   * Constructs a new instance of the `Messager` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param content - Content for the body of the message.
   * @param contentType - Content type of the body of the message.
   * @param options - Options bucket. See {@link MessagerOptions} for details.
   */
  constructor(userAgent, targetURI, content2, contentType = "text/plain", options = {}) {
    this.logger = userAgent.getLogger("sip.Messager");
    options.params = options.params || {};
    let fromURI = userAgent.userAgentCore.configuration.aor;
    if (options.params.fromUri) {
      fromURI = typeof options.params.fromUri === "string" ? Grammar$1.URIParse(options.params.fromUri) : options.params.fromUri;
    }
    if (!fromURI) {
      throw new TypeError("Invalid from URI: " + options.params.fromUri);
    }
    let toURI = targetURI;
    if (options.params.toUri) {
      toURI = typeof options.params.toUri === "string" ? Grammar$1.URIParse(options.params.toUri) : options.params.toUri;
    }
    if (!toURI) {
      throw new TypeError("Invalid to URI: " + options.params.toUri);
    }
    const params = options.params ? Object.assign({}, options.params) : {};
    const extraHeaders = (options.extraHeaders || []).slice();
    const contentDisposition = "render";
    const body = {
      contentDisposition,
      contentType,
      content: content2
    };
    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C$1.MESSAGE, targetURI, fromURI, toURI, params, extraHeaders, body);
    this.userAgent = userAgent;
  }
  /**
   * Send the message.
   */
  message(options = {}) {
    this.userAgent.userAgentCore.request(this.request, options.requestDelegate);
    return Promise.resolve();
  }
};
var RegistererState$1;
(function(RegistererState2) {
  RegistererState2["Initial"] = "Initial";
  RegistererState2["Registered"] = "Registered";
  RegistererState2["Unregistered"] = "Unregistered";
  RegistererState2["Terminated"] = "Terminated";
})(RegistererState$1 = RegistererState$1 || (RegistererState$1 = {}));
let Registerer$1 = class Registerer {
  /**
   * Constructs a new instance of the `Registerer` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param options - Options bucket. See {@link RegistererOptions} for details.
   */
  constructor(userAgent, options = {}) {
    this.disposed = false;
    this._contacts = [];
    this._retryAfter = void 0;
    this._state = RegistererState$1.Initial;
    this._waiting = false;
    this._stateEventEmitter = new EmitterImpl$1();
    this._waitingEventEmitter = new EmitterImpl$1();
    this.userAgent = userAgent;
    const defaultUserAgentRegistrar = userAgent.configuration.uri.clone();
    defaultUserAgentRegistrar.user = void 0;
    this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), { registrar: defaultUserAgentRegistrar }), Registerer.stripUndefinedProperties(options));
    this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();
    this.options.extraHeaders = (this.options.extraHeaders || []).slice();
    if (!this.options.registrar) {
      throw new Error("Registrar undefined.");
    }
    this.options.registrar = this.options.registrar.clone();
    if (this.options.regId && !this.options.instanceId) {
      this.options.instanceId = this.userAgent.instanceId;
    } else if (!this.options.regId && this.options.instanceId) {
      this.options.regId = 1;
    }
    if (this.options.instanceId && Grammar$1.parse(this.options.instanceId, "uuid") === -1) {
      throw new Error("Invalid instanceId.");
    }
    if (this.options.regId && this.options.regId < 0) {
      throw new Error("Invalid regId.");
    }
    const registrar = this.options.registrar;
    const fromURI = this.options.params && this.options.params.fromUri || userAgent.userAgentCore.configuration.aor;
    const toURI = this.options.params && this.options.params.toUri || userAgent.configuration.uri;
    const params = this.options.params || {};
    const extraHeaders = (options.extraHeaders || []).slice();
    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C$1.REGISTER, registrar, fromURI, toURI, params, extraHeaders, void 0);
    this.expires = this.options.expires || Registerer.defaultExpires;
    if (this.expires < 0) {
      throw new Error("Invalid expires.");
    }
    this.refreshFrequency = this.options.refreshFrequency || Registerer.defaultRefreshFrequency;
    if (this.refreshFrequency < 50 || this.refreshFrequency > 99) {
      throw new Error("Invalid refresh frequency. The value represents a percentage of the expiration time and should be between 50 and 99.");
    }
    this.logger = userAgent.getLogger("sip.Registerer");
    if (this.options.logConfiguration) {
      this.logger.log("Configuration:");
      Object.keys(this.options).forEach((key) => {
        const value2 = this.options[key];
        switch (key) {
          case "registrar":
            this.logger.log("· " + key + ": " + value2);
            break;
          default:
            this.logger.log("· " + key + ": " + JSON.stringify(value2));
        }
      });
    }
    this.id = this.request.callId + this.request.from.parameters.tag;
    this.userAgent._registerers[this.id] = this;
  }
  /** Default registerer options. */
  static defaultOptions() {
    return {
      expires: Registerer.defaultExpires,
      extraContactHeaderParams: [],
      extraHeaders: [],
      logConfiguration: true,
      instanceId: "",
      params: {},
      regId: 0,
      registrar: new URI$1("sip", "anonymous", "anonymous.invalid"),
      refreshFrequency: Registerer.defaultRefreshFrequency
    };
  }
  /**
   * Strip properties with undefined values from options.
   * This is a work around while waiting for missing vs undefined to be addressed (or not)...
   * https://github.com/Microsoft/TypeScript/issues/13195
   * @param options - Options to reduce
   */
  static stripUndefinedProperties(options) {
    return Object.keys(options).reduce((object, key) => {
      if (options[key] !== void 0) {
        object[key] = options[key];
      }
      return object;
    }, {});
  }
  /** The registered contacts. */
  get contacts() {
    return this._contacts.slice();
  }
  /**
   * The number of seconds to wait before retrying to register.
   * @defaultValue `undefined`
   * @remarks
   * When the server rejects a registration request, if it provides a suggested
   * duration to wait before retrying, that value is available here when and if
   * the state transitions to `Unsubscribed`. It is also available during the
   * callback to `onReject` after a call to `register`. (Note that if the state
   * if already `Unsubscribed`, a rejected request created by `register` will
   * not cause the state to transition to `Unsubscribed`. One way to avoid this
   * case is to dispose of `Registerer` when unregistered and create a new
   * `Registerer` for any attempts to retry registering.)
   * @example
   * ```ts
   * // Checking for retry after on state change
   * registerer.stateChange.addListener((newState) => {
   *   switch (newState) {
   *     case RegistererState.Unregistered:
   *       const retryAfter = registerer.retryAfter;
   *       break;
   *   }
   * });
   *
   * // Checking for retry after on request rejection
   * registerer.register({
   *   requestDelegate: {
   *     onReject: () => {
   *       const retryAfter = registerer.retryAfter;
   *     }
   *   }
   * });
   * ```
   */
  get retryAfter() {
    return this._retryAfter;
  }
  /** The registration state. */
  get state() {
    return this._state;
  }
  /** Emits when the registerer state changes. */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /** Destructor. */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`);
    delete this.userAgent._registerers[this.id];
    return new Promise((resolve) => {
      const doClose = () => {
        if (!this.waiting && this._state === RegistererState$1.Registered) {
          this.stateChange.addListener(() => {
            this.terminated();
            resolve();
          }, { once: true });
          this.unregister();
          return;
        }
        this.terminated();
        resolve();
      };
      if (this.waiting) {
        this.waitingChange.addListener(() => {
          doClose();
        }, { once: true });
      } else {
        doClose();
      }
    });
  }
  /**
   * Sends the REGISTER request.
   * @remarks
   * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.
   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
   */
  register(options = {}) {
    if (this.state === RegistererState$1.Terminated) {
      this.stateError();
      throw new Error("Registerer terminated. Unable to register.");
    }
    if (this.disposed) {
      this.stateError();
      throw new Error("Registerer disposed. Unable to register.");
    }
    if (this.waiting) {
      this.waitingWarning();
      const error = new RequestPendingError$1("REGISTER request already in progress, waiting for final response");
      return Promise.reject(error);
    }
    if (options.requestOptions) {
      this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);
    }
    const extraHeaders = (this.options.extraHeaders || []).slice();
    extraHeaders.push("Contact: " + this.generateContactHeader(this.expires));
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());
    this.request.cseq++;
    this.request.setHeader("cseq", this.request.cseq + " REGISTER");
    this.request.extraHeaders = extraHeaders;
    this.waitingToggle(true);
    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
      onAccept: (response) => {
        let expires;
        if (response.message.hasHeader("expires")) {
          expires = Number(response.message.getHeader("expires"));
        }
        this._contacts = response.message.getHeaders("contact");
        let contacts = this._contacts.length;
        if (!contacts) {
          this.logger.error("No Contact header in response to REGISTER, dropping response.");
          this.unregistered();
          return;
        }
        let contact2;
        while (contacts--) {
          contact2 = response.message.parseHeader("contact", contacts);
          if (!contact2) {
            throw new Error("Contact undefined");
          }
          if (this.userAgent.contact.pubGruu && equivalentURI$1(contact2.uri, this.userAgent.contact.pubGruu)) {
            expires = Number(contact2.getParam("expires"));
            break;
          }
          if (this.userAgent.configuration.contactName === "") {
            if (contact2.uri.user === this.userAgent.contact.uri.user) {
              expires = Number(contact2.getParam("expires"));
              break;
            }
          } else {
            if (equivalentURI$1(contact2.uri, this.userAgent.contact.uri)) {
              expires = Number(contact2.getParam("expires"));
              break;
            }
          }
          contact2 = void 0;
        }
        if (contact2 === void 0) {
          this.logger.error("No Contact header pointing to us, dropping response");
          this.unregistered();
          this.waitingToggle(false);
          return;
        }
        if (expires === void 0) {
          this.logger.error("Contact pointing to us is missing expires parameter, dropping response");
          this.unregistered();
          this.waitingToggle(false);
          return;
        }
        if (contact2.hasParam("temp-gruu")) {
          const gruu = contact2.getParam("temp-gruu");
          if (gruu) {
            this.userAgent.contact.tempGruu = Grammar$1.URIParse(gruu.replace(/"/g, ""));
          }
        }
        if (contact2.hasParam("pub-gruu")) {
          const gruu = contact2.getParam("pub-gruu");
          if (gruu) {
            this.userAgent.contact.pubGruu = Grammar$1.URIParse(gruu.replace(/"/g, ""));
          }
        }
        this.registered(expires);
        if (options.requestDelegate && options.requestDelegate.onAccept) {
          options.requestDelegate.onAccept(response);
        }
        this.waitingToggle(false);
      },
      onProgress: (response) => {
        if (options.requestDelegate && options.requestDelegate.onProgress) {
          options.requestDelegate.onProgress(response);
        }
      },
      onRedirect: (response) => {
        this.logger.error("Redirect received. Not supported.");
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onRedirect) {
          options.requestDelegate.onRedirect(response);
        }
        this.waitingToggle(false);
      },
      onReject: (response) => {
        if (response.message.statusCode === 423) {
          if (!response.message.hasHeader("min-expires")) {
            this.logger.error("423 response received for REGISTER without Min-Expires, dropping response");
            this.unregistered();
            this.waitingToggle(false);
            return;
          }
          this.expires = Number(response.message.getHeader("min-expires"));
          this.waitingToggle(false);
          this.register();
          return;
        }
        this.logger.warn(`Failed to register, status code ${response.message.statusCode}`);
        let retryAfterDuration = NaN;
        if (response.message.statusCode === 500 || response.message.statusCode === 503) {
          const header = response.message.getHeader("retry-after");
          if (header) {
            retryAfterDuration = Number.parseInt(header, void 0);
          }
        }
        this._retryAfter = isNaN(retryAfterDuration) ? void 0 : retryAfterDuration;
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onReject) {
          options.requestDelegate.onReject(response);
        }
        this._retryAfter = void 0;
        this.waitingToggle(false);
      },
      onTrying: (response) => {
        if (options.requestDelegate && options.requestDelegate.onTrying) {
          options.requestDelegate.onTrying(response);
        }
      }
    });
    return Promise.resolve(outgoingRegisterRequest);
  }
  /**
   * Sends the REGISTER request with expires equal to zero.
   * @remarks
   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
   */
  unregister(options = {}) {
    if (this.state === RegistererState$1.Terminated) {
      this.stateError();
      throw new Error("Registerer terminated. Unable to register.");
    }
    if (this.disposed) {
      if (this.state !== RegistererState$1.Registered) {
        this.stateError();
        throw new Error("Registerer disposed. Unable to register.");
      }
    }
    if (this.waiting) {
      this.waitingWarning();
      const error = new RequestPendingError$1("REGISTER request already in progress, waiting for final response");
      return Promise.reject(error);
    }
    if (this._state !== RegistererState$1.Registered && !options.all) {
      this.logger.warn("Not currently registered, but sending an unregister anyway.");
    }
    const extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();
    this.request.extraHeaders = extraHeaders;
    if (options.all) {
      extraHeaders.push("Contact: *");
      extraHeaders.push("Expires: 0");
    } else {
      extraHeaders.push("Contact: " + this.generateContactHeader(0));
    }
    this.request.cseq++;
    this.request.setHeader("cseq", this.request.cseq + " REGISTER");
    if (this.registrationTimer !== void 0) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = void 0;
    }
    this.waitingToggle(true);
    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
      onAccept: (response) => {
        this._contacts = response.message.getHeaders("contact");
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onAccept) {
          options.requestDelegate.onAccept(response);
        }
        this.waitingToggle(false);
      },
      onProgress: (response) => {
        if (options.requestDelegate && options.requestDelegate.onProgress) {
          options.requestDelegate.onProgress(response);
        }
      },
      onRedirect: (response) => {
        this.logger.error("Unregister redirected. Not currently supported.");
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onRedirect) {
          options.requestDelegate.onRedirect(response);
        }
        this.waitingToggle(false);
      },
      onReject: (response) => {
        this.logger.error(`Unregister rejected with status code ${response.message.statusCode}`);
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onReject) {
          options.requestDelegate.onReject(response);
        }
        this.waitingToggle(false);
      },
      onTrying: (response) => {
        if (options.requestDelegate && options.requestDelegate.onTrying) {
          options.requestDelegate.onTrying(response);
        }
      }
    });
    return Promise.resolve(outgoingRegisterRequest);
  }
  /**
   * Clear registration timers.
   */
  clearTimers() {
    if (this.registrationTimer !== void 0) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = void 0;
    }
    if (this.registrationExpiredTimer !== void 0) {
      clearTimeout(this.registrationExpiredTimer);
      this.registrationExpiredTimer = void 0;
    }
  }
  /**
   * Generate Contact Header
   */
  generateContactHeader(expires) {
    let contact2 = this.userAgent.contact.toString({ register: true });
    if (this.options.regId && this.options.instanceId) {
      contact2 += ";reg-id=" + this.options.regId;
      contact2 += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
    }
    if (this.options.extraContactHeaderParams) {
      this.options.extraContactHeaderParams.forEach((header) => {
        contact2 += ";" + header;
      });
    }
    contact2 += ";expires=" + expires;
    return contact2;
  }
  /**
   * Helper function, called when registered.
   */
  registered(expires) {
    this.clearTimers();
    this.registrationTimer = setTimeout(() => {
      this.registrationTimer = void 0;
      this.register();
    }, this.refreshFrequency / 100 * expires * 1e3);
    this.registrationExpiredTimer = setTimeout(() => {
      this.logger.warn("Registration expired");
      this.unregistered();
    }, expires * 1e3);
    if (this._state !== RegistererState$1.Registered) {
      this.stateTransition(RegistererState$1.Registered);
    }
  }
  /**
   * Helper function, called when unregistered.
   */
  unregistered() {
    this.clearTimers();
    if (this._state !== RegistererState$1.Unregistered) {
      this.stateTransition(RegistererState$1.Unregistered);
    }
  }
  /**
   * Helper function, called when terminated.
   */
  terminated() {
    this.clearTimers();
    if (this._state !== RegistererState$1.Terminated) {
      this.stateTransition(RegistererState$1.Terminated);
    }
  }
  /**
   * Transition registration state.
   */
  stateTransition(newState) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case RegistererState$1.Initial:
        if (newState !== RegistererState$1.Registered && newState !== RegistererState$1.Unregistered && newState !== RegistererState$1.Terminated) {
          invalidTransition();
        }
        break;
      case RegistererState$1.Registered:
        if (newState !== RegistererState$1.Unregistered && newState !== RegistererState$1.Terminated) {
          invalidTransition();
        }
        break;
      case RegistererState$1.Unregistered:
        if (newState !== RegistererState$1.Registered && newState !== RegistererState$1.Terminated) {
          invalidTransition();
        }
        break;
      case RegistererState$1.Terminated:
        invalidTransition();
        break;
      default:
        throw new Error("Unrecognized state.");
    }
    this._state = newState;
    this.logger.log(`Registration transitioned to state ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === RegistererState$1.Terminated) {
      this.dispose();
    }
  }
  /** True if the registerer is currently waiting for final response to a REGISTER request. */
  get waiting() {
    return this._waiting;
  }
  /** Emits when the registerer waiting state changes. */
  get waitingChange() {
    return this._waitingEventEmitter;
  }
  /**
   * Toggle waiting.
   */
  waitingToggle(waiting2) {
    if (this._waiting === waiting2) {
      throw new Error(`Invalid waiting transition from ${this._waiting} to ${waiting2}`);
    }
    this._waiting = waiting2;
    this.logger.log(`Waiting toggled to ${this._waiting}`);
    this._waitingEventEmitter.emit(this._waiting);
  }
  /** Hopefully helpful as the standard behavior has been found to be unexpected. */
  waitingWarning() {
    let message2 = "An attempt was made to send a REGISTER request while a prior one was still in progress.";
    message2 += " RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response";
    message2 += " from the registrar for the previous one or the previous REGISTER request has timed out.";
    message2 += " Note that if the transport disconnects, you still must wait for the prior request to time out before";
    message2 += " sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.";
    this.logger.warn(message2);
  }
  /** Hopefully helpful as the standard behavior has been found to be unexpected. */
  stateError() {
    const reason = this.state === RegistererState$1.Terminated ? "is in 'Terminated' state" : "has been disposed";
    let message2 = `An attempt was made to send a REGISTER request when the Registerer ${reason}.`;
    message2 += " The Registerer transitions to 'Terminated' when Registerer.dispose() is called.";
    message2 += " Perhaps you called UserAgent.stop() which dipsoses of all Registerers?";
    this.logger.error(message2);
  }
};
Registerer$1.defaultExpires = 600;
Registerer$1.defaultRefreshFrequency = 99;
let Md5$1 = class Md5 {
  constructor() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state = new Int32Array(4);
    this._buffer = new ArrayBuffer(68);
    this._buffer8 = new Uint8Array(this._buffer, 0, 68);
    this._buffer32 = new Uint32Array(this._buffer, 0, 17);
    this.start();
  }
  static hashStr(str, raw = false) {
    return this.onePassHasher.start().appendStr(str).end(raw);
  }
  static hashAsciiStr(str, raw = false) {
    return this.onePassHasher.start().appendAsciiStr(str).end(raw);
  }
  static _hex(x) {
    const hc = Md5.hexChars;
    const ho = Md5.hexOut;
    let n2;
    let offset;
    let j;
    let i2;
    for (i2 = 0; i2 < 4; i2 += 1) {
      offset = i2 * 8;
      n2 = x[i2];
      for (j = 0; j < 8; j += 2) {
        ho[offset + 1 + j] = hc.charAt(n2 & 15);
        n2 >>>= 4;
        ho[offset + 0 + j] = hc.charAt(n2 & 15);
        n2 >>>= 4;
      }
    }
    return ho.join("");
  }
  static _md5cycle(x, k) {
    let a2 = x[0];
    let b = x[1];
    let c2 = x[2];
    let d = x[3];
    a2 += (b & c2 | ~b & d) + k[0] - 680876936 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[1] - 389564586 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[2] + 606105819 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[3] - 1044525330 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & c2 | ~b & d) + k[4] - 176418897 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[5] + 1200080426 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[6] - 1473231341 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[7] - 45705983 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & c2 | ~b & d) + k[8] + 1770035416 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[9] - 1958414417 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[10] - 42063 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[11] - 1990404162 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & c2 | ~b & d) + k[12] + 1804603682 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[13] - 40341101 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[14] - 1502002290 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[15] + 1236535329 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[1] - 165796510 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[6] - 1069501632 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[11] + 643717713 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[0] - 373897302 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[5] - 701558691 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[10] + 38016083 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[15] - 660478335 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[4] - 405537848 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[9] + 568446438 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[14] - 1019803690 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[3] - 187363961 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[8] + 1163531501 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[13] - 1444681467 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[2] - 51403784 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[7] + 1735328473 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[12] - 1926607734 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[5] - 378558 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[8] - 2022574463 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[11] + 1839030562 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[14] - 35309556 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[1] - 1530992060 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[4] + 1272893353 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[7] - 155497632 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[10] - 1094730640 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[13] + 681279174 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[0] - 358537222 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[3] - 722521979 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[6] + 76029189 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[9] - 640364487 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[12] - 421815835 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[15] + 530742520 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[2] - 995338651 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[0] - 198630844 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[7] + 1126891415 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[14] - 1416354905 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[5] - 57434055 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[12] + 1700485571 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[3] - 1894986606 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[10] - 1051523 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[1] - 2054922799 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[8] + 1873313359 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[15] - 30611744 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[6] - 1560198380 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[13] + 1309151649 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[4] - 145523070 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[11] - 1120210379 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[2] + 718787259 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[9] - 343485551 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    x[0] = a2 + x[0] | 0;
    x[1] = b + x[1] | 0;
    x[2] = c2 + x[2] | 0;
    x[3] = d + x[3] | 0;
  }
  start() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state.set(Md5.stateIdentity);
    return this;
  }
  // Char to code point to to array conversion:
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
  // #Example.3A_Fixing_charCodeAt_to_handle_non-Basic-Multilingual-Plane_characters_if_their_presence_earlier_in_the_string_is_unknown
  appendStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let code;
    let i2;
    for (i2 = 0; i2 < str.length; i2 += 1) {
      code = str.charCodeAt(i2);
      if (code < 128) {
        buf8[bufLen++] = code;
      } else if (code < 2048) {
        buf8[bufLen++] = (code >>> 6) + 192;
        buf8[bufLen++] = code & 63 | 128;
      } else if (code < 55296 || code > 56319) {
        buf8[bufLen++] = (code >>> 12) + 224;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      } else {
        code = (code - 55296) * 1024 + (str.charCodeAt(++i2) - 56320) + 65536;
        if (code > 1114111) {
          throw new Error("Unicode standard supports code points up to U+10FFFF");
        }
        buf8[bufLen++] = (code >>> 18) + 240;
        buf8[bufLen++] = code >>> 12 & 63 | 128;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      }
      if (bufLen >= 64) {
        this._dataLength += 64;
        Md5._md5cycle(this._state, buf32);
        bufLen -= 64;
        buf32[0] = buf32[16];
      }
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendAsciiStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i2;
    let j = 0;
    for (; ; ) {
      i2 = Math.min(str.length - j, 64 - bufLen);
      while (i2--) {
        buf8[bufLen++] = str.charCodeAt(j++);
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md5._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendByteArray(input) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i2;
    let j = 0;
    for (; ; ) {
      i2 = Math.min(input.length - j, 64 - bufLen);
      while (i2--) {
        buf8[bufLen++] = input[j++];
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md5._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  getState() {
    const self2 = this;
    const s2 = self2._state;
    return {
      buffer: String.fromCharCode.apply(null, self2._buffer8),
      buflen: self2._bufferLength,
      length: self2._dataLength,
      state: [s2[0], s2[1], s2[2], s2[3]]
    };
  }
  setState(state) {
    const buf = state.buffer;
    const x = state.state;
    const s2 = this._state;
    let i2;
    this._dataLength = state.length;
    this._bufferLength = state.buflen;
    s2[0] = x[0];
    s2[1] = x[1];
    s2[2] = x[2];
    s2[3] = x[3];
    for (i2 = 0; i2 < buf.length; i2 += 1) {
      this._buffer8[i2] = buf.charCodeAt(i2);
    }
  }
  end(raw = false) {
    const bufLen = this._bufferLength;
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    const i2 = (bufLen >> 2) + 1;
    let dataBitsLen;
    this._dataLength += bufLen;
    buf8[bufLen] = 128;
    buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
    buf32.set(Md5.buffer32Identity.subarray(i2), i2);
    if (bufLen > 55) {
      Md5._md5cycle(this._state, buf32);
      buf32.set(Md5.buffer32Identity);
    }
    dataBitsLen = this._dataLength * 8;
    if (dataBitsLen <= 4294967295) {
      buf32[14] = dataBitsLen;
    } else {
      const matches2 = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
      if (matches2 === null) {
        return;
      }
      const lo = parseInt(matches2[2], 16);
      const hi = parseInt(matches2[1], 16) || 0;
      buf32[14] = lo;
      buf32[15] = hi;
    }
    Md5._md5cycle(this._state, buf32);
    return raw ? this._state : Md5._hex(this._state);
  }
};
Md5$1.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
Md5$1.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
Md5$1.hexChars = "0123456789abcdef";
Md5$1.hexOut = [];
Md5$1.onePassHasher = new Md5$1();
if (Md5$1.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
  console.error("Md5 self test failed.");
}
function MD5$1(s2) {
  return Md5$1.hashStr(s2);
}
let DigestAuthentication$1 = class DigestAuthentication {
  /**
   * Constructor.
   * @param loggerFactory - LoggerFactory.
   * @param username - Username.
   * @param password - Password.
   */
  constructor(loggerFactory, ha1, username, password) {
    this.logger = loggerFactory.getLogger("sipjs.digestauthentication");
    this.username = username;
    this.password = password;
    this.ha1 = ha1;
    this.nc = 0;
    this.ncHex = "00000000";
  }
  /**
   * Performs Digest authentication given a SIP request and the challenge
   * received in a response to that request.
   * @param request -
   * @param challenge -
   * @returns true if credentials were successfully generated, false otherwise.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  authenticate(request, challenge, body) {
    this.algorithm = challenge.algorithm;
    this.realm = challenge.realm;
    this.nonce = challenge.nonce;
    this.opaque = challenge.opaque;
    this.stale = challenge.stale;
    if (this.algorithm) {
      if (this.algorithm !== "MD5") {
        this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
        return false;
      }
    } else {
      this.algorithm = "MD5";
    }
    if (!this.realm) {
      this.logger.warn("challenge without Digest realm, authentication aborted");
      return false;
    }
    if (!this.nonce) {
      this.logger.warn("challenge without Digest nonce, authentication aborted");
      return false;
    }
    if (challenge.qop) {
      if (challenge.qop.indexOf("auth") > -1) {
        this.qop = "auth";
      } else if (challenge.qop.indexOf("auth-int") > -1) {
        this.qop = "auth-int";
      } else {
        this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
        return false;
      }
    } else {
      this.qop = void 0;
    }
    this.method = request.method;
    this.uri = request.ruri;
    this.cnonce = createRandomToken$1(12);
    this.nc += 1;
    this.updateNcHex();
    if (this.nc === 4294967296) {
      this.nc = 1;
      this.ncHex = "00000001";
    }
    this.calculateResponse(body);
    return true;
  }
  /**
   * Return the Proxy-Authorization or WWW-Authorization header value.
   */
  toString() {
    const authParams = [];
    if (!this.response) {
      throw new Error("response field does not exist, cannot generate Authorization header");
    }
    authParams.push("algorithm=" + this.algorithm);
    authParams.push('username="' + this.username + '"');
    authParams.push('realm="' + this.realm + '"');
    authParams.push('nonce="' + this.nonce + '"');
    authParams.push('uri="' + this.uri + '"');
    authParams.push('response="' + this.response + '"');
    if (this.opaque) {
      authParams.push('opaque="' + this.opaque + '"');
    }
    if (this.qop) {
      authParams.push("qop=" + this.qop);
      authParams.push('cnonce="' + this.cnonce + '"');
      authParams.push("nc=" + this.ncHex);
    }
    return "Digest " + authParams.join(", ");
  }
  /**
   * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
   */
  updateNcHex() {
    const hex = Number(this.nc).toString(16);
    this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
  }
  /**
   * Generate Digest 'response' value.
   */
  calculateResponse(body) {
    let ha1, ha2;
    ha1 = this.ha1;
    if (ha1 === "" || ha1 === void 0) {
      ha1 = MD5$1(this.username + ":" + this.realm + ":" + this.password);
    }
    if (this.qop === "auth") {
      ha2 = MD5$1(this.method + ":" + this.uri);
      this.response = MD5$1(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
    } else if (this.qop === "auth-int") {
      ha2 = MD5$1(this.method + ":" + this.uri + ":" + MD5$1(body ? body : ""));
      this.response = MD5$1(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
    } else if (this.qop === void 0) {
      ha2 = MD5$1(this.method + ":" + this.uri);
      this.response = MD5$1(ha1 + ":" + this.nonce + ":" + ha2);
    }
  }
};
var Levels$1;
(function(Levels2) {
  Levels2[Levels2["error"] = 0] = "error";
  Levels2[Levels2["warn"] = 1] = "warn";
  Levels2[Levels2["log"] = 2] = "log";
  Levels2[Levels2["debug"] = 3] = "debug";
})(Levels$1 = Levels$1 || (Levels$1 = {}));
let Logger$1 = class Logger3 {
  constructor(logger, category, label) {
    this.logger = logger;
    this.category = category;
    this.label = label;
  }
  error(content2) {
    this.genericLog(Levels$1.error, content2);
  }
  warn(content2) {
    this.genericLog(Levels$1.warn, content2);
  }
  log(content2) {
    this.genericLog(Levels$1.log, content2);
  }
  debug(content2) {
    this.genericLog(Levels$1.debug, content2);
  }
  genericLog(level, content2) {
    this.logger.genericLog(level, this.category, this.label, content2);
  }
  get level() {
    return this.logger.level;
  }
  set level(newLevel) {
    this.logger.level = newLevel;
  }
};
let LoggerFactory$1 = class LoggerFactory {
  constructor() {
    this.builtinEnabled = true;
    this._level = Levels$1.log;
    this.loggers = {};
    this.logger = this.getLogger("sip:loggerfactory");
  }
  get level() {
    return this._level;
  }
  set level(newLevel) {
    if (newLevel >= 0 && newLevel <= 3) {
      this._level = newLevel;
    } else if (newLevel > 3) {
      this._level = 3;
    } else if (Levels$1.hasOwnProperty(newLevel)) {
      this._level = newLevel;
    } else {
      this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get connector() {
    return this._connector;
  }
  set connector(value2) {
    if (!value2) {
      this._connector = void 0;
    } else if (typeof value2 === "function") {
      this._connector = value2;
    } else {
      this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value2));
    }
  }
  getLogger(category, label) {
    if (label && this.level === 3) {
      return new Logger$1(this, category, label);
    } else if (this.loggers[category]) {
      return this.loggers[category];
    } else {
      const logger = new Logger$1(this, category);
      this.loggers[category] = logger;
      return logger;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  genericLog(levelToLog, category, label, content2) {
    if (this.level >= levelToLog) {
      if (this.builtinEnabled) {
        this.print(levelToLog, category, label, content2);
      }
    }
    if (this.connector) {
      this.connector(Levels$1[levelToLog], category, label, content2);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  print(levelToLog, category, label, content2) {
    if (typeof content2 === "string") {
      const prefix = [/* @__PURE__ */ new Date(), category];
      if (label) {
        prefix.push(label);
      }
      content2 = prefix.concat(content2).join(" | ");
    }
    switch (levelToLog) {
      case Levels$1.error:
        console.error(content2);
        break;
      case Levels$1.warn:
        console.warn(content2);
        break;
      case Levels$1.log:
        console.log(content2);
        break;
      case Levels$1.debug:
        console.debug(content2);
        break;
    }
  }
};
var Parser$1;
(function(Parser2) {
  function getHeader(data, headerStart) {
    let start = headerStart;
    let end = 0;
    let partialEnd = 0;
    if (data.substring(start, start + 2).match(/(^\r\n)/)) {
      return -2;
    }
    while (end === 0) {
      partialEnd = data.indexOf("\r\n", start);
      if (partialEnd === -1) {
        return partialEnd;
      }
      if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
        start = partialEnd + 2;
      } else {
        end = partialEnd;
      }
    }
    return end;
  }
  Parser2.getHeader = getHeader;
  function parseHeader(message2, data, headerStart, headerEnd) {
    const hcolonIndex = data.indexOf(":", headerStart);
    const headerName = data.substring(headerStart, hcolonIndex).trim();
    const headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
    let parsed;
    switch (headerName.toLowerCase()) {
      case "via":
      case "v":
        message2.addHeader("via", headerValue);
        if (message2.getHeaders("via").length === 1) {
          parsed = message2.parseHeader("Via");
          if (parsed) {
            message2.via = parsed;
            message2.viaBranch = parsed.branch;
          }
        } else {
          parsed = 0;
        }
        break;
      case "from":
      case "f":
        message2.setHeader("from", headerValue);
        parsed = message2.parseHeader("from");
        if (parsed) {
          message2.from = parsed;
          message2.fromTag = parsed.getParam("tag");
        }
        break;
      case "to":
      case "t":
        message2.setHeader("to", headerValue);
        parsed = message2.parseHeader("to");
        if (parsed) {
          message2.to = parsed;
          message2.toTag = parsed.getParam("tag");
        }
        break;
      case "record-route":
        parsed = Grammar$1.parse(headerValue, "Record_Route");
        if (parsed === -1) {
          parsed = void 0;
          break;
        }
        if (!(parsed instanceof Array)) {
          parsed = void 0;
          break;
        }
        parsed.forEach((header) => {
          message2.addHeader("record-route", headerValue.substring(header.position, header.offset));
          message2.headers["Record-Route"][message2.getHeaders("record-route").length - 1].parsed = header.parsed;
        });
        break;
      case "call-id":
      case "i":
        message2.setHeader("call-id", headerValue);
        parsed = message2.parseHeader("call-id");
        if (parsed) {
          message2.callId = headerValue;
        }
        break;
      case "contact":
      case "m":
        parsed = Grammar$1.parse(headerValue, "Contact");
        if (parsed === -1) {
          parsed = void 0;
          break;
        }
        if (!(parsed instanceof Array)) {
          parsed = void 0;
          break;
        }
        parsed.forEach((header) => {
          message2.addHeader("contact", headerValue.substring(header.position, header.offset));
          message2.headers.Contact[message2.getHeaders("contact").length - 1].parsed = header.parsed;
        });
        break;
      case "content-length":
      case "l":
        message2.setHeader("content-length", headerValue);
        parsed = message2.parseHeader("content-length");
        break;
      case "content-type":
      case "c":
        message2.setHeader("content-type", headerValue);
        parsed = message2.parseHeader("content-type");
        break;
      case "cseq":
        message2.setHeader("cseq", headerValue);
        parsed = message2.parseHeader("cseq");
        if (parsed) {
          message2.cseq = parsed.value;
        }
        if (message2 instanceof IncomingResponseMessage$1) {
          message2.method = parsed.method;
        }
        break;
      case "max-forwards":
        message2.setHeader("max-forwards", headerValue);
        parsed = message2.parseHeader("max-forwards");
        break;
      case "www-authenticate":
        message2.setHeader("www-authenticate", headerValue);
        parsed = message2.parseHeader("www-authenticate");
        break;
      case "proxy-authenticate":
        message2.setHeader("proxy-authenticate", headerValue);
        parsed = message2.parseHeader("proxy-authenticate");
        break;
      case "refer-to":
      case "r":
        message2.setHeader("refer-to", headerValue);
        parsed = message2.parseHeader("refer-to");
        if (parsed) {
          message2.referTo = parsed;
        }
        break;
      default:
        message2.addHeader(headerName.toLowerCase(), headerValue);
        parsed = 0;
    }
    if (parsed === void 0) {
      return {
        error: "error parsing header '" + headerName + "'"
      };
    } else {
      return true;
    }
  }
  Parser2.parseHeader = parseHeader;
  function parseMessage(data, logger) {
    let headerStart = 0;
    let headerEnd = data.indexOf("\r\n");
    if (headerEnd === -1) {
      logger.warn("no CRLF found, not a SIP message, discarded");
      return;
    }
    const firstLine = data.substring(0, headerEnd);
    const parsed = Grammar$1.parse(firstLine, "Request_Response");
    let message2;
    if (parsed === -1) {
      logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
      return;
    } else if (!parsed.status_code) {
      message2 = new IncomingRequestMessage$1();
      message2.method = parsed.method;
      message2.ruri = parsed.uri;
    } else {
      message2 = new IncomingResponseMessage$1();
      message2.statusCode = parsed.status_code;
      message2.reasonPhrase = parsed.reason_phrase;
    }
    message2.data = data;
    headerStart = headerEnd + 2;
    let bodyStart;
    while (true) {
      headerEnd = getHeader(data, headerStart);
      if (headerEnd === -2) {
        bodyStart = headerStart + 2;
        break;
      } else if (headerEnd === -1) {
        logger.error("malformed message");
        return;
      }
      const parsedHeader = parseHeader(message2, data, headerStart, headerEnd);
      if (parsedHeader && parsedHeader !== true) {
        logger.error(parsedHeader.error);
        return;
      }
      headerStart = headerEnd + 2;
    }
    if (message2.hasHeader("content-length")) {
      message2.body = data.substr(bodyStart, Number(message2.getHeader("content-length")));
    } else {
      message2.body = data.substring(bodyStart);
    }
    return message2;
  }
  Parser2.parseMessage = parseMessage;
})(Parser$1 = Parser$1 || (Parser$1 = {}));
function constructOutgoingResponse$1(message2, options) {
  const CRLF = "\r\n";
  if (options.statusCode < 100 || options.statusCode > 699) {
    throw new TypeError("Invalid statusCode: " + options.statusCode);
  }
  const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase$1(options.statusCode);
  let response = "SIP/2.0 " + options.statusCode + " " + reasonPhrase + CRLF;
  if (options.statusCode >= 100 && options.statusCode < 200) ;
  if (options.statusCode === 100) ;
  const fromHeader = "From: " + message2.getHeader("From") + CRLF;
  const callIdHeader = "Call-ID: " + message2.callId + CRLF;
  const cSeqHeader = "CSeq: " + message2.cseq + " " + message2.method + CRLF;
  const viaHeaders = message2.getHeaders("via").reduce((previous, current2) => {
    return previous + "Via: " + current2 + CRLF;
  }, "");
  let toHeader = "To: " + message2.getHeader("to");
  if (options.statusCode > 100 && !message2.parseHeader("to").hasParam("tag")) {
    let toTag = options.toTag;
    if (!toTag) {
      toTag = newTag$1();
    }
    toHeader += ";tag=" + toTag;
  }
  toHeader += CRLF;
  let supportedHeader = "";
  if (options.supported) {
    supportedHeader = "Supported: " + options.supported.join(", ") + CRLF;
  }
  let userAgentHeader = "";
  if (options.userAgent) {
    userAgentHeader = "User-Agent: " + options.userAgent + CRLF;
  }
  let extensionHeaders = "";
  if (options.extraHeaders) {
    extensionHeaders = options.extraHeaders.reduce((previous, current2) => {
      return previous + current2.trim() + CRLF;
    }, "");
  }
  response += viaHeaders;
  response += fromHeader;
  response += toHeader;
  response += cSeqHeader;
  response += callIdHeader;
  response += supportedHeader;
  response += userAgentHeader;
  response += extensionHeaders;
  if (options.body) {
    response += "Content-Type: " + options.body.contentType + CRLF;
    response += "Content-Length: " + utf8Length$2(options.body.content) + CRLF + CRLF;
    response += options.body.content;
  } else {
    response += "Content-Length: 0" + CRLF + CRLF;
  }
  return { message: response };
}
let TransportError$2 = class TransportError extends Exception$1 {
  constructor(message2) {
    super(message2 ? message2 : "Unspecified transport error.");
  }
};
let Transaction$1 = class Transaction {
  constructor(_transport, _user, _id, _state, loggerCategory) {
    this._transport = _transport;
    this._user = _user;
    this._id = _id;
    this._state = _state;
    this.listeners = new Array();
    this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
    this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);
  }
  /**
   * Destructor.
   * Once the transaction is in the "terminated" state, it is destroyed
   * immediately and there is no need to call `dispose`. However, if a
   * transaction needs to be ended prematurely, the transaction user may
   * do so by calling this method (for example, perhaps the UA is shutting down).
   * No state transition will occur upon calling this method, all outstanding
   * transmission timers will be cancelled, and use of the transaction after
   * calling `dispose` is undefined.
   */
  dispose() {
    this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);
  }
  /** Transaction id. */
  get id() {
    return this._id;
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    throw new Error("Invalid kind.");
  }
  /** Transaction state. */
  get state() {
    return this._state;
  }
  /** Transaction transport. */
  get transport() {
    return this._transport;
  }
  /**
   * Sets up a function that will be called whenever the transaction state changes.
   * @param listener - Callback function.
   * @param options - An options object that specifies characteristics about the listener.
   *                  If once true, indicates that the listener should be invoked at most once after being added.
   *                  If once true, the listener would be automatically removed when invoked.
   */
  addStateChangeListener(listener, options) {
    const onceWrapper = () => {
      this.removeStateChangeListener(onceWrapper);
      listener();
    };
    (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);
  }
  /**
   * This is currently public so tests may spy on it.
   * @internal
   */
  notifyStateChangeListeners() {
    this.listeners.slice().forEach((listener) => listener());
  }
  /**
   * Removes a listener previously registered with addStateListener.
   * @param listener - Callback function.
   */
  removeStateChangeListener(listener) {
    this.listeners = this.listeners.filter((l2) => l2 !== listener);
  }
  logTransportError(error, message2) {
    this.logger.error(error.message);
    this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`);
    this.logger.error(message2);
  }
  /**
   * Pass message to transport for transmission. If transport fails,
   * the transaction user is notified by callback to onTransportError().
   * @returns
   * Rejects with `TransportError` if transport fails.
   */
  send(message2) {
    return this.transport.send(message2).catch((error) => {
      if (error instanceof TransportError$2) {
        this.onTransportError(error);
        throw error;
      }
      let transportError;
      if (error && typeof error.message === "string") {
        transportError = new TransportError$2(error.message);
      } else {
        transportError = new TransportError$2();
      }
      this.onTransportError(transportError);
      throw transportError;
    });
  }
  setState(state) {
    this.logger.debug(`State change to "${state}" on ${this.typeToString()} with id ${this.id}.`);
    this._state = state;
    if (this._user.onStateChange) {
      this._user.onStateChange(state);
    }
    this.notifyStateChangeListeners();
  }
  typeToString() {
    return "UnknownType";
  }
};
let ServerTransaction$1 = class ServerTransaction extends Transaction$1 {
  constructor(_request, transport, user, state, loggerCategory) {
    super(transport, user, _request.viaBranch, state, loggerCategory);
    this._request = _request;
    this.user = user;
  }
  /** The incoming request the transaction handling. */
  get request() {
    return this._request;
  }
};
var TransactionState$1;
(function(TransactionState2) {
  TransactionState2["Accepted"] = "Accepted";
  TransactionState2["Calling"] = "Calling";
  TransactionState2["Completed"] = "Completed";
  TransactionState2["Confirmed"] = "Confirmed";
  TransactionState2["Proceeding"] = "Proceeding";
  TransactionState2["Terminated"] = "Terminated";
  TransactionState2["Trying"] = "Trying";
})(TransactionState$1 = TransactionState$1 || (TransactionState$1 = {}));
let InviteServerTransaction$1 = class InviteServerTransaction extends ServerTransaction$1 {
  /**
   * Constructor.
   * Upon construction, a "100 Trying" reply will be immediately sent.
   * After construction the transaction will be in the "proceeding" state and the transaction
   * `id` will equal the branch parameter set in the Via header of the incoming request.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   * @param request - Incoming INVITE request from the transport.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState$1.Proceeding, "sip.transaction.ist");
  }
  /**
   * Destructor.
   */
  dispose() {
    this.stopProgressExtensionTimer();
    if (this.H) {
      clearTimeout(this.H);
      this.H = void 0;
    }
    if (this.I) {
      clearTimeout(this.I);
      this.I = void 0;
    }
    if (this.L) {
      clearTimeout(this.L);
      this.L = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "ist";
  }
  /**
   * Receive requests from transport matching this transaction.
   * @param request - Request matching this transaction.
   */
  receiveRequest(request) {
    switch (this.state) {
      case TransactionState$1.Proceeding:
        if (request.method === C$1.INVITE) {
          if (this.lastProvisionalResponse) {
            this.send(this.lastProvisionalResponse).catch((error) => {
              this.logTransportError(error, "Failed to send retransmission of provisional response.");
            });
          }
          return;
        }
        break;
      case TransactionState$1.Accepted:
        if (request.method === C$1.INVITE) {
          return;
        }
        break;
      case TransactionState$1.Completed:
        if (request.method === C$1.INVITE) {
          if (!this.lastFinalResponse) {
            throw new Error("Last final response undefined.");
          }
          this.send(this.lastFinalResponse).catch((error) => {
            this.logTransportError(error, "Failed to send retransmission of final response.");
          });
          return;
        }
        if (request.method === C$1.ACK) {
          this.stateTransition(TransactionState$1.Confirmed);
          return;
        }
        break;
      case TransactionState$1.Confirmed:
        if (request.method === C$1.INVITE || request.method === C$1.ACK) {
          return;
        }
        break;
      case TransactionState$1.Terminated:
        if (request.method === C$1.INVITE || request.method === C$1.ACK) {
          return;
        }
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `INVITE server transaction received unexpected ${request.method} request while in state ${this.state}.`;
    this.logger.warn(message2);
    return;
  }
  /**
   * Receive responses from TU for this transaction.
   * @param statusCode - Status code of response.
   * @param response - Response.
   */
  receiveResponse(statusCode, response) {
    if (statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    switch (this.state) {
      case TransactionState$1.Proceeding:
        if (statusCode >= 100 && statusCode <= 199) {
          this.lastProvisionalResponse = response;
          if (statusCode > 100) {
            this.startProgressExtensionTimer();
          }
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send 1xx response.");
          });
          return;
        }
        if (statusCode >= 200 && statusCode <= 299) {
          this.lastFinalResponse = response;
          this.stateTransition(TransactionState$1.Accepted);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send 2xx response.");
          });
          return;
        }
        if (statusCode >= 300 && statusCode <= 699) {
          this.lastFinalResponse = response;
          this.stateTransition(TransactionState$1.Completed);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send non-2xx final response.");
          });
          return;
        }
        break;
      case TransactionState$1.Accepted:
        if (statusCode >= 200 && statusCode <= 299) {
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send 2xx response.");
          });
          return;
        }
        break;
      case TransactionState$1.Completed:
        break;
      case TransactionState$1.Confirmed:
        break;
      case TransactionState$1.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;
    this.logger.error(message2);
    throw new Error(message2);
  }
  /**
   * Retransmit the last 2xx response. This is a noop if not in the "accepted" state.
   */
  retransmitAcceptedResponse() {
    if (this.state === TransactionState$1.Accepted && this.lastFinalResponse) {
      this.send(this.lastFinalResponse).catch((error) => {
        this.logTransportError(error, "Failed to send 2xx response.");
      });
    }
  }
  /**
   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
   * inform the TU that a failure has occurred, and MUST remain in the current state.
   * https://tools.ietf.org/html/rfc6026#section-8.8
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
  }
  /** For logging. */
  typeToString() {
    return "INVITE server transaction";
  }
  /**
   * Execute a state transition.
   * @param newState - New state.
   */
  stateTransition(newState) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState$1.Proceeding:
        invalidStateTransition();
        break;
      case TransactionState$1.Accepted:
      case TransactionState$1.Completed:
        if (this.state !== TransactionState$1.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Confirmed:
        if (this.state !== TransactionState$1.Completed) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Terminated:
        if (this.state !== TransactionState$1.Accepted && this.state !== TransactionState$1.Completed && this.state !== TransactionState$1.Confirmed) {
          invalidStateTransition();
        }
        break;
      default:
        invalidStateTransition();
    }
    this.stopProgressExtensionTimer();
    if (newState === TransactionState$1.Accepted) {
      this.L = setTimeout(() => this.timerL(), Timers$1.TIMER_L);
    }
    if (newState === TransactionState$1.Completed) {
      this.H = setTimeout(() => this.timerH(), Timers$1.TIMER_H);
    }
    if (newState === TransactionState$1.Confirmed) {
      this.I = setTimeout(() => this.timerI(), Timers$1.TIMER_I);
    }
    if (newState === TransactionState$1.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
   */
  startProgressExtensionTimer() {
    if (this.progressExtensionTimer === void 0) {
      this.progressExtensionTimer = setInterval(() => {
        this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`);
        if (!this.lastProvisionalResponse) {
          throw new Error("Last provisional response undefined.");
        }
        this.send(this.lastProvisionalResponse).catch((error) => {
          this.logTransportError(error, "Failed to send retransmission of provisional response.");
        });
      }, Timers$1.PROVISIONAL_RESPONSE_INTERVAL);
    }
  }
  /**
   * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
   */
  stopProgressExtensionTimer() {
    if (this.progressExtensionTimer !== void 0) {
      clearInterval(this.progressExtensionTimer);
      this.progressExtensionTimer = void 0;
    }
  }
  /**
   * While in the "Proceeding" state, if the TU passes a response with status code
   * from 300 to 699 to the server transaction, the response MUST be passed to the
   * transport layer for transmission, and the state machine MUST enter the "Completed" state.
   * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
   * reliable transports. If timer G fires, the response is passed to the transport layer once
   * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
   * when timer G fires, the response is passed to the transport again for transmission, and
   * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
   * it is reset with the value of T2.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   */
  timerG() {
  }
  /**
   * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
   * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
   * indicate to the TU that a transaction failure has occurred.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   */
  timerH() {
    this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`);
    if (this.state === TransactionState$1.Completed) {
      this.logger.warn("ACK to negative final response was never received, terminating transaction.");
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
  /**
   * Once timer I fires, the server MUST transition to the "Terminated" state.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   */
  timerI() {
    this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`);
    this.stateTransition(TransactionState$1.Terminated);
  }
  /**
   * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
   * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
   * it MUST be destroyed immediately. Timer L reflects the amount of time the server
   * transaction could receive 2xx responses for retransmission from the
   * TU while it is waiting to receive an ACK.
   * https://tools.ietf.org/html/rfc6026#section-7.1
   * https://tools.ietf.org/html/rfc6026#section-8.7
   */
  timerL() {
    this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`);
    if (this.state === TransactionState$1.Accepted) {
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
};
let ClientTransaction$1 = class ClientTransaction extends Transaction$1 {
  constructor(_request, transport, user, state, loggerCategory) {
    super(transport, user, ClientTransaction.makeId(_request), state, loggerCategory);
    this._request = _request;
    this.user = user;
    _request.setViaHeader(this.id, transport.protocol);
  }
  static makeId(request) {
    if (request.method === "CANCEL") {
      if (!request.branch) {
        throw new Error("Outgoing CANCEL request without a branch.");
      }
      return request.branch;
    } else {
      return "z9hG4bK" + Math.floor(Math.random() * 1e7);
    }
  }
  /** The outgoing request the transaction handling. */
  get request() {
    return this._request;
  }
  /**
   * A 408 to non-INVITE will always arrive too late to be useful ([3]),
   * The client already has full knowledge of the timeout. The only
   * information this message would convey is whether or not the server
   * believed the transaction timed out. However, with the current design
   * of the NIT, a client cannot do anything with this knowledge. Thus,
   * the 408 is simply wasting network resources and contributes to the
   * response bombardment illustrated in [3].
   * https://tools.ietf.org/html/rfc4320#section-4.1
   */
  onRequestTimeout() {
    if (this.user.onRequestTimeout) {
      this.user.onRequestTimeout();
    }
  }
};
let NonInviteClientTransaction$1 = class NonInviteClientTransaction extends ClientTransaction$1 {
  /**
   * Constructor
   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
   * Then `toString` is called on the outgoing request and the message is sent via the transport.
   * After construction the transaction will be in the "calling" state and the transaction id
   * will equal the branch parameter set in the Via header of the outgoing request.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2
   * @param request - The outgoing Non-INVITE request.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState$1.Trying, "sip.transaction.nict");
    this.F = setTimeout(() => this.timerF(), Timers$1.TIMER_F);
    this.send(request.toString()).catch((error) => {
      this.logTransportError(error, "Failed to send initial outgoing request.");
    });
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.F) {
      clearTimeout(this.F);
      this.F = void 0;
    }
    if (this.K) {
      clearTimeout(this.K);
      this.K = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "nict";
  }
  /**
   * Handler for incoming responses from the transport which match this transaction.
   * @param response - The incoming response.
   */
  receiveResponse(response) {
    const statusCode = response.statusCode;
    if (!statusCode || statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    switch (this.state) {
      case TransactionState$1.Trying:
        if (statusCode >= 100 && statusCode <= 199) {
          this.stateTransition(TransactionState$1.Proceeding);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState$1.Completed);
          if (statusCode === 408) {
            this.onRequestTimeout();
            return;
          }
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState$1.Proceeding:
        if (statusCode >= 100 && statusCode <= 199) {
          if (this.user.receiveResponse) {
            return this.user.receiveResponse(response);
          }
        }
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState$1.Completed);
          if (statusCode === 408) {
            this.onRequestTimeout();
            return;
          }
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState$1.Completed:
        return;
      case TransactionState$1.Terminated:
        return;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `Non-INVITE client transaction received unexpected ${statusCode} response while in state ${this.state}.`;
    this.logger.warn(message2);
    return;
  }
  /**
   * The client transaction SHOULD inform the TU that a transport failure has occurred,
   * and the client transaction SHOULD transition directly to the "Terminated" state.
   * The TU will handle the fail over mechanisms described in [4].
   * https://tools.ietf.org/html/rfc3261#section-17.1.4
   * @param error - Transport error
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
    this.stateTransition(TransactionState$1.Terminated, true);
  }
  /** For logging. */
  typeToString() {
    return "non-INVITE client transaction";
  }
  /**
   * Execute a state transition.
   * @param newState - New state.
   */
  stateTransition(newState, dueToTransportError = false) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState$1.Trying:
        invalidStateTransition();
        break;
      case TransactionState$1.Proceeding:
        if (this.state !== TransactionState$1.Trying) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Completed:
        if (this.state !== TransactionState$1.Trying && this.state !== TransactionState$1.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Terminated:
        if (this.state !== TransactionState$1.Trying && this.state !== TransactionState$1.Proceeding && this.state !== TransactionState$1.Completed) {
          if (!dueToTransportError) {
            invalidStateTransition();
          }
        }
        break;
      default:
        invalidStateTransition();
    }
    if (newState === TransactionState$1.Completed) {
      if (this.F) {
        clearTimeout(this.F);
        this.F = void 0;
      }
      this.K = setTimeout(() => this.timerK(), Timers$1.TIMER_K);
    }
    if (newState === TransactionState$1.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * If Timer F fires while the client transaction is still in the
   * "Trying" state, the client transaction SHOULD inform the TU about the
   * timeout, and then it SHOULD enter the "Terminated" state.
   * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
   * a timeout, and the client transaction MUST transition to the terminated state.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
   */
  timerF() {
    this.logger.debug(`Timer F expired for non-INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState$1.Trying || this.state === TransactionState$1.Proceeding) {
      this.onRequestTimeout();
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
  /**
   * If Timer K fires while in this (COMPLETED) state, the client transaction
   * MUST transition to the "Terminated" state.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
   */
  timerK() {
    if (this.state === TransactionState$1.Completed) {
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
};
let Dialog$1 = class Dialog {
  /**
   * Dialog constructor.
   * @param core - User agent core.
   * @param dialogState - Initial dialog state.
   */
  constructor(core2, dialogState) {
    this.core = core2;
    this.dialogState = dialogState;
    this.core.dialogs.set(this.id, this);
  }
  /**
   * When a UAC receives a response that establishes a dialog, it
   * constructs the state of the dialog.  This state MUST be maintained
   * for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.2
   * @param outgoingRequestMessage - Outgoing request message for dialog.
   * @param incomingResponseMessage - Incoming response message creating dialog.
   */
  static initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {
    const secure = false;
    const routeSet = incomingResponseMessage.getHeaders("record-route").reverse();
    const contact2 = incomingResponseMessage.parseHeader("contact");
    if (!contact2) {
      throw new Error("Contact undefined.");
    }
    if (!(contact2 instanceof NameAddrHeader$1)) {
      throw new Error("Contact not instance of NameAddrHeader.");
    }
    const remoteTarget = contact2.uri;
    const localSequenceNumber = outgoingRequestMessage.cseq;
    const remoteSequenceNumber = void 0;
    const callId = outgoingRequestMessage.callId;
    const localTag = outgoingRequestMessage.fromTag;
    const remoteTag = incomingResponseMessage.toTag;
    if (!callId) {
      throw new Error("Call id undefined.");
    }
    if (!localTag) {
      throw new Error("From tag undefined.");
    }
    if (!remoteTag) {
      throw new Error("To tag undefined.");
    }
    if (!outgoingRequestMessage.from) {
      throw new Error("From undefined.");
    }
    if (!outgoingRequestMessage.to) {
      throw new Error("To undefined.");
    }
    const localURI = outgoingRequestMessage.from.uri;
    const remoteURI = outgoingRequestMessage.to.uri;
    if (!incomingResponseMessage.statusCode) {
      throw new Error("Incoming response status code undefined.");
    }
    const early = incomingResponseMessage.statusCode < 200 ? true : false;
    const dialogState = {
      id: callId + localTag + remoteTag,
      early,
      callId,
      localTag,
      remoteTag,
      localSequenceNumber,
      remoteSequenceNumber,
      localURI,
      remoteURI,
      remoteTarget,
      routeSet,
      secure
    };
    return dialogState;
  }
  /**
   * The UAS then constructs the state of the dialog.  This state MUST be
   * maintained for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.1
   * @param incomingRequestMessage - Incoming request message creating dialog.
   * @param toTag - Tag in the To field in the response to the incoming request.
   */
  static initialDialogStateForUserAgentServer(incomingRequestMessage, toTag, early = false) {
    const secure = false;
    const routeSet = incomingRequestMessage.getHeaders("record-route");
    const contact2 = incomingRequestMessage.parseHeader("contact");
    if (!contact2) {
      throw new Error("Contact undefined.");
    }
    if (!(contact2 instanceof NameAddrHeader$1)) {
      throw new Error("Contact not instance of NameAddrHeader.");
    }
    const remoteTarget = contact2.uri;
    const remoteSequenceNumber = incomingRequestMessage.cseq;
    const localSequenceNumber = void 0;
    const callId = incomingRequestMessage.callId;
    const localTag = toTag;
    const remoteTag = incomingRequestMessage.fromTag;
    const remoteURI = incomingRequestMessage.from.uri;
    const localURI = incomingRequestMessage.to.uri;
    const dialogState = {
      id: callId + localTag + remoteTag,
      early,
      callId,
      localTag,
      remoteTag,
      localSequenceNumber,
      remoteSequenceNumber,
      localURI,
      remoteURI,
      remoteTarget,
      routeSet,
      secure
    };
    return dialogState;
  }
  /** Destructor. */
  dispose() {
    this.core.dialogs.delete(this.id);
  }
  /**
   * A dialog is identified at each UA with a dialog ID, which consists of
   * a Call-ID value, a local tag and a remote tag.  The dialog ID at each
   * UA involved in the dialog is not the same.  Specifically, the local
   * tag at one UA is identical to the remote tag at the peer UA.  The
   * tags are opaque tokens that facilitate the generation of unique
   * dialog IDs.
   * https://tools.ietf.org/html/rfc3261#section-12
   */
  get id() {
    return this.dialogState.id;
  }
  /**
   * A dialog can also be in the "early" state, which occurs when it is
   * created with a provisional response, and then it transition to the
   * "confirmed" state when a 2xx final response received or is sent.
   *
   * Note: RFC 3261 is concise on when a dialog is "confirmed", but it
   * can be a point of confusion if an INVITE dialog is "confirmed" after
   * a 2xx is sent or after receiving the ACK for the 2xx response.
   * With careful reading it can be inferred a dialog is always is
   * "confirmed" when the 2xx is sent (regardless of type of dialog).
   * However a INVITE dialog does have additional considerations
   * when it is confirmed but an ACK has not yet been received (in
   * particular with regard to a callee sending BYE requests).
   */
  get early() {
    return this.dialogState.early;
  }
  /** Call identifier component of the dialog id. */
  get callId() {
    return this.dialogState.callId;
  }
  /** Local tag component of the dialog id. */
  get localTag() {
    return this.dialogState.localTag;
  }
  /** Remote tag component of the dialog id. */
  get remoteTag() {
    return this.dialogState.remoteTag;
  }
  /** Local sequence number (used to order requests from the UA to its peer). */
  get localSequenceNumber() {
    return this.dialogState.localSequenceNumber;
  }
  /** Remote sequence number (used to order requests from its peer to the UA). */
  get remoteSequenceNumber() {
    return this.dialogState.remoteSequenceNumber;
  }
  /** Local URI. */
  get localURI() {
    return this.dialogState.localURI;
  }
  /** Remote URI. */
  get remoteURI() {
    return this.dialogState.remoteURI;
  }
  /** Remote target. */
  get remoteTarget() {
    return this.dialogState.remoteTarget;
  }
  /**
   * Route set, which is an ordered list of URIs. The route set is the
   * list of servers that need to be traversed to send a request to the peer.
   */
  get routeSet() {
    return this.dialogState.routeSet;
  }
  /**
   * If the request was sent over TLS, and the Request-URI contained
   * a SIPS URI, the "secure" flag is set to true. *NOT IMPLEMENTED*
   */
  get secure() {
    return this.dialogState.secure;
  }
  /** The user agent core servicing this dialog. */
  get userAgentCore() {
    return this.core;
  }
  /** Confirm the dialog. Only matters if dialog is currently early. */
  confirm() {
    this.dialogState.early = false;
  }
  /**
   * Requests sent within a dialog, as any other requests, are atomic.  If
   * a particular request is accepted by the UAS, all the state changes
   * associated with it are performed.  If the request is rejected, none
   * of the state changes are performed.
   *
   *    Note that some requests, such as INVITEs, affect several pieces of
   *    state.
   *
   * https://tools.ietf.org/html/rfc3261#section-12.2.2
   * @param message - Incoming request message within this dialog.
   */
  receiveRequest(message2) {
    if (message2.method === C$1.ACK) {
      return;
    }
    if (this.remoteSequenceNumber) {
      if (message2.cseq <= this.remoteSequenceNumber) {
        throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
      }
      this.dialogState.remoteSequenceNumber = message2.cseq;
    }
    if (!this.remoteSequenceNumber) {
      this.dialogState.remoteSequenceNumber = message2.cseq;
    }
  }
  /**
   * If the dialog identifier in the 2xx response matches the dialog
   * identifier of an existing dialog, the dialog MUST be transitioned to
   * the "confirmed" state, and the route set for the dialog MUST be
   * recomputed based on the 2xx response using the procedures of Section
   * 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
   * constructed using the procedures of Section 12.1.2.
   *
   * Note that the only piece of state that is recomputed is the route
   * set.  Other pieces of state such as the highest sequence numbers
   * (remote and local) sent within the dialog are not recomputed.  The
   * route set only is recomputed for backwards compatibility.  RFC
   * 2543 did not mandate mirroring of the Record-Route header field in
   * a 1xx, only 2xx.  However, we cannot update the entire state of
   * the dialog, since mid-dialog requests may have been sent within
   * the early dialog, modifying the sequence numbers, for example.
   *
   *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4
   */
  recomputeRouteSet(message2) {
    this.dialogState.routeSet = message2.getHeaders("record-route").reverse();
  }
  /**
   * A request within a dialog is constructed by using many of the
   * components of the state stored as part of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.2.1.1
   * @param method - Outgoing request method.
   */
  createOutgoingRequestMessage(method, options) {
    const toUri = this.remoteURI;
    const toTag = this.remoteTag;
    const fromUri = this.localURI;
    const fromTag = this.localTag;
    const callId = this.callId;
    let cseq;
    if (options && options.cseq) {
      cseq = options.cseq;
    } else if (!this.dialogState.localSequenceNumber) {
      cseq = this.dialogState.localSequenceNumber = 1;
    } else {
      cseq = this.dialogState.localSequenceNumber += 1;
    }
    const ruri = this.remoteTarget;
    const routeSet = this.routeSet;
    const extraHeaders = options && options.extraHeaders;
    const body = options && options.body;
    const message2 = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {
      callId,
      cseq,
      fromTag,
      toTag,
      routeSet
    }, extraHeaders, body);
    return message2;
  }
  /**
   * Increment the local sequence number by one.
   * It feels like this should be protected, but the current authentication handling currently
   * needs this to keep the dialog in sync when "auto re-sends" request messages.
   * @internal
   */
  incrementLocalSequenceNumber() {
    if (!this.dialogState.localSequenceNumber) {
      throw new Error("Local sequence number undefined.");
    }
    this.dialogState.localSequenceNumber += 1;
  }
  /**
   * If the remote sequence number was not empty, but the sequence number
   * of the request is lower than the remote sequence number, the request
   * is out of order and MUST be rejected with a 500 (Server Internal
   * Error) response.
   * https://tools.ietf.org/html/rfc3261#section-12.2.2
   * @param request - Incoming request to guard.
   * @returns True if the program execution is to continue in the branch in question.
   *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.
   */
  sequenceGuard(message2) {
    if (message2.method === C$1.ACK) {
      return true;
    }
    if (this.remoteSequenceNumber && message2.cseq <= this.remoteSequenceNumber) {
      this.core.replyStateless(message2, { statusCode: 500 });
      return false;
    }
    return true;
  }
};
let InviteClientTransaction$1 = class InviteClientTransaction extends ClientTransaction$1 {
  /**
   * Constructor.
   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
   * Then `toString` is called on the outgoing request and the message is sent via the transport.
   * After construction the transaction will be in the "calling" state and the transaction id
   * will equal the branch parameter set in the Via header of the outgoing request.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1
   * @param request - The outgoing INVITE request.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState$1.Calling, "sip.transaction.ict");
    this.ackRetransmissionCache = /* @__PURE__ */ new Map();
    this.B = setTimeout(() => this.timerB(), Timers$1.TIMER_B);
    this.send(request.toString()).catch((error) => {
      this.logTransportError(error, "Failed to send initial outgoing request.");
    });
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.B) {
      clearTimeout(this.B);
      this.B = void 0;
    }
    if (this.D) {
      clearTimeout(this.D);
      this.D = void 0;
    }
    if (this.M) {
      clearTimeout(this.M);
      this.M = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "ict";
  }
  /**
   * ACK a 2xx final response.
   *
   * The transaction includes the ACK only if the final response was not a 2xx response (the
   * transaction will generate and send the ACK to the transport automagically). If the
   * final response was a 2xx, the ACK is not considered part of the transaction (the
   * transaction user needs to generate and send the ACK).
   *
   * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
   * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
   * by the transaction layer (instead of the UAC core). The "standard" approach is for
   * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
   * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
   * and any retransmissions of those ACKs as needed.
   *
   * @param ack - The outgoing ACK request.
   */
  ackResponse(ack) {
    const toTag = ack.toTag;
    if (!toTag) {
      throw new Error("To tag undefined.");
    }
    const id = "z9hG4bK" + Math.floor(Math.random() * 1e7);
    ack.setViaHeader(id, this.transport.protocol);
    this.ackRetransmissionCache.set(toTag, ack);
    this.send(ack.toString()).catch((error) => {
      this.logTransportError(error, "Failed to send ACK to 2xx response.");
    });
  }
  /**
   * Handler for incoming responses from the transport which match this transaction.
   * @param response - The incoming response.
   */
  receiveResponse(response) {
    const statusCode = response.statusCode;
    if (!statusCode || statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    switch (this.state) {
      case TransactionState$1.Calling:
        if (statusCode >= 100 && statusCode <= 199) {
          this.stateTransition(TransactionState$1.Proceeding);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 200 && statusCode <= 299) {
          this.ackRetransmissionCache.set(response.toTag, void 0);
          this.stateTransition(TransactionState$1.Accepted);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 300 && statusCode <= 699) {
          this.stateTransition(TransactionState$1.Completed);
          this.ack(response);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState$1.Proceeding:
        if (statusCode >= 100 && statusCode <= 199) {
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 200 && statusCode <= 299) {
          this.ackRetransmissionCache.set(response.toTag, void 0);
          this.stateTransition(TransactionState$1.Accepted);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 300 && statusCode <= 699) {
          this.stateTransition(TransactionState$1.Completed);
          this.ack(response);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState$1.Accepted:
        if (statusCode >= 200 && statusCode <= 299) {
          if (!this.ackRetransmissionCache.has(response.toTag)) {
            this.ackRetransmissionCache.set(response.toTag, void 0);
            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }
            return;
          }
          const ack = this.ackRetransmissionCache.get(response.toTag);
          if (ack) {
            this.send(ack.toString()).catch((error) => {
              this.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
            });
            return;
          }
          return;
        }
        break;
      case TransactionState$1.Completed:
        if (statusCode >= 300 && statusCode <= 699) {
          this.ack(response);
          return;
        }
        break;
      case TransactionState$1.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `Received unexpected ${statusCode} response while in state ${this.state}.`;
    this.logger.warn(message2);
    return;
  }
  /**
   * The client transaction SHOULD inform the TU that a transport failure
   * has occurred, and the client transaction SHOULD transition directly
   * to the "Terminated" state.  The TU will handle the failover
   * mechanisms described in [4].
   * https://tools.ietf.org/html/rfc3261#section-17.1.4
   * @param error - The error.
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
    this.stateTransition(TransactionState$1.Terminated, true);
  }
  /** For logging. */
  typeToString() {
    return "INVITE client transaction";
  }
  ack(response) {
    const ruri = this.request.ruri;
    const callId = this.request.callId;
    const cseq = this.request.cseq;
    const from = this.request.getHeader("from");
    const to = response.getHeader("to");
    const via = this.request.getHeader("via");
    const route = this.request.getHeader("route");
    if (!from) {
      throw new Error("From undefined.");
    }
    if (!to) {
      throw new Error("To undefined.");
    }
    if (!via) {
      throw new Error("Via undefined.");
    }
    let ack = `ACK ${ruri} SIP/2.0\r
`;
    if (route) {
      ack += `Route: ${route}\r
`;
    }
    ack += `Via: ${via}\r
`;
    ack += `To: ${to}\r
`;
    ack += `From: ${from}\r
`;
    ack += `Call-ID: ${callId}\r
`;
    ack += `CSeq: ${cseq} ACK\r
`;
    ack += `Max-Forwards: 70\r
`;
    ack += `Content-Length: 0\r
\r
`;
    this.send(ack).catch((error) => {
      this.logTransportError(error, "Failed to send ACK to non-2xx response.");
    });
    return;
  }
  /**
   * Execute a state transition.
   * @param newState - New state.
   */
  stateTransition(newState, dueToTransportError = false) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState$1.Calling:
        invalidStateTransition();
        break;
      case TransactionState$1.Proceeding:
        if (this.state !== TransactionState$1.Calling) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Accepted:
      case TransactionState$1.Completed:
        if (this.state !== TransactionState$1.Calling && this.state !== TransactionState$1.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Terminated:
        if (this.state !== TransactionState$1.Calling && this.state !== TransactionState$1.Accepted && this.state !== TransactionState$1.Completed) {
          if (!dueToTransportError) {
            invalidStateTransition();
          }
        }
        break;
      default:
        invalidStateTransition();
    }
    if (this.B) {
      clearTimeout(this.B);
      this.B = void 0;
    }
    if (newState === TransactionState$1.Proceeding) ;
    if (newState === TransactionState$1.Completed) {
      this.D = setTimeout(() => this.timerD(), Timers$1.TIMER_D);
    }
    if (newState === TransactionState$1.Accepted) {
      this.M = setTimeout(() => this.timerM(), Timers$1.TIMER_M);
    }
    if (newState === TransactionState$1.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * When timer A fires, the client transaction MUST retransmit the
   * request by passing it to the transport layer, and MUST reset the
   * timer with a value of 2*T1.
   * When timer A fires 2*T1 seconds later, the request MUST be
   * retransmitted again (assuming the client transaction is still in this
   * state). This process MUST continue so that the request is
   * retransmitted with intervals that double after each transmission.
   * These retransmissions SHOULD only be done while the client
   * transaction is in the "Calling" state.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
   */
  timerA() {
  }
  /**
   * If the client transaction is still in the "Calling" state when timer
   * B fires, the client transaction SHOULD inform the TU that a timeout
   * has occurred.  The client transaction MUST NOT generate an ACK.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
   */
  timerB() {
    this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState$1.Calling) {
      this.onRequestTimeout();
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
  /**
   * If Timer D fires while the client transaction is in the "Completed" state,
   * the client transaction MUST move to the "Terminated" state.
   * https://tools.ietf.org/html/rfc6026#section-8.4
   */
  timerD() {
    this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState$1.Completed) {
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
  /**
   * If Timer M fires while the client transaction is in the "Accepted"
   * state, the client transaction MUST move to the "Terminated" state.
   * https://tools.ietf.org/html/rfc6026#section-8.4
   */
  timerM() {
    this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState$1.Accepted) {
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
};
let UserAgentClient$1 = class UserAgentClient {
  constructor(transactionConstructor, core2, message2, delegate) {
    this.transactionConstructor = transactionConstructor;
    this.core = core2;
    this.message = message2;
    this.delegate = delegate;
    this.challenged = false;
    this.stale = false;
    this.logger = this.loggerFactory.getLogger("sip.user-agent-client");
    this.init();
  }
  dispose() {
    this.transaction.dispose();
  }
  get loggerFactory() {
    return this.core.loggerFactory;
  }
  /** The transaction associated with this request. */
  get transaction() {
    if (!this._transaction) {
      throw new Error("Transaction undefined.");
    }
    return this._transaction;
  }
  /**
   * Since requests other than INVITE are responded to immediately, sending a
   * CANCEL for a non-INVITE request would always create a race condition.
   * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
   * https://tools.ietf.org/html/rfc3261#section-9.1
   * @param options - Cancel options bucket.
   */
  cancel(reason, options = {}) {
    if (!this.transaction) {
      throw new Error("Transaction undefined.");
    }
    if (!this.message.to) {
      throw new Error("To undefined.");
    }
    if (!this.message.from) {
      throw new Error("From undefined.");
    }
    const message2 = this.core.makeOutgoingRequestMessage(C$1.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
      toTag: this.message.toTag,
      fromTag: this.message.fromTag,
      callId: this.message.callId,
      cseq: this.message.cseq
    }, options.extraHeaders);
    message2.branch = this.message.branch;
    if (this.message.headers.Route) {
      message2.headers.Route = this.message.headers.Route;
    }
    if (reason) {
      message2.setHeader("Reason", reason);
    }
    if (this.transaction.state === TransactionState$1.Proceeding) {
      new UserAgentClient(NonInviteClientTransaction$1, this.core, message2);
    } else {
      this.transaction.addStateChangeListener(() => {
        if (this.transaction && this.transaction.state === TransactionState$1.Proceeding) {
          new UserAgentClient(NonInviteClientTransaction$1, this.core, message2);
        }
      }, { once: true });
    }
    return message2;
  }
  /**
   * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
   * response is received, the UAC SHOULD follow the authorization
   * procedures of Section 22.2 and Section 22.3 to retry the request with
   * credentials.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3.5
   * 22 Usage of HTTP Authentication
   * https://tools.ietf.org/html/rfc3261#section-22
   * 22.1 Framework
   * https://tools.ietf.org/html/rfc3261#section-22.1
   * 22.2 User-to-User Authentication
   * https://tools.ietf.org/html/rfc3261#section-22.2
   * 22.3 Proxy-to-User Authentication
   * https://tools.ietf.org/html/rfc3261#section-22.3
   *
   * FIXME: This "guard for and retry the request with credentials"
   * implementation is not complete and at best minimally passable.
   * @param response - The incoming response to guard.
   * @param dialog - If defined, the dialog within which the response was received.
   * @returns True if the program execution is to continue in the branch in question.
   *          Otherwise the request is retried with credentials and current request processing must stop.
   */
  authenticationGuard(message2, dialog) {
    const statusCode = message2.statusCode;
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    if (statusCode !== 401 && statusCode !== 407) {
      return true;
    }
    let challenge;
    let authorizationHeaderName;
    if (statusCode === 401) {
      challenge = message2.parseHeader("www-authenticate");
      authorizationHeaderName = "authorization";
    } else {
      challenge = message2.parseHeader("proxy-authenticate");
      authorizationHeaderName = "proxy-authorization";
    }
    if (!challenge) {
      this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
      return true;
    }
    if (this.challenged && (this.stale || challenge.stale !== true)) {
      this.logger.warn(statusCode + " apparently in authentication loop, cannot authenticate");
      return true;
    }
    if (!this.credentials) {
      this.credentials = this.core.configuration.authenticationFactory();
      if (!this.credentials) {
        this.logger.warn("Unable to obtain credentials, cannot authenticate");
        return true;
      }
    }
    if (!this.credentials.authenticate(this.message, challenge)) {
      return true;
    }
    this.challenged = true;
    if (challenge.stale) {
      this.stale = true;
    }
    let cseq = this.message.cseq += 1;
    if (dialog && dialog.localSequenceNumber) {
      dialog.incrementLocalSequenceNumber();
      cseq = this.message.cseq = dialog.localSequenceNumber;
    }
    this.message.setHeader("cseq", cseq + " " + this.message.method);
    this.message.setHeader(authorizationHeaderName, this.credentials.toString());
    this.init();
    return false;
  }
  /**
   * 8.1.3.1 Transaction Layer Errors
   * In some cases, the response returned by the transaction layer will
   * not be a SIP message, but rather a transaction layer error.  When a
   * timeout error is received from the transaction layer, it MUST be
   * treated as if a 408 (Request Timeout) status code has been received.
   * If a fatal transport error is reported by the transport layer
   * (generally, due to fatal ICMP errors in UDP or connection failures in
   * TCP), the condition MUST be treated as a 503 (Service Unavailable)
   * status code.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
   */
  onRequestTimeout() {
    this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
    const message2 = new IncomingResponseMessage$1();
    message2.statusCode = 408;
    message2.reasonPhrase = "Request Timeout";
    this.receiveResponse(message2);
    return;
  }
  /**
   * 8.1.3.1 Transaction Layer Errors
   * In some cases, the response returned by the transaction layer will
   * not be a SIP message, but rather a transaction layer error.  When a
   * timeout error is received from the transaction layer, it MUST be
   * treated as if a 408 (Request Timeout) status code has been received.
   * If a fatal transport error is reported by the transport layer
   * (generally, due to fatal ICMP errors in UDP or connection failures in
   * TCP), the condition MUST be treated as a 503 (Service Unavailable)
   * status code.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
   * @param error - Transport error
   */
  onTransportError(error) {
    this.logger.error(error.message);
    this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
    const message2 = new IncomingResponseMessage$1();
    message2.statusCode = 503;
    message2.reasonPhrase = "Service Unavailable";
    this.receiveResponse(message2);
  }
  /**
   * Receive a response from the transaction layer.
   * @param message - Incoming response message.
   */
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2)) {
      return;
    }
    const statusCode = message2.statusCode ? message2.statusCode.toString() : "";
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    switch (true) {
      case /^100$/.test(statusCode):
        if (this.delegate && this.delegate.onTrying) {
          this.delegate.onTrying({ message: message2 });
        }
        break;
      case /^1[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onProgress) {
          this.delegate.onProgress({ message: message2 });
        }
        break;
      case /^2[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onAccept) {
          this.delegate.onAccept({ message: message2 });
        }
        break;
      case /^3[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onRedirect) {
          this.delegate.onRedirect({ message: message2 });
        }
        break;
      case /^[4-6][0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onReject) {
          this.delegate.onReject({ message: message2 });
        }
        break;
      default:
        throw new Error(`Invalid status code ${statusCode}`);
    }
  }
  init() {
    const user = {
      loggerFactory: this.loggerFactory,
      onRequestTimeout: () => this.onRequestTimeout(),
      onStateChange: (newState) => {
        if (newState === TransactionState$1.Terminated) {
          this.core.userAgentClients.delete(userAgentClientId);
          if (transaction === this._transaction) {
            this.dispose();
          }
        }
      },
      onTransportError: (error) => this.onTransportError(error),
      receiveResponse: (message2) => this.receiveResponse(message2)
    };
    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);
    this._transaction = transaction;
    const userAgentClientId = transaction.id + transaction.request.method;
    this.core.userAgentClients.set(userAgentClientId, this);
  }
};
let ByeUserAgentClient$1 = class ByeUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.BYE, options);
    super(NonInviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
    dialog.dispose();
  }
};
let NonInviteServerTransaction$1 = class NonInviteServerTransaction extends ServerTransaction$1 {
  /**
   * Constructor.
   * After construction the transaction will be in the "trying": state and the transaction
   * `id` will equal the branch parameter set in the Via header of the incoming request.
   * https://tools.ietf.org/html/rfc3261#section-17.2.2
   * @param request - Incoming Non-INVITE request from the transport.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState$1.Trying, "sip.transaction.nist");
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.J) {
      clearTimeout(this.J);
      this.J = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "nist";
  }
  /**
   * Receive requests from transport matching this transaction.
   * @param request - Request matching this transaction.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  receiveRequest(request) {
    switch (this.state) {
      case TransactionState$1.Trying:
        break;
      case TransactionState$1.Proceeding:
        if (!this.lastResponse) {
          throw new Error("Last response undefined.");
        }
        this.send(this.lastResponse).catch((error) => {
          this.logTransportError(error, "Failed to send retransmission of provisional response.");
        });
        break;
      case TransactionState$1.Completed:
        if (!this.lastResponse) {
          throw new Error("Last response undefined.");
        }
        this.send(this.lastResponse).catch((error) => {
          this.logTransportError(error, "Failed to send retransmission of final response.");
        });
        break;
      case TransactionState$1.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
  }
  /**
   * Receive responses from TU for this transaction.
   * @param statusCode - Status code of response. 101-199 not allowed per RFC 4320.
   * @param response - Response to send.
   */
  receiveResponse(statusCode, response) {
    if (statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    if (statusCode > 100 && statusCode <= 199) {
      throw new Error("Provisional response other than 100 not allowed.");
    }
    switch (this.state) {
      case TransactionState$1.Trying:
        this.lastResponse = response;
        if (statusCode >= 100 && statusCode < 200) {
          this.stateTransition(TransactionState$1.Proceeding);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send provisional response.");
          });
          return;
        }
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState$1.Completed);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send final response.");
          });
          return;
        }
        break;
      case TransactionState$1.Proceeding:
        this.lastResponse = response;
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState$1.Completed);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send final response.");
          });
          return;
        }
        break;
      case TransactionState$1.Completed:
        return;
      case TransactionState$1.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `Non-INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;
    this.logger.error(message2);
    throw new Error(message2);
  }
  /**
   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
   * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
   * https://tools.ietf.org/html/rfc3261#section-17.2.4
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
    this.stateTransition(TransactionState$1.Terminated, true);
  }
  /** For logging. */
  typeToString() {
    return "non-INVITE server transaction";
  }
  stateTransition(newState, dueToTransportError = false) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState$1.Trying:
        invalidStateTransition();
        break;
      case TransactionState$1.Proceeding:
        if (this.state !== TransactionState$1.Trying) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Completed:
        if (this.state !== TransactionState$1.Trying && this.state !== TransactionState$1.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState$1.Terminated:
        if (this.state !== TransactionState$1.Proceeding && this.state !== TransactionState$1.Completed) {
          if (!dueToTransportError) {
            invalidStateTransition();
          }
        }
        break;
      default:
        invalidStateTransition();
    }
    if (newState === TransactionState$1.Completed) {
      this.J = setTimeout(() => this.timerJ(), Timers$1.TIMER_J);
    }
    if (newState === TransactionState$1.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * The server transaction remains in this state until Timer J fires,
   * at which point it MUST transition to the "Terminated" state.
   * https://tools.ietf.org/html/rfc3261#section-17.2.2
   */
  timerJ() {
    this.logger.debug(`Timer J expired for NON-INVITE server transaction ${this.id}.`);
    if (this.state === TransactionState$1.Completed) {
      this.stateTransition(TransactionState$1.Terminated);
    }
  }
};
let UserAgentServer$1 = class UserAgentServer {
  constructor(transactionConstructor, core2, message2, delegate) {
    this.transactionConstructor = transactionConstructor;
    this.core = core2;
    this.message = message2;
    this.delegate = delegate;
    this.logger = this.loggerFactory.getLogger("sip.user-agent-server");
    this.toTag = message2.toTag ? message2.toTag : newTag$1();
    this.init();
  }
  dispose() {
    this.transaction.dispose();
  }
  get loggerFactory() {
    return this.core.loggerFactory;
  }
  /** The transaction associated with this request. */
  get transaction() {
    if (!this._transaction) {
      throw new Error("Transaction undefined.");
    }
    return this._transaction;
  }
  accept(options = { statusCode: 200 }) {
    if (!this.acceptable) {
      throw new TransactionStateError$1(`${this.message.method} not acceptable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 200 || statusCode > 299) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const response = this.reply(options);
    return response;
  }
  progress(options = { statusCode: 180 }) {
    if (!this.progressable) {
      throw new TransactionStateError$1(`${this.message.method} not progressable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 101 || statusCode > 199) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const response = this.reply(options);
    return response;
  }
  redirect(contacts, options = { statusCode: 302 }) {
    if (!this.redirectable) {
      throw new TransactionStateError$1(`${this.message.method} not redirectable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 300 || statusCode > 399) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const contactHeaders = new Array();
    contacts.forEach((contact2) => contactHeaders.push(`Contact: ${contact2.toString()}`));
    options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);
    const response = this.reply(options);
    return response;
  }
  reject(options = { statusCode: 480 }) {
    if (!this.rejectable) {
      throw new TransactionStateError$1(`${this.message.method} not rejectable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 400 || statusCode > 699) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const response = this.reply(options);
    return response;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trying(options) {
    if (!this.tryingable) {
      throw new TransactionStateError$1(`${this.message.method} not tryingable in state ${this.transaction.state}.`);
    }
    const response = this.reply({ statusCode: 100 });
    return response;
  }
  /**
   * If the UAS did not find a matching transaction for the CANCEL
   * according to the procedure above, it SHOULD respond to the CANCEL
   * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction
   * for the original request still exists, the behavior of the UAS on
   * receiving a CANCEL request depends on whether it has already sent a
   * final response for the original request.  If it has, the CANCEL
   * request has no effect on the processing of the original request, no
   * effect on any session state, and no effect on the responses generated
   * for the original request.  If the UAS has not issued a final response
   * for the original request, its behavior depends on the method of the
   * original request.  If the original request was an INVITE, the UAS
   * SHOULD immediately respond to the INVITE with a 487 (Request
   * Terminated).  A CANCEL request has no impact on the processing of
   * transactions with any other method defined in this specification.
   * https://tools.ietf.org/html/rfc3261#section-9.2
   * @param request - Incoming CANCEL request.
   */
  receiveCancel(message2) {
    if (this.delegate && this.delegate.onCancel) {
      this.delegate.onCancel(message2);
    }
  }
  get acceptable() {
    if (this.transaction instanceof InviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Proceeding || this.transaction.state === TransactionState$1.Accepted;
    }
    if (this.transaction instanceof NonInviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Trying || this.transaction.state === TransactionState$1.Proceeding;
    }
    throw new Error("Unknown transaction type.");
  }
  get progressable() {
    if (this.transaction instanceof InviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction$1) {
      return false;
    }
    throw new Error("Unknown transaction type.");
  }
  get redirectable() {
    if (this.transaction instanceof InviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Trying || this.transaction.state === TransactionState$1.Proceeding;
    }
    throw new Error("Unknown transaction type.");
  }
  get rejectable() {
    if (this.transaction instanceof InviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Trying || this.transaction.state === TransactionState$1.Proceeding;
    }
    throw new Error("Unknown transaction type.");
  }
  get tryingable() {
    if (this.transaction instanceof InviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction$1) {
      return this.transaction.state === TransactionState$1.Trying;
    }
    throw new Error("Unknown transaction type.");
  }
  /**
   * When a UAS wishes to construct a response to a request, it follows
   * the general procedures detailed in the following subsections.
   * Additional behaviors specific to the response code in question, which
   * are not detailed in this section, may also be required.
   *
   * Once all procedures associated with the creation of a response have
   * been completed, the UAS hands the response back to the server
   * transaction from which it received the request.
   * https://tools.ietf.org/html/rfc3261#section-8.2.6
   * @param statusCode - Status code to reply with.
   * @param options - Reply options bucket.
   */
  reply(options) {
    if (!options.toTag && options.statusCode !== 100) {
      options.toTag = this.toTag;
    }
    options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;
    options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;
    const response = constructOutgoingResponse$1(this.message, options);
    this.transaction.receiveResponse(options.statusCode, response.message);
    return response;
  }
  init() {
    const user = {
      loggerFactory: this.loggerFactory,
      onStateChange: (newState) => {
        if (newState === TransactionState$1.Terminated) {
          this.core.userAgentServers.delete(userAgentServerId);
          this.dispose();
        }
      },
      onTransportError: (error) => {
        this.logger.error(error.message);
        if (this.delegate && this.delegate.onTransportError) {
          this.delegate.onTransportError(error);
        } else {
          this.logger.error("User agent server response transport error.");
        }
      }
    };
    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);
    this._transaction = transaction;
    const userAgentServerId = transaction.id;
    this.core.userAgentServers.set(transaction.id, this);
  }
};
let ByeUserAgentServer$1 = class ByeUserAgentServer extends UserAgentServer$1 {
  constructor(dialog, message2, delegate) {
    super(NonInviteServerTransaction$1, dialog.userAgentCore, message2, delegate);
  }
};
let InfoUserAgentClient$1 = class InfoUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.INFO, options);
    super(NonInviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
  }
};
let InfoUserAgentServer$1 = class InfoUserAgentServer extends UserAgentServer$1 {
  constructor(dialog, message2, delegate) {
    super(NonInviteServerTransaction$1, dialog.userAgentCore, message2, delegate);
  }
};
let MessageUserAgentClient$1 = class MessageUserAgentClient extends UserAgentClient$1 {
  constructor(core2, message2, delegate) {
    super(NonInviteClientTransaction$1, core2, message2, delegate);
  }
};
let MessageUserAgentServer$1 = class MessageUserAgentServer extends UserAgentServer$1 {
  constructor(core2, message2, delegate) {
    super(NonInviteServerTransaction$1, core2, message2, delegate);
  }
};
let NotifyUserAgentClient$1 = class NotifyUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.NOTIFY, options);
    super(NonInviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
  }
};
function instanceOfDialog$1(object) {
  return object.userAgentCore !== void 0;
}
let NotifyUserAgentServer$1 = class NotifyUserAgentServer extends UserAgentServer$1 {
  /**
   * NOTIFY UAS constructor.
   * @param dialogOrCore - Dialog for in dialog NOTIFY, UserAgentCore for out of dialog NOTIFY (deprecated).
   * @param message - Incoming NOTIFY request message.
   */
  constructor(dialogOrCore, message2, delegate) {
    const userAgentCore = instanceOfDialog$1(dialogOrCore) ? dialogOrCore.userAgentCore : dialogOrCore;
    super(NonInviteServerTransaction$1, userAgentCore, message2, delegate);
  }
};
let PrackUserAgentClient$1 = class PrackUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.PRACK, options);
    super(NonInviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
    dialog.signalingStateTransition(message2);
  }
};
let PrackUserAgentServer$1 = class PrackUserAgentServer extends UserAgentServer$1 {
  constructor(dialog, message2, delegate) {
    super(NonInviteServerTransaction$1, dialog.userAgentCore, message2, delegate);
    dialog.signalingStateTransition(message2);
    this.dialog = dialog;
  }
  /**
   * Update the dialog signaling state on a 2xx response.
   * @param options - Options bucket.
   */
  accept(options = { statusCode: 200 }) {
    if (options.body) {
      this.dialog.signalingStateTransition(options.body);
    }
    return super.accept(options);
  }
};
let ReInviteUserAgentClient$1 = class ReInviteUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.INVITE, options);
    super(InviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
    this.delegate = delegate;
    dialog.signalingStateTransition(message2);
    dialog.reinviteUserAgentClient = this;
    this.dialog = dialog;
  }
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2, this.dialog)) {
      return;
    }
    const statusCode = message2.statusCode ? message2.statusCode.toString() : "";
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    switch (true) {
      case /^100$/.test(statusCode):
        if (this.delegate && this.delegate.onTrying) {
          this.delegate.onTrying({ message: message2 });
        }
        break;
      case /^1[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onProgress) {
          this.delegate.onProgress({
            message: message2,
            session: this.dialog,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            prack: (options) => {
              throw new Error("Unimplemented.");
            }
          });
        }
        break;
      case /^2[0-9]{2}$/.test(statusCode):
        this.dialog.signalingStateTransition(message2);
        if (this.delegate && this.delegate.onAccept) {
          this.delegate.onAccept({
            message: message2,
            session: this.dialog,
            ack: (options) => {
              const outgoingAckRequest = this.dialog.ack(options);
              return outgoingAckRequest;
            }
          });
        }
        break;
      case /^3[0-9]{2}$/.test(statusCode):
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentClient = void 0;
        if (this.delegate && this.delegate.onRedirect) {
          this.delegate.onRedirect({ message: message2 });
        }
        break;
      case /^[4-6][0-9]{2}$/.test(statusCode):
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentClient = void 0;
        if (this.delegate && this.delegate.onReject) {
          this.delegate.onReject({ message: message2 });
        }
        break;
      default:
        throw new Error(`Invalid status code ${statusCode}`);
    }
  }
};
let ReInviteUserAgentServer$1 = class ReInviteUserAgentServer extends UserAgentServer$1 {
  constructor(dialog, message2, delegate) {
    super(InviteServerTransaction$1, dialog.userAgentCore, message2, delegate);
    dialog.reinviteUserAgentServer = this;
    this.dialog = dialog;
  }
  /**
   * Update the dialog signaling state on a 2xx response.
   * @param options - Options bucket.
   */
  accept(options = { statusCode: 200 }) {
    options.extraHeaders = options.extraHeaders || [];
    options.extraHeaders = options.extraHeaders.concat(this.dialog.routeSet.map((route) => `Record-Route: ${route}`));
    const response = super.accept(options);
    const session2 = this.dialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      this.dialog.signalingStateTransition(options.body);
    }
    this.dialog.reConfirm();
    return result;
  }
  /**
   * Update the dialog signaling state on a 1xx response.
   * @param options - Progress options bucket.
   */
  progress(options = { statusCode: 180 }) {
    const response = super.progress(options);
    const session2 = this.dialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      this.dialog.signalingStateTransition(options.body);
    }
    return result;
  }
  /**
   * TODO: Not Yet Supported
   * @param contacts - Contacts to redirect to.
   * @param options - Redirect options bucket.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  redirect(contacts, options = { statusCode: 302 }) {
    this.dialog.signalingStateRollback();
    this.dialog.reinviteUserAgentServer = void 0;
    throw new Error("Unimplemented.");
  }
  /**
   * 3.1 Background on Re-INVITE Handling by UASs
   * An error response to a re-INVITE has the following semantics.  As
   * specified in Section 12.2.2 of RFC 3261 [RFC3261], if a re-INVITE is
   * rejected, no state changes are performed.
   * https://tools.ietf.org/html/rfc6141#section-3.1
   * @param options - Reject options bucket.
   */
  reject(options = { statusCode: 488 }) {
    this.dialog.signalingStateRollback();
    this.dialog.reinviteUserAgentServer = void 0;
    return super.reject(options);
  }
};
let ReferUserAgentClient$1 = class ReferUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.REFER, options);
    super(NonInviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
  }
};
function instanceOfSessionDialog$1(object) {
  return object.userAgentCore !== void 0;
}
let ReferUserAgentServer$1 = class ReferUserAgentServer extends UserAgentServer$1 {
  /**
   * REFER UAS constructor.
   * @param dialogOrCore - Dialog for in dialog REFER, UserAgentCore for out of dialog REFER.
   * @param message - Incoming REFER request message.
   */
  constructor(dialogOrCore, message2, delegate) {
    const userAgentCore = instanceOfSessionDialog$1(dialogOrCore) ? dialogOrCore.userAgentCore : dialogOrCore;
    super(NonInviteServerTransaction$1, userAgentCore, message2, delegate);
  }
};
let SessionDialog$1 = class SessionDialog extends Dialog$1 {
  constructor(initialTransaction, core2, state, delegate) {
    super(core2, state);
    this.initialTransaction = initialTransaction;
    this._signalingState = SignalingState$1.Initial;
    this.ackWait = false;
    this.ackProcessing = false;
    this.delegate = delegate;
    if (initialTransaction instanceof InviteServerTransaction$1) {
      this.ackWait = true;
    }
    if (!this.early) {
      this.start2xxRetransmissionTimer();
    }
    this.signalingStateTransition(initialTransaction.request);
    this.logger = core2.loggerFactory.getLogger("sip.invite-dialog");
    this.logger.log(`INVITE dialog ${this.id} constructed`);
  }
  dispose() {
    super.dispose();
    this._signalingState = SignalingState$1.Closed;
    this._offer = void 0;
    this._answer = void 0;
    if (this.invite2xxTimer) {
      clearTimeout(this.invite2xxTimer);
      this.invite2xxTimer = void 0;
    }
    this.logger.log(`INVITE dialog ${this.id} destroyed`);
  }
  // FIXME: Need real state machine
  get sessionState() {
    if (this.early) {
      return SessionState$3.Early;
    } else if (this.ackWait) {
      return SessionState$3.AckWait;
    } else if (this._signalingState === SignalingState$1.Closed) {
      return SessionState$3.Terminated;
    } else {
      return SessionState$3.Confirmed;
    }
  }
  /** The state of the offer/answer exchange. */
  get signalingState() {
    return this._signalingState;
  }
  /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */
  get offer() {
    return this._offer;
  }
  /** The current answer. Undefined unless signaling state Stable. */
  get answer() {
    return this._answer;
  }
  /** Confirm the dialog. Only matters if dialog is currently early. */
  confirm() {
    if (this.early) {
      this.start2xxRetransmissionTimer();
    }
    super.confirm();
  }
  /** Re-confirm the dialog. Only matters if handling re-INVITE request. */
  reConfirm() {
    if (this.reinviteUserAgentServer) {
      this.startReInvite2xxRetransmissionTimer();
    }
  }
  /**
   * The UAC core MUST generate an ACK request for each 2xx received from
   * the transaction layer.  The header fields of the ACK are constructed
   * in the same way as for any request sent within a dialog (see Section
   * 12) with the exception of the CSeq and the header fields related to
   * authentication.  The sequence number of the CSeq header field MUST be
   * the same as the INVITE being acknowledged, but the CSeq method MUST
   * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
   * the 2xx contains an offer (based on the rules above), the ACK MUST
   * carry an answer in its body.  If the offer in the 2xx response is not
   * acceptable, the UAC core MUST generate a valid answer in the ACK and
   * then send a BYE immediately.
   * https://tools.ietf.org/html/rfc3261#section-13.2.2.4
   * @param options - ACK options bucket.
   */
  ack(options = {}) {
    this.logger.log(`INVITE dialog ${this.id} sending ACK request`);
    let transaction;
    if (this.reinviteUserAgentClient) {
      if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction$1)) {
        throw new Error("Transaction not instance of InviteClientTransaction.");
      }
      transaction = this.reinviteUserAgentClient.transaction;
      this.reinviteUserAgentClient = void 0;
    } else {
      if (!(this.initialTransaction instanceof InviteClientTransaction$1)) {
        throw new Error("Initial transaction not instance of InviteClientTransaction.");
      }
      transaction = this.initialTransaction;
    }
    const message2 = this.createOutgoingRequestMessage(C$1.ACK, {
      cseq: transaction.request.cseq,
      extraHeaders: options.extraHeaders,
      body: options.body
    });
    transaction.ackResponse(message2);
    this.signalingStateTransition(message2);
    return { message: message2 };
  }
  /**
   * Terminating a Session
   *
   * This section describes the procedures for terminating a session
   * established by SIP.  The state of the session and the state of the
   * dialog are very closely related.  When a session is initiated with an
   * INVITE, each 1xx or 2xx response from a distinct UAS creates a
   * dialog, and if that response completes the offer/answer exchange, it
   * also creates a session.  As a result, each session is "associated"
   * with a single dialog - the one which resulted in its creation.  If an
   * initial INVITE generates a non-2xx final response, that terminates
   * all sessions (if any) and all dialogs (if any) that were created
   * through responses to the request.  By virtue of completing the
   * transaction, a non-2xx final response also prevents further sessions
   * from being created as a result of the INVITE.  The BYE request is
   * used to terminate a specific session or attempted session.  In this
   * case, the specific session is the one with the peer UA on the other
   * side of the dialog.  When a BYE is received on a dialog, any session
   * associated with that dialog SHOULD terminate.  A UA MUST NOT send a
   * BYE outside of a dialog.  The caller's UA MAY send a BYE for either
   * confirmed or early dialogs, and the callee's UA MAY send a BYE on
   * confirmed dialogs, but MUST NOT send a BYE on early dialogs.
   *
   * However, the callee's UA MUST NOT send a BYE on a confirmed dialog
   * until it has received an ACK for its 2xx response or until the server
   * transaction times out.  If no SIP extensions have defined other
   * application layer states associated with the dialog, the BYE also
   * terminates the dialog.
   *
   * https://tools.ietf.org/html/rfc3261#section-15
   * FIXME: Make these proper Exceptions...
   * @param options - BYE options bucket.
   * @returns
   * Throws `Error` if callee's UA attempts a BYE on an early dialog.
   * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog
   *                while it's waiting on the ACK for its 2xx response.
   */
  bye(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending BYE request`);
    if (this.initialTransaction instanceof InviteServerTransaction$1) {
      if (this.early) {
        throw new Error("UAS MUST NOT send a BYE on early dialogs.");
      }
      if (this.ackWait && this.initialTransaction.state !== TransactionState$1.Terminated) {
        throw new Error("UAS MUST NOT send a BYE on a confirmed dialog until it has received an ACK for its 2xx response or until the server transaction times out.");
      }
    }
    return new ByeUserAgentClient$1(this, delegate, options);
  }
  /**
   * An INFO request can be associated with an Info Package (see
   * Section 5), or associated with a legacy INFO usage (see Section 2).
   *
   * The construction of the INFO request is the same as any other
   * non-target refresh request within an existing invite dialog usage as
   * described in Section 12.2 of RFC 3261.
   * https://tools.ietf.org/html/rfc6086#section-4.2.1
   * @param options - Options bucket.
   */
  info(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending INFO request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    return new InfoUserAgentClient$1(this, delegate, options);
  }
  /**
   * Modifying an Existing Session
   *
   * A successful INVITE request (see Section 13) establishes both a
   * dialog between two user agents and a session using the offer-answer
   * model.  Section 12 explains how to modify an existing dialog using a
   * target refresh request (for example, changing the remote target URI
   * of the dialog).  This section describes how to modify the actual
   * session.  This modification can involve changing addresses or ports,
   * adding a media stream, deleting a media stream, and so on.  This is
   * accomplished by sending a new INVITE request within the same dialog
   * that established the session.  An INVITE request sent within an
   * existing dialog is known as a re-INVITE.
   *
   *    Note that a single re-INVITE can modify the dialog and the
   *    parameters of the session at the same time.
   *
   * Either the caller or callee can modify an existing session.
   * https://tools.ietf.org/html/rfc3261#section-14
   * @param options - Options bucket
   */
  invite(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending INVITE request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    if (this.reinviteUserAgentClient) {
      throw new Error("There is an ongoing re-INVITE client transaction.");
    }
    if (this.reinviteUserAgentServer) {
      throw new Error("There is an ongoing re-INVITE server transaction.");
    }
    return new ReInviteUserAgentClient$1(this, delegate, options);
  }
  /**
   * A UAC MAY associate a MESSAGE request with an existing dialog.  If a
   * MESSAGE request is sent within a dialog, it is "associated" with any
   * media session or sessions associated with that dialog.
   * https://tools.ietf.org/html/rfc3428#section-4
   * @param options - Options bucket.
   */
  message(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    const message2 = this.createOutgoingRequestMessage(C$1.MESSAGE, options);
    return new MessageUserAgentClient$1(this.core, message2, delegate);
  }
  /**
   * The NOTIFY mechanism defined in [2] MUST be used to inform the agent
   * sending the REFER of the status of the reference.
   * https://tools.ietf.org/html/rfc3515#section-2.4.4
   * @param options - Options bucket.
   */
  notify(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    return new NotifyUserAgentClient$1(this, delegate, options);
  }
  /**
   * Assuming the response is to be transmitted reliably, the UAC MUST
   * create a new request with method PRACK.  This request is sent within
   * the dialog associated with the provisional response (indeed, the
   * provisional response may have created the dialog).  PRACK requests
   * MAY contain bodies, which are interpreted according to their type and
   * disposition.
   * https://tools.ietf.org/html/rfc3262#section-4
   * @param options - Options bucket.
   */
  prack(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending PRACK request`);
    return new PrackUserAgentClient$1(this, delegate, options);
  }
  /**
   * REFER is a SIP request and is constructed as defined in [1].  A REFER
   * request MUST contain exactly one Refer-To header field value.
   * https://tools.ietf.org/html/rfc3515#section-2.4.1
   * @param options - Options bucket.
   */
  refer(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending REFER request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    return new ReferUserAgentClient$1(this, delegate, options);
  }
  /**
   * Requests sent within a dialog, as any other requests, are atomic.  If
   * a particular request is accepted by the UAS, all the state changes
   * associated with it are performed.  If the request is rejected, none
   * of the state changes are performed.
   * https://tools.ietf.org/html/rfc3261#section-12.2.2
   * @param message - Incoming request message within this dialog.
   */
  receiveRequest(message2) {
    this.logger.log(`INVITE dialog ${this.id} received ${message2.method} request`);
    if (message2.method === C$1.ACK) {
      if (this.ackWait) {
        if (this.initialTransaction instanceof InviteClientTransaction$1) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        if (this.initialTransaction.request.cseq !== message2.cseq) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        this.ackWait = false;
      } else {
        if (!this.reinviteUserAgentServer) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        if (this.reinviteUserAgentServer.transaction.request.cseq !== message2.cseq) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        this.reinviteUserAgentServer = void 0;
      }
      this.signalingStateTransition(message2);
      if (this.delegate && this.delegate.onAck) {
        const promiseOrVoid = this.delegate.onAck({ message: message2 });
        if (promiseOrVoid instanceof Promise) {
          this.ackProcessing = true;
          promiseOrVoid.then(() => this.ackProcessing = false).catch(() => this.ackProcessing = false);
        }
      }
      return;
    }
    if (!this.sequenceGuard(message2)) {
      this.logger.log(`INVITE dialog ${this.id} rejected out of order ${message2.method} request.`);
      return;
    }
    super.receiveRequest(message2);
    if (message2.method === C$1.INVITE) {
      const warning2 = () => {
        const reason = this.ackWait ? "waiting for initial ACK" : "processing initial ACK";
        this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${reason}`);
        let msg = "RFC 5407 suggests the following to avoid this race condition... ";
        msg += " Note: Implementation issues are outside the scope of this document,";
        msg += " but the following tip is provided for avoiding race conditions of";
        msg += " this type.  The caller can delay sending re-INVITE F6 for some period";
        msg += " of time (2 seconds, perhaps), after which the caller can reasonably";
        msg += " assume that its ACK has been received.  Implementors can decouple the";
        msg += " actions of the user (e.g., pressing the hold button) from the actions";
        msg += " of the protocol (the sending of re-INVITE F6), so that the UA can";
        msg += " behave like this.  In this case, it is the implementor's choice as to";
        msg += " how long to wait.  In most cases, such an implementation may be";
        msg += " useful to prevent the type of race condition shown in this section.";
        msg += " This document expresses no preference about whether or not they";
        msg += " should wait for an ACK to be delivered.  After considering the impact";
        msg += " on user experience, implementors should decide whether or not to wait";
        msg += " for a while, because the user experience depends on the";
        msg += " implementation and has no direct bearing on protocol behavior.";
        this.logger.warn(msg);
        return;
      };
      const retryAfter = Math.floor(Math.random() * 10) + 1;
      const extraHeaders = [`Retry-After: ${retryAfter}`];
      if (this.ackProcessing) {
        this.core.replyStateless(message2, { statusCode: 500, extraHeaders });
        warning2();
        return;
      }
      if (this.ackWait && this.signalingState !== SignalingState$1.Stable) {
        this.core.replyStateless(message2, { statusCode: 500, extraHeaders });
        warning2();
        return;
      }
      if (this.reinviteUserAgentServer) {
        this.core.replyStateless(message2, { statusCode: 500, extraHeaders });
        return;
      }
      if (this.reinviteUserAgentClient) {
        this.core.replyStateless(message2, { statusCode: 491 });
        return;
      }
    }
    if (message2.method === C$1.INVITE) {
      const contact2 = message2.parseHeader("contact");
      if (!contact2) {
        throw new Error("Contact undefined.");
      }
      if (!(contact2 instanceof NameAddrHeader$1)) {
        throw new Error("Contact not instance of NameAddrHeader.");
      }
      this.dialogState.remoteTarget = contact2.uri;
    }
    switch (message2.method) {
      case C$1.BYE:
        {
          const uas = new ByeUserAgentServer$1(this, message2);
          this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();
          this.dispose();
        }
        break;
      case C$1.INFO:
        {
          const uas = new InfoUserAgentServer$1(this, message2);
          this.delegate && this.delegate.onInfo ? this.delegate.onInfo(uas) : uas.reject({
            statusCode: 469,
            extraHeaders: ["Recv-Info:"]
          });
        }
        break;
      case C$1.INVITE:
        {
          const uas = new ReInviteUserAgentServer$1(this, message2);
          this.signalingStateTransition(message2);
          this.delegate && this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject({ statusCode: 488 });
        }
        break;
      case C$1.MESSAGE:
        {
          const uas = new MessageUserAgentServer$1(this.core, message2);
          this.delegate && this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();
        }
        break;
      case C$1.NOTIFY:
        {
          const uas = new NotifyUserAgentServer$1(this, message2);
          this.delegate && this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.accept();
        }
        break;
      case C$1.PRACK:
        {
          const uas = new PrackUserAgentServer$1(this, message2);
          this.delegate && this.delegate.onPrack ? this.delegate.onPrack(uas) : uas.accept();
        }
        break;
      case C$1.REFER:
        {
          const uas = new ReferUserAgentServer$1(this, message2);
          this.delegate && this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject();
        }
        break;
      default:
        {
          this.logger.log(`INVITE dialog ${this.id} received unimplemented ${message2.method} request`);
          this.core.replyStateless(message2, { statusCode: 501 });
        }
        break;
    }
  }
  /**
   * Guard against out of order reliable provisional responses and retransmissions.
   * Returns false if the response should be discarded, otherwise true.
   * @param message - Incoming response message within this dialog.
   */
  reliableSequenceGuard(message2) {
    const statusCode = message2.statusCode;
    if (!statusCode) {
      throw new Error("Status code undefined");
    }
    if (statusCode > 100 && statusCode < 200) {
      const requireHeader = message2.getHeader("require");
      const rseqHeader = message2.getHeader("rseq");
      const rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : void 0;
      if (rseq) {
        if (this.rseq && this.rseq + 1 !== rseq) {
          return false;
        }
        this.rseq = this.rseq ? this.rseq + 1 : rseq;
      }
    }
    return true;
  }
  /**
   * If not in a stable signaling state, rollback to prior stable signaling state.
   */
  signalingStateRollback() {
    if (this._signalingState === SignalingState$1.HaveLocalOffer || this.signalingState === SignalingState$1.HaveRemoteOffer) {
      if (this._rollbackOffer && this._rollbackAnswer) {
        this._signalingState = SignalingState$1.Stable;
        this._offer = this._rollbackOffer;
        this._answer = this._rollbackAnswer;
      }
    }
  }
  /**
   * Update the signaling state of the dialog.
   * @param message - The message to base the update off of.
   */
  signalingStateTransition(message2) {
    const body = getBody$1(message2);
    if (!body || body.contentDisposition !== "session") {
      return;
    }
    if (this._signalingState === SignalingState$1.Stable) {
      this._rollbackOffer = this._offer;
      this._rollbackAnswer = this._answer;
    }
    if (message2 instanceof IncomingRequestMessage$1) {
      switch (this._signalingState) {
        case SignalingState$1.Initial:
        case SignalingState$1.Stable:
          this._signalingState = SignalingState$1.HaveRemoteOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState$1.HaveLocalOffer:
          this._signalingState = SignalingState$1.Stable;
          this._answer = body;
          break;
        case SignalingState$1.HaveRemoteOffer:
          break;
        case SignalingState$1.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
    if (message2 instanceof IncomingResponseMessage$1) {
      switch (this._signalingState) {
        case SignalingState$1.Initial:
        case SignalingState$1.Stable:
          this._signalingState = SignalingState$1.HaveRemoteOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState$1.HaveLocalOffer:
          this._signalingState = SignalingState$1.Stable;
          this._answer = body;
          break;
        case SignalingState$1.HaveRemoteOffer:
          break;
        case SignalingState$1.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
    if (message2 instanceof OutgoingRequestMessage$1) {
      switch (this._signalingState) {
        case SignalingState$1.Initial:
        case SignalingState$1.Stable:
          this._signalingState = SignalingState$1.HaveLocalOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState$1.HaveLocalOffer:
          break;
        case SignalingState$1.HaveRemoteOffer:
          this._signalingState = SignalingState$1.Stable;
          this._answer = body;
          break;
        case SignalingState$1.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
    if (isBody$1(message2)) {
      switch (this._signalingState) {
        case SignalingState$1.Initial:
        case SignalingState$1.Stable:
          this._signalingState = SignalingState$1.HaveLocalOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState$1.HaveLocalOffer:
          break;
        case SignalingState$1.HaveRemoteOffer:
          this._signalingState = SignalingState$1.Stable;
          this._answer = body;
          break;
        case SignalingState$1.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
  }
  start2xxRetransmissionTimer() {
    if (this.initialTransaction instanceof InviteServerTransaction$1) {
      const transaction = this.initialTransaction;
      let timeout2 = Timers$1.T1;
      const retransmission = () => {
        if (!this.ackWait) {
          this.invite2xxTimer = void 0;
          return;
        }
        this.logger.log("No ACK for 2xx response received, attempting retransmission");
        transaction.retransmitAcceptedResponse();
        timeout2 = Math.min(timeout2 * 2, Timers$1.T2);
        this.invite2xxTimer = setTimeout(retransmission, timeout2);
      };
      this.invite2xxTimer = setTimeout(retransmission, timeout2);
      const stateChanged = () => {
        if (transaction.state === TransactionState$1.Terminated) {
          transaction.removeStateChangeListener(stateChanged);
          if (this.invite2xxTimer) {
            clearTimeout(this.invite2xxTimer);
            this.invite2xxTimer = void 0;
          }
          if (this.ackWait) {
            if (this.delegate && this.delegate.onAckTimeout) {
              this.delegate.onAckTimeout();
            } else {
              this.bye();
            }
          }
        }
      };
      transaction.addStateChangeListener(stateChanged);
    }
  }
  // FIXME: Refactor
  startReInvite2xxRetransmissionTimer() {
    if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction$1) {
      const transaction = this.reinviteUserAgentServer.transaction;
      let timeout2 = Timers$1.T1;
      const retransmission = () => {
        if (!this.reinviteUserAgentServer) {
          this.invite2xxTimer = void 0;
          return;
        }
        this.logger.log("No ACK for 2xx response received, attempting retransmission");
        transaction.retransmitAcceptedResponse();
        timeout2 = Math.min(timeout2 * 2, Timers$1.T2);
        this.invite2xxTimer = setTimeout(retransmission, timeout2);
      };
      this.invite2xxTimer = setTimeout(retransmission, timeout2);
      const stateChanged = () => {
        if (transaction.state === TransactionState$1.Terminated) {
          transaction.removeStateChangeListener(stateChanged);
          if (this.invite2xxTimer) {
            clearTimeout(this.invite2xxTimer);
            this.invite2xxTimer = void 0;
          }
          if (this.reinviteUserAgentServer) ;
        }
      };
      transaction.addStateChangeListener(stateChanged);
    }
  }
};
let InviteUserAgentClient$1 = class InviteUserAgentClient extends UserAgentClient$1 {
  constructor(core2, message2, delegate) {
    super(InviteClientTransaction$1, core2, message2, delegate);
    this.confirmedDialogAcks = /* @__PURE__ */ new Map();
    this.confirmedDialogs = /* @__PURE__ */ new Map();
    this.earlyDialogs = /* @__PURE__ */ new Map();
    this.delegate = delegate;
  }
  dispose() {
    this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());
    this.earlyDialogs.clear();
    super.dispose();
  }
  /**
   * Special case for transport error while sending ACK.
   * @param error - Transport error
   */
  onTransportError(error) {
    if (this.transaction.state === TransactionState$1.Calling) {
      return super.onTransportError(error);
    }
    this.logger.error(error.message);
    this.logger.error("User agent client request transport error while sending ACK.");
  }
  /**
   * Once the INVITE has been passed to the INVITE client transaction, the
   * UAC waits for responses for the INVITE.
   * https://tools.ietf.org/html/rfc3261#section-13.2.2
   * @param incomingResponse - Incoming response to INVITE request.
   */
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2)) {
      return;
    }
    const statusCode = message2.statusCode ? message2.statusCode.toString() : "";
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    switch (true) {
      case /^100$/.test(statusCode):
        if (this.delegate && this.delegate.onTrying) {
          this.delegate.onTrying({ message: message2 });
        }
        return;
      case /^1[0-9]{2}$/.test(statusCode):
        {
          if (!message2.toTag) {
            this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
            return;
          }
          const contact2 = message2.parseHeader("contact");
          if (!contact2) {
            this.logger.error("Non-100 1xx INVITE response received without a Contact header field, dropping.");
            return;
          }
          const dialogState = Dialog$1.initialDialogStateForUserAgentClient(this.message, message2);
          let earlyDialog = this.earlyDialogs.get(dialogState.id);
          if (!earlyDialog) {
            const transaction = this.transaction;
            if (!(transaction instanceof InviteClientTransaction$1)) {
              throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            earlyDialog = new SessionDialog$1(transaction, this.core, dialogState);
            this.earlyDialogs.set(earlyDialog.id, earlyDialog);
          }
          if (!earlyDialog.reliableSequenceGuard(message2)) {
            this.logger.warn("1xx INVITE reliable response received out of order or is a retransmission, dropping.");
            return;
          }
          if (earlyDialog.signalingState === SignalingState$1.Initial || earlyDialog.signalingState === SignalingState$1.HaveLocalOffer) {
            earlyDialog.signalingStateTransition(message2);
          }
          const session2 = earlyDialog;
          if (this.delegate && this.delegate.onProgress) {
            this.delegate.onProgress({
              message: message2,
              session: session2,
              prack: (options) => {
                const outgoingPrackRequest = session2.prack(void 0, options);
                return outgoingPrackRequest;
              }
            });
          }
        }
        return;
      case /^2[0-9]{2}$/.test(statusCode):
        {
          if (!message2.toTag) {
            this.logger.error("2xx INVITE response received without a to tag, dropping.");
            return;
          }
          const contact2 = message2.parseHeader("contact");
          if (!contact2) {
            this.logger.error("2xx INVITE response received without a Contact header field, dropping.");
            return;
          }
          const dialogState = Dialog$1.initialDialogStateForUserAgentClient(this.message, message2);
          let dialog = this.confirmedDialogs.get(dialogState.id);
          if (dialog) {
            const outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);
            if (outgoingAckRequest) {
              const transaction = this.transaction;
              if (!(transaction instanceof InviteClientTransaction$1)) {
                throw new Error("Client transaction not instance of InviteClientTransaction.");
              }
              transaction.ackResponse(outgoingAckRequest.message);
            }
            return;
          }
          dialog = this.earlyDialogs.get(dialogState.id);
          if (dialog) {
            dialog.confirm();
            dialog.recomputeRouteSet(message2);
            this.earlyDialogs.delete(dialog.id);
            this.confirmedDialogs.set(dialog.id, dialog);
          } else {
            const transaction = this.transaction;
            if (!(transaction instanceof InviteClientTransaction$1)) {
              throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            dialog = new SessionDialog$1(transaction, this.core, dialogState);
            this.confirmedDialogs.set(dialog.id, dialog);
          }
          if (dialog.signalingState === SignalingState$1.Initial || dialog.signalingState === SignalingState$1.HaveLocalOffer) {
            dialog.signalingStateTransition(message2);
          }
          const session2 = dialog;
          if (this.delegate && this.delegate.onAccept) {
            this.delegate.onAccept({
              message: message2,
              session: session2,
              ack: (options) => {
                const outgoingAckRequest = session2.ack(options);
                this.confirmedDialogAcks.set(session2.id, outgoingAckRequest);
                return outgoingAckRequest;
              }
            });
          } else {
            const outgoingAckRequest = session2.ack();
            this.confirmedDialogAcks.set(session2.id, outgoingAckRequest);
          }
        }
        return;
      case /^3[0-9]{2}$/.test(statusCode):
        this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());
        this.earlyDialogs.clear();
        if (this.delegate && this.delegate.onRedirect) {
          this.delegate.onRedirect({ message: message2 });
        }
        return;
      case /^[4-6][0-9]{2}$/.test(statusCode):
        this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());
        this.earlyDialogs.clear();
        if (this.delegate && this.delegate.onReject) {
          this.delegate.onReject({ message: message2 });
        }
        return;
      default:
        throw new Error(`Invalid status code ${statusCode}`);
    }
  }
};
let InviteUserAgentServer$1 = class InviteUserAgentServer extends UserAgentServer$1 {
  constructor(core2, message2, delegate) {
    super(InviteServerTransaction$1, core2, message2, delegate);
    this.core = core2;
  }
  dispose() {
    if (this.earlyDialog) {
      this.earlyDialog.dispose();
    }
    super.dispose();
  }
  /**
   * 13.3.1.4 The INVITE is Accepted
   * The UAS core generates a 2xx response.  This response establishes a
   * dialog, and therefore follows the procedures of Section 12.1.1 in
   * addition to those of Section 8.2.6.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.4
   * @param options - Accept options bucket.
   */
  accept(options = { statusCode: 200 }) {
    if (!this.acceptable) {
      throw new TransactionStateError$1(`${this.message.method} not acceptable in state ${this.transaction.state}.`);
    }
    if (!this.confirmedDialog) {
      if (this.earlyDialog) {
        this.earlyDialog.confirm();
        this.confirmedDialog = this.earlyDialog;
        this.earlyDialog = void 0;
      } else {
        const transaction = this.transaction;
        if (!(transaction instanceof InviteServerTransaction$1)) {
          throw new Error("Transaction not instance of InviteClientTransaction.");
        }
        const state = Dialog$1.initialDialogStateForUserAgentServer(this.message, this.toTag);
        this.confirmedDialog = new SessionDialog$1(transaction, this.core, state);
      }
    }
    const recordRouteHeader = this.message.getHeaders("record-route").map((header) => `Record-Route: ${header}`);
    const contactHeader = `Contact: ${this.core.configuration.contact.toString()}`;
    const allowHeader = "Allow: " + AllowedMethods$1.toString();
    if (!options.body) {
      if (this.confirmedDialog.signalingState === SignalingState$1.Stable) {
        options.body = this.confirmedDialog.answer;
      } else if (this.confirmedDialog.signalingState === SignalingState$1.Initial || this.confirmedDialog.signalingState === SignalingState$1.HaveRemoteOffer) {
        throw new Error("Response must have a body.");
      }
    }
    options.statusCode = options.statusCode || 200;
    options.extraHeaders = options.extraHeaders || [];
    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
    options.extraHeaders.push(allowHeader);
    options.extraHeaders.push(contactHeader);
    const response = super.accept(options);
    const session2 = this.confirmedDialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      if (this.confirmedDialog.signalingState !== SignalingState$1.Stable) {
        this.confirmedDialog.signalingStateTransition(options.body);
      }
    }
    return result;
  }
  /**
   * 13.3.1.1 Progress
   * If the UAS is not able to answer the invitation immediately, it can
   * choose to indicate some kind of progress to the UAC (for example, an
   * indication that a phone is ringing).  This is accomplished with a
   * provisional response between 101 and 199.  These provisional
   * responses establish early dialogs and therefore follow the procedures
   * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY
   * send as many provisional responses as it likes.  Each of these MUST
   * indicate the same dialog ID.  However, these will not be delivered
   * reliably.
   *
   * If the UAS desires an extended period of time to answer the INVITE,
   * it will need to ask for an "extension" in order to prevent proxies
   * from canceling the transaction.  A proxy has the option of canceling
   * a transaction when there is a gap of 3 minutes between responses in a
   * transaction.  To prevent cancellation, the UAS MUST send a non-100
   * provisional response at every minute, to handle the possibility of
   * lost provisional responses.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.1
   * @param options - Progress options bucket.
   */
  progress(options = { statusCode: 180 }) {
    if (!this.progressable) {
      throw new TransactionStateError$1(`${this.message.method} not progressable in state ${this.transaction.state}.`);
    }
    if (!this.earlyDialog) {
      const transaction = this.transaction;
      if (!(transaction instanceof InviteServerTransaction$1)) {
        throw new Error("Transaction not instance of InviteClientTransaction.");
      }
      const state = Dialog$1.initialDialogStateForUserAgentServer(this.message, this.toTag, true);
      this.earlyDialog = new SessionDialog$1(transaction, this.core, state);
    }
    const recordRouteHeader = this.message.getHeaders("record-route").map((header) => `Record-Route: ${header}`);
    const contactHeader = `Contact: ${this.core.configuration.contact}`;
    options.extraHeaders = options.extraHeaders || [];
    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
    options.extraHeaders.push(contactHeader);
    const response = super.progress(options);
    const session2 = this.earlyDialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      if (this.earlyDialog.signalingState !== SignalingState$1.Stable) {
        this.earlyDialog.signalingStateTransition(options.body);
      }
    }
    return result;
  }
  /**
   * 13.3.1.2 The INVITE is Redirected
   * If the UAS decides to redirect the call, a 3xx response is sent.  A
   * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved
   * Temporarily) response SHOULD contain a Contact header field
   * containing one or more URIs of new addresses to be tried.  The
   * response is passed to the INVITE server transaction, which will deal
   * with its retransmissions.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.2
   * @param contacts - Contacts to redirect to.
   * @param options - Redirect options bucket.
   */
  redirect(contacts, options = { statusCode: 302 }) {
    return super.redirect(contacts, options);
  }
  /**
   * 13.3.1.3 The INVITE is Rejected
   * A common scenario occurs when the callee is currently not willing or
   * able to take additional calls at this end system.  A 486 (Busy Here)
   * SHOULD be returned in such a scenario.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.3
   * @param options - Reject options bucket.
   */
  reject(options = { statusCode: 486 }) {
    return super.reject(options);
  }
};
let PublishUserAgentClient$1 = class PublishUserAgentClient extends UserAgentClient$1 {
  constructor(core2, message2, delegate) {
    super(NonInviteClientTransaction$1, core2, message2, delegate);
  }
};
let RegisterUserAgentClient$1 = class RegisterUserAgentClient extends UserAgentClient$1 {
  constructor(core2, message2, delegate) {
    super(NonInviteClientTransaction$1, core2, message2, delegate);
  }
};
let RegisterUserAgentServer$1 = class RegisterUserAgentServer extends UserAgentServer$1 {
  constructor(core2, message2, delegate) {
    super(NonInviteServerTransaction$1, core2, message2, delegate);
    this.core = core2;
  }
};
var SubscriptionState$2;
(function(SubscriptionState2) {
  SubscriptionState2["Initial"] = "Initial";
  SubscriptionState2["NotifyWait"] = "NotifyWait";
  SubscriptionState2["Pending"] = "Pending";
  SubscriptionState2["Active"] = "Active";
  SubscriptionState2["Terminated"] = "Terminated";
})(SubscriptionState$2 = SubscriptionState$2 || (SubscriptionState$2 = {}));
let ReSubscribeUserAgentClient$1 = class ReSubscribeUserAgentClient extends UserAgentClient$1 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C$1.SUBSCRIBE, options);
    super(NonInviteClientTransaction$1, dialog.userAgentCore, message2, delegate);
    this.dialog = dialog;
  }
  waitNotifyStop() {
    return;
  }
  /**
   * Receive a response from the transaction layer.
   * @param message - Incoming response message.
   */
  receiveResponse(message2) {
    if (message2.statusCode && message2.statusCode >= 200 && message2.statusCode < 300) {
      const expires = message2.getHeader("Expires");
      if (!expires) {
        this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
      } else {
        const subscriptionExpiresReceived = Number(expires);
        if (this.dialog.subscriptionExpires > subscriptionExpiresReceived) {
          this.dialog.subscriptionExpires = subscriptionExpiresReceived;
        }
      }
    }
    if (message2.statusCode && message2.statusCode >= 400 && message2.statusCode < 700) {
      const errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];
      if (errorCodes.includes(message2.statusCode)) {
        this.dialog.terminate();
      }
    }
    super.receiveResponse(message2);
  }
};
let SubscriptionDialog$1 = class SubscriptionDialog extends Dialog$1 {
  constructor(subscriptionEvent, subscriptionExpires, subscriptionState, core2, state, delegate) {
    super(core2, state);
    this.delegate = delegate;
    this._autoRefresh = false;
    this._subscriptionEvent = subscriptionEvent;
    this._subscriptionExpires = subscriptionExpires;
    this._subscriptionExpiresInitial = subscriptionExpires;
    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1e3);
    this._subscriptionRefresh = void 0;
    this._subscriptionRefreshLastSet = void 0;
    this._subscriptionState = subscriptionState;
    this.logger = core2.loggerFactory.getLogger("sip.subscribe-dialog");
    this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);
  }
  /**
   * When a UAC receives a response that establishes a dialog, it
   * constructs the state of the dialog.  This state MUST be maintained
   * for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.2
   * @param outgoingRequestMessage - Outgoing request message for dialog.
   * @param incomingResponseMessage - Incoming response message creating dialog.
   */
  static initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {
    const secure = false;
    const routeSet = incomingNotifyRequestMessage.getHeaders("record-route");
    const contact2 = incomingNotifyRequestMessage.parseHeader("contact");
    if (!contact2) {
      throw new Error("Contact undefined.");
    }
    if (!(contact2 instanceof NameAddrHeader$1)) {
      throw new Error("Contact not instance of NameAddrHeader.");
    }
    const remoteTarget = contact2.uri;
    const localSequenceNumber = outgoingSubscribeRequestMessage.cseq;
    const remoteSequenceNumber = void 0;
    const callId = outgoingSubscribeRequestMessage.callId;
    const localTag = outgoingSubscribeRequestMessage.fromTag;
    const remoteTag = incomingNotifyRequestMessage.fromTag;
    if (!callId) {
      throw new Error("Call id undefined.");
    }
    if (!localTag) {
      throw new Error("From tag undefined.");
    }
    if (!remoteTag) {
      throw new Error("To tag undefined.");
    }
    if (!outgoingSubscribeRequestMessage.from) {
      throw new Error("From undefined.");
    }
    if (!outgoingSubscribeRequestMessage.to) {
      throw new Error("To undefined.");
    }
    const localURI = outgoingSubscribeRequestMessage.from.uri;
    const remoteURI = outgoingSubscribeRequestMessage.to.uri;
    const early = false;
    const dialogState = {
      id: callId + localTag + remoteTag,
      early,
      callId,
      localTag,
      remoteTag,
      localSequenceNumber,
      remoteSequenceNumber,
      localURI,
      remoteURI,
      remoteTarget,
      routeSet,
      secure
    };
    return dialogState;
  }
  dispose() {
    super.dispose();
    if (this.N) {
      clearTimeout(this.N);
      this.N = void 0;
    }
    this.refreshTimerClear();
    this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);
  }
  get autoRefresh() {
    return this._autoRefresh;
  }
  set autoRefresh(autoRefresh) {
    this._autoRefresh = true;
    this.refreshTimerSet();
  }
  get subscriptionEvent() {
    return this._subscriptionEvent;
  }
  /** Number of seconds until subscription expires. */
  get subscriptionExpires() {
    const secondsSinceLastSet = Math.floor(Date.now() / 1e3) - this._subscriptionExpiresLastSet;
    const secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;
    return Math.max(secondsUntilExpires, 0);
  }
  set subscriptionExpires(expires) {
    if (expires < 0) {
      throw new Error("Expires must be greater than or equal to zero.");
    }
    this._subscriptionExpires = expires;
    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1e3);
    if (this.autoRefresh) {
      const refresh = this.subscriptionRefresh;
      if (refresh === void 0 || refresh >= expires) {
        this.refreshTimerSet();
      }
    }
  }
  get subscriptionExpiresInitial() {
    return this._subscriptionExpiresInitial;
  }
  /** Number of seconds until subscription auto refresh. */
  get subscriptionRefresh() {
    if (this._subscriptionRefresh === void 0 || this._subscriptionRefreshLastSet === void 0) {
      return void 0;
    }
    const secondsSinceLastSet = Math.floor(Date.now() / 1e3) - this._subscriptionRefreshLastSet;
    const secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;
    return Math.max(secondsUntilExpires, 0);
  }
  get subscriptionState() {
    return this._subscriptionState;
  }
  /**
   * Receive in dialog request message from transport.
   * @param message -  The incoming request message.
   */
  receiveRequest(message2) {
    this.logger.log(`SUBSCRIBE dialog ${this.id} received ${message2.method} request`);
    if (!this.sequenceGuard(message2)) {
      this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${message2.method} request.`);
      return;
    }
    super.receiveRequest(message2);
    switch (message2.method) {
      case C$1.NOTIFY:
        this.onNotify(message2);
        break;
      default:
        this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${message2.method} request`);
        this.core.replyStateless(message2, { statusCode: 501 });
        break;
    }
  }
  /**
   * 4.1.2.2.  Refreshing of Subscriptions
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
   */
  refresh() {
    const allowHeader = "Allow: " + AllowedMethods$1.toString();
    const options = {};
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.extraHeaders.push(allowHeader);
    options.extraHeaders.push("Event: " + this.subscriptionEvent);
    options.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial);
    options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
    return this.subscribe(void 0, options);
  }
  /**
   * 4.1.2.2.  Refreshing of Subscriptions
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
   * @param delegate - Delegate to handle responses.
   * @param options - Options bucket.
   */
  subscribe(delegate, options = {}) {
    var _a;
    if (this.subscriptionState !== SubscriptionState$2.Pending && this.subscriptionState !== SubscriptionState$2.Active) {
      throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state "pending" or "active".`);
    }
    this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);
    const uac = new ReSubscribeUserAgentClient$1(this, delegate, options);
    if (this.N) {
      clearTimeout(this.N);
      this.N = void 0;
    }
    if (!((_a = options.extraHeaders) === null || _a === void 0 ? void 0 : _a.includes("Expires: 0"))) {
      this.N = setTimeout(() => this.timerN(), Timers$1.TIMER_N);
    }
    return uac;
  }
  /**
   * 4.4.1.  Dialog Creation and Termination
   * A subscription is destroyed after a notifier sends a NOTIFY request
   * with a "Subscription-State" of "terminated", or in certain error
   * situations described elsewhere in this document.
   * https://tools.ietf.org/html/rfc6665#section-4.4.1
   */
  terminate() {
    this.stateTransition(SubscriptionState$2.Terminated);
    this.onTerminated();
  }
  /**
   * 4.1.2.3.  Unsubscribing
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.3
   */
  unsubscribe() {
    const allowHeader = "Allow: " + AllowedMethods$1.toString();
    const options = {};
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.extraHeaders.push(allowHeader);
    options.extraHeaders.push("Event: " + this.subscriptionEvent);
    options.extraHeaders.push("Expires: 0");
    options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
    return this.subscribe(void 0, options);
  }
  /**
   * Handle in dialog NOTIFY requests.
   * This does not include the first NOTIFY which created the dialog.
   * @param message - The incoming NOTIFY request message.
   */
  onNotify(message2) {
    const event = message2.parseHeader("Event").event;
    if (!event || event !== this.subscriptionEvent) {
      this.core.replyStateless(message2, { statusCode: 489 });
      return;
    }
    if (this.N) {
      clearTimeout(this.N);
      this.N = void 0;
    }
    const subscriptionState = message2.parseHeader("Subscription-State");
    if (!subscriptionState || !subscriptionState.state) {
      this.core.replyStateless(message2, { statusCode: 489 });
      return;
    }
    const state = subscriptionState.state;
    const expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : void 0;
    switch (state) {
      case "pending":
        this.stateTransition(SubscriptionState$2.Pending, expires);
        break;
      case "active":
        this.stateTransition(SubscriptionState$2.Active, expires);
        break;
      case "terminated":
        this.stateTransition(SubscriptionState$2.Terminated, expires);
        break;
      default:
        this.logger.warn("Unrecognized subscription state.");
        break;
    }
    const uas = new NotifyUserAgentServer$1(this, message2);
    if (this.delegate && this.delegate.onNotify) {
      this.delegate.onNotify(uas);
    } else {
      uas.accept();
    }
  }
  onRefresh(request) {
    if (this.delegate && this.delegate.onRefresh) {
      this.delegate.onRefresh(request);
    }
  }
  onTerminated() {
    if (this.delegate && this.delegate.onTerminated) {
      this.delegate.onTerminated();
    }
  }
  refreshTimerClear() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = void 0;
    }
  }
  refreshTimerSet() {
    this.refreshTimerClear();
    if (this.autoRefresh && this.subscriptionExpires > 0) {
      const refresh = this.subscriptionExpires * 900;
      this._subscriptionRefresh = Math.floor(refresh / 1e3);
      this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1e3);
      this.refreshTimer = setTimeout(() => {
        this.refreshTimer = void 0;
        this._subscriptionRefresh = void 0;
        this._subscriptionRefreshLastSet = void 0;
        this.onRefresh(this.refresh());
      }, refresh);
    }
  }
  stateTransition(newState, newExpires) {
    const invalidStateTransition = () => {
      this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${newState}`);
    };
    switch (newState) {
      case SubscriptionState$2.Initial:
        invalidStateTransition();
        return;
      case SubscriptionState$2.NotifyWait:
        invalidStateTransition();
        return;
      case SubscriptionState$2.Pending:
        if (this.subscriptionState !== SubscriptionState$2.NotifyWait && this.subscriptionState !== SubscriptionState$2.Pending) {
          invalidStateTransition();
          return;
        }
        break;
      case SubscriptionState$2.Active:
        if (this.subscriptionState !== SubscriptionState$2.NotifyWait && this.subscriptionState !== SubscriptionState$2.Pending && this.subscriptionState !== SubscriptionState$2.Active) {
          invalidStateTransition();
          return;
        }
        break;
      case SubscriptionState$2.Terminated:
        if (this.subscriptionState !== SubscriptionState$2.NotifyWait && this.subscriptionState !== SubscriptionState$2.Pending && this.subscriptionState !== SubscriptionState$2.Active) {
          invalidStateTransition();
          return;
        }
        break;
      default:
        invalidStateTransition();
        return;
    }
    if (newState === SubscriptionState$2.Pending) {
      if (newExpires) {
        this.subscriptionExpires = newExpires;
      }
    }
    if (newState === SubscriptionState$2.Active) {
      if (newExpires) {
        this.subscriptionExpires = newExpires;
      }
    }
    if (newState === SubscriptionState$2.Terminated) {
      this.dispose();
    }
    this._subscriptionState = newState;
  }
  /**
   * When refreshing a subscription, a subscriber starts Timer N, set to
   * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires
   * prior to the receipt of a NOTIFY request, the subscriber considers
   * the subscription terminated.  If the subscriber receives a success
   * response to the SUBSCRIBE request that indicates that no NOTIFY
   * request will be generated -- such as the 204 response defined for use
   * with the optional extension described in [RFC5839] -- then it MUST
   * cancel Timer N.
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
   */
  timerN() {
    this.logger.warn(`Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.`);
    if (this.subscriptionState !== SubscriptionState$2.Terminated) {
      this.stateTransition(SubscriptionState$2.Terminated);
      this.onTerminated();
    }
  }
};
let SubscribeUserAgentClient$1 = class SubscribeUserAgentClient extends UserAgentClient$1 {
  constructor(core2, message2, delegate) {
    const event = message2.getHeader("Event");
    if (!event) {
      throw new Error("Event undefined");
    }
    const expires = message2.getHeader("Expires");
    if (!expires) {
      throw new Error("Expires undefined");
    }
    super(NonInviteClientTransaction$1, core2, message2, delegate);
    this.delegate = delegate;
    this.subscriberId = message2.callId + message2.fromTag + event;
    this.subscriptionExpiresRequested = this.subscriptionExpires = Number(expires);
    this.subscriptionEvent = event;
    this.subscriptionState = SubscriptionState$2.NotifyWait;
    this.waitNotifyStart();
  }
  /**
   * Destructor.
   * Note that Timer N may live on waiting for an initial NOTIFY and
   * the delegate may still receive that NOTIFY. If you don't want
   * that behavior then either clear the delegate so the delegate
   * doesn't get called (a 200 will be sent in response to the NOTIFY)
   * or call `waitNotifyStop` which will clear Timer N and remove this
   * UAC from the core (a 481 will be sent in response to the NOTIFY).
   */
  dispose() {
    super.dispose();
  }
  /**
   * Handle out of dialog NOTIFY associated with SUBSCRIBE request.
   * This is the first NOTIFY received after the SUBSCRIBE request.
   * @param uas - User agent server handling the subscription creating NOTIFY.
   */
  onNotify(uas) {
    const event = uas.message.parseHeader("Event").event;
    if (!event || event !== this.subscriptionEvent) {
      this.logger.warn(`Failed to parse event.`);
      uas.reject({ statusCode: 489 });
      return;
    }
    const subscriptionState = uas.message.parseHeader("Subscription-State");
    if (!subscriptionState || !subscriptionState.state) {
      this.logger.warn("Failed to parse subscription state.");
      uas.reject({ statusCode: 489 });
      return;
    }
    const state = subscriptionState.state;
    switch (state) {
      case "pending":
        break;
      case "active":
        break;
      case "terminated":
        break;
      default:
        this.logger.warn(`Invalid subscription state ${state}`);
        uas.reject({ statusCode: 489 });
        return;
    }
    if (state !== "terminated") {
      const contact2 = uas.message.parseHeader("contact");
      if (!contact2) {
        this.logger.warn("Failed to parse contact.");
        uas.reject({ statusCode: 489 });
        return;
      }
    }
    if (this.dialog) {
      throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");
    }
    this.waitNotifyStop();
    this.subscriptionExpires = subscriptionState.expires ? Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) : this.subscriptionExpires;
    switch (state) {
      case "pending":
        this.subscriptionState = SubscriptionState$2.Pending;
        break;
      case "active":
        this.subscriptionState = SubscriptionState$2.Active;
        break;
      case "terminated":
        this.subscriptionState = SubscriptionState$2.Terminated;
        break;
      default:
        throw new Error(`Unrecognized state ${state}.`);
    }
    if (this.subscriptionState !== SubscriptionState$2.Terminated) {
      const dialogState = SubscriptionDialog$1.initialDialogStateForSubscription(this.message, uas.message);
      this.dialog = new SubscriptionDialog$1(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);
    }
    if (this.delegate && this.delegate.onNotify) {
      const request = uas;
      const subscription = this.dialog;
      this.delegate.onNotify({ request, subscription });
    } else {
      uas.accept();
    }
  }
  waitNotifyStart() {
    if (!this.N) {
      this.core.subscribers.set(this.subscriberId, this);
      this.N = setTimeout(() => this.timerN(), Timers$1.TIMER_N);
    }
  }
  waitNotifyStop() {
    if (this.N) {
      this.core.subscribers.delete(this.subscriberId);
      clearTimeout(this.N);
      this.N = void 0;
    }
  }
  /**
   * Receive a response from the transaction layer.
   * @param message - Incoming response message.
   */
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2)) {
      return;
    }
    if (message2.statusCode && message2.statusCode >= 200 && message2.statusCode < 300) {
      const expires = message2.getHeader("Expires");
      if (!expires) {
        this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
      } else {
        const subscriptionExpiresReceived = Number(expires);
        if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {
          this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request");
        }
        if (subscriptionExpiresReceived < this.subscriptionExpires) {
          this.subscriptionExpires = subscriptionExpiresReceived;
        }
      }
      if (this.dialog) {
        if (this.dialog.subscriptionExpires > this.subscriptionExpires) {
          this.dialog.subscriptionExpires = this.subscriptionExpires;
        }
      }
    }
    if (message2.statusCode && message2.statusCode >= 300 && message2.statusCode < 700) {
      this.waitNotifyStop();
    }
    super.receiveResponse(message2);
  }
  /**
   * To ensure that subscribers do not wait indefinitely for a
   * subscription to be established, a subscriber starts a Timer N, set to
   * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires
   * prior to the receipt of a NOTIFY request, the subscriber considers
   * the subscription failed, and cleans up any state associated with the
   * subscription attempt.
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.4
   */
  timerN() {
    this.logger.warn(`Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.`);
    this.waitNotifyStop();
    if (this.delegate && this.delegate.onNotifyTimeout) {
      this.delegate.onNotifyTimeout();
    }
  }
};
let SubscribeUserAgentServer$1 = class SubscribeUserAgentServer extends UserAgentServer$1 {
  constructor(core2, message2, delegate) {
    super(NonInviteServerTransaction$1, core2, message2, delegate);
    this.core = core2;
  }
};
const acceptedBodyTypes$1 = ["application/sdp", "application/dtmf-relay"];
let UserAgentCore$1 = class UserAgentCore {
  /**
   * Constructor.
   * @param configuration - Configuration.
   * @param delegate - Delegate.
   */
  constructor(configuration, delegate = {}) {
    this.userAgentClients = /* @__PURE__ */ new Map();
    this.userAgentServers = /* @__PURE__ */ new Map();
    this.configuration = configuration;
    this.delegate = delegate;
    this.dialogs = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Map();
    this.logger = configuration.loggerFactory.getLogger("sip.user-agent-core");
  }
  /** Destructor. */
  dispose() {
    this.reset();
  }
  /** Reset. */
  reset() {
    this.dialogs.forEach((dialog) => dialog.dispose());
    this.dialogs.clear();
    this.subscribers.forEach((subscriber) => subscriber.dispose());
    this.subscribers.clear();
    this.userAgentClients.forEach((uac) => uac.dispose());
    this.userAgentClients.clear();
    this.userAgentServers.forEach((uac) => uac.dispose());
    this.userAgentServers.clear();
  }
  /** Logger factory. */
  get loggerFactory() {
    return this.configuration.loggerFactory;
  }
  /** Transport. */
  get transport() {
    const transport = this.configuration.transportAccessor();
    if (!transport) {
      throw new Error("Transport undefined.");
    }
    return transport;
  }
  /**
   * Send INVITE.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  invite(request, delegate) {
    return new InviteUserAgentClient$1(this, request, delegate);
  }
  /**
   * Send MESSAGE.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  message(request, delegate) {
    return new MessageUserAgentClient$1(this, request, delegate);
  }
  /**
   * Send PUBLISH.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  publish(request, delegate) {
    return new PublishUserAgentClient$1(this, request, delegate);
  }
  /**
   * Send REGISTER.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  register(request, delegate) {
    return new RegisterUserAgentClient$1(this, request, delegate);
  }
  /**
   * Send SUBSCRIBE.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  subscribe(request, delegate) {
    return new SubscribeUserAgentClient$1(this, request, delegate);
  }
  /**
   * Send a request.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  request(request, delegate) {
    return new UserAgentClient$1(NonInviteClientTransaction$1, this, request, delegate);
  }
  /**
   * Outgoing request message factory function.
   * @param method - Method.
   * @param requestURI - Request-URI.
   * @param fromURI - From URI.
   * @param toURI - To URI.
   * @param options - Request options.
   * @param extraHeaders - Extra headers to add.
   * @param body - Message body.
   */
  makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {
    const callIdPrefix = this.configuration.sipjsId;
    const fromDisplayName = this.configuration.displayName;
    const forceRport = this.configuration.viaForceRport;
    const hackViaTcp = this.configuration.hackViaTcp;
    const optionTags = this.configuration.supportedOptionTags.slice();
    if (method === C$1.REGISTER) {
      optionTags.push("path", "gruu");
    }
    if (method === C$1.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {
      optionTags.push("gruu");
    }
    const routeSet = this.configuration.routeSet;
    const userAgentString = this.configuration.userAgentHeaderFieldValue;
    const viaHost = this.configuration.viaHost;
    const defaultOptions2 = {
      callIdPrefix,
      forceRport,
      fromDisplayName,
      hackViaTcp,
      optionTags,
      routeSet,
      userAgentString,
      viaHost
    };
    const requestOptions = Object.assign(Object.assign({}, defaultOptions2), options);
    return new OutgoingRequestMessage$1(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);
  }
  /**
   * Handle an incoming request message from the transport.
   * @param message - Incoming request message from transport layer.
   */
  receiveIncomingRequestFromTransport(message2) {
    this.receiveRequestFromTransport(message2);
  }
  /**
   * Handle an incoming response message from the transport.
   * @param message - Incoming response message from transport layer.
   */
  receiveIncomingResponseFromTransport(message2) {
    this.receiveResponseFromTransport(message2);
  }
  /**
   * A stateless UAS is a UAS that does not maintain transaction state.
   * It replies to requests normally, but discards any state that would
   * ordinarily be retained by a UAS after a response has been sent.  If a
   * stateless UAS receives a retransmission of a request, it regenerates
   * the response and re-sends it, just as if it were replying to the first
   * instance of the request. A UAS cannot be stateless unless the request
   * processing for that method would always result in the same response
   * if the requests are identical. This rules out stateless registrars,
   * for example.  Stateless UASs do not use a transaction layer; they
   * receive requests directly from the transport layer and send responses
   * directly to the transport layer.
   * https://tools.ietf.org/html/rfc3261#section-8.2.7
   * @param message - Incoming request message to reply to.
   * @param statusCode - Status code to reply with.
   */
  replyStateless(message2, options) {
    const userAgent = this.configuration.userAgentHeaderFieldValue;
    const supported = this.configuration.supportedOptionTagsResponse;
    options = Object.assign(Object.assign({}, options), { userAgent, supported });
    const response = constructOutgoingResponse$1(message2, options);
    this.transport.send(response.message).catch((error) => {
      if (error instanceof Error) {
        this.logger.error(error.message);
      }
      this.logger.error(`Transport error occurred sending stateless reply to ${message2.method} request.`);
    });
    return response;
  }
  /**
   * In Section 18.2.1, replace the last paragraph with:
   *
   * Next, the server transport attempts to match the request to a
   * server transaction.  It does so using the matching rules described
   * in Section 17.2.3.  If a matching server transaction is found, the
   * request is passed to that transaction for processing.  If no match
   * is found, the request is passed to the core, which may decide to
   * construct a new server transaction for that request.
   * https://tools.ietf.org/html/rfc6026#section-8.10
   * @param message - Incoming request message from transport layer.
   */
  receiveRequestFromTransport(message2) {
    const transactionId = message2.viaBranch;
    const uas = this.userAgentServers.get(transactionId);
    if (message2.method === C$1.ACK) {
      if (uas && uas.transaction.state === TransactionState$1.Accepted) {
        if (uas instanceof InviteUserAgentServer$1) {
          this.logger.warn(`Discarding out of dialog ACK after 2xx response sent on transaction ${transactionId}.`);
          return;
        }
      }
    }
    if (message2.method === C$1.CANCEL) {
      if (uas) {
        this.replyStateless(message2, { statusCode: 200 });
        if (uas.transaction instanceof InviteServerTransaction$1 && uas.transaction.state === TransactionState$1.Proceeding) {
          if (uas instanceof InviteUserAgentServer$1) {
            uas.receiveCancel(message2);
          }
        }
      } else {
        this.replyStateless(message2, { statusCode: 481 });
      }
      return;
    }
    if (uas) {
      uas.transaction.receiveRequest(message2);
      return;
    }
    this.receiveRequest(message2);
    return;
  }
  /**
   * UAC and UAS procedures depend strongly on two factors.  First, based
   * on whether the request or response is inside or outside of a dialog,
   * and second, based on the method of a request.  Dialogs are discussed
   * thoroughly in Section 12; they represent a peer-to-peer relationship
   * between user agents and are established by specific SIP methods, such
   * as INVITE.
   * @param message - Incoming request message.
   */
  receiveRequest(message2) {
    if (!AllowedMethods$1.includes(message2.method)) {
      const allowHeader = "Allow: " + AllowedMethods$1.toString();
      this.replyStateless(message2, {
        statusCode: 405,
        extraHeaders: [allowHeader]
      });
      return;
    }
    if (!message2.ruri) {
      throw new Error("Request-URI undefined.");
    }
    if (message2.ruri.scheme !== "sip") {
      this.replyStateless(message2, { statusCode: 416 });
      return;
    }
    const ruri = message2.ruri;
    const ruriMatches = (uri) => {
      return !!uri && uri.user === ruri.user;
    };
    if (!ruriMatches(this.configuration.aor) && !(ruriMatches(this.configuration.contact.uri) || ruriMatches(this.configuration.contact.pubGruu) || ruriMatches(this.configuration.contact.tempGruu))) {
      this.logger.warn("Request-URI does not point to us.");
      if (message2.method !== C$1.ACK) {
        this.replyStateless(message2, { statusCode: 404 });
      }
      return;
    }
    if (message2.method === C$1.INVITE) {
      if (!message2.hasHeader("Contact")) {
        this.replyStateless(message2, {
          statusCode: 400,
          reasonPhrase: "Missing Contact Header"
        });
        return;
      }
    }
    if (!message2.toTag) {
      const transactionId = message2.viaBranch;
      if (!this.userAgentServers.has(transactionId)) {
        const mergedRequest = Array.from(this.userAgentServers.values()).some((uas) => uas.transaction.request.fromTag === message2.fromTag && uas.transaction.request.callId === message2.callId && uas.transaction.request.cseq === message2.cseq);
        if (mergedRequest) {
          this.replyStateless(message2, { statusCode: 482 });
          return;
        }
      }
    }
    if (message2.toTag) {
      this.receiveInsideDialogRequest(message2);
    } else {
      this.receiveOutsideDialogRequest(message2);
    }
    return;
  }
  /**
   * Once a dialog has been established between two UAs, either of them
   * MAY initiate new transactions as needed within the dialog.  The UA
   * sending the request will take the UAC role for the transaction.  The
   * UA receiving the request will take the UAS role.  Note that these may
   * be different roles than the UAs held during the transaction that
   * established the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.2
   * @param message - Incoming request message.
   */
  receiveInsideDialogRequest(message2) {
    if (message2.method === C$1.NOTIFY) {
      const event = message2.parseHeader("Event");
      if (!event || !event.event) {
        this.replyStateless(message2, { statusCode: 489 });
        return;
      }
      const subscriberId = message2.callId + message2.toTag + event.event;
      const subscriber = this.subscribers.get(subscriberId);
      if (subscriber) {
        const uas = new NotifyUserAgentServer$1(this, message2);
        subscriber.onNotify(uas);
        return;
      }
    }
    const dialogId = message2.callId + message2.toTag + message2.fromTag;
    const dialog = this.dialogs.get(dialogId);
    if (dialog) {
      if (message2.method === C$1.OPTIONS) {
        const allowHeader = "Allow: " + AllowedMethods$1.toString();
        const acceptHeader = "Accept: " + acceptedBodyTypes$1.toString();
        this.replyStateless(message2, {
          statusCode: 200,
          extraHeaders: [allowHeader, acceptHeader]
        });
        return;
      }
      dialog.receiveRequest(message2);
      return;
    }
    if (message2.method === C$1.ACK) {
      return;
    }
    this.replyStateless(message2, { statusCode: 481 });
    return;
  }
  /**
   * Assuming all of the checks in the previous subsections are passed,
   * the UAS processing becomes method-specific.
   *  https://tools.ietf.org/html/rfc3261#section-8.2.5
   * @param message - Incoming request message.
   */
  receiveOutsideDialogRequest(message2) {
    switch (message2.method) {
      case C$1.ACK:
        break;
      case C$1.BYE:
        this.replyStateless(message2, { statusCode: 481 });
        break;
      case C$1.CANCEL:
        throw new Error(`Unexpected out of dialog request method ${message2.method}.`);
      case C$1.INFO:
        this.replyStateless(message2, { statusCode: 405 });
        break;
      case C$1.INVITE:
        {
          const uas = new InviteUserAgentServer$1(this, message2);
          this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();
        }
        break;
      case C$1.MESSAGE:
        {
          const uas = new MessageUserAgentServer$1(this, message2);
          this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();
        }
        break;
      case C$1.NOTIFY:
        {
          const uas = new NotifyUserAgentServer$1(this, message2);
          this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.reject({ statusCode: 405 });
        }
        break;
      case C$1.OPTIONS:
        {
          const allowHeader = "Allow: " + AllowedMethods$1.toString();
          const acceptHeader = "Accept: " + acceptedBodyTypes$1.toString();
          this.replyStateless(message2, {
            statusCode: 200,
            extraHeaders: [allowHeader, acceptHeader]
          });
        }
        break;
      case C$1.REFER:
        {
          const uas = new ReferUserAgentServer$1(this, message2);
          this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject({ statusCode: 405 });
        }
        break;
      case C$1.REGISTER:
        {
          const uas = new RegisterUserAgentServer$1(this, message2);
          this.delegate.onRegister ? this.delegate.onRegister(uas) : uas.reject({ statusCode: 405 });
        }
        break;
      case C$1.SUBSCRIBE:
        {
          const uas = new SubscribeUserAgentServer$1(this, message2);
          this.delegate.onSubscribe ? this.delegate.onSubscribe(uas) : uas.reject({ statusCode: 480 });
        }
        break;
      default:
        throw new Error(`Unexpected out of dialog request method ${message2.method}.`);
    }
    return;
  }
  /**
   * Responses are first processed by the transport layer and then passed
   * up to the transaction layer.  The transaction layer performs its
   * processing and then passes the response up to the TU.  The majority
   * of response processing in the TU is method specific.  However, there
   * are some general behaviors independent of the method.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3
   * @param message - Incoming response message from transport layer.
   */
  receiveResponseFromTransport(message2) {
    if (message2.getHeaders("via").length > 1) {
      this.logger.warn("More than one Via header field present in the response, dropping");
      return;
    }
    const userAgentClientId = message2.viaBranch + message2.method;
    const userAgentClient = this.userAgentClients.get(userAgentClientId);
    if (userAgentClient) {
      userAgentClient.transaction.receiveResponse(message2);
    } else {
      this.logger.warn(`Discarding unmatched ${message2.statusCode} response to ${message2.method} ${userAgentClientId}.`);
    }
  }
};
let StateTransitionError$1 = class StateTransitionError extends Exception$1 {
  constructor(message2) {
    super(message2 ? message2 : "An error occurred during state transition.");
  }
};
var TransportState$1;
(function(TransportState2) {
  TransportState2["Connecting"] = "Connecting";
  TransportState2["Connected"] = "Connected";
  TransportState2["Disconnecting"] = "Disconnecting";
  TransportState2["Disconnected"] = "Disconnected";
})(TransportState$1 = TransportState$1 || (TransportState$1 = {}));
let Transport$2 = class Transport {
  constructor(logger, options) {
    this._state = TransportState$1.Disconnected;
    this.transitioningState = false;
    this._stateEventEmitter = new EmitterImpl$1();
    this.logger = logger;
    if (options) {
      const optionsDeprecated = options;
      const wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;
      const maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;
      if (wsServersDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "wsServers" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (maxReconnectionAttemptsDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "maxReconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (wsServersDeprecated && !options.server) {
        if (typeof wsServersDeprecated === "string") {
          options.server = wsServersDeprecated;
        }
        if (wsServersDeprecated instanceof Array) {
          options.server = wsServersDeprecated[0];
        }
      }
    }
    this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options);
    const url2 = this.configuration.server;
    const parsed = Grammar$1.parse(url2, "absoluteURI");
    if (parsed === -1) {
      this.logger.error(`Invalid WebSocket Server URL "${url2}"`);
      throw new Error("Invalid WebSocket Server URL");
    }
    if (!["wss", "ws", "udp"].includes(parsed.scheme)) {
      this.logger.error(`Invalid scheme in WebSocket Server URL "${url2}"`);
      throw new Error("Invalid scheme in WebSocket Server URL");
    }
    this._protocol = parsed.scheme.toUpperCase();
  }
  dispose() {
    return this.disconnect();
  }
  /**
   * The protocol.
   *
   * @remarks
   * Formatted as defined for the Via header sent-protocol transport.
   * https://tools.ietf.org/html/rfc3261#section-20.42
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * The URL of the WebSocket Server.
   */
  get server() {
    return this.configuration.server;
  }
  /**
   * Transport state.
   */
  get state() {
    return this._state;
  }
  /**
   * Transport state change emitter.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * The WebSocket.
   */
  get ws() {
    return this._ws;
  }
  /**
   * Connect to network.
   * Resolves once connected. Otherwise rejects with an Error.
   */
  connect() {
    return this._connect();
  }
  /**
   * Disconnect from network.
   * Resolves once disconnected. Otherwise rejects with an Error.
   */
  disconnect() {
    return this._disconnect();
  }
  /**
   * Returns true if the `state` equals "Connected".
   * @remarks
   * This is equivalent to `state === TransportState.Connected`.
   */
  isConnected() {
    return this.state === TransportState$1.Connected;
  }
  /**
   * Sends a message.
   * Resolves once message is sent. Otherwise rejects with an Error.
   * @param message - Message to send.
   */
  send(message2) {
    return this._send(message2);
  }
  _connect() {
    this.logger.log(`Connecting ${this.server}`);
    switch (this.state) {
      case TransportState$1.Connecting:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState$1.Connecting));
        }
        if (!this.connectPromise) {
          throw new Error("Connect promise must be defined.");
        }
        return this.connectPromise;
      case TransportState$1.Connected:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState$1.Connecting));
        }
        if (this.connectPromise) {
          throw new Error("Connect promise must not be defined.");
        }
        return Promise.resolve();
      case TransportState$1.Disconnecting:
        if (this.connectPromise) {
          throw new Error("Connect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState$1.Connecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError$1) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      case TransportState$1.Disconnected:
        if (this.connectPromise) {
          throw new Error("Connect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState$1.Connecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError$1) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      default:
        throw new Error("Unknown state");
    }
    let ws;
    try {
      ws = new WebSocket(this.server, "sip");
      ws.binaryType = "arraybuffer";
      ws.addEventListener("close", (ev) => this.onWebSocketClose(ev, ws));
      ws.addEventListener("error", (ev) => this.onWebSocketError(ev, ws));
      ws.addEventListener("open", (ev) => this.onWebSocketOpen(ev, ws));
      ws.addEventListener("message", (ev) => this.onWebSocketMessage(ev, ws));
      this._ws = ws;
    } catch (error) {
      this._ws = void 0;
      this.logger.error("WebSocket construction failed.");
      this.logger.error(error.toString());
      return new Promise((resolve, reject) => {
        this.connectResolve = resolve;
        this.connectReject = reject;
        this.transitionState(TransportState$1.Disconnected, error);
      });
    }
    this.connectPromise = new Promise((resolve, reject) => {
      this.connectResolve = resolve;
      this.connectReject = reject;
      this.connectTimeout = setTimeout(() => {
        this.logger.warn("Connect timed out. Exceeded time set in configuration.connectionTimeout: " + this.configuration.connectionTimeout + "s.");
        ws.close(1e3);
      }, this.configuration.connectionTimeout * 1e3);
    });
    return this.connectPromise;
  }
  _disconnect() {
    this.logger.log(`Disconnecting ${this.server}`);
    switch (this.state) {
      case TransportState$1.Connecting:
        if (this.disconnectPromise) {
          throw new Error("Disconnect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState$1.Disconnecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError$1) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      case TransportState$1.Connected:
        if (this.disconnectPromise) {
          throw new Error("Disconnect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState$1.Disconnecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError$1) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      case TransportState$1.Disconnecting:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState$1.Disconnecting));
        }
        if (!this.disconnectPromise) {
          throw new Error("Disconnect promise must be defined.");
        }
        return this.disconnectPromise;
      case TransportState$1.Disconnected:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState$1.Disconnecting));
        }
        if (this.disconnectPromise) {
          throw new Error("Disconnect promise must not be defined.");
        }
        return Promise.resolve();
      default:
        throw new Error("Unknown state");
    }
    if (!this._ws) {
      throw new Error("WebSocket must be defined.");
    }
    const ws = this._ws;
    this.disconnectPromise = new Promise((resolve, reject) => {
      this.disconnectResolve = resolve;
      this.disconnectReject = reject;
      try {
        ws.close(1e3);
      } catch (error) {
        this.logger.error("WebSocket close failed.");
        this.logger.error(error.toString());
        throw error;
      }
    });
    return this.disconnectPromise;
  }
  _send(message2) {
    if (this.configuration.traceSip === true) {
      this.logger.log("Sending WebSocket message:\n\n" + message2 + "\n");
    }
    if (this._state !== TransportState$1.Connected) {
      return Promise.reject(new Error("Not connected."));
    }
    if (!this._ws) {
      throw new Error("WebSocket undefined.");
    }
    try {
      this._ws.send(message2);
    } catch (error) {
      if (error instanceof Error) {
        return Promise.reject(error);
      }
      return Promise.reject(new Error("WebSocket send failed."));
    }
    return Promise.resolve();
  }
  /**
   * WebSocket "onclose" event handler.
   * @param ev - Event.
   */
  onWebSocketClose(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    const message2 = `WebSocket closed ${this.server} (code: ${ev.code})`;
    const error = !this.disconnectPromise ? new Error(message2) : void 0;
    if (error) {
      this.logger.warn("WebSocket closed unexpectedly");
    }
    this.logger.log(message2);
    this._ws = void 0;
    this.transitionState(TransportState$1.Disconnected, error);
  }
  /**
   * WebSocket "onerror" event handler.
   * @param ev - Event.
   */
  onWebSocketError(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    this.logger.error("WebSocket error occurred.");
  }
  /**
   * WebSocket "onmessage" event handler.
   * @param ev - Event.
   */
  onWebSocketMessage(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    const data = ev.data;
    let finishedData;
    if (/^(\r\n)+$/.test(data)) {
      this.clearKeepAliveTimeout();
      if (this.configuration.traceSip === true) {
        this.logger.log("Received WebSocket message with CRLF Keep Alive response");
      }
      return;
    }
    if (!data) {
      this.logger.warn("Received empty message, discarding...");
      return;
    }
    if (typeof data !== "string") {
      try {
        finishedData = new TextDecoder().decode(new Uint8Array(data));
      } catch (err) {
        this.logger.error(err.toString());
        this.logger.error("Received WebSocket binary message failed to be converted into string, message discarded");
        return;
      }
      if (this.configuration.traceSip === true) {
        this.logger.log("Received WebSocket binary message:\n\n" + finishedData + "\n");
      }
    } else {
      finishedData = data;
      if (this.configuration.traceSip === true) {
        this.logger.log("Received WebSocket text message:\n\n" + finishedData + "\n");
      }
    }
    if (this.state !== TransportState$1.Connected) {
      this.logger.warn("Received message while not connected, discarding...");
      return;
    }
    if (this.onMessage) {
      try {
        this.onMessage(finishedData);
      } catch (e2) {
        this.logger.error(e2.toString());
        this.logger.error("Exception thrown by onMessage callback");
        throw e2;
      }
    }
  }
  /**
   * WebSocket "onopen" event handler.
   * @param ev - Event.
   */
  onWebSocketOpen(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    if (this._state === TransportState$1.Connecting) {
      this.logger.log(`WebSocket opened ${this.server}`);
      this.transitionState(TransportState$1.Connected);
    }
  }
  /**
   * Helper function to generate an Error.
   * @param state - State transitioning to.
   */
  transitionLoopDetectedError(state) {
    let message2 = `A state transition loop has been detected.`;
    message2 += ` An attempt to transition from ${this._state} to ${state} before the prior transition completed.`;
    message2 += ` Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?`;
    this.logger.error(message2);
    return new StateTransitionError$1("Loop detected.");
  }
  /**
   * Transition transport state.
   * @internal
   */
  transitionState(newState, error) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    if (this.transitioningState) {
      throw this.transitionLoopDetectedError(newState);
    }
    this.transitioningState = true;
    switch (this._state) {
      case TransportState$1.Connecting:
        if (newState !== TransportState$1.Connected && newState !== TransportState$1.Disconnecting && newState !== TransportState$1.Disconnected) {
          invalidTransition();
        }
        break;
      case TransportState$1.Connected:
        if (newState !== TransportState$1.Disconnecting && newState !== TransportState$1.Disconnected) {
          invalidTransition();
        }
        break;
      case TransportState$1.Disconnecting:
        if (newState !== TransportState$1.Connecting && newState !== TransportState$1.Disconnected) {
          invalidTransition();
        }
        break;
      case TransportState$1.Disconnected:
        if (newState !== TransportState$1.Connecting) {
          invalidTransition();
        }
        break;
      default:
        throw new Error("Unknown state.");
    }
    const oldState = this._state;
    this._state = newState;
    const connectResolve = this.connectResolve;
    const connectReject = this.connectReject;
    if (oldState === TransportState$1.Connecting) {
      this.connectPromise = void 0;
      this.connectResolve = void 0;
      this.connectReject = void 0;
    }
    const disconnectResolve = this.disconnectResolve;
    const disconnectReject = this.disconnectReject;
    if (oldState === TransportState$1.Disconnecting) {
      this.disconnectPromise = void 0;
      this.disconnectResolve = void 0;
      this.disconnectReject = void 0;
    }
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
    this.logger.log(`Transitioned from ${oldState} to ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === TransportState$1.Connected) {
      this.startSendingKeepAlives();
      if (this.onConnect) {
        try {
          this.onConnect();
        } catch (e2) {
          this.logger.error(e2.toString());
          this.logger.error("Exception thrown by onConnect callback");
          throw e2;
        }
      }
    }
    if (oldState === TransportState$1.Connected) {
      this.stopSendingKeepAlives();
      if (this.onDisconnect) {
        try {
          if (error) {
            this.onDisconnect(error);
          } else {
            this.onDisconnect();
          }
        } catch (e2) {
          this.logger.error(e2.toString());
          this.logger.error("Exception thrown by onDisconnect callback");
          throw e2;
        }
      }
    }
    if (oldState === TransportState$1.Connecting) {
      if (!connectResolve) {
        throw new Error("Connect resolve undefined.");
      }
      if (!connectReject) {
        throw new Error("Connect reject undefined.");
      }
      newState === TransportState$1.Connected ? connectResolve() : connectReject(error || new Error("Connect aborted."));
    }
    if (oldState === TransportState$1.Disconnecting) {
      if (!disconnectResolve) {
        throw new Error("Disconnect resolve undefined.");
      }
      if (!disconnectReject) {
        throw new Error("Disconnect reject undefined.");
      }
      newState === TransportState$1.Disconnected ? disconnectResolve() : disconnectReject(error || new Error("Disconnect aborted."));
    }
    this.transitioningState = false;
  }
  // TODO: Review "KeepAlive Stuff".
  // It is not clear if it works and there are no tests for it.
  // It was blindly lifted the keep alive code unchanged from earlier transport code.
  //
  // From the RFC...
  //
  // SIP WebSocket Clients and Servers may keep their WebSocket
  // connections open by sending periodic WebSocket "Ping" frames as
  // described in [RFC6455], Section 5.5.2.
  // ...
  // The indication and use of the CRLF NAT keep-alive mechanism defined
  // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or
  // [RFC6223] are, of course, usable over the transport defined in this
  // specification.
  // https://tools.ietf.org/html/rfc7118#section-6
  //
  // and...
  //
  // The Ping frame contains an opcode of 0x9.
  // https://tools.ietf.org/html/rfc6455#section-5.5.2
  //
  // ==============================
  // KeepAlive Stuff
  // ==============================
  clearKeepAliveTimeout() {
    if (this.keepAliveDebounceTimeout) {
      clearTimeout(this.keepAliveDebounceTimeout);
    }
    this.keepAliveDebounceTimeout = void 0;
  }
  /**
   * Send a keep-alive (a double-CRLF sequence).
   */
  sendKeepAlive() {
    if (this.keepAliveDebounceTimeout) {
      return Promise.resolve();
    }
    this.keepAliveDebounceTimeout = setTimeout(() => {
      this.clearKeepAliveTimeout();
    }, this.configuration.keepAliveDebounce * 1e3);
    return this.send("\r\n\r\n");
  }
  /**
   * Start sending keep-alives.
   */
  startSendingKeepAlives() {
    const computeKeepAliveTimeout = (upperBound) => {
      const lowerBound = upperBound * 0.8;
      return 1e3 * (Math.random() * (upperBound - lowerBound) + lowerBound);
    };
    if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
      this.keepAliveInterval = setInterval(() => {
        this.sendKeepAlive();
        this.startSendingKeepAlives();
      }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
    }
  }
  /**
   * Stop sending keep-alives.
   */
  stopSendingKeepAlives() {
    if (this.keepAliveInterval) {
      clearInterval(this.keepAliveInterval);
    }
    if (this.keepAliveDebounceTimeout) {
      clearTimeout(this.keepAliveDebounceTimeout);
    }
    this.keepAliveInterval = void 0;
    this.keepAliveDebounceTimeout = void 0;
  }
};
Transport$2.defaultOptions = {
  server: "",
  connectionTimeout: 5,
  keepAliveInterval: 0,
  keepAliveDebounce: 10,
  traceSip: true
};
const LIBRARY_VERSION$1 = "0.21.1";
var UserAgentState$1;
(function(UserAgentState2) {
  UserAgentState2["Started"] = "Started";
  UserAgentState2["Stopped"] = "Stopped";
})(UserAgentState$1 = UserAgentState$1 || (UserAgentState$1 = {}));
let UserAgent$1 = class UserAgent {
  /**
   * Constructs a new instance of the `UserAgent` class.
   * @param options - Options bucket. See {@link UserAgentOptions} for details.
   */
  constructor(options = {}) {
    this._publishers = {};
    this._registerers = {};
    this._sessions = {};
    this._subscriptions = {};
    this._state = UserAgentState$1.Stopped;
    this._stateEventEmitter = new EmitterImpl$1();
    this.delegate = options.delegate;
    this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), { sipjsId: createRandomToken$1(5) }), { uri: new URI$1("sip", "anonymous." + createRandomToken$1(6), "anonymous.invalid") }), { viaHost: createRandomToken$1(12) + ".invalid" }), UserAgent.stripUndefinedProperties(options));
    if (this.options.hackIpInContact) {
      if (typeof this.options.hackIpInContact === "boolean" && this.options.hackIpInContact) {
        const from = 1;
        const to = 254;
        const octet = Math.floor(Math.random() * (to - from + 1) + from);
        this.options.viaHost = "192.0.2." + octet;
      } else if (this.options.hackIpInContact) {
        this.options.viaHost = this.options.hackIpInContact;
      }
    }
    this.loggerFactory = new LoggerFactory$1();
    this.logger = this.loggerFactory.getLogger("sip.UserAgent");
    this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;
    this.loggerFactory.connector = this.options.logConnector;
    switch (this.options.logLevel) {
      case "error":
        this.loggerFactory.level = Levels$1.error;
        break;
      case "warn":
        this.loggerFactory.level = Levels$1.warn;
        break;
      case "log":
        this.loggerFactory.level = Levels$1.log;
        break;
      case "debug":
        this.loggerFactory.level = Levels$1.debug;
        break;
    }
    if (this.options.logConfiguration) {
      this.logger.log("Configuration:");
      Object.keys(this.options).forEach((key) => {
        const value2 = this.options[key];
        switch (key) {
          case "uri":
          case "sessionDescriptionHandlerFactory":
            this.logger.log("· " + key + ": " + value2);
            break;
          case "authorizationPassword":
            this.logger.log("· " + key + ": NOT SHOWN");
            break;
          case "transportConstructor":
            this.logger.log("· " + key + ": " + value2.name);
            break;
          default:
            this.logger.log("· " + key + ": " + JSON.stringify(value2));
        }
      });
    }
    if (this.options.transportOptions) {
      const optionsDeprecated = this.options.transportOptions;
      const maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;
      const reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;
      if (maxReconnectionAttemptsDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "maxReconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (reconnectionTimeoutDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "reconnectionTimeout" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (options.reconnectionDelay === void 0 && reconnectionTimeoutDeprecated !== void 0) {
        this.options.reconnectionDelay = reconnectionTimeoutDeprecated;
      }
      if (options.reconnectionAttempts === void 0 && maxReconnectionAttemptsDeprecated !== void 0) {
        this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;
      }
    }
    if (options.reconnectionDelay !== void 0) {
      const deprecatedMessage = `The user agent option "reconnectionDelay" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
      this.logger.warn(deprecatedMessage);
    }
    if (options.reconnectionAttempts !== void 0) {
      const deprecatedMessage = `The user agent option "reconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
      this.logger.warn(deprecatedMessage);
    }
    this._transport = new this.options.transportConstructor(this.getLogger("sip.Transport"), this.options.transportOptions);
    this.initTransportCallbacks();
    this._contact = this.initContact();
    this._instanceId = this.options.instanceId ? this.options.instanceId : UserAgent.newUUID();
    if (Grammar$1.parse(this._instanceId, "uuid") === -1) {
      throw new Error("Invalid instanceId.");
    }
    this._userAgentCore = this.initCore();
  }
  /**
   * Create a URI instance from a string.
   * @param uri - The string to parse.
   *
   * @remarks
   * Returns undefined if the syntax of the URI is invalid.
   * The syntax must conform to a SIP URI as defined in the RFC.
   * 25 Augmented BNF for the SIP Protocol
   * https://tools.ietf.org/html/rfc3261#section-25
   *
   * @example
   * ```ts
   * const uri = UserAgent.makeURI("sip:edgar@example.com");
   * ```
   */
  static makeURI(uri) {
    return Grammar$1.URIParse(uri);
  }
  /** Default user agent options. */
  static defaultOptions() {
    return {
      allowLegacyNotifications: false,
      authorizationHa1: "",
      authorizationPassword: "",
      authorizationUsername: "",
      delegate: {},
      contactName: "",
      contactParams: { transport: "ws" },
      displayName: "",
      forceRport: false,
      gracefulShutdown: true,
      hackAllowUnregisteredOptionTags: false,
      hackIpInContact: false,
      hackViaTcp: false,
      instanceId: "",
      instanceIdAlwaysAdded: false,
      logBuiltinEnabled: true,
      logConfiguration: true,
      logConnector: () => {
      },
      logLevel: "log",
      noAnswerTimeout: 60,
      preloadedRouteSet: [],
      reconnectionAttempts: 0,
      reconnectionDelay: 4,
      sendInitialProvisionalResponse: true,
      sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory$1(),
      sessionDescriptionHandlerFactoryOptions: {},
      sipExtension100rel: SIPExtension$1.Unsupported,
      sipExtensionReplaces: SIPExtension$1.Unsupported,
      sipExtensionExtraSupported: [],
      sipjsId: "",
      transportConstructor: Transport$2,
      transportOptions: {},
      uri: new URI$1("sip", "anonymous", "anonymous.invalid"),
      userAgentString: "SIP.js/" + LIBRARY_VERSION$1,
      viaHost: ""
    };
  }
  // http://stackoverflow.com/users/109538/broofa
  static newUUID() {
    const UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
      const r2 = Math.floor(Math.random() * 16);
      const v = c2 === "x" ? r2 : r2 % 4 + 8;
      return v.toString(16);
    });
    return UUID;
  }
  /**
   * Strip properties with undefined values from options.
   * This is a work around while waiting for missing vs undefined to be addressed (or not)...
   * https://github.com/Microsoft/TypeScript/issues/13195
   * @param options - Options to reduce
   */
  static stripUndefinedProperties(options) {
    return Object.keys(options).reduce((object, key) => {
      if (options[key] !== void 0) {
        object[key] = options[key];
      }
      return object;
    }, {});
  }
  /**
   * User agent configuration.
   */
  get configuration() {
    return this.options;
  }
  /**
   * User agent contact.
   */
  get contact() {
    return this._contact;
  }
  /**
   * User agent instance id.
   */
  get instanceId() {
    return this._instanceId;
  }
  /**
   * User agent state.
   */
  get state() {
    return this._state;
  }
  /**
   * User agent state change emitter.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * User agent transport.
   */
  get transport() {
    return this._transport;
  }
  /**
   * User agent core.
   */
  get userAgentCore() {
    return this._userAgentCore;
  }
  /**
   * The logger.
   */
  getLogger(category, label) {
    return this.loggerFactory.getLogger(category, label);
  }
  /**
   * The logger factory.
   */
  getLoggerFactory() {
    return this.loggerFactory;
  }
  /**
   * True if transport is connected.
   */
  isConnected() {
    return this.transport.isConnected();
  }
  /**
   * Reconnect the transport.
   */
  reconnect() {
    if (this.state === UserAgentState$1.Stopped) {
      return Promise.reject(new Error("User agent stopped."));
    }
    return Promise.resolve().then(() => this.transport.connect());
  }
  /**
   * Start the user agent.
   *
   * @remarks
   * Resolves if transport connects, otherwise rejects.
   * Calling `start()` after calling `stop()` will fail if `stop()` has yet to resolve.
   *
   * @example
   * ```ts
   * userAgent.start()
   *   .then(() => {
   *     // userAgent.isConnected() === true
   *   })
   *   .catch((error: Error) => {
   *     // userAgent.isConnected() === false
   *   });
   * ```
   */
  start() {
    if (this.state === UserAgentState$1.Started) {
      this.logger.warn(`User agent already started`);
      return Promise.resolve();
    }
    this.logger.log(`Starting ${this.configuration.uri}`);
    this.transitionState(UserAgentState$1.Started);
    return this.transport.connect();
  }
  /**
   * Stop the user agent.
   *
   * @remarks
   * Resolves when the user agent has completed a graceful shutdown.
   * ```txt
   * 1) Sessions terminate.
   * 2) Registerers unregister.
   * 3) Subscribers unsubscribe.
   * 4) Publishers unpublish.
   * 5) Transport disconnects.
   * 6) User Agent Core resets.
   * ```
   * The user agent state transistions to stopped once these steps have been completed.
   * Calling `start()` after calling `stop()` will fail if `stop()` has yet to resolve.
   *
   * NOTE: While this is a "graceful shutdown", it can also be very slow one if you
   * are waiting for the returned Promise to resolve. The disposal of the clients and
   * dialogs is done serially - waiting on one to finish before moving on to the next.
   * This can be slow if there are lot of subscriptions to unsubscribe for example.
   *
   * THE SLOW PACE IS INTENTIONAL!
   * While one could spin them all down in parallel, this could slam the remote server.
   * It is bad practice to denial of service attack (DoS attack) servers!!!
   * Moreover, production servers will automatically blacklist clients which send too
   * many requests in too short a period of time - dropping any additional requests.
   *
   * If a different approach to disposing is needed, one can implement whatever is
   * needed and execute that prior to calling `stop()`. Alternatively one may simply
   * not wait for the Promise returned by `stop()` to complete.
   */
  async stop() {
    if (this.state === UserAgentState$1.Stopped) {
      this.logger.warn(`User agent already stopped`);
      return Promise.resolve();
    }
    this.logger.log(`Stopping ${this.configuration.uri}`);
    if (!this.options.gracefulShutdown) {
      this.logger.log(`Dispose of transport`);
      this.transport.dispose().catch((error) => {
        this.logger.error(error.message);
        throw error;
      });
      this.logger.log(`Dispose of core`);
      this.userAgentCore.dispose();
      this._publishers = {};
      this._registerers = {};
      this._sessions = {};
      this._subscriptions = {};
      this.transitionState(UserAgentState$1.Stopped);
      return Promise.resolve();
    }
    const publishers = Object.assign({}, this._publishers);
    const registerers = Object.assign({}, this._registerers);
    const sessions = Object.assign({}, this._sessions);
    const subscriptions = Object.assign({}, this._subscriptions);
    const transport = this.transport;
    const userAgentCore = this.userAgentCore;
    this.logger.log(`Dispose of registerers`);
    for (const id in registerers) {
      if (registerers[id]) {
        await registerers[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._registerers[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of sessions`);
    for (const id in sessions) {
      if (sessions[id]) {
        await sessions[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._sessions[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of subscriptions`);
    for (const id in subscriptions) {
      if (subscriptions[id]) {
        await subscriptions[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._subscriptions[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of publishers`);
    for (const id in publishers) {
      if (publishers[id]) {
        await publishers[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._publishers[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of transport`);
    await transport.dispose().catch((error) => {
      this.logger.error(error.message);
      throw error;
    });
    this.logger.log(`Dispose of core`);
    userAgentCore.dispose();
    this.transitionState(UserAgentState$1.Stopped);
  }
  /**
   * Used to avoid circular references.
   * @internal
   */
  _makeInviter(targetURI, options) {
    return new Inviter$1(this, targetURI, options);
  }
  /**
   * Attempt reconnection up to `maxReconnectionAttempts` times.
   * @param reconnectionAttempt - Current attempt number.
   */
  attemptReconnection(reconnectionAttempt = 1) {
    const reconnectionAttempts = this.options.reconnectionAttempts;
    const reconnectionDelay = this.options.reconnectionDelay;
    if (reconnectionAttempt > reconnectionAttempts) {
      this.logger.log(`Maximum reconnection attempts reached`);
      return;
    }
    this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);
    setTimeout(() => {
      this.reconnect().then(() => {
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);
      }).catch((error) => {
        this.logger.error(error.message);
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);
        this.attemptReconnection(++reconnectionAttempt);
      });
    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1e3);
  }
  /**
   * Initialize contact.
   */
  initContact() {
    const contactName = this.options.contactName !== "" ? this.options.contactName : createRandomToken$1(8);
    const contactParams = this.options.contactParams;
    const contact2 = {
      pubGruu: void 0,
      tempGruu: void 0,
      uri: new URI$1("sip", contactName, this.options.viaHost, void 0, contactParams),
      toString: (contactToStringOptions = {}) => {
        const anonymous = contactToStringOptions.anonymous || false;
        const outbound = contactToStringOptions.outbound || false;
        const register = contactToStringOptions.register || false;
        let contactString = "<";
        if (anonymous) {
          contactString += this.contact.tempGruu || `sip:anonymous@anonymous.invalid;transport=${contactParams.transport ? contactParams.transport : "ws"}`;
        } else if (register) {
          contactString += this.contact.uri;
        } else {
          contactString += this.contact.pubGruu || this.contact.uri;
        }
        if (outbound) {
          contactString += ";ob";
        }
        contactString += ">";
        if (this.options.instanceIdAlwaysAdded) {
          contactString += ';+sip.instance="<urn:uuid:' + this._instanceId + '>"';
        }
        return contactString;
      }
    };
    return contact2;
  }
  /**
   * Initialize user agent core.
   */
  initCore() {
    let supportedOptionTags = [];
    supportedOptionTags.push("outbound");
    if (this.options.sipExtension100rel === SIPExtension$1.Supported) {
      supportedOptionTags.push("100rel");
    }
    if (this.options.sipExtensionReplaces === SIPExtension$1.Supported) {
      supportedOptionTags.push("replaces");
    }
    if (this.options.sipExtensionExtraSupported) {
      supportedOptionTags.push(...this.options.sipExtensionExtraSupported);
    }
    if (!this.options.hackAllowUnregisteredOptionTags) {
      supportedOptionTags = supportedOptionTags.filter((optionTag) => UserAgentRegisteredOptionTags$1[optionTag]);
    }
    supportedOptionTags = Array.from(new Set(supportedOptionTags));
    const supportedOptionTagsResponse = supportedOptionTags.slice();
    if (this.contact.pubGruu || this.contact.tempGruu) {
      supportedOptionTagsResponse.push("gruu");
    }
    const userAgentCoreConfiguration = {
      aor: this.options.uri,
      contact: this.contact,
      displayName: this.options.displayName,
      loggerFactory: this.loggerFactory,
      hackViaTcp: this.options.hackViaTcp,
      routeSet: this.options.preloadedRouteSet,
      supportedOptionTags,
      supportedOptionTagsResponse,
      sipjsId: this.options.sipjsId,
      userAgentHeaderFieldValue: this.options.userAgentString,
      viaForceRport: this.options.forceRport,
      viaHost: this.options.viaHost,
      authenticationFactory: () => {
        const username = this.options.authorizationUsername ? this.options.authorizationUsername : this.options.uri.user;
        const password = this.options.authorizationPassword ? this.options.authorizationPassword : void 0;
        const ha1 = this.options.authorizationHa1 ? this.options.authorizationHa1 : void 0;
        return new DigestAuthentication$1(this.getLoggerFactory(), ha1, username, password);
      },
      transportAccessor: () => this.transport
    };
    const userAgentCoreDelegate = {
      onInvite: (incomingInviteRequest) => {
        var _a;
        const invitation = new Invitation$1(this, incomingInviteRequest);
        incomingInviteRequest.delegate = {
          onCancel: (cancel) => {
            invitation._onCancel(cancel);
          },
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onTransportError: (error) => {
            this.logger.error("A transport error has occurred while handling an incoming INVITE request.");
          }
        };
        incomingInviteRequest.trying();
        if (this.options.sipExtensionReplaces !== SIPExtension$1.Unsupported) {
          const message2 = incomingInviteRequest.message;
          const replaces = message2.parseHeader("replaces");
          if (replaces) {
            const callId = replaces.call_id;
            if (typeof callId !== "string") {
              throw new Error("Type of call id is not string");
            }
            const toTag = replaces.replaces_to_tag;
            if (typeof toTag !== "string") {
              throw new Error("Type of to tag is not string");
            }
            const fromTag = replaces.replaces_from_tag;
            if (typeof fromTag !== "string") {
              throw new Error("type of from tag is not string");
            }
            const targetDialogId = callId + toTag + fromTag;
            const targetDialog = this.userAgentCore.dialogs.get(targetDialogId);
            if (!targetDialog) {
              invitation.reject({ statusCode: 481 });
              return;
            }
            if (!targetDialog.early && replaces.early_only === true) {
              invitation.reject({ statusCode: 486 });
              return;
            }
            const targetSession = this._sessions[callId + fromTag] || this._sessions[callId + toTag] || void 0;
            if (!targetSession) {
              throw new Error("Session does not exist.");
            }
            invitation._replacee = targetSession;
          }
        }
        if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {
          if (invitation.autoSendAnInitialProvisionalResponse) {
            invitation.progress().then(() => {
              var _a2;
              if (((_a2 = this.delegate) === null || _a2 === void 0 ? void 0 : _a2.onInvite) === void 0) {
                throw new Error("onInvite undefined.");
              }
              this.delegate.onInvite(invitation);
            });
            return;
          }
          this.delegate.onInvite(invitation);
          return;
        }
        invitation.reject({ statusCode: 486 });
      },
      onMessage: (incomingMessageRequest) => {
        if (this.delegate && this.delegate.onMessage) {
          const message2 = new Message$1(incomingMessageRequest);
          this.delegate.onMessage(message2);
        } else {
          incomingMessageRequest.accept();
        }
      },
      onNotify: (incomingNotifyRequest) => {
        if (this.delegate && this.delegate.onNotify) {
          const notification = new Notification$1(incomingNotifyRequest);
          this.delegate.onNotify(notification);
        } else {
          if (this.options.allowLegacyNotifications) {
            incomingNotifyRequest.accept();
          } else {
            incomingNotifyRequest.reject({ statusCode: 481 });
          }
        }
      },
      onRefer: (incomingReferRequest) => {
        this.logger.warn("Received an out of dialog REFER request");
        if (this.delegate && this.delegate.onReferRequest) {
          this.delegate.onReferRequest(incomingReferRequest);
        } else {
          incomingReferRequest.reject({ statusCode: 405 });
        }
      },
      onRegister: (incomingRegisterRequest) => {
        this.logger.warn("Received an out of dialog REGISTER request");
        if (this.delegate && this.delegate.onRegisterRequest) {
          this.delegate.onRegisterRequest(incomingRegisterRequest);
        } else {
          incomingRegisterRequest.reject({ statusCode: 405 });
        }
      },
      onSubscribe: (incomingSubscribeRequest) => {
        this.logger.warn("Received an out of dialog SUBSCRIBE request");
        if (this.delegate && this.delegate.onSubscribeRequest) {
          this.delegate.onSubscribeRequest(incomingSubscribeRequest);
        } else {
          incomingSubscribeRequest.reject({ statusCode: 405 });
        }
      }
    };
    return new UserAgentCore$1(userAgentCoreConfiguration, userAgentCoreDelegate);
  }
  initTransportCallbacks() {
    this.transport.onConnect = () => this.onTransportConnect();
    this.transport.onDisconnect = (error) => this.onTransportDisconnect(error);
    this.transport.onMessage = (message2) => this.onTransportMessage(message2);
  }
  onTransportConnect() {
    if (this.state === UserAgentState$1.Stopped) {
      return;
    }
    if (this.delegate && this.delegate.onConnect) {
      this.delegate.onConnect();
    }
  }
  onTransportDisconnect(error) {
    if (this.state === UserAgentState$1.Stopped) {
      return;
    }
    if (this.delegate && this.delegate.onDisconnect) {
      this.delegate.onDisconnect(error);
    }
    if (error && this.options.reconnectionAttempts > 0) {
      this.attemptReconnection();
    }
  }
  onTransportMessage(messageString) {
    const message2 = Parser$1.parseMessage(messageString, this.getLogger("sip.Parser"));
    if (!message2) {
      this.logger.warn("Failed to parse incoming message. Dropping.");
      return;
    }
    if (this.state === UserAgentState$1.Stopped && message2 instanceof IncomingRequestMessage$1) {
      this.logger.warn(`Received ${message2.method} request while stopped. Dropping.`);
      return;
    }
    const hasMinimumHeaders = () => {
      const mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];
      for (const header of mandatoryHeaders) {
        if (!message2.hasHeader(header)) {
          this.logger.warn(`Missing mandatory header field : ${header}.`);
          return false;
        }
      }
      return true;
    };
    if (message2 instanceof IncomingRequestMessage$1) {
      if (!hasMinimumHeaders()) {
        this.logger.warn(`Request missing mandatory header field. Dropping.`);
        return;
      }
      if (!message2.toTag && message2.callId.substr(0, 5) === this.options.sipjsId) {
        this.userAgentCore.replyStateless(message2, { statusCode: 482 });
        return;
      }
      const len = utf8Length$2(message2.body);
      const contentLength = message2.getHeader("content-length");
      if (contentLength && len < Number(contentLength)) {
        this.userAgentCore.replyStateless(message2, { statusCode: 400 });
        return;
      }
    }
    if (message2 instanceof IncomingResponseMessage$1) {
      if (!hasMinimumHeaders()) {
        this.logger.warn(`Response missing mandatory header field. Dropping.`);
        return;
      }
      if (message2.getHeaders("via").length > 1) {
        this.logger.warn("More than one Via header field present in the response. Dropping.");
        return;
      }
      if (message2.via.host !== this.options.viaHost || message2.via.port !== void 0) {
        this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
        return;
      }
      const len = utf8Length$2(message2.body);
      const contentLength = message2.getHeader("content-length");
      if (contentLength && len < Number(contentLength)) {
        this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
        return;
      }
    }
    if (message2 instanceof IncomingRequestMessage$1) {
      this.userAgentCore.receiveIncomingRequestFromTransport(message2);
      return;
    }
    if (message2 instanceof IncomingResponseMessage$1) {
      this.userAgentCore.receiveIncomingResponseFromTransport(message2);
      return;
    }
    throw new Error("Invalid message type.");
  }
  /**
   * Transition state.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  transitionState(newState, error) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case UserAgentState$1.Started:
        if (newState !== UserAgentState$1.Stopped) {
          invalidTransition();
        }
        break;
      case UserAgentState$1.Stopped:
        if (newState !== UserAgentState$1.Started) {
          invalidTransition();
        }
        break;
      default:
        throw new Error("Unknown state.");
    }
    this.logger.log(`Transitioned from ${this._state} to ${newState}`);
    this._state = newState;
    this._stateEventEmitter.emit(this._state);
  }
};
class SessionManager {
  /**
   * Constructs a new instance of the `SessionManager` class.
   * @param server - SIP WebSocket Server URL.
   * @param options - Options bucket. See {@link SessionManagerOptions} for details.
   */
  constructor(server, options = {}) {
    this.managedSessions = [];
    this.attemptingReconnection = false;
    this.optionsPingFailure = false;
    this.optionsPingRunning = false;
    this.shouldBeConnected = false;
    this.shouldBeRegistered = false;
    this.delegate = options.delegate;
    this.options = Object.assign({
      aor: "",
      autoStop: true,
      delegate: {},
      iceStopWaitingOnServerReflexive: false,
      managedSessionFactory: defaultManagedSessionFactory(),
      maxSimultaneousSessions: 2,
      media: {},
      optionsPingInterval: -1,
      optionsPingRequestURI: "",
      reconnectionAttempts: 3,
      reconnectionDelay: 4,
      registrationRetry: false,
      registrationRetryInterval: 3,
      registerGuard: null,
      registererOptions: {},
      registererRegisterOptions: {},
      sendDTMFUsingSessionDescriptionHandler: false,
      userAgentOptions: {}
    }, SessionManager.stripUndefinedProperties(options));
    const userAgentOptions = Object.assign({}, options.userAgentOptions);
    if (!userAgentOptions.transportConstructor) {
      userAgentOptions.transportConstructor = Transport$2;
    }
    if (!userAgentOptions.transportOptions) {
      userAgentOptions.transportOptions = {
        server
      };
    }
    if (!userAgentOptions.uri) {
      if (options.aor) {
        const uri = UserAgent$1.makeURI(options.aor);
        if (!uri) {
          throw new Error(`Failed to create valid URI from ${options.aor}`);
        }
        userAgentOptions.uri = uri;
      }
    }
    this.userAgent = new UserAgent$1(userAgentOptions);
    this.userAgent.delegate = {
      // Handle connection with server established
      onConnect: () => {
        this.logger.log(`Connected`);
        if (this.delegate && this.delegate.onServerConnect) {
          this.delegate.onServerConnect();
        }
        if (this.shouldBeRegistered) {
          this.register();
        }
        if (this.options.optionsPingInterval > 0) {
          this.optionsPingStart();
        }
      },
      // Handle connection with server lost
      onDisconnect: async (error) => {
        this.logger.log(`Disconnected`);
        let optionsPingFailure = false;
        if (this.options.optionsPingInterval > 0) {
          optionsPingFailure = this.optionsPingFailure;
          this.optionsPingFailure = false;
          this.optionsPingStop();
        }
        if (this.delegate && this.delegate.onServerDisconnect) {
          this.delegate.onServerDisconnect(error);
        }
        if (error || optionsPingFailure) {
          if (this.registerer) {
            this.logger.log(`Disposing of registerer...`);
            this.registerer.dispose().catch((e2) => {
              this.logger.debug(`Error occurred disposing of registerer after connection with server was lost.`);
              this.logger.debug(e2.toString());
            });
            this.registerer = void 0;
          }
          this.managedSessions.slice().map((el) => el.session).forEach(async (session2) => {
            this.logger.log(`Disposing of session...`);
            session2.dispose().catch((e2) => {
              this.logger.debug(`Error occurred disposing of a session after connection with server was lost.`);
              this.logger.debug(e2.toString());
            });
          });
          if (this.shouldBeConnected) {
            this.attemptReconnection();
          }
        }
      },
      // Handle incoming invitations
      onInvite: (invitation) => {
        this.logger.log(`[${invitation.id}] Received INVITE`);
        const maxSessions = this.options.maxSimultaneousSessions;
        if (maxSessions !== 0 && this.managedSessions.length > maxSessions) {
          this.logger.warn(`[${invitation.id}] Session already in progress, rejecting INVITE...`);
          invitation.reject().then(() => {
            this.logger.log(`[${invitation.id}] Rejected INVITE`);
          }).catch((error) => {
            this.logger.error(`[${invitation.id}] Failed to reject INVITE`);
            this.logger.error(error.toString());
          });
          return;
        }
        const referralInviterOptions = {
          sessionDescriptionHandlerOptions: { constraints: this.constraints }
        };
        this.initSession(invitation, referralInviterOptions);
        if (this.delegate && this.delegate.onCallReceived) {
          this.delegate.onCallReceived(invitation);
        } else {
          this.logger.warn(`[${invitation.id}] No handler available, rejecting INVITE...`);
          invitation.reject().then(() => {
            this.logger.log(`[${invitation.id}] Rejected INVITE`);
          }).catch((error) => {
            this.logger.error(`[${invitation.id}] Failed to reject INVITE`);
            this.logger.error(error.toString());
          });
        }
      },
      // Handle incoming messages
      onMessage: (message2) => {
        message2.accept().then(() => {
          if (this.delegate && this.delegate.onMessageReceived) {
            this.delegate.onMessageReceived(message2);
          }
        });
      },
      // Handle incoming notifications
      onNotify: (notification) => {
        notification.accept().then(() => {
          if (this.delegate && this.delegate.onNotificationReceived) {
            this.delegate.onNotificationReceived(notification);
          }
        });
      }
    };
    this.registererOptions = Object.assign({}, options.registererOptions);
    this.registererRegisterOptions = Object.assign({}, options.registererRegisterOptions);
    if (this.options.registrationRetry) {
      this.registererRegisterOptions.requestDelegate = this.registererRegisterOptions.requestDelegate || {};
      const existingOnReject = this.registererRegisterOptions.requestDelegate.onReject;
      this.registererRegisterOptions.requestDelegate.onReject = (response) => {
        existingOnReject && existingOnReject(response);
        this.attemptRegistration();
      };
    }
    this.logger = this.userAgent.getLogger("sip.SessionManager");
    window.addEventListener("online", () => {
      this.logger.log(`Online`);
      if (this.shouldBeConnected) {
        this.connect();
      }
    });
    if (this.options.autoStop) {
      window.addEventListener("beforeunload", async () => {
        this.shouldBeConnected = false;
        this.shouldBeRegistered = false;
        if (this.userAgent.state !== UserAgentState$1.Stopped) {
          await this.userAgent.stop();
        }
      });
    }
  }
  /**
   * Strip properties with undefined values from options.
   * This is a work around while waiting for missing vs undefined to be addressed (or not)...
   * https://github.com/Microsoft/TypeScript/issues/13195
   * @param options - Options to reduce
   */
  static stripUndefinedProperties(options) {
    return Object.keys(options).reduce((object, key) => {
      if (options[key] !== void 0) {
        object[key] = options[key];
      }
      return object;
    }, {});
  }
  /**
   * The local media stream. Undefined if call not answered.
   * @param session - Session to get the media stream from.
   */
  getLocalMediaStream(session2) {
    const sdh = session2.sessionDescriptionHandler;
    if (!sdh) {
      return void 0;
    }
    if (!(sdh instanceof SessionDescriptionHandler$1)) {
      throw new Error("Session description handler not instance of web SessionDescriptionHandler");
    }
    return sdh.localMediaStream;
  }
  /**
   * The remote media stream. Undefined if call not answered.
   * @param session - Session to get the media stream from.
   */
  getRemoteMediaStream(session2) {
    const sdh = session2.sessionDescriptionHandler;
    if (!sdh) {
      return void 0;
    }
    if (!(sdh instanceof SessionDescriptionHandler$1)) {
      throw new Error("Session description handler not instance of web SessionDescriptionHandler");
    }
    return sdh.remoteMediaStream;
  }
  /**
   * The local audio track, if available.
   * @param session - Session to get track from.
   * @deprecated Use localMediaStream and get track from the stream.
   */
  getLocalAudioTrack(session2) {
    var _a;
    return (_a = this.getLocalMediaStream(session2)) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === "audio");
  }
  /**
   * The local video track, if available.
   * @param session - Session to get track from.
   * @deprecated Use localMediaStream and get track from the stream.
   */
  getLocalVideoTrack(session2) {
    var _a;
    return (_a = this.getLocalMediaStream(session2)) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === "video");
  }
  /**
   * The remote audio track, if available.
   * @param session - Session to get track from.
   * @deprecated Use remoteMediaStream and get track from the stream.
   */
  getRemoteAudioTrack(session2) {
    var _a;
    return (_a = this.getRemoteMediaStream(session2)) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === "audio");
  }
  /**
   * The remote video track, if available.
   * @param session - Session to get track from.
   * @deprecated Use remoteMediaStream and get track from the stream.
   */
  getRemoteVideoTrack(session2) {
    var _a;
    return (_a = this.getRemoteMediaStream(session2)) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === "video");
  }
  /**
   * Connect.
   * @remarks
   * If not started, starts the UserAgent connecting the WebSocket Transport.
   * Otherwise reconnects the UserAgent's WebSocket Transport.
   * Attempts will be made to reconnect as needed.
   */
  async connect() {
    this.logger.log(`Connecting UserAgent...`);
    this.shouldBeConnected = true;
    if (this.userAgent.state !== UserAgentState$1.Started) {
      return this.userAgent.start();
    }
    return this.userAgent.reconnect();
  }
  /**
   * Disconnect.
   * @remarks
   * If not stopped, stops the UserAgent disconnecting the WebSocket Transport.
   */
  async disconnect() {
    this.logger.log(`Disconnecting UserAgent...`);
    if (this.userAgent.state === UserAgentState$1.Stopped) {
      return Promise.resolve();
    }
    this.shouldBeConnected = false;
    this.shouldBeRegistered = false;
    this.registerer = void 0;
    return this.userAgent.stop();
  }
  /**
   * Return true if transport is connected.
   */
  isConnected() {
    return this.userAgent.isConnected();
  }
  /**
   * Start receiving incoming calls.
   * @remarks
   * Send a REGISTER request for the UserAgent's AOR.
   * Resolves when the REGISTER request is sent, otherwise rejects.
   * Attempts will be made to re-register as needed.
   */
  async register(registererRegisterOptions) {
    this.logger.log(`Registering UserAgent...`);
    this.shouldBeRegistered = true;
    if (registererRegisterOptions !== void 0) {
      this.registererRegisterOptions = Object.assign({}, registererRegisterOptions);
    }
    if (!this.registerer) {
      this.registerer = new Registerer$1(this.userAgent, this.registererOptions);
      this.registerer.stateChange.addListener((state) => {
        switch (state) {
          case RegistererState$1.Initial:
            break;
          case RegistererState$1.Registered:
            if (this.delegate && this.delegate.onRegistered) {
              this.delegate.onRegistered();
            }
            break;
          case RegistererState$1.Unregistered:
            if (this.delegate && this.delegate.onUnregistered) {
              this.delegate.onUnregistered();
            }
            if (this.shouldBeRegistered) {
              this.attemptRegistration();
            }
            break;
          case RegistererState$1.Terminated:
            break;
          default:
            throw new Error("Unknown registerer state.");
        }
      });
    }
    return this.attemptRegistration(true);
  }
  /**
   * Stop receiving incoming calls.
   * @remarks
   * Send an un-REGISTER request for the UserAgent's AOR.
   * Resolves when the un-REGISTER request is sent, otherwise rejects.
   */
  async unregister(registererUnregisterOptions) {
    this.logger.log(`Unregistering UserAgent...`);
    this.shouldBeRegistered = false;
    if (!this.registerer) {
      this.logger.warn(`No registerer to unregister.`);
      return Promise.resolve();
    }
    return this.registerer.unregister(registererUnregisterOptions).then(() => {
      return;
    });
  }
  /**
   * Make an outgoing call.
   * @remarks
   * Send an INVITE request to create a new Session.
   * Resolves when the INVITE request is sent, otherwise rejects.
   * Use `onCallAnswered` delegate method to determine if Session is established.
   * @param destination - The target destination to call. A SIP address to send the INVITE to.
   * @param inviterOptions - Optional options for Inviter constructor.
   * @param inviterInviteOptions - Optional options for Inviter.invite().
   */
  async call(destination, inviterOptions, inviterInviteOptions) {
    this.logger.log(`Beginning Session...`);
    const maxSessions = this.options.maxSimultaneousSessions;
    if (maxSessions !== 0 && this.managedSessions.length > maxSessions) {
      return Promise.reject(new Error("Maximum number of sessions already exists."));
    }
    const target = UserAgent$1.makeURI(destination);
    if (!target) {
      return Promise.reject(new Error(`Failed to create a valid URI from "${destination}"`));
    }
    if (!inviterOptions) {
      inviterOptions = {};
    }
    if (!inviterOptions.sessionDescriptionHandlerOptions) {
      inviterOptions.sessionDescriptionHandlerOptions = {};
    }
    if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {
      inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;
    }
    if (inviterOptions.earlyMedia) {
      inviterInviteOptions = inviterInviteOptions || {};
      inviterInviteOptions.requestDelegate = inviterInviteOptions.requestDelegate || {};
      const existingOnProgress = inviterInviteOptions.requestDelegate.onProgress;
      inviterInviteOptions.requestDelegate.onProgress = (response) => {
        if (response.message.statusCode === 183) {
          this.setupRemoteMedia(inviter);
        }
        existingOnProgress && existingOnProgress(response);
      };
    }
    if (this.options.iceStopWaitingOnServerReflexive) {
      inviterOptions.delegate = inviterOptions.delegate || {};
      inviterOptions.delegate.onSessionDescriptionHandler = (sessionDescriptionHandler) => {
        if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler$1)) {
          throw new Error("Session description handler not instance of SessionDescriptionHandler");
        }
        sessionDescriptionHandler.peerConnectionDelegate = {
          onicecandidate: (event) => {
            var _a;
            if (((_a = event.candidate) === null || _a === void 0 ? void 0 : _a.type) === "srflx") {
              this.logger.log(`[${inviter.id}] Found srflx ICE candidate, stop waiting...`);
              const sdh = sessionDescriptionHandler;
              sdh.iceGatheringComplete();
            }
          }
        };
      };
    }
    const inviter = new Inviter$1(this.userAgent, target, inviterOptions);
    return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(() => {
      return inviter;
    });
  }
  /**
   * Hangup a call.
   * @param session - Session to hangup.
   * @remarks
   * Send a BYE request, CANCEL request or reject response to end the current Session.
   * Resolves when the request/response is sent, otherwise rejects.
   * Use `onCallHangup` delegate method to determine if and when call is ended.
   */
  async hangup(session2) {
    this.logger.log(`[${session2.id}] Hangup...`);
    if (!this.sessionExists(session2)) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.terminate(session2);
  }
  /**
   * Answer an incoming call.
   * @param session - Session to answer.
   * @remarks
   * Accept an incoming INVITE request creating a new Session.
   * Resolves with the response is sent, otherwise rejects.
   * Use `onCallAnswered` delegate method to determine if and when call is established.
   * @param invitationAcceptOptions - Optional options for Inviter.accept().
   */
  async answer(session2, invitationAcceptOptions) {
    this.logger.log(`[${session2.id}] Accepting Invitation...`);
    if (!this.sessionExists(session2)) {
      return Promise.reject(new Error("Session does not exist."));
    }
    if (!(session2 instanceof Invitation$1)) {
      return Promise.reject(new Error("Session not instance of Invitation."));
    }
    if (!invitationAcceptOptions) {
      invitationAcceptOptions = {};
    }
    if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {
      invitationAcceptOptions.sessionDescriptionHandlerOptions = {};
    }
    if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {
      invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;
    }
    return session2.accept(invitationAcceptOptions);
  }
  /**
   * Decline an incoming call.
   * @param session - Session to decline.
   * @remarks
   * Reject an incoming INVITE request.
   * Resolves with the response is sent, otherwise rejects.
   * Use `onCallHangup` delegate method to determine if and when call is ended.
   */
  async decline(session2) {
    this.logger.log(`[${session2.id}] Rejecting Invitation...`);
    if (!this.sessionExists(session2)) {
      return Promise.reject(new Error("Session does not exist."));
    }
    if (!(session2 instanceof Invitation$1)) {
      return Promise.reject(new Error("Session not instance of Invitation."));
    }
    return session2.reject();
  }
  /**
   * Hold call
   * @param session - Session to hold.
   * @remarks
   * Send a re-INVITE with new offer indicating "hold".
   * Resolves when the re-INVITE request is sent, otherwise rejects.
   * Use `onCallHold` delegate method to determine if request is accepted or rejected.
   * See: https://tools.ietf.org/html/rfc6337
   */
  async hold(session2) {
    this.logger.log(`[${session2.id}] Holding session...`);
    return this.setHold(session2, true);
  }
  /**
   * Unhold call.
   * @param session - Session to unhold.
   * @remarks
   * Send a re-INVITE with new offer indicating "unhold".
   * Resolves when the re-INVITE request is sent, otherwise rejects.
   * Use `onCallHold` delegate method to determine if request is accepted or rejected.
   * See: https://tools.ietf.org/html/rfc6337
   */
  async unhold(session2) {
    this.logger.log(`[${session2.id}] Unholding session...`);
    return this.setHold(session2, false);
  }
  /**
   * Hold state.
   * @param session - Session to check.
   * @remarks
   * True if session is on hold.
   */
  isHeld(session2) {
    const managedSession = this.sessionManaged(session2);
    return managedSession ? managedSession.held : false;
  }
  /**
   * Mute call.
   * @param session - Session to mute.
   * @remarks
   * Disable sender's media tracks.
   */
  mute(session2) {
    this.logger.log(`[${session2.id}] Disabling media tracks...`);
    this.setMute(session2, true);
  }
  /**
   * Unmute call.
   * @param session - Session to unmute.
   * @remarks
   * Enable sender's media tracks.
   */
  unmute(session2) {
    this.logger.log(`[${session2.id}] Enabling media tracks...`);
    this.setMute(session2, false);
  }
  /**
   * Mute state.
   * @param session - Session to check.
   * @remarks
   * True if sender's media track is disabled.
   */
  isMuted(session2) {
    const managedSession = this.sessionManaged(session2);
    return managedSession ? managedSession.muted : false;
  }
  /**
   * Send DTMF.
   * @param session - Session to send on.
   * @remarks
   * Send an INFO request with content type application/dtmf-relay.
   * @param tone - Tone to send.
   */
  async sendDTMF(session2, tone) {
    this.logger.log(`[${session2.id}] Sending DTMF...`);
    if (!/^[0-9A-D#*,]$/.exec(tone)) {
      return Promise.reject(new Error("Invalid DTMF tone."));
    }
    if (!this.sessionExists(session2)) {
      return Promise.reject(new Error("Session does not exist."));
    }
    this.logger.log(`[${session2.id}] Sending DTMF tone: ${tone}`);
    if (this.options.sendDTMFUsingSessionDescriptionHandler) {
      if (!session2.sessionDescriptionHandler) {
        return Promise.reject(new Error("Session desciption handler undefined."));
      }
      if (!session2.sessionDescriptionHandler.sendDtmf(tone)) {
        return Promise.reject(new Error("Failed to send DTMF"));
      }
      return Promise.resolve();
    } else {
      const dtmf = tone;
      const duration2 = 2e3;
      const body = {
        contentDisposition: "render",
        contentType: "application/dtmf-relay",
        content: "Signal=" + dtmf + "\r\nDuration=" + duration2
      };
      const requestOptions = { body };
      return session2.info({ requestOptions }).then(() => {
        return;
      });
    }
  }
  /**
   * Transfer.
   * @param session - Session with the transferee to transfer.
   * @param target - The referral target.
   * @remarks
   * If target is a Session this is an attended transfer completion (REFER with Replaces),
   * otherwise this is a blind transfer (REFER). Attempting an attended transfer
   * completion on a call that has not been answered will be rejected. To implement
   * an attended transfer with early completion, hangup the call with the target
   * and execute a blind transfer to the target.
   */
  async transfer(session2, target, options) {
    this.logger.log(`[${session2.id}] Referring session...`);
    if (target instanceof Session$1) {
      return session2.refer(target, options).then(() => {
        return;
      });
    }
    const uri = UserAgent$1.makeURI(target);
    if (!uri) {
      return Promise.reject(new Error(`Failed to create a valid URI from "${target}"`));
    }
    return session2.refer(uri, options).then(() => {
      return;
    });
  }
  /**
   * Send a message.
   * @remarks
   * Send a MESSAGE request.
   * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.
   */
  async message(destination, message2) {
    this.logger.log(`Sending message...`);
    const target = UserAgent$1.makeURI(destination);
    if (!target) {
      return Promise.reject(new Error(`Failed to create a valid URI from "${destination}"`));
    }
    return new Messager$1(this.userAgent, target, message2).message();
  }
  /** Media constraints. */
  get constraints() {
    let constraints = { audio: true, video: false };
    if (this.options.media.constraints) {
      constraints = Object.assign({}, this.options.media.constraints);
    }
    return constraints;
  }
  /**
   * Attempt reconnection up to `reconnectionAttempts` times.
   * @param reconnectionAttempt - Current attempt number.
   */
  attemptReconnection(reconnectionAttempt = 1) {
    const reconnectionAttempts = this.options.reconnectionAttempts;
    const reconnectionDelay = this.options.reconnectionDelay;
    if (!this.shouldBeConnected) {
      this.logger.log(`Should not be connected currently`);
      return;
    }
    if (this.attemptingReconnection) {
      this.logger.log(`Reconnection attempt already in progress`);
    }
    if (reconnectionAttempt > reconnectionAttempts) {
      this.logger.log(`Reconnection maximum attempts reached`);
      return;
    }
    if (reconnectionAttempt === 1) {
      this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);
    } else {
      this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying in ${reconnectionDelay} seconds`);
    }
    this.attemptingReconnection = true;
    setTimeout(() => {
      if (!this.shouldBeConnected) {
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - aborted`);
        this.attemptingReconnection = false;
        return;
      }
      this.userAgent.reconnect().then(() => {
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);
        this.attemptingReconnection = false;
      }).catch((error) => {
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);
        this.logger.error(error.message);
        this.attemptingReconnection = false;
        this.attemptReconnection(++reconnectionAttempt);
      });
    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1e3);
  }
  /**
   * Register to receive calls.
   * @param withoutDelay - If true attempt immediately, otherwise wait `registrationRetryInterval`.
   */
  attemptRegistration(withoutDelay = false) {
    this.logger.log(`Registration attempt ${withoutDelay ? "without delay" : ""}`);
    if (!this.shouldBeRegistered) {
      this.logger.log(`Should not be registered currently`);
      return Promise.resolve();
    }
    if (this.registrationAttemptTimeout !== void 0) {
      this.logger.log(`Registration attempt already in progress`);
      return Promise.resolve();
    }
    const _register = () => {
      if (!this.registerer) {
        this.logger.log(`Registerer undefined`);
        return Promise.resolve();
      }
      if (!this.isConnected()) {
        this.logger.log(`User agent not connected`);
        return Promise.resolve();
      }
      if (this.userAgent.state === UserAgentState$1.Stopped) {
        this.logger.log(`User agent stopped`);
        return Promise.resolve();
      }
      if (!this.options.registerGuard) {
        return this.registerer.register(this.registererRegisterOptions).then(() => {
          return;
        });
      }
      return this.options.registerGuard().catch((error) => {
        this.logger.log(`Register guard rejected will making registration attempt`);
        throw error;
      }).then((halt) => {
        if (halt || !this.registerer) {
          return Promise.resolve();
        }
        return this.registerer.register(this.registererRegisterOptions).then(() => {
          return;
        });
      });
    };
    const computeRegistrationTimeout = (lowerBound) => {
      const upperBound = lowerBound * 2;
      return 1e3 * (Math.random() * (upperBound - lowerBound) + lowerBound);
    };
    return new Promise((resolve, reject) => {
      this.registrationAttemptTimeout = setTimeout(() => {
        _register().then(() => {
          this.registrationAttemptTimeout = void 0;
          resolve();
        }).catch((error) => {
          this.registrationAttemptTimeout = void 0;
          if (error instanceof RequestPendingError$1) {
            resolve();
          } else {
            reject(error);
          }
        });
      }, withoutDelay ? 0 : computeRegistrationTimeout(this.options.registrationRetryInterval));
    });
  }
  /** Helper function to remove media from html elements. */
  cleanupMedia(session2) {
    const managedSession = this.sessionManaged(session2);
    if (!managedSession) {
      throw new Error("Managed session does not exist.");
    }
    if (managedSession.mediaLocal) {
      if (managedSession.mediaLocal.video) {
        managedSession.mediaLocal.video.srcObject = null;
        managedSession.mediaLocal.video.pause();
      }
    }
    if (managedSession.mediaRemote) {
      if (managedSession.mediaRemote.audio) {
        managedSession.mediaRemote.audio.srcObject = null;
        managedSession.mediaRemote.audio.pause();
      }
      if (managedSession.mediaRemote.video) {
        managedSession.mediaRemote.video.srcObject = null;
        managedSession.mediaRemote.video.pause();
      }
    }
  }
  /** Helper function to enable/disable media tracks. */
  enableReceiverTracks(session2, enable) {
    if (!this.sessionExists(session2)) {
      throw new Error("Session does not exist.");
    }
    const sessionDescriptionHandler = session2.sessionDescriptionHandler;
    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler$1)) {
      throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
    }
    sessionDescriptionHandler.enableReceiverTracks(enable);
  }
  /** Helper function to enable/disable media tracks. */
  enableSenderTracks(session2, enable) {
    if (!this.sessionExists(session2)) {
      throw new Error("Session does not exist.");
    }
    const sessionDescriptionHandler = session2.sessionDescriptionHandler;
    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler$1)) {
      throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
    }
    sessionDescriptionHandler.enableSenderTracks(enable);
  }
  /**
   * Setup session delegate and state change handler.
   * @param session - Session to setup.
   * @param referralInviterOptions - Options for any Inviter created as result of a REFER.
   */
  initSession(session2, referralInviterOptions) {
    this.sessionAdd(session2);
    if (this.delegate && this.delegate.onCallCreated) {
      this.delegate.onCallCreated(session2);
    }
    session2.stateChange.addListener((state) => {
      this.logger.log(`[${session2.id}] Session state changed to ${state}`);
      switch (state) {
        case SessionState$2.Initial:
          break;
        case SessionState$2.Establishing:
          break;
        case SessionState$2.Established:
          this.setupLocalMedia(session2);
          this.setupRemoteMedia(session2);
          if (this.delegate && this.delegate.onCallAnswered) {
            this.delegate.onCallAnswered(session2);
          }
          break;
        case SessionState$2.Terminating:
        case SessionState$2.Terminated:
          if (this.sessionExists(session2)) {
            this.cleanupMedia(session2);
            this.sessionRemove(session2);
            if (this.delegate && this.delegate.onCallHangup) {
              this.delegate.onCallHangup(session2);
            }
          }
          break;
        default:
          throw new Error("Unknown session state.");
      }
    });
    session2.delegate = session2.delegate || {};
    session2.delegate.onInfo = (info) => {
      var _a;
      if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === void 0) {
        info.reject();
        return;
      }
      const contentType = info.request.getHeader("content-type");
      if (!contentType || !/^application\/dtmf-relay/i.exec(contentType)) {
        info.reject();
        return;
      }
      const body = info.request.body.split("\r\n", 2);
      if (body.length !== 2) {
        info.reject();
        return;
      }
      let tone;
      const toneRegExp = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;
      if (body[0] !== void 0 && toneRegExp.test(body[0])) {
        tone = body[0].replace(toneRegExp, "$2");
      }
      if (!tone) {
        info.reject();
        return;
      }
      let duration2;
      const durationRegExp = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
      if (body[1] !== void 0 && durationRegExp.test(body[1])) {
        duration2 = parseInt(body[1].replace(durationRegExp, "$2"), 10);
      }
      if (!duration2) {
        info.reject();
        return;
      }
      info.accept().then(() => {
        if (this.delegate && this.delegate.onCallDTMFReceived) {
          if (!tone || !duration2) {
            throw new Error("Tone or duration undefined.");
          }
          this.delegate.onCallDTMFReceived(session2, tone, duration2);
        }
      }).catch((error) => {
        this.logger.error(error.message);
      });
    };
    session2.delegate.onRefer = (referral) => {
      referral.accept().then(() => this.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions)).catch((error) => {
        this.logger.error(error.message);
      });
    };
  }
  /**
   * Periodically send OPTIONS pings and disconnect when a ping fails.
   * @param requestURI - Request URI to target
   * @param fromURI - From URI
   * @param toURI - To URI
   */
  optionsPingRun(requestURI, fromURI, toURI) {
    if (this.options.optionsPingInterval < 1) {
      throw new Error("Invalid options ping interval.");
    }
    if (this.optionsPingRunning) {
      return;
    }
    this.optionsPingRunning = true;
    this.optionsPingTimeout = setTimeout(() => {
      this.optionsPingTimeout = void 0;
      const onPingSuccess = () => {
        this.optionsPingFailure = false;
        if (this.optionsPingRunning) {
          this.optionsPingRunning = false;
          this.optionsPingRun(requestURI, fromURI, toURI);
        }
      };
      const onPingFailure = () => {
        this.logger.error("OPTIONS ping failed");
        this.optionsPingFailure = true;
        this.optionsPingRunning = false;
        this.userAgent.transport.disconnect().catch((error) => this.logger.error(error));
      };
      const core2 = this.userAgent.userAgentCore;
      const message2 = core2.makeOutgoingRequestMessage("OPTIONS", requestURI, fromURI, toURI, {});
      this.optionsPingRequest = core2.request(message2, {
        onAccept: () => {
          this.optionsPingRequest = void 0;
          onPingSuccess();
        },
        onReject: (response) => {
          this.optionsPingRequest = void 0;
          if (response.message.statusCode === 408 || response.message.statusCode === 503) {
            onPingFailure();
          } else {
            onPingSuccess();
          }
        }
      });
    }, this.options.optionsPingInterval * 1e3);
  }
  /**
   * Start sending OPTIONS pings.
   */
  optionsPingStart() {
    this.logger.log(`OPTIONS pings started`);
    let requestURI, fromURI, toURI;
    if (this.options.optionsPingRequestURI) {
      requestURI = UserAgent$1.makeURI(this.options.optionsPingRequestURI);
      if (!requestURI) {
        throw new Error("Failed to create Request URI.");
      }
      fromURI = this.userAgent.contact.uri.clone();
      toURI = this.userAgent.contact.uri.clone();
    } else if (this.options.aor) {
      const uri = UserAgent$1.makeURI(this.options.aor);
      if (!uri) {
        throw new Error("Failed to create URI.");
      }
      requestURI = uri.clone();
      requestURI.user = void 0;
      fromURI = uri.clone();
      toURI = uri.clone();
    } else {
      this.logger.error("You have enabled sending OPTIONS pings and as such you must provide either a) an AOR to register, or b) an RURI to use for the target of the OPTIONS ping requests. ");
      return;
    }
    this.optionsPingRun(requestURI, fromURI, toURI);
  }
  /**
   * Stop sending OPTIONS pings.
   */
  optionsPingStop() {
    this.logger.log(`OPTIONS pings stopped`);
    this.optionsPingRunning = false;
    this.optionsPingFailure = false;
    if (this.optionsPingRequest) {
      this.optionsPingRequest.dispose();
      this.optionsPingRequest = void 0;
    }
    if (this.optionsPingTimeout) {
      clearTimeout(this.optionsPingTimeout);
      this.optionsPingTimeout = void 0;
    }
  }
  /** Helper function to init send then send invite. */
  async sendInvite(inviter, inviterOptions, inviterInviteOptions) {
    this.initSession(inviter, inviterOptions);
    return inviter.invite(inviterInviteOptions).then(() => {
      this.logger.log(`[${inviter.id}] Sent INVITE`);
    });
  }
  /** Helper function to add a session to the ones we are managing. */
  sessionAdd(session2) {
    const managedSession = this.options.managedSessionFactory(this, session2);
    this.managedSessions.push(managedSession);
  }
  /** Helper function to check if the session is one we are managing. */
  sessionExists(session2) {
    return this.sessionManaged(session2) !== void 0;
  }
  /** Helper function to check if the session is one we are managing. */
  sessionManaged(session2) {
    return this.managedSessions.find((el) => el.session.id === session2.id);
  }
  /** Helper function to remoce a session from the ones we are managing. */
  sessionRemove(session2) {
    this.managedSessions = this.managedSessions.filter((el) => el.session.id !== session2.id);
  }
  /**
   * Puts Session on hold.
   * @param session - The session to set.
   * @param hold - Hold on if true, off if false.
   */
  async setHold(session2, hold) {
    if (!this.sessionExists(session2)) {
      return Promise.reject(new Error("Session does not exist."));
    }
    if (this.isHeld(session2) === hold) {
      return Promise.resolve();
    }
    const sessionDescriptionHandler = session2.sessionDescriptionHandler;
    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler$1)) {
      throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
    }
    const options = {
      requestDelegate: {
        onAccept: () => {
          const managedSession2 = this.sessionManaged(session2);
          if (managedSession2 !== void 0) {
            managedSession2.held = hold;
            this.enableReceiverTracks(session2, !managedSession2.held);
            this.enableSenderTracks(session2, !managedSession2.held && !managedSession2.muted);
            if (this.delegate && this.delegate.onCallHold) {
              this.delegate.onCallHold(session2, managedSession2.held);
            }
          }
        },
        onReject: () => {
          this.logger.warn(`[${session2.id}] Re-invite request was rejected`);
          const managedSession2 = this.sessionManaged(session2);
          if (managedSession2 !== void 0) {
            managedSession2.held = !hold;
            this.enableReceiverTracks(session2, !managedSession2.held);
            this.enableSenderTracks(session2, !managedSession2.held && !managedSession2.muted);
            if (this.delegate && this.delegate.onCallHold) {
              this.delegate.onCallHold(session2, managedSession2.held);
            }
          }
        }
      }
    };
    const sessionDescriptionHandlerOptions = session2.sessionDescriptionHandlerOptionsReInvite;
    sessionDescriptionHandlerOptions.hold = hold;
    session2.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;
    const managedSession = this.sessionManaged(session2);
    if (!managedSession) {
      throw new Error("Managed session is undefiend.");
    }
    managedSession.held = hold;
    return session2.invite(options).then(() => {
      const managedSession2 = this.sessionManaged(session2);
      if (managedSession2 !== void 0) {
        this.enableReceiverTracks(session2, !managedSession2.held);
        this.enableSenderTracks(session2, !managedSession2.held && !managedSession2.muted);
      }
    }).catch((error) => {
      managedSession.held = !hold;
      if (error instanceof RequestPendingError$1) {
        this.logger.error(`[${session2.id}] A hold request is already in progress.`);
      }
      throw error;
    });
  }
  /**
   * Puts Session on mute.
   * @param session - The session to mute.
   * @param mute - Mute on if true, off if false.
   */
  setMute(session2, mute) {
    if (!this.sessionExists(session2)) {
      this.logger.warn(`[${session2.id}] A session is required to enabled/disable media tracks`);
      return;
    }
    if (session2.state !== SessionState$2.Established) {
      this.logger.warn(`[${session2.id}] An established session is required to enable/disable media tracks`);
      return;
    }
    const managedSession = this.sessionManaged(session2);
    if (managedSession !== void 0) {
      managedSession.muted = mute;
      this.enableSenderTracks(session2, !managedSession.held && !managedSession.muted);
    }
  }
  /** Helper function to attach local media to html elements. */
  setupLocalMedia(session2) {
    const managedSession = this.sessionManaged(session2);
    if (!managedSession) {
      throw new Error("Managed session does not exist.");
    }
    const mediaLocal = typeof this.options.media.local === "function" ? this.options.media.local(session2) : this.options.media.local;
    managedSession.mediaLocal = mediaLocal;
    const mediaElement = mediaLocal === null || mediaLocal === void 0 ? void 0 : mediaLocal.video;
    if (mediaElement) {
      const localStream = this.getLocalMediaStream(session2);
      if (!localStream) {
        throw new Error("Local media stream undefiend.");
      }
      mediaElement.srcObject = localStream;
      mediaElement.volume = 0;
      mediaElement.play().catch((error) => {
        this.logger.error(`[${session2.id}] Failed to play local media`);
        this.logger.error(error.message);
      });
    }
  }
  /** Helper function to attach remote media to html elements. */
  setupRemoteMedia(session2) {
    const managedSession = this.sessionManaged(session2);
    if (!managedSession) {
      throw new Error("Managed session does not exist.");
    }
    const mediaRemote = typeof this.options.media.remote === "function" ? this.options.media.remote(session2) : this.options.media.remote;
    managedSession.mediaRemote = mediaRemote;
    const mediaElement = (mediaRemote === null || mediaRemote === void 0 ? void 0 : mediaRemote.video) || (mediaRemote === null || mediaRemote === void 0 ? void 0 : mediaRemote.audio);
    if (mediaElement) {
      const remoteStream = this.getRemoteMediaStream(session2);
      if (!remoteStream) {
        throw new Error("Remote media stream undefiend.");
      }
      mediaElement.autoplay = true;
      mediaElement.srcObject = remoteStream;
      mediaElement.play().catch((error) => {
        this.logger.error(`[${session2.id}] Failed to play remote media`);
        this.logger.error(error.message);
      });
      remoteStream.onaddtrack = () => {
        this.logger.log(`Remote media onaddtrack`);
        mediaElement.load();
        mediaElement.play().catch((error) => {
          this.logger.error(`[${session2.id}] Failed to play remote media`);
          this.logger.error(error.message);
        });
      };
    }
  }
  /**
   * End a session.
   * @param session - The session to terminate.
   * @remarks
   * Send a BYE request, CANCEL request or reject response to end the current Session.
   * Resolves when the request/response is sent, otherwise rejects.
   * Use `onCallHangup` delegate method to determine if and when Session is terminated.
   */
  async terminate(session2) {
    this.logger.log(`[${session2.id}] Terminating...`);
    switch (session2.state) {
      case SessionState$2.Initial:
        if (session2 instanceof Inviter$1) {
          return session2.cancel().then(() => {
            this.logger.log(`[${session2.id}] Inviter never sent INVITE (canceled)`);
          });
        } else if (session2 instanceof Invitation$1) {
          return session2.reject().then(() => {
            this.logger.log(`[${session2.id}] Invitation rejected (sent 480)`);
          });
        } else {
          throw new Error("Unknown session type.");
        }
      case SessionState$2.Establishing:
        if (session2 instanceof Inviter$1) {
          return session2.cancel().then(() => {
            this.logger.log(`[${session2.id}] Inviter canceled (sent CANCEL)`);
          });
        } else if (session2 instanceof Invitation$1) {
          return session2.reject().then(() => {
            this.logger.log(`[${session2.id}] Invitation rejected (sent 480)`);
          });
        } else {
          throw new Error("Unknown session type.");
        }
      case SessionState$2.Established:
        return session2.bye().then(() => {
          this.logger.log(`[${session2.id}] Session ended (sent BYE)`);
        });
      case SessionState$2.Terminating:
        break;
      case SessionState$2.Terminated:
        break;
      default:
        throw new Error("Unknown state");
    }
    this.logger.log(`[${session2.id}] Terminating in state ${session2.state}, no action taken`);
    return Promise.resolve();
  }
}
class SimpleUser {
  /**
   * Constructs a new instance of the `SimpleUser` class.
   * @param server - SIP WebSocket Server URL.
   * @param options - Options bucket. See {@link SimpleUserOptions} for details.
   */
  constructor(server, options = {}) {
    this.session = void 0;
    this.delegate = options.delegate;
    this.options = Object.assign({}, options);
    const sessionManagerOptions = {
      aor: this.options.aor,
      delegate: {
        onCallAnswered: () => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallAnswered) === null || _b === void 0 ? void 0 : _b.call(_a);
        },
        onCallCreated: (session2) => {
          var _a, _b;
          this.session = session2;
          (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallCreated) === null || _b === void 0 ? void 0 : _b.call(_a);
        },
        onCallReceived: () => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallReceived) === null || _b === void 0 ? void 0 : _b.call(_a);
        },
        onCallHangup: () => {
          var _a, _b;
          this.session = void 0;
          ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallHangup) && ((_b = this.delegate) === null || _b === void 0 ? void 0 : _b.onCallHangup());
        },
        onCallHold: (s2, held) => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallHold) === null || _b === void 0 ? void 0 : _b.call(_a, held);
        },
        onCallDTMFReceived: (s2, tone, dur) => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === null || _b === void 0 ? void 0 : _b.call(_a, tone, dur);
        },
        onMessageReceived: (message2) => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onMessageReceived) === null || _b === void 0 ? void 0 : _b.call(_a, message2.request.body);
        },
        onRegistered: () => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onRegistered) === null || _b === void 0 ? void 0 : _b.call(_a);
        },
        onUnregistered: () => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onUnregistered) === null || _b === void 0 ? void 0 : _b.call(_a);
        },
        onServerConnect: () => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onServerConnect) === null || _b === void 0 ? void 0 : _b.call(_a);
        },
        onServerDisconnect: () => {
          var _a, _b;
          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onServerDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      },
      maxSimultaneousSessions: 1,
      media: this.options.media,
      reconnectionAttempts: this.options.reconnectionAttempts,
      reconnectionDelay: this.options.reconnectionDelay,
      registererOptions: this.options.registererOptions,
      sendDTMFUsingSessionDescriptionHandler: this.options.sendDTMFUsingSessionDescriptionHandler,
      userAgentOptions: this.options.userAgentOptions
    };
    this.sessionManager = new SessionManager(server, sessionManagerOptions);
    this.logger = this.sessionManager.userAgent.getLogger("sip.SimpleUser");
  }
  /**
   * Instance identifier.
   * @internal
   */
  get id() {
    return this.options.userAgentOptions && this.options.userAgentOptions.displayName || "Anonymous";
  }
  /** The local media stream. Undefined if call not answered. */
  get localMediaStream() {
    return this.session && this.sessionManager.getLocalMediaStream(this.session);
  }
  /** The remote media stream. Undefined if call not answered. */
  get remoteMediaStream() {
    return this.session && this.sessionManager.getRemoteMediaStream(this.session);
  }
  /**
   * The local audio track, if available.
   * @deprecated Use localMediaStream and get track from the stream.
   */
  get localAudioTrack() {
    return this.session && this.sessionManager.getLocalAudioTrack(this.session);
  }
  /**
   * The local video track, if available.
   * @deprecated Use localMediaStream and get track from the stream.
   */
  get localVideoTrack() {
    return this.session && this.sessionManager.getLocalVideoTrack(this.session);
  }
  /**
   * The remote audio track, if available.
   * @deprecated Use remoteMediaStream and get track from the stream.
   */
  get remoteAudioTrack() {
    return this.session && this.sessionManager.getRemoteAudioTrack(this.session);
  }
  /**
   * The remote video track, if available.
   * @deprecated Use remoteMediaStream and get track from the stream.
   */
  get remoteVideoTrack() {
    return this.session && this.sessionManager.getRemoteVideoTrack(this.session);
  }
  /**
   * Connect.
   * @remarks
   * Start the UserAgent's WebSocket Transport.
   */
  connect() {
    this.logger.log(`[${this.id}] Connecting UserAgent...`);
    return this.sessionManager.connect();
  }
  /**
   * Disconnect.
   * @remarks
   * Stop the UserAgent's WebSocket Transport.
   */
  disconnect() {
    this.logger.log(`[${this.id}] Disconnecting UserAgent...`);
    return this.sessionManager.disconnect();
  }
  /**
   * Return true if connected.
   */
  isConnected() {
    return this.sessionManager.isConnected();
  }
  /**
   * Start receiving incoming calls.
   * @remarks
   * Send a REGISTER request for the UserAgent's AOR.
   * Resolves when the REGISTER request is sent, otherwise rejects.
   */
  register(registererRegisterOptions) {
    this.logger.log(`[${this.id}] Registering UserAgent...`);
    return this.sessionManager.register(registererRegisterOptions);
  }
  /**
   * Stop receiving incoming calls.
   * @remarks
   * Send an un-REGISTER request for the UserAgent's AOR.
   * Resolves when the un-REGISTER request is sent, otherwise rejects.
   */
  unregister(registererUnregisterOptions) {
    this.logger.log(`[${this.id}] Unregistering UserAgent...`);
    return this.sessionManager.unregister(registererUnregisterOptions);
  }
  /**
   * Make an outgoing call.
   * @remarks
   * Send an INVITE request to create a new Session.
   * Resolves when the INVITE request is sent, otherwise rejects.
   * Use `onCallAnswered` delegate method to determine if Session is established.
   * @param destination - The target destination to call. A SIP address to send the INVITE to.
   * @param inviterOptions - Optional options for Inviter constructor.
   * @param inviterInviteOptions - Optional options for Inviter.invite().
   */
  call(destination, inviterOptions, inviterInviteOptions) {
    this.logger.log(`[${this.id}] Beginning Session...`);
    if (this.session) {
      return Promise.reject(new Error("Session already exists."));
    }
    return this.sessionManager.call(destination, inviterOptions, inviterInviteOptions).then(() => {
      return;
    });
  }
  /**
   * Hangup a call.
   * @remarks
   * Send a BYE request, CANCEL request or reject response to end the current Session.
   * Resolves when the request/response is sent, otherwise rejects.
   * Use `onCallHangup` delegate method to determine if and when call is ended.
   */
  hangup() {
    this.logger.log(`[${this.id}] Hangup...`);
    if (!this.session) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.sessionManager.hangup(this.session).then(() => {
      this.session = void 0;
    });
  }
  /**
   * Answer an incoming call.
   * @remarks
   * Accept an incoming INVITE request creating a new Session.
   * Resolves with the response is sent, otherwise rejects.
   * Use `onCallAnswered` delegate method to determine if and when call is established.
   * @param invitationAcceptOptions - Optional options for Inviter.accept().
   */
  answer(invitationAcceptOptions) {
    this.logger.log(`[${this.id}] Accepting Invitation...`);
    if (!this.session) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.sessionManager.answer(this.session, invitationAcceptOptions);
  }
  /**
   * Decline an incoming call.
   * @remarks
   * Reject an incoming INVITE request.
   * Resolves with the response is sent, otherwise rejects.
   * Use `onCallHangup` delegate method to determine if and when call is ended.
   */
  decline() {
    this.logger.log(`[${this.id}] rejecting Invitation...`);
    if (!this.session) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.sessionManager.decline(this.session);
  }
  /**
   * Hold call
   * @remarks
   * Send a re-INVITE with new offer indicating "hold".
   * Resolves when the re-INVITE request is sent, otherwise rejects.
   * Use `onCallHold` delegate method to determine if request is accepted or rejected.
   * See: https://tools.ietf.org/html/rfc6337
   */
  hold() {
    this.logger.log(`[${this.id}] holding session...`);
    if (!this.session) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.sessionManager.hold(this.session);
  }
  /**
   * Unhold call.
   * @remarks
   * Send a re-INVITE with new offer indicating "unhold".
   * Resolves when the re-INVITE request is sent, otherwise rejects.
   * Use `onCallHold` delegate method to determine if request is accepted or rejected.
   * See: https://tools.ietf.org/html/rfc6337
   */
  unhold() {
    this.logger.log(`[${this.id}] unholding session...`);
    if (!this.session) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.sessionManager.unhold(this.session);
  }
  /**
   * Hold state.
   * @remarks
   * True if session is on hold.
   */
  isHeld() {
    return this.session ? this.sessionManager.isHeld(this.session) : false;
  }
  /**
   * Mute call.
   * @remarks
   * Disable sender's media tracks.
   */
  mute() {
    this.logger.log(`[${this.id}] disabling media tracks...`);
    return this.session && this.sessionManager.mute(this.session);
  }
  /**
   * Unmute call.
   * @remarks
   * Enable sender's media tracks.
   */
  unmute() {
    this.logger.log(`[${this.id}] enabling media tracks...`);
    return this.session && this.sessionManager.unmute(this.session);
  }
  /**
   * Mute state.
   * @remarks
   * True if sender's media track is disabled.
   */
  isMuted() {
    return this.session ? this.sessionManager.isMuted(this.session) : false;
  }
  /**
   * Send DTMF.
   * @remarks
   * Send an INFO request with content type application/dtmf-relay.
   * @param tone - Tone to send.
   */
  sendDTMF(tone) {
    this.logger.log(`[${this.id}] sending DTMF...`);
    if (!this.session) {
      return Promise.reject(new Error("Session does not exist."));
    }
    return this.sessionManager.sendDTMF(this.session, tone);
  }
  /**
   * Send a message.
   * @remarks
   * Send a MESSAGE request.
   * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.
   */
  message(destination, message2) {
    this.logger.log(`[${this.id}] sending message...`);
    return this.sessionManager.message(destination, message2);
  }
}
const fakeInternetCall = {
  url: "wss://portsip.omicx.vn:5065"
};
const _SIP_SDK = class _SIP_SDK {
  constructor({ info }) {
    __publicField(this, "dispatch");
    __publicField(this, "snackbar");
    __publicField(this, "store");
    __publicField(this, "simpleUser");
    __publicField(this, "sessionManager");
    __publicField(this, "server_url", config_url.sip_url);
    __publicField(this, "sip_port", config_port.sip || "");
    __publicField(this, "senderId", "");
    __publicField(this, "audioElement", new Audio());
    // protected audioLocal = new Audio("/sounds/ringing.mp3") as HTMLAudioElement;
    __publicField(this, "registed_sip", false);
    __publicField(this, "mute", true);
    __publicField(this, "camera", true);
    __publicField(this, "info_agent");
    __publicField(this, "isRefuseTransfer", false);
    __publicField(this, "elAudioId", "");
    this.snackbar = alertSnackbar();
    this.info_agent = info;
    this.dispatch = store.dispatch;
  }
  stopAudioRemote() {
    this.audioElement.pause();
  }
  stopAudioLocal() {
  }
  pushCallEventEmitter(type, object = {}) {
    client_socket.emit(Event_SDK.CallEvent, {
      type,
      ...object
    });
  }
  setCloneSessionId(sessionId) {
  }
  async onUnRegister() {
    try {
      await this.simpleUser.unregister({
        requestDelegate: {
          onAccept: (response) => {
          },
          onProgress: (response) => {
          },
          onRedirect: (response) => {
          },
          onTrying: (response) => {
          }
        }
      });
      this.registed_sip = false;
    } catch (error) {
    }
  }
  getElement(id) {
    return document.getElementById(id);
  }
  setRegisted(registed) {
    this.registed_sip = registed;
  }
  async onReconnect() {
    try {
      await this.simpleUser.connect();
      return Promise.resolve(true);
    } catch (error) {
      return Promise.reject(false);
    }
  }
  async connect_sip({
    localVideoId,
    remoteVideoId,
    remoteAudioId,
    server
  }) {
    var _a, _b, _c, _d, _e, _f;
    const sipExtension = (_b = (_a = this.info_agent) == null ? void 0 : _a.user) == null ? void 0 : _b.extension;
    const dynamicPassword = (_d = (_c = this.info_agent) == null ? void 0 : _c.user) == null ? void 0 : _d.sipPassword;
    if (localVideoId) {
      const el = document.getElementById(localVideoId);
      if (!el) {
        const createVideo = document.createElement("video");
        createVideo.id = localVideoId;
        document.body.appendChild(createVideo);
      }
    }
    if (remoteVideoId) {
      const el = document.getElementById(remoteVideoId);
      if (!el) {
        const createVideo = document.createElement("video");
        createVideo.id = remoteVideoId;
        document.body.appendChild(createVideo);
      }
    }
    if (remoteAudioId) {
      const el = document.getElementById(remoteAudioId);
      if (!el) {
        const createAudio = document.createElement("audio");
        createAudio.id = remoteAudioId;
        document.body.appendChild(createAudio);
        createAudio.style.display = "none";
      }
      this.elAudioId = remoteAudioId;
    }
    try {
      const options = {
        aor: `sip:${sipExtension}@${(_f = (_e = this.info_agent) == null ? void 0 : _e.tenant) == null ? void 0 : _f.domainContext}`,
        media: {
          local: {
            video: this.getElement(localVideoId || "") || null
            // audio: (this.getElement("localAudio") as HTMLAudioElement) || null,
          },
          remote: {
            video: this.getElement(remoteVideoId || "") || null,
            audio: this.getElement(remoteAudioId || "") || null
          }
        },
        userAgentOptions: {
          authorizationUsername: sipExtension,
          authorizationPassword: dynamicPassword,
          logLevel: "error",
          // displayName: phone,
          // contactName: phone,
          delegate: {
            onInvite: (invitation) => {
            }
          }
        },
        delegate: {
          onCallCreated: () => {
            var _a2;
            const sessionId = this.getHeader("X-Session-Id");
            const auto_call = this.getHeader("Answer-Mode");
            client_socket.emit(Event_SDK.CallEvent, {
              type: CallEventType.CALL_CONNECTED,
              name: CallEventType.CALL_CONNECTED,
              applicationId: "",
              senderId: "",
              sessionId
            });
            const session2 = (_a2 = this.simpleUser) == null ? void 0 : _a2.session;
            _SIP_SDK.sessionIds.push(sessionId);
            _SIP_SDK.invitations.set(sessionId, session2);
            if (auto_call === "Auto;require") {
              this.accept().then(() => {
                var _a3;
                if (((_a3 = _SIP_SDK.sessionIds) == null ? void 0 : _a3.length) > 1 && !this.sessionManager.isHeld(
                  _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
                )) {
                  this.sessionManager.hold(
                    _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
                  ).then().catch((e2) => console.error(e2));
                }
              }).catch((e2) => console.error(e2));
            }
          },
          onCallAnswered() {
          },
          onCallHangup: () => {
            this.camera = true;
            this.mute = true;
          },
          onCallHold: (held) => {
            this.dispatch(
              setActionBtn({
                hold: !held
              })
            );
            this.pushCallEventEmitter(
              !held ? CallEventType.CALL_UNHOLD : CallEventType.CALL_HOLD,
              { held }
            );
          },
          onCallReceived: () => {
          },
          // onCallHold(held: boolean) {},
          onRegistered() {
          },
          onServerDisconnect: () => {
          },
          onServerConnect: () => {
          }
        }
      };
      this.simpleUser = new SimpleUser(server, options);
      this.sessionManager = this.simpleUser.sessionManager;
      try {
        await this.simpleUser.connect();
        await this.simpleUser.register({
          requestDelegate: {
            onAccept: () => {
              this.setRegisted(true);
              client_socket.emit(Event_SDK.AppEvent, {
                type: AppEventType$1.CONNECTED,
                message: AppEventType$1.CONNECTED
              });
            },
            onRedirect: (res) => {
            }
          }
        });
        this.dispatch(
          setSipJs({
            // invitation: this.invitation,
            acceptCall: () => this.accept(),
            rejectCall: () => this.rejectCallInbound(),
            endCall: () => this.endCall(),
            stopAudioLocal: () => this.stopAudioLocal(),
            holdCall: () => this.holdCall(),
            unHoldCall: () => this.unHoldCall(),
            setMuteInBound: (enabled) => this.setMuteInBound(),
            muteCall: () => this.muteCall(),
            unMuteCall: () => this.unMuteCall()
          })
        );
      } catch (error) {
      }
    } catch (error) {
    }
  }
  async disconnect_sip() {
    try {
      await this.simpleUser.disconnect();
    } catch (error) {
    }
  }
  getHeader(key) {
    var _a, _b;
    if (!this.simpleUser) return "";
    const session2 = (_a = this.simpleUser) == null ? void 0 : _a.session;
    if (!session2) return "";
    const value2 = (session2 == null ? void 0 : session2.request) && session2 ? ((_b = session2.request) == null ? void 0 : _b.getHeader(key)) ?? "" : "";
    return value2;
  }
  sip_Accept_Transfer(body) {
    var _a;
    if (((_a = _SIP_SDK.sessionIds) == null ? void 0 : _a.length) > 1) {
      postAcceptTransfer({ ...body, sessionId: _SIP_SDK.sessionIds[0] }).then((response) => {
        var _a2;
        if ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.success) {
          this.isRefuseTransfer = false;
          this.pushCallEventEmitter(CallEventType.CALL_TRANSFER_ACCEPTED, {
            sessionId: _SIP_SDK.sessionIds[0],
            applicationId: body == null ? void 0 : body.applicationId,
            senderId: body == null ? void 0 : body.senderId
          });
          _SIP_SDK.sessionIds = [];
          _SIP_SDK.invitations = /* @__PURE__ */ new Map();
        }
      }).catch(() => {
        alertSnackbar()({
          title: "Không thể chuyển cho agent",
          status: "error"
        });
      });
    }
  }
  sip_refuse_transfer(body) {
    var _a;
    if (((_a = _SIP_SDK.sessionIds) == null ? void 0 : _a.length) >= 1) {
      postRefuseTransfer({ ...body, sessionId: _SIP_SDK.sessionIds[0] }).then((response) => {
        var _a2, _b, _c, _d;
        if ((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.success) {
          const session2 = (_b = this.simpleUser) == null ? void 0 : _b.session;
          if (((_c = _SIP_SDK.sessionIds) == null ? void 0 : _c.length) > 1) {
            this.sessionManager.hangup(
              _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[1]) || session2
            );
          }
          this.isRefuseTransfer = true;
          const localStream = this.sessionManager.getRemoteMediaStream(
            _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
          );
          client_socket.emit(Event_SDK.CallEvent, {
            type: CallEventType.CALL_REFUSE_TRANSFER,
            name: CallEventType.CALL_REFUSE_TRANSFER,
            senderId: body == null ? void 0 : body.senderId,
            applicationId: body == null ? void 0 : body.applicationId,
            sessionId: _SIP_SDK.sessionIds[0]
          });
          if (this.elAudioId) {
            const mediaElement = this.getElement(
              this.elAudioId || ""
            );
            if (mediaElement && localStream) {
              mediaElement.srcObject = localStream;
              mediaElement.play().catch((error) => {
                console.error(
                  `[${session2.id}]_${error} Failed to play local media`
                );
              });
              localStream.onaddtrack = () => {
                var _a3;
                mediaElement == null ? void 0 : mediaElement.load();
                (_a3 = mediaElement == null ? void 0 : mediaElement.play) == null ? void 0 : _a3.call(mediaElement).catch((error) => {
                });
              };
            }
          }
          (_d = this.dispatch) == null ? void 0 : _d.call(this, setStatusCall(CallStatusInfo.listeningCall));
        }
      }).catch(() => {
        alertSnackbar()({
          title: "Không thể chuyển cho agent",
          status: "error"
        });
      });
    }
  }
  /**
   * Make a call to a specific phone number
   * @param phoneNumber - The phone number to call
   * @param domain - The SIP domain
   * @param cbStatus - Optional callback for status updates
   * @returns Promise resolving to true if successful
   */
  async makeCall(phoneNumber2, domain = "voice.omicx.vn") {
    try {
      await this.simpleUser.call(
        `sip:${phoneNumber2}@${domain}`,
        {},
        {
          requestDelegate: {
            onAccept: () => {
            },
            onProgress: () => {
            },
            onTrying: () => {
            },
            onRedirect: () => {
            }
          }
        }
      );
      return Promise.resolve(true);
    } catch (error) {
      this.snackbar({
        title: "Không thể thực hiện cuộc gọi!",
        status: "error"
      });
      return Promise.reject(false);
    }
  }
  async accept() {
    try {
      try {
        await this.simpleUser.answer();
      } catch (error) {
      }
    } catch (error) {
    }
  }
  async rejectCallInbound() {
    this.stopAudioLocal();
    try {
      await this.simpleUser.decline();
      return Promise.resolve(true);
    } catch (error) {
      return Promise.reject(false);
    }
  }
  async voiceToVideoCall(cb) {
    const session2 = this.simpleUser.session;
    const sessionDescriptionHandler = session2;
    if (sessionDescriptionHandler) {
      try {
        await sessionDescriptionHandler.invite({
          requestDelegate: {
            onAccept: (response) => {
              cb(true);
            },
            onReject: (response) => {
              cb(false);
            }
          },
          sessionDescriptionHandlerOptions: {
            constraints: {
              video: true,
              audio: true
            }
          }
        });
      } catch (error) {
        cb(false);
        this.snackbar({
          title: "Không thể chuyển sang video!",
          status: "error"
        });
      }
    }
  }
  async endCall() {
    var _a, _b, _c;
    if ((_a = _SIP_SDK.sessionIds) == null ? void 0 : _a.length) {
      try {
        const session2 = (_b = this.simpleUser) == null ? void 0 : _b.session;
        await this.sessionManager.hangup(
          _SIP_SDK.invitations.get(
            _SIP_SDK.sessionIds[((_c = _SIP_SDK.sessionIds) == null ? void 0 : _c.length) - 1]
          ) || session2
        );
      } catch (error) {
      }
    }
  }
  async holdCall() {
    var _a;
    try {
      if (this.isRefuseTransfer) {
        const session2 = (_a = this.simpleUser) == null ? void 0 : _a.session;
        await this.sessionManager.hold(
          _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
        );
      } else {
        await this.simpleUser.hold();
      }
      return Promise.resolve(true);
    } catch (error) {
      return Promise.reject(false);
    }
  }
  async unHoldCall() {
    var _a;
    try {
      if (this.isRefuseTransfer) {
        const session2 = (_a = this.simpleUser) == null ? void 0 : _a.session;
        await this.sessionManager.unhold(
          _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
        );
      } else {
        await this.simpleUser.unhold();
      }
      return Promise.resolve(true);
    } catch (error) {
      return Promise.reject(false);
    }
  }
  async muteCall() {
    var _a;
    try {
      if (this.isRefuseTransfer) {
        const session2 = (_a = this.simpleUser) == null ? void 0 : _a.session;
        await this.sessionManager.mute(
          _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
        );
      } else {
        await this.simpleUser.mute();
      }
      this.pushCallEventEmitter(CallEventType.CALL_MUTE);
      this.dispatch(
        setActionBtn({
          mute: false
        })
      );
    } catch (error) {
    }
  }
  async unMuteCall() {
    var _a;
    try {
      if (this.isRefuseTransfer) {
        const session2 = (_a = this.simpleUser) == null ? void 0 : _a.session;
        await this.sessionManager.unmute(
          _SIP_SDK.invitations.get(_SIP_SDK.sessionIds[0]) || session2
        );
      } else {
        await this.simpleUser.unmute();
      }
      this.pushCallEventEmitter(CallEventType.CALL_UNMUTE);
      this.dispatch(
        setActionBtn({
          mute: true
        })
      );
    } catch (error) {
    }
  }
  setMuteInBound(cb) {
    try {
      const session2 = this.simpleUser.session;
      const sessionDescriptionHandler = session2.sessionDescriptionHandler;
      if (sessionDescriptionHandler) {
        const pc = sessionDescriptionHandler.peerConnection;
        if (pc) {
          pc.getLocalStreams().forEach((stream) => {
            stream.getAudioTracks().forEach((track) => {
              track.enabled = this.mute;
            });
          });
          this.mute = !this.mute;
          cb && cb(this.mute);
        }
      }
    } catch (error) {
    }
  }
  setCamera(camera) {
    try {
      const session2 = this.simpleUser.session;
      const sessionDescriptionHandler = session2.sessionDescriptionHandler;
      if (sessionDescriptionHandler) {
        const pc = sessionDescriptionHandler.peerConnection;
        if (pc) {
          pc.getLocalStreams().forEach((stream) => {
            stream.getVideoTracks().forEach((track) => {
              track.enabled = camera;
            });
          });
        }
      }
    } catch (error) {
    }
  }
};
__publicField(_SIP_SDK, "sessionIds", []);
__publicField(_SIP_SDK, "invitations", /* @__PURE__ */ new Map());
let SIP_SDK = _SIP_SDK;
const LIBRARY_VERSION = "0.20.0";
class Parameters2 {
  constructor(parameters) {
    this.parameters = {};
    for (const param in parameters) {
      if (parameters.hasOwnProperty(param)) {
        this.setParam(param, parameters[param]);
      }
    }
  }
  setParam(key, value2) {
    if (key) {
      this.parameters[key.toLowerCase()] = typeof value2 === "undefined" || value2 === null ? null : value2.toString();
    }
  }
  getParam(key) {
    if (key) {
      return this.parameters[key.toLowerCase()];
    }
  }
  hasParam(key) {
    return !!(key && this.parameters[key.toLowerCase()] !== void 0);
  }
  deleteParam(key) {
    key = key.toLowerCase();
    if (this.hasParam(key)) {
      const value2 = this.parameters[key];
      delete this.parameters[key];
      return value2;
    }
  }
  clearParams() {
    this.parameters = {};
  }
}
class NameAddrHeader2 extends Parameters2 {
  /**
   * Constructor
   * @param uri -
   * @param displayName -
   * @param parameters -
   */
  constructor(uri, displayName, parameters) {
    super(parameters);
    this.uri = uri;
    this._displayName = displayName;
  }
  get friendlyName() {
    return this.displayName || this.uri.aor;
  }
  get displayName() {
    return this._displayName;
  }
  set displayName(value2) {
    this._displayName = value2;
  }
  clone() {
    return new NameAddrHeader2(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
  }
  toString() {
    let body = this.displayName || this.displayName === "0" ? '"' + this.displayName + '" ' : "";
    body += "<" + this.uri.toString() + ">";
    for (const parameter in this.parameters) {
      if (this.parameters.hasOwnProperty(parameter)) {
        body += ";" + parameter;
        if (this.parameters[parameter] !== null) {
          body += "=" + this.parameters[parameter];
        }
      }
    }
    return body;
  }
}
class URI2 extends Parameters2 {
  /**
   * Constructor
   * @param scheme -
   * @param user -
   * @param host -
   * @param port -
   * @param parameters -
   * @param headers -
   */
  constructor(scheme = "sip", user, host, port, parameters, headers) {
    super(parameters || {});
    this.headers = {};
    if (!host) {
      throw new TypeError('missing or invalid "host" parameter');
    }
    for (const header in headers) {
      if (headers.hasOwnProperty(header)) {
        this.setHeader(header, headers[header]);
      }
    }
    this.raw = {
      scheme,
      user,
      host,
      port
    };
    this.normal = {
      scheme: scheme.toLowerCase(),
      user,
      host: host.toLowerCase(),
      port
    };
  }
  get scheme() {
    return this.normal.scheme;
  }
  set scheme(value2) {
    this.raw.scheme = value2;
    this.normal.scheme = value2.toLowerCase();
  }
  get user() {
    return this.normal.user;
  }
  set user(value2) {
    this.normal.user = this.raw.user = value2;
  }
  get host() {
    return this.normal.host;
  }
  set host(value2) {
    this.raw.host = value2;
    this.normal.host = value2.toLowerCase();
  }
  get aor() {
    return this.normal.user + "@" + this.normal.host;
  }
  get port() {
    return this.normal.port;
  }
  set port(value2) {
    this.normal.port = this.raw.port = value2 === 0 ? value2 : value2;
  }
  setHeader(name2, value2) {
    this.headers[this.headerize(name2)] = value2 instanceof Array ? value2 : [value2];
  }
  getHeader(name2) {
    if (name2) {
      return this.headers[this.headerize(name2)];
    }
  }
  hasHeader(name2) {
    return !!name2 && !!this.headers.hasOwnProperty(this.headerize(name2));
  }
  deleteHeader(header) {
    header = this.headerize(header);
    if (this.headers.hasOwnProperty(header)) {
      const value2 = this.headers[header];
      delete this.headers[header];
      return value2;
    }
  }
  clearHeaders() {
    this.headers = {};
  }
  clone() {
    return new URI2(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
  }
  toRaw() {
    return this._toString(this._raw);
  }
  toString() {
    return this._toString(this._normal);
  }
  get _normal() {
    return this.normal;
  }
  get _raw() {
    return this.raw;
  }
  _toString(uri) {
    let uriString = uri.scheme + ":";
    if (!uri.scheme.toLowerCase().match("^sips?$")) {
      uriString += "//";
    }
    if (uri.user) {
      uriString += this.escapeUser(uri.user) + "@";
    }
    uriString += uri.host;
    if (uri.port || uri.port === 0) {
      uriString += ":" + uri.port;
    }
    for (const parameter in this.parameters) {
      if (this.parameters.hasOwnProperty(parameter)) {
        uriString += ";" + parameter;
        if (this.parameters[parameter] !== null) {
          uriString += "=" + this.parameters[parameter];
        }
      }
    }
    const headers = [];
    for (const header in this.headers) {
      if (this.headers.hasOwnProperty(header)) {
        for (const idx in this.headers[header]) {
          if (this.headers[header].hasOwnProperty(idx)) {
            headers.push(header + "=" + this.headers[header][idx]);
          }
        }
      }
    }
    if (headers.length > 0) {
      uriString += "?" + headers.join("&");
    }
    return uriString;
  }
  /*
   * Hex-escape a SIP URI user.
   * @private
   * @param {String} user
   */
  escapeUser(user) {
    let decodedUser;
    try {
      decodedUser = decodeURIComponent(user);
    } catch (error) {
      throw error;
    }
    return encodeURIComponent(decodedUser).replace(/%3A/ig, ":").replace(/%2B/ig, "+").replace(/%3F/ig, "?").replace(/%2F/ig, "/");
  }
  headerize(str) {
    const exceptions = {
      "Call-Id": "Call-ID",
      "Cseq": "CSeq",
      "Min-Se": "Min-SE",
      "Rack": "RAck",
      "Rseq": "RSeq",
      "Www-Authenticate": "WWW-Authenticate"
    };
    const name2 = str.toLowerCase().replace(/_/g, "-").split("-");
    const parts2 = name2.length;
    let hname = "";
    for (let part = 0; part < parts2; part++) {
      if (part !== 0) {
        hname += "-";
      }
      hname += name2[part].charAt(0).toUpperCase() + name2[part].substring(1);
    }
    if (exceptions[hname]) {
      hname = exceptions[hname];
    }
    return hname;
  }
}
function equivalentURI(a2, b) {
  if (a2.scheme !== b.scheme) {
    return false;
  }
  if (a2.user !== b.user || a2.host !== b.host || a2.port !== b.port) {
    return false;
  }
  function compareParameters(a3, b2) {
    const parameterKeysA = Object.keys(a3.parameters);
    const parameterKeysB = Object.keys(b2.parameters);
    const intersection = parameterKeysA.filter((x) => parameterKeysB.includes(x));
    if (!intersection.every((key) => a3.parameters[key] === b2.parameters[key])) {
      return false;
    }
    if (!["user", "ttl", "method", "transport"].every((key) => a3.hasParam(key) && b2.hasParam(key) || !a3.hasParam(key) && !b2.hasParam(key))) {
      return false;
    }
    if (!["maddr"].every((key) => a3.hasParam(key) && b2.hasParam(key) || !a3.hasParam(key) && !b2.hasParam(key))) {
      return false;
    }
    return true;
  }
  if (!compareParameters(a2, b)) {
    return false;
  }
  const headerKeysA = Object.keys(a2.headers);
  const headerKeysB = Object.keys(b.headers);
  if (headerKeysA.length !== 0 || headerKeysB.length !== 0) {
    if (headerKeysA.length !== headerKeysB.length) {
      return false;
    }
    const intersection = headerKeysA.filter((x) => headerKeysB.includes(x));
    if (intersection.length !== headerKeysB.length) {
      return false;
    }
    if (!intersection.every((key) => a2.headers[key].length && b.headers[key].length && a2.headers[key][0] === b.headers[key][0])) {
      return false;
    }
  }
  return true;
}
class SyntaxError2 extends Error {
  constructor(message2, expected, found, location2) {
    super();
    this.message = message2;
    this.expected = expected;
    this.found = found;
    this.location = location2;
    this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, SyntaxError2);
    }
  }
  static buildMessage(expected, found) {
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
    }
    function describeExpectation(expectation) {
      switch (expectation.type) {
        case "literal":
          return '"' + literalEscape(expectation.text) + '"';
        case "class":
          const escapedParts = expectation.parts.map((part) => {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }
    function describeExpected(expected1) {
      const descriptions = expected1.map(describeExpectation);
      let i2;
      let j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i2 = 1, j = 1; i2 < descriptions.length; i2++) {
          if (descriptions[i2 - 1] !== descriptions[i2]) {
            descriptions[j] = descriptions[i2];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found1) {
      return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }
}
function peg$parse(input, options) {
  options = options !== void 0 ? options : {};
  const peg$FAILED = {};
  const peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 };
  let peg$startRuleIndex = 119;
  const peg$consts = [
    "\r\n",
    peg$literalExpectation("\r\n", false),
    /^[0-9]/,
    peg$classExpectation([["0", "9"]], false, false),
    /^[a-zA-Z]/,
    peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
    /^[0-9a-fA-F]/,
    peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
    /^[\0-\xFF]/,
    peg$classExpectation([["\0", "ÿ"]], false, false),
    /^["]/,
    peg$classExpectation(['"'], false, false),
    " ",
    peg$literalExpectation(" ", false),
    "	",
    peg$literalExpectation("	", false),
    /^[a-zA-Z0-9]/,
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
    ";",
    peg$literalExpectation(";", false),
    "/",
    peg$literalExpectation("/", false),
    "?",
    peg$literalExpectation("?", false),
    ":",
    peg$literalExpectation(":", false),
    "@",
    peg$literalExpectation("@", false),
    "&",
    peg$literalExpectation("&", false),
    "=",
    peg$literalExpectation("=", false),
    "+",
    peg$literalExpectation("+", false),
    "$",
    peg$literalExpectation("$", false),
    ",",
    peg$literalExpectation(",", false),
    "-",
    peg$literalExpectation("-", false),
    "_",
    peg$literalExpectation("_", false),
    ".",
    peg$literalExpectation(".", false),
    "!",
    peg$literalExpectation("!", false),
    "~",
    peg$literalExpectation("~", false),
    "*",
    peg$literalExpectation("*", false),
    "'",
    peg$literalExpectation("'", false),
    "(",
    peg$literalExpectation("(", false),
    ")",
    peg$literalExpectation(")", false),
    "%",
    peg$literalExpectation("%", false),
    function() {
      return " ";
    },
    function() {
      return ":";
    },
    /^[!-~]/,
    peg$classExpectation([["!", "~"]], false, false),
    /^[\x80-\uFFFF]/,
    peg$classExpectation([["", "￿"]], false, false),
    /^[\x80-\xBF]/,
    peg$classExpectation([["", "¿"]], false, false),
    /^[a-f]/,
    peg$classExpectation([["a", "f"]], false, false),
    "`",
    peg$literalExpectation("`", false),
    "<",
    peg$literalExpectation("<", false),
    ">",
    peg$literalExpectation(">", false),
    "\\",
    peg$literalExpectation("\\", false),
    "[",
    peg$literalExpectation("[", false),
    "]",
    peg$literalExpectation("]", false),
    "{",
    peg$literalExpectation("{", false),
    "}",
    peg$literalExpectation("}", false),
    function() {
      return "*";
    },
    function() {
      return "/";
    },
    function() {
      return "=";
    },
    function() {
      return "(";
    },
    function() {
      return ")";
    },
    function() {
      return ">";
    },
    function() {
      return "<";
    },
    function() {
      return ",";
    },
    function() {
      return ";";
    },
    function() {
      return ":";
    },
    function() {
      return '"';
    },
    /^[!-']/,
    peg$classExpectation([["!", "'"]], false, false),
    /^[*-[]/,
    peg$classExpectation([["*", "["]], false, false),
    /^[\]-~]/,
    peg$classExpectation([["]", "~"]], false, false),
    function(contents) {
      return contents;
    },
    /^[#-[]/,
    peg$classExpectation([["#", "["]], false, false),
    /^[\0-\t]/,
    peg$classExpectation([["\0", "	"]], false, false),
    /^[\x0B-\f]/,
    peg$classExpectation([["\v", "\f"]], false, false),
    /^[\x0E-\x7F]/,
    peg$classExpectation([["", ""]], false, false),
    function() {
      options = options || { data: {} };
      options.data.uri = new URI2(options.data.scheme, options.data.user, options.data.host, options.data.port);
      delete options.data.scheme;
      delete options.data.user;
      delete options.data.host;
      delete options.data.host_type;
      delete options.data.port;
    },
    function() {
      options = options || { data: {} };
      options.data.uri = new URI2(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
      delete options.data.scheme;
      delete options.data.user;
      delete options.data.host;
      delete options.data.host_type;
      delete options.data.port;
      delete options.data.uri_params;
      if (options.startRule === "SIP_URI") {
        options.data = options.data.uri;
      }
    },
    "sips",
    peg$literalExpectation("sips", true),
    "sip",
    peg$literalExpectation("sip", true),
    function(uri_scheme) {
      options = options || { data: {} };
      options.data.scheme = uri_scheme;
    },
    function() {
      options = options || { data: {} };
      options.data.user = decodeURIComponent(text().slice(0, -1));
    },
    function() {
      options = options || { data: {} };
      options.data.password = text();
    },
    function() {
      options = options || { data: {} };
      options.data.host = text();
      return options.data.host;
    },
    function() {
      options = options || { data: {} };
      options.data.host_type = "domain";
      return text();
    },
    /^[a-zA-Z0-9_\-]/,
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
    /^[a-zA-Z0-9\-]/,
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
    function() {
      options = options || { data: {} };
      options.data.host_type = "IPv6";
      return text();
    },
    "::",
    peg$literalExpectation("::", false),
    function() {
      options = options || { data: {} };
      options.data.host_type = "IPv6";
      return text();
    },
    function() {
      options = options || { data: {} };
      options.data.host_type = "IPv4";
      return text();
    },
    "25",
    peg$literalExpectation("25", false),
    /^[0-5]/,
    peg$classExpectation([["0", "5"]], false, false),
    "2",
    peg$literalExpectation("2", false),
    /^[0-4]/,
    peg$classExpectation([["0", "4"]], false, false),
    "1",
    peg$literalExpectation("1", false),
    /^[1-9]/,
    peg$classExpectation([["1", "9"]], false, false),
    function(port) {
      options = options || { data: {} };
      port = parseInt(port.join(""));
      options.data.port = port;
      return port;
    },
    "transport=",
    peg$literalExpectation("transport=", true),
    "udp",
    peg$literalExpectation("udp", true),
    "tcp",
    peg$literalExpectation("tcp", true),
    "sctp",
    peg$literalExpectation("sctp", true),
    "tls",
    peg$literalExpectation("tls", true),
    function(transport) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["transport"] = transport.toLowerCase();
    },
    "user=",
    peg$literalExpectation("user=", true),
    "phone",
    peg$literalExpectation("phone", true),
    "ip",
    peg$literalExpectation("ip", true),
    function(user) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["user"] = user.toLowerCase();
    },
    "method=",
    peg$literalExpectation("method=", true),
    function(method) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["method"] = method;
    },
    "ttl=",
    peg$literalExpectation("ttl=", true),
    function(ttl) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      options.data.params["ttl"] = ttl;
    },
    "maddr=",
    peg$literalExpectation("maddr=", true),
    function(maddr) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["maddr"] = maddr;
    },
    "lr",
    peg$literalExpectation("lr", true),
    function() {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      options.data.uri_params["lr"] = void 0;
    },
    function(param, value2) {
      options = options || { data: {} };
      if (!options.data.uri_params)
        options.data.uri_params = {};
      if (value2 === null) {
        value2 = void 0;
      } else {
        value2 = value2[1];
      }
      options.data.uri_params[param.toLowerCase()] = value2;
    },
    function(hname, hvalue) {
      hname = hname.join("").toLowerCase();
      hvalue = hvalue.join("");
      options = options || { data: {} };
      if (!options.data.uri_headers)
        options.data.uri_headers = {};
      if (!options.data.uri_headers[hname]) {
        options.data.uri_headers[hname] = [hvalue];
      } else {
        options.data.uri_headers[hname].push(hvalue);
      }
    },
    function() {
      options = options || { data: {} };
      if (options.startRule === "Refer_To") {
        options.data.uri = new URI2(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
        delete options.data.scheme;
        delete options.data.user;
        delete options.data.host;
        delete options.data.host_type;
        delete options.data.port;
        delete options.data.uri_params;
      }
    },
    "//",
    peg$literalExpectation("//", false),
    function() {
      options = options || { data: {} };
      options.data.scheme = text();
    },
    peg$literalExpectation("SIP", true),
    function() {
      options = options || { data: {} };
      options.data.sip_version = text();
    },
    "INVITE",
    peg$literalExpectation("INVITE", false),
    "ACK",
    peg$literalExpectation("ACK", false),
    "VXACH",
    peg$literalExpectation("VXACH", false),
    "OPTIONS",
    peg$literalExpectation("OPTIONS", false),
    "BYE",
    peg$literalExpectation("BYE", false),
    "CANCEL",
    peg$literalExpectation("CANCEL", false),
    "REGISTER",
    peg$literalExpectation("REGISTER", false),
    "SUBSCRIBE",
    peg$literalExpectation("SUBSCRIBE", false),
    "NOTIFY",
    peg$literalExpectation("NOTIFY", false),
    "REFER",
    peg$literalExpectation("REFER", false),
    "PUBLISH",
    peg$literalExpectation("PUBLISH", false),
    function() {
      options = options || { data: {} };
      options.data.method = text();
      return options.data.method;
    },
    function(status_code) {
      options = options || { data: {} };
      options.data.status_code = parseInt(status_code.join(""));
    },
    function() {
      options = options || { data: {} };
      options.data.reason_phrase = text();
    },
    function() {
      options = options || { data: {} };
      options.data = text();
    },
    function() {
      var idx, length;
      options = options || { data: {} };
      length = options.data.multi_header.length;
      for (idx = 0; idx < length; idx++) {
        if (options.data.multi_header[idx].parsed === null) {
          options.data = null;
          break;
        }
      }
      if (options.data !== null) {
        options.data = options.data.multi_header;
      } else {
        options.data = -1;
      }
    },
    function() {
      var header;
      options = options || { data: {} };
      if (!options.data.multi_header)
        options.data.multi_header = [];
      try {
        header = new NameAddrHeader2(options.data.uri, options.data.displayName, options.data.params);
        delete options.data.uri;
        delete options.data.displayName;
        delete options.data.params;
      } catch (e2) {
        header = null;
      }
      options.data.multi_header.push({
        "position": peg$currPos,
        "offset": location2().start.offset,
        "parsed": header
      });
    },
    function(displayName) {
      displayName = text().trim();
      if (displayName[0] === '"') {
        displayName = displayName.substring(1, displayName.length - 1);
      }
      options = options || { data: {} };
      options.data.displayName = displayName;
    },
    "q",
    peg$literalExpectation("q", true),
    function(q) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      options.data.params["q"] = q;
    },
    "expires",
    peg$literalExpectation("expires", true),
    function(expires) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      options.data.params["expires"] = expires;
    },
    function(delta_seconds) {
      return parseInt(delta_seconds.join(""));
    },
    "0",
    peg$literalExpectation("0", false),
    function() {
      return parseFloat(text());
    },
    function(param, value2) {
      options = options || { data: {} };
      if (!options.data.params)
        options.data.params = {};
      if (value2 === null) {
        value2 = void 0;
      } else {
        value2 = value2[1];
      }
      options.data.params[param.toLowerCase()] = value2;
    },
    "render",
    peg$literalExpectation("render", true),
    "session",
    peg$literalExpectation("session", true),
    "icon",
    peg$literalExpectation("icon", true),
    "alert",
    peg$literalExpectation("alert", true),
    function() {
      options = options || { data: {} };
      if (options.startRule === "Content_Disposition") {
        options.data.type = text().toLowerCase();
      }
    },
    "handling",
    peg$literalExpectation("handling", true),
    "optional",
    peg$literalExpectation("optional", true),
    "required",
    peg$literalExpectation("required", true),
    function(length) {
      options = options || { data: {} };
      options.data = parseInt(length.join(""));
    },
    function() {
      options = options || { data: {} };
      options.data = text();
    },
    "text",
    peg$literalExpectation("text", true),
    "image",
    peg$literalExpectation("image", true),
    "audio",
    peg$literalExpectation("audio", true),
    "video",
    peg$literalExpectation("video", true),
    "application",
    peg$literalExpectation("application", true),
    "message",
    peg$literalExpectation("message", true),
    "multipart",
    peg$literalExpectation("multipart", true),
    "x-",
    peg$literalExpectation("x-", true),
    function(cseq_value) {
      options = options || { data: {} };
      options.data.value = parseInt(cseq_value.join(""));
    },
    function(expires) {
      options = options || { data: {} };
      options.data = expires;
    },
    function(event_type) {
      options = options || { data: {} };
      options.data.event = event_type.toLowerCase();
    },
    function() {
      options = options || { data: {} };
      var tag = options.data.tag;
      options.data = new NameAddrHeader2(options.data.uri, options.data.displayName, options.data.params);
      if (tag) {
        options.data.setParam("tag", tag);
      }
    },
    "tag",
    peg$literalExpectation("tag", true),
    function(tag) {
      options = options || { data: {} };
      options.data.tag = tag;
    },
    function(forwards) {
      options = options || { data: {} };
      options.data = parseInt(forwards.join(""));
    },
    function(min_expires) {
      options = options || { data: {} };
      options.data = min_expires;
    },
    function() {
      options = options || { data: {} };
      options.data = new NameAddrHeader2(options.data.uri, options.data.displayName, options.data.params);
    },
    "digest",
    peg$literalExpectation("Digest", true),
    "realm",
    peg$literalExpectation("realm", true),
    function(realm) {
      options = options || { data: {} };
      options.data.realm = realm;
    },
    "domain",
    peg$literalExpectation("domain", true),
    "nonce",
    peg$literalExpectation("nonce", true),
    function(nonce) {
      options = options || { data: {} };
      options.data.nonce = nonce;
    },
    "opaque",
    peg$literalExpectation("opaque", true),
    function(opaque) {
      options = options || { data: {} };
      options.data.opaque = opaque;
    },
    "stale",
    peg$literalExpectation("stale", true),
    "true",
    peg$literalExpectation("true", true),
    function() {
      options = options || { data: {} };
      options.data.stale = true;
    },
    "false",
    peg$literalExpectation("false", true),
    function() {
      options = options || { data: {} };
      options.data.stale = false;
    },
    "algorithm",
    peg$literalExpectation("algorithm", true),
    "md5",
    peg$literalExpectation("MD5", true),
    "md5-sess",
    peg$literalExpectation("MD5-sess", true),
    function(algorithm) {
      options = options || { data: {} };
      options.data.algorithm = algorithm.toUpperCase();
    },
    "qop",
    peg$literalExpectation("qop", true),
    "auth-int",
    peg$literalExpectation("auth-int", true),
    "auth",
    peg$literalExpectation("auth", true),
    function(qop_value) {
      options = options || { data: {} };
      options.data.qop || (options.data.qop = []);
      options.data.qop.push(qop_value.toLowerCase());
    },
    function(rack_value) {
      options = options || { data: {} };
      options.data.value = parseInt(rack_value.join(""));
    },
    function() {
      var idx, length;
      options = options || { data: {} };
      length = options.data.multi_header.length;
      for (idx = 0; idx < length; idx++) {
        if (options.data.multi_header[idx].parsed === null) {
          options.data = null;
          break;
        }
      }
      if (options.data !== null) {
        options.data = options.data.multi_header;
      } else {
        options.data = -1;
      }
    },
    function() {
      var header;
      options = options || { data: {} };
      if (!options.data.multi_header)
        options.data.multi_header = [];
      try {
        header = new NameAddrHeader2(options.data.uri, options.data.displayName, options.data.params);
        delete options.data.uri;
        delete options.data.displayName;
        delete options.data.params;
      } catch (e2) {
        header = null;
      }
      options.data.multi_header.push({
        "position": peg$currPos,
        "offset": location2().start.offset,
        "parsed": header
      });
    },
    function() {
      options = options || { data: {} };
      options.data = new NameAddrHeader2(options.data.uri, options.data.displayName, options.data.params);
    },
    function() {
      options = options || { data: {} };
      if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
        options.data = -1;
      }
    },
    function() {
      options = options || { data: {} };
      options.data = {
        call_id: options.data
      };
    },
    "from-tag",
    peg$literalExpectation("from-tag", true),
    function(from_tag) {
      options = options || { data: {} };
      options.data.replaces_from_tag = from_tag;
    },
    "to-tag",
    peg$literalExpectation("to-tag", true),
    function(to_tag) {
      options = options || { data: {} };
      options.data.replaces_to_tag = to_tag;
    },
    "early-only",
    peg$literalExpectation("early-only", true),
    function() {
      options = options || { data: {} };
      options.data.early_only = true;
    },
    function(head, r2) {
      return r2;
    },
    function(head, tail) {
      return list(head, tail);
    },
    function(value2) {
      options = options || { data: {} };
      if (options.startRule === "Require") {
        options.data = value2 || [];
      }
    },
    function(rseq_value) {
      options = options || { data: {} };
      options.data.value = parseInt(rseq_value.join(""));
    },
    "active",
    peg$literalExpectation("active", true),
    "pending",
    peg$literalExpectation("pending", true),
    "terminated",
    peg$literalExpectation("terminated", true),
    function() {
      options = options || { data: {} };
      options.data.state = text();
    },
    "reason",
    peg$literalExpectation("reason", true),
    function(reason) {
      options = options || { data: {} };
      if (typeof reason !== "undefined")
        options.data.reason = reason;
    },
    function(expires) {
      options = options || { data: {} };
      if (typeof expires !== "undefined")
        options.data.expires = expires;
    },
    "retry_after",
    peg$literalExpectation("retry_after", true),
    function(retry_after) {
      options = options || { data: {} };
      if (typeof retry_after !== "undefined")
        options.data.retry_after = retry_after;
    },
    "deactivated",
    peg$literalExpectation("deactivated", true),
    "probation",
    peg$literalExpectation("probation", true),
    "rejected",
    peg$literalExpectation("rejected", true),
    "timeout",
    peg$literalExpectation("timeout", true),
    "giveup",
    peg$literalExpectation("giveup", true),
    "noresource",
    peg$literalExpectation("noresource", true),
    "invariant",
    peg$literalExpectation("invariant", true),
    function(value2) {
      options = options || { data: {} };
      if (options.startRule === "Supported") {
        options.data = value2 || [];
      }
    },
    function() {
      options = options || { data: {} };
      var tag = options.data.tag;
      options.data = new NameAddrHeader2(options.data.uri, options.data.displayName, options.data.params);
      if (tag) {
        options.data.setParam("tag", tag);
      }
    },
    "ttl",
    peg$literalExpectation("ttl", true),
    function(via_ttl_value) {
      options = options || { data: {} };
      options.data.ttl = via_ttl_value;
    },
    "maddr",
    peg$literalExpectation("maddr", true),
    function(via_maddr) {
      options = options || { data: {} };
      options.data.maddr = via_maddr;
    },
    "received",
    peg$literalExpectation("received", true),
    function(via_received) {
      options = options || { data: {} };
      options.data.received = via_received;
    },
    "branch",
    peg$literalExpectation("branch", true),
    function(via_branch) {
      options = options || { data: {} };
      options.data.branch = via_branch;
    },
    "rport",
    peg$literalExpectation("rport", true),
    function(response_port) {
      options = options || { data: {} };
      if (typeof response_port !== "undefined")
        options.data.rport = response_port.join("");
    },
    function(via_protocol) {
      options = options || { data: {} };
      options.data.protocol = via_protocol;
    },
    peg$literalExpectation("UDP", true),
    peg$literalExpectation("TCP", true),
    peg$literalExpectation("TLS", true),
    peg$literalExpectation("SCTP", true),
    function(via_transport) {
      options = options || { data: {} };
      options.data.transport = via_transport;
    },
    function() {
      options = options || { data: {} };
      options.data.host = text();
    },
    function(via_sent_by_port) {
      options = options || { data: {} };
      options.data.port = parseInt(via_sent_by_port.join(""));
    },
    function(ttl) {
      return parseInt(ttl.join(""));
    },
    function(deltaSeconds) {
      options = options || { data: {} };
      if (options.startRule === "Session_Expires") {
        options.data.deltaSeconds = deltaSeconds;
      }
    },
    "refresher",
    peg$literalExpectation("refresher", false),
    "uas",
    peg$literalExpectation("uas", false),
    "uac",
    peg$literalExpectation("uac", false),
    function(endpoint) {
      options = options || { data: {} };
      if (options.startRule === "Session_Expires") {
        options.data.refresher = endpoint;
      }
    },
    function(deltaSeconds) {
      options = options || { data: {} };
      if (options.startRule === "Min_SE") {
        options.data = deltaSeconds;
      }
    },
    "stuns",
    peg$literalExpectation("stuns", true),
    "stun",
    peg$literalExpectation("stun", true),
    function(scheme) {
      options = options || { data: {} };
      options.data.scheme = scheme;
    },
    function(host) {
      options = options || { data: {} };
      options.data.host = host;
    },
    "?transport=",
    peg$literalExpectation("?transport=", false),
    "turns",
    peg$literalExpectation("turns", true),
    "turn",
    peg$literalExpectation("turn", true),
    function(transport) {
      options = options || { data: {} };
      options.data.transport = transport;
    },
    function() {
      options = options || { data: {} };
      options.data = text();
    },
    "Referred-By",
    peg$literalExpectation("Referred-By", false),
    "b",
    peg$literalExpectation("b", false),
    "cid",
    peg$literalExpectation("cid", false)
  ];
  const peg$bytecode = [
    peg$decode('2 ""6 7!'),
    peg$decode('4"""5!7#'),
    peg$decode('4$""5!7%'),
    peg$decode(`4&""5!7'`),
    peg$decode(";'.# &;("),
    peg$decode('4(""5!7)'),
    peg$decode('4*""5!7+'),
    peg$decode('2,""6,7-'),
    peg$decode('2.""6.7/'),
    peg$decode('40""5!71'),
    peg$decode('22""6273. &24""6475.} &26""6677.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'),
    peg$decode(";).# &;,"),
    peg$decode('2F""6F7G.} &2H""6H7I.q &2J""6J7K.e &2L""6L7M.Y &2N""6N7O.M &2P""6P7Q.A &2R""6R7S.5 &2T""6T7U.) &2V""6V7W'),
    peg$decode(`%%2X""6X7Y/5#;#/,$;#/#$+#)(#'#("'#&'#/"!&,)`),
    peg$decode(`%%$;$0#*;$&/,#; /#$+")("'#&'#." &"/=#$;$/&#0#*;$&&&#/'$8":Z" )("'#&'#`),
    peg$decode(';.." &"'),
    peg$decode(`%$;'.# &;(0)*;'.# &;(&/?#28""6879/0$;//'$8#:[# )(#'#("'#&'#`),
    peg$decode(`%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+")("'#&'#0=*%$;.0#*;.&/,#;2/#$+")("'#&'#&/#$+")("'#&'#/"!&,)`),
    peg$decode('4\\""5!7].# &;3'),
    peg$decode('4^""5!7_'),
    peg$decode('4`""5!7a'),
    peg$decode(';!.) &4b""5!7c'),
    peg$decode('%$;). &2F""6F7G. &2J""6J7K.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O/#0*;). &2F""6F7G. &2J""6J7K.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O&&&#/"!&,)'),
    peg$decode('%$;). &2F""6F7G.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O/#0*;). &2F""6F7G.} &2L""6L7M.q &2X""6X7Y.e &2P""6P7Q.Y &2H""6H7I.M &2@""6@7A.A &2d""6d7e.5 &2R""6R7S.) &2N""6N7O&&&#/"!&,)'),
    peg$decode(`2T""6T7U.ã &2V""6V7W.× &2f""6f7g.Ë &2h""6h7i.¿ &2:""6:7;.³ &2D""6D7E.§ &22""6273. &28""6879. &2j""6j7k. &;&.} &24""6475.q &2l""6l7m.e &2n""6n7o.Y &26""6677.M &2>""6>7?.A &2p""6p7q.5 &2r""6r7s.) &;'.# &;(`),
    peg$decode('%$;).ī &2F""6F7G.ğ &2J""6J7K.ē &2L""6L7M.ć &2X""6X7Y.û &2P""6P7Q.ï &2H""6H7I.ã &2@""6@7A.× &2d""6d7e.Ë &2R""6R7S.¿ &2N""6N7O.³ &2T""6T7U.§ &2V""6V7W. &2f""6f7g. &2h""6h7i. &28""6879.w &2j""6j7k.k &;&.e &24""6475.Y &2l""6l7m.M &2n""6n7o.A &26""6677.5 &2p""6p7q.) &2r""6r7s/Ĵ#0ı*;).ī &2F""6F7G.ğ &2J""6J7K.ē &2L""6L7M.ć &2X""6X7Y.û &2P""6P7Q.ï &2H""6H7I.ã &2@""6@7A.× &2d""6d7e.Ë &2R""6R7S.¿ &2N""6N7O.³ &2T""6T7U.§ &2V""6V7W. &2f""6f7g. &2h""6h7i. &28""6879.w &2j""6j7k.k &;&.e &24""6475.Y &2l""6l7m.M &2n""6n7o.A &26""6677.5 &2p""6p7q.) &2r""6r7s&&&#/"!&,)'),
    peg$decode(`%;//?#2P""6P7Q/0$;//'$8#:t# )(#'#("'#&'#`),
    peg$decode(`%;//?#24""6475/0$;//'$8#:u# )(#'#("'#&'#`),
    peg$decode(`%;//?#2>""6>7?/0$;//'$8#:v# )(#'#("'#&'#`),
    peg$decode(`%;//?#2T""6T7U/0$;//'$8#:w# )(#'#("'#&'#`),
    peg$decode(`%;//?#2V""6V7W/0$;//'$8#:x# )(#'#("'#&'#`),
    peg$decode(`%2h""6h7i/0#;//'$8":y" )("'#&'#`),
    peg$decode(`%;//6#2f""6f7g/'$8":z" )("'#&'#`),
    peg$decode(`%;//?#2D""6D7E/0$;//'$8#:{# )(#'#("'#&'#`),
    peg$decode(`%;//?#22""6273/0$;//'$8#:|# )(#'#("'#&'#`),
    peg$decode(`%;//?#28""6879/0$;//'$8#:}# )(#'#("'#&'#`),
    peg$decode(`%;//0#;&/'$8":~" )("'#&'#`),
    peg$decode(`%;&/0#;//'$8":~" )("'#&'#`),
    peg$decode(`%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#("'#&'#`),
    peg$decode('4""5!7.A &4""5!7.5 &4""5!7.) &;3.# &;.'),
    peg$decode(`%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#("'#&'#/"!&,)`),
    peg$decode(`%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/"!&,)/1$;&/($8$:$!!)($'#(#'#("'#&'#`),
    peg$decode(';..G &2L""6L7M.; &4""5!7./ &4""5!7.# &;3'),
    peg$decode(`%2j""6j7k/J#4""5!7.5 &4""5!7.) &4""5!7/#$+")("'#&'#`),
    peg$decode(`%;N/M#28""6879/>$;O." &"/0$;S/'$8$:$ )($'#(#'#("'#&'#`),
    peg$decode(`%;N/d#28""6879/U$;O." &"/G$;S/>$;_/5$;l." &"/'$8&:& )(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(`%3""5$7.) &3""5#7/' 8!:!! )`),
    peg$decode(`%;P/]#%28""6879/,#;R/#$+")("'#&'#." &"/6$2:""6:7;/'$8#:# )(#'#("'#&'#`),
    peg$decode("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"),
    peg$decode('2<""6<7=.q &2>""6>7?.e &2@""6@7A.Y &2B""6B7C.M &2D""6D7E.A &22""6273.5 &26""6677.) &24""6475'),
    peg$decode('%$;+._ &;-.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E0e*;+._ &;-.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E&/& 8!:! )'),
    peg$decode(`%;T/J#%28""6879/,#;^/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode("%;U.) &;\\.# &;X/& 8!:! )"),
    peg$decode(`%$%;V/2#2J""6J7K/#$+")("'#&'#0<*%;V/2#2J""6J7K/#$+")("'#&'#&/D#;W/;$2J""6J7K." &"/'$8#:# )(#'#("'#&'#`),
    peg$decode('$4""5!7/,#0)*4""5!7&&&#'),
    peg$decode(`%4$""5!7%/?#$4""5!70)*4""5!7&/#$+")("'#&'#`),
    peg$decode(`%2l""6l7m/?#;Y/6$2n""6n7o/'$8#:# )(#'#("'#&'#`),
    peg$decode(`%%;Z/³#28""6879/¤$;Z/$28""6879/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.ސ &%2""67/¤#;Z/$28""6879/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.۹ &%2""67/#;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.ٺ &%2""67/t#;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#.ؓ &%2""67/\\#;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+&)(&'#(%'#($'#(#'#("'#&'#.ׄ &%2""67/D#;Z/;$28""6879/,$;[/#$+$)($'#(#'#("'#&'#.֍ &%2""67/,#;[/#$+")("'#&'#.ծ &%2""67/,#;Z/#$+")("'#&'#.Տ &%;Z/#2""67/$;Z/$28""6879/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.Ӈ &%;Z/ª#%28""6879/,#;Z/#$+")("'#&'#." &"/$2""67/t$;Z/k$28""6879/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.а &%;Z/¹#%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/k$2""67/\\$;Z/S$28""6879/D$;Z/;$28""6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#.Ί &%;Z/È#%28""6879/,#;Z/#$+")("'#&'#." &"/¡$%28""6879/,#;Z/#$+")("'#&'#." &"/z$%28""6879/,#;Z/#$+")("'#&'#." &"/S$2""67/D$;Z/;$28""6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#.˕ &%;Z/×#%28""6879/,#;Z/#$+")("'#&'#." &"/°$%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/b$%28""6879/,#;Z/#$+")("'#&'#." &"/;$2""67/,$;[/#$+')(''#(&'#(%'#($'#(#'#("'#&'#.ȑ &%;Z/þ#%28""6879/,#;Z/#$+")("'#&'#." &"/×$%28""6879/,#;Z/#$+")("'#&'#." &"/°$%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/b$%28""6879/,#;Z/#$+")("'#&'#." &"/;$2""67/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#.Ħ &%;Z/Ĝ#%28""6879/,#;Z/#$+")("'#&'#." &"/õ$%28""6879/,#;Z/#$+")("'#&'#." &"/Î$%28""6879/,#;Z/#$+")("'#&'#." &"/§$%28""6879/,#;Z/#$+")("'#&'#." &"/$%28""6879/,#;Z/#$+")("'#&'#." &"/Y$%28""6879/,#;Z/#$+")("'#&'#." &"/2$2""67/#$+()(('#(''#(&'#(%'#($'#(#'#("'#&'#/& 8!: ! )`),
    peg$decode(`%;#/M#;#." &"/?$;#." &"/1$;#." &"/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%;Z/;#28""6879/,$;Z/#$+#)(#'#("'#&'#.# &;\\`),
    peg$decode(`%;]/o#2J""6J7K/\`$;]/W$2J""6J7K/H$;]/?$2J""6J7K/0$;]/'$8':¡' )(''#(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(`%2¢""6¢7£/2#4¤""5!7¥/#$+")("'#&'#. &%2¦""6¦7§/;#4¨""5!7©/,$;!/#$+#)(#'#("'#&'#.j &%2ª""6ª7«/5#;!/,$;!/#$+#)(#'#("'#&'#.B &%4¬""5!7­/,#;!/#$+")("'#&'#.# &;!`),
    peg$decode(`%%;!." &"/[#;!." &"/M$;!." &"/?$;!." &"/1$;!." &"/#$+%)(%'#($'#(#'#("'#&'#/' 8!:®!! )`),
    peg$decode(`$%22""6273/,#;\`/#$+")("'#&'#0<*%22""6273/,#;\`/#$+")("'#&'#&`),
    peg$decode(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"),
    peg$decode(`%3¯""5*7°/a#3±""5#7².G &3³""5#7´.; &3µ""5$7¶./ &3·""5#7¸.# &;6/($8":¹"! )("'#&'#`),
    peg$decode(`%3º""5%7»/I#3¼""5%7½./ &3¾""5"7¿.# &;6/($8":À"! )("'#&'#`),
    peg$decode(`%3Á""5'7Â/1#;/($8":Ã"! )("'#&'#`),
    peg$decode(`%3Ä""5$7Å/1#;ð/($8":Æ"! )("'#&'#`),
    peg$decode(`%3Ç""5&7È/1#;T/($8":É"! )("'#&'#`),
    peg$decode(`%3Ê""5"7Ë/N#%2>""6>7?/,#;6/#$+")("'#&'#." &"/'$8":Ì" )("'#&'#`),
    peg$decode(`%;h/P#%2>""6>7?/,#;i/#$+")("'#&'#." &"/)$8":Í""! )("'#&'#`),
    peg$decode('%$;j/&#0#*;j&&&#/"!&,)'),
    peg$decode('%$;j/&#0#*;j&&&#/"!&,)'),
    peg$decode(";k.) &;+.# &;-"),
    peg$decode('2l""6l7m.e &2n""6n7o.Y &24""6475.M &28""6879.A &2<""6<7=.5 &2@""6@7A.) &2B""6B7C'),
    peg$decode(`%26""6677/n#;m/e$$%2<""6<7=/,#;m/#$+")("'#&'#0<*%2<""6<7=/,#;m/#$+")("'#&'#&/#$+#)(#'#("'#&'#`),
    peg$decode(`%;n/A#2>""6>7?/2$;o/)$8#:Î#"" )(#'#("'#&'#`),
    peg$decode("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"),
    peg$decode("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"),
    peg$decode('2l""6l7m.e &2n""6n7o.Y &24""6475.M &26""6677.A &28""6879.5 &2@""6@7A.) &2B""6B7C'),
    peg$decode(";.# &;r"),
    peg$decode(`%;/G#;'/>$;s/5$;'/,$;/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode(";M.# &;t"),
    peg$decode(`%;/E#28""6879/6$;u.# &;x/'$8#:Ï# )(#'#("'#&'#`),
    peg$decode(`%;v.# &;w/J#%26""6677/,#;/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode(`%2Ð""6Ð7Ñ/:#;/1$;w." &"/#$+#)(#'#("'#&'#`),
    peg$decode(`%24""6475/,#;{/#$+")("'#&'#`),
    peg$decode(`%;z/3#$;y0#*;y&/#$+")("'#&'#`),
    peg$decode(";*.) &;+.# &;-"),
    peg$decode(';+. &;-. &22""6273.} &26""6677.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'),
    peg$decode(`%;|/e#$%24""6475/,#;|/#$+")("'#&'#0<*%24""6475/,#;|/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%$;~0#*;~&/e#$%22""6273/,#;}/#$+")("'#&'#0<*%22""6273/,#;}/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode("$;~0#*;~&"),
    peg$decode(';+.w &;-.q &28""6879.e &2:""6:7;.Y &2<""6<7=.M &2>""6>7?.A &2@""6@7A.5 &2B""6B7C.) &2D""6D7E'),
    peg$decode(`%%;"/#$;".G &;!.A &2@""6@7A.5 &2F""6F7G.) &2J""6J7K0M*;".G &;!.A &2@""6@7A.5 &2F""6F7G.) &2J""6J7K&/#$+")("'#&'#/& 8!:Ò! )`),
    peg$decode(";.# &;"),
    peg$decode(`%%;O/2#2:""6:7;/#$+")("'#&'#." &"/,#;S/#$+")("'#&'#." &"`),
    peg$decode('$;+. &;-.} &2B""6B7C.q &2D""6D7E.e &22""6273.Y &28""6879.M &2:""6:7;.A &2<""6<7=.5 &2>""6>7?.) &2@""6@7A/#0*;+. &;-.} &2B""6B7C.q &2D""6D7E.e &22""6273.Y &28""6879.M &2:""6:7;.A &2<""6<7=.5 &2>""6>7?.) &2@""6@7A&&&#'),
    peg$decode("$;y0#*;y&"),
    peg$decode(`%3""5#7Ó/q#24""6475/b$$;!/&#0#*;!&&&#/L$2J""6J7K/=$$;!/&#0#*;!&&&#/'$8%:Ô% )(%'#($'#(#'#("'#&'#`),
    peg$decode('2Õ""6Õ7Ö'),
    peg$decode('2×""6×7Ø'),
    peg$decode('2Ù""6Ù7Ú'),
    peg$decode('2Û""6Û7Ü'),
    peg$decode('2Ý""6Ý7Þ'),
    peg$decode('2ß""6ß7à'),
    peg$decode('2á""6á7â'),
    peg$decode('2ã""6ã7ä'),
    peg$decode('2å""6å7æ'),
    peg$decode('2ç""6ç7è'),
    peg$decode('2é""6é7ê'),
    peg$decode("%;.Y &;.S &;.M &;.G &;.A &;.; &;.5 &;./ &;.) &;.# &;6/& 8!:ë! )"),
    peg$decode(`%;/G#;'/>$;/5$;'/,$;/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode("%;/' 8!:ì!! )"),
    peg$decode(`%;!/5#;!/,$;!/#$+#)(#'#("'#&'#`),
    peg$decode("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:í! )"),
    peg$decode(`%;¶/Y#$%;A/,#;¶/#$+")("'#&'#06*%;A/,#;¶/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;9/N#%2:""6:7;/,#;9/#$+")("'#&'#." &"/'$8":î" )("'#&'#`),
    peg$decode(`%;:.c &%;/Y#$%;A/,#;/#$+")("'#&'#06*%;A/,#;/#$+")("'#&'#&/#$+")("'#&'#/& 8!:ï! )`),
    peg$decode(`%;L.# &;/]#$%;B/,#;/#$+")("'#&'#06*%;B/,#;/#$+")("'#&'#&/'$8":ð" )("'#&'#`),
    peg$decode(`%;." &"/>#;@/5$;M/,$;?/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%%;6/Y#$%;./,#;6/#$+")("'#&'#06*%;./,#;6/#$+")("'#&'#&/#$+")("'#&'#.# &;H/' 8!:ñ!! )`),
    peg$decode(";.) &;.# &; "),
    peg$decode(`%3ò""5!7ó/:#;</1$;/($8#:ô#! )(#'#("'#&'#`),
    peg$decode(`%3õ""5'7ö/:#;</1$;/($8#:÷#! )(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ø!! )"),
    peg$decode(`%2ù""6ù7ú/o#%2J""6J7K/M#;!." &"/?$;!." &"/1$;!." &"/#$+$)($'#(#'#("'#&'#." &"/'$8":û" )("'#&'#`),
    peg$decode(`%;6/J#%;</,#;¡/#$+")("'#&'#." &"/)$8":ü""! )("'#&'#`),
    peg$decode(";6.) &;T.# &;H"),
    peg$decode(`%;£/Y#$%;B/,#;¤/#$+")("'#&'#06*%;B/,#;¤/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%3ý""5&7þ.G &3ÿ""5'7Ā.; &3ā""5$7Ă./ &3ă""5%7Ą.# &;6/& 8!:ą! )`),
    peg$decode(";¥.# &; "),
    peg$decode(`%3Ć""5(7ć/M#;</D$3Ĉ""5(7ĉ./ &3Ċ""5(7ċ.# &;6/#$+#)(#'#("'#&'#`),
    peg$decode(`%;6/Y#$%;A/,#;6/#$+")("'#&'#06*%;A/,#;6/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:Č!! )"),
    peg$decode("%;©/& 8!:č! )"),
    peg$decode(`%;ª/k#;;/b$;¯/Y$$%;B/,#;°/#$+")("'#&'#06*%;B/,#;°/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(";«.# &;¬"),
    peg$decode('3Ď""5$7ď.S &3Đ""5%7đ.G &3Ē""5%7ē.; &3Ĕ""5%7ĕ./ &3Ė""5+7ė.# &;­'),
    peg$decode(`3Ę""5'7ę./ &3Ě""5)7ě.# &;­`),
    peg$decode(";6.# &;®"),
    peg$decode(`%3Ĝ""5"7ĝ/,#;6/#$+")("'#&'#`),
    peg$decode(";­.# &;6"),
    peg$decode(`%;6/5#;</,$;±/#$+#)(#'#("'#&'#`),
    peg$decode(";6.# &;H"),
    peg$decode(`%;³/5#;./,$;/#$+#)(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:Ğ!! )"),
    peg$decode("%;/' 8!:ğ!! )"),
    peg$decode(`%;¶/^#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/($8":Ġ"!!)("'#&'#`),
    peg$decode(`%%;7/e#$%2J""6J7K/,#;7/#$+")("'#&'#0<*%2J""6J7K/,#;7/#$+")("'#&'#&/#$+")("'#&'#/"!&,)`),
    peg$decode(`%;L.# &;/]#$%;B/,#;¸/#$+")("'#&'#06*%;B/,#;¸/#$+")("'#&'#&/'$8":ġ" )("'#&'#`),
    peg$decode(";¹.# &; "),
    peg$decode(`%3Ģ""5#7ģ/:#;</1$;6/($8#:Ĥ#! )(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ĥ!! )"),
    peg$decode("%;/' 8!:Ħ!! )"),
    peg$decode(`%$;0#*;&/x#;@/o$;M/f$;?/]$$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/'$8%:ħ% )(%'#($'#(#'#("'#&'#`),
    peg$decode(";¾"),
    peg$decode(`%3Ĩ""5&7ĩ/k#;./b$;Á/Y$$%;A/,#;Á/#$+")("'#&'#06*%;A/,#;Á/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#.# &;¿`),
    peg$decode(`%;6/k#;./b$;À/Y$$%;A/,#;À/#$+")("'#&'#06*%;A/,#;À/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%;6/;#;</2$;6.# &;H/#$+#)(#'#("'#&'#`),
    peg$decode(";Â.G &;Ä.A &;Æ.; &;È.5 &;É./ &;Ê.) &;Ë.# &;À"),
    peg$decode(`%3Ī""5%7ī/5#;</,$;Ã/#$+#)(#'#("'#&'#`),
    peg$decode("%;I/' 8!:Ĭ!! )"),
    peg$decode(`%3ĭ""5&7Į/#;</$;D/$;Å/|$$%$;'/&#0#*;'&&&#/,#;Å/#$+")("'#&'#0C*%$;'/&#0#*;'&&&#/,#;Å/#$+")("'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(";t.# &;w"),
    peg$decode(`%3į""5%7İ/5#;</,$;Ç/#$+#)(#'#("'#&'#`),
    peg$decode("%;I/' 8!:ı!! )"),
    peg$decode(`%3Ĳ""5&7ĳ/:#;</1$;I/($8#:Ĵ#! )(#'#("'#&'#`),
    peg$decode(`%3ĵ""5%7Ķ/]#;</T$%3ķ""5$7ĸ/& 8!:Ĺ! ).4 &%3ĺ""5%7Ļ/& 8!:ļ! )/#$+#)(#'#("'#&'#`),
    peg$decode(`%3Ľ""5)7ľ/R#;</I$3Ŀ""5#7ŀ./ &3Ł""5(7ł.# &;6/($8#:Ń#! )(#'#("'#&'#`),
    peg$decode(`%3ń""5#7Ņ/#;</$;D/$%;Ì/e#$%2D""6D7E/,#;Ì/#$+")("'#&'#0<*%2D""6D7E/,#;Ì/#$+")("'#&'#&/#$+")("'#&'#/,$;E/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode(`%3ņ""5(7Ň./ &3ň""5$7ŉ.# &;6/' 8!:Ŋ!! )`),
    peg$decode(`%;6/Y#$%;A/,#;6/#$+")("'#&'#06*%;A/,#;6/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;Ï/G#;./>$;Ï/5$;./,$;/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ŋ!! )"),
    peg$decode(`%;Ñ/]#$%;A/,#;Ñ/#$+")("'#&'#06*%;A/,#;Ñ/#$+")("'#&'#&/'$8":Ō" )("'#&'#`),
    peg$decode(`%;/]#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/'$8":ō" )("'#&'#`),
    peg$decode(`%;L.O &;.I &%;@." &"/:#;t/1$;?." &"/#$+#)(#'#("'#&'#/]#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/'$8":Ŏ" )("'#&'#`),
    peg$decode(`%;Ô/]#$%;B/,#;Õ/#$+")("'#&'#06*%;B/,#;Õ/#$+")("'#&'#&/'$8":ŏ" )("'#&'#`),
    peg$decode("%;/& 8!:Ő! )"),
    peg$decode(`%3ő""5(7Œ/:#;</1$;6/($8#:œ#! )(#'#("'#&'#.g &%3Ŕ""5&7ŕ/:#;</1$;6/($8#:Ŗ#! )(#'#("'#&'#.: &%3ŗ""5*7Ř/& 8!:ř! ).# &; `),
    peg$decode(`%%;6/k#$%;A/2#;6/)$8":Ś""$ )("'#&'#0<*%;A/2#;6/)$8":Ś""$ )("'#&'#&/)$8":ś""! )("'#&'#." &"/' 8!:Ŝ!! )`),
    peg$decode(`%;Ø/Y#$%;A/,#;Ø/#$+")("'#&'#06*%;A/,#;Ø/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;/Y#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode("%$;!/&#0#*;!&&&#/' 8!:ŝ!! )"),
    peg$decode(`%;Û/Y#$%;B/,#;Ü/#$+")("'#&'#06*%;B/,#;Ü/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%3Ş""5&7ş.; &3Š""5'7š./ &3Ţ""5*7ţ.# &;6/& 8!:Ť! )`),
    peg$decode(`%3ť""5&7Ŧ/:#;</1$;Ý/($8#:ŧ#! )(#'#("'#&'#.} &%3õ""5'7ö/:#;</1$;/($8#:Ũ#! )(#'#("'#&'#.P &%3ũ""5+7Ū/:#;</1$;/($8#:ū#! )(#'#("'#&'#.# &; `),
    peg$decode(`3Ŭ""5+7ŭ.k &3Ů""5)7ů._ &3Ű""5(7ű.S &3Ų""5'7ų.G &3Ŵ""5&7ŵ.; &3Ŷ""5*7ŷ./ &3Ÿ""5)7Ź.# &;6`),
    peg$decode(';1." &"'),
    peg$decode(`%%;6/k#$%;A/2#;6/)$8":Ś""$ )("'#&'#0<*%;A/2#;6/)$8":Ś""$ )("'#&'#&/)$8":ś""! )("'#&'#." &"/' 8!:ź!! )`),
    peg$decode(`%;L.# &;/]#$%;B/,#;á/#$+")("'#&'#06*%;B/,#;á/#$+")("'#&'#&/'$8":Ż" )("'#&'#`),
    peg$decode(";¹.# &; "),
    peg$decode(`%;ã/Y#$%;A/,#;ã/#$+")("'#&'#06*%;A/,#;ã/#$+")("'#&'#&/#$+")("'#&'#`),
    peg$decode(`%;ê/k#;./b$;í/Y$$%;B/,#;ä/#$+")("'#&'#06*%;B/,#;ä/#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(";å.; &;æ.5 &;ç./ &;è.) &;é.# &; "),
    peg$decode(`%3ż""5#7Ž/:#;</1$;ð/($8#:ž#! )(#'#("'#&'#`),
    peg$decode(`%3ſ""5%7ƀ/:#;</1$;T/($8#:Ɓ#! )(#'#("'#&'#`),
    peg$decode(`%3Ƃ""5(7ƃ/F#;</=$;\\.) &;Y.# &;X/($8#:Ƅ#! )(#'#("'#&'#`),
    peg$decode(`%3ƅ""5&7Ɔ/:#;</1$;6/($8#:Ƈ#! )(#'#("'#&'#`),
    peg$decode(`%3ƈ""5%7Ɖ/A#;</8$$;!0#*;!&/($8#:Ɗ#! )(#'#("'#&'#`),
    peg$decode(`%;ë/G#;;/>$;6/5$;;/,$;ì/#$+%)(%'#($'#(#'#("'#&'#`),
    peg$decode(`%3""5#7Ó.# &;6/' 8!:Ƌ!! )`),
    peg$decode(`%3±""5#7ƌ.G &3³""5#7ƍ.; &3·""5#7Ǝ./ &3µ""5$7Ə.# &;6/' 8!:Ɛ!! )`),
    peg$decode(`%;î/D#%;C/,#;ï/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode("%;U.) &;\\.# &;X/& 8!:Ƒ! )"),
    peg$decode(`%%;!." &"/[#;!." &"/M$;!." &"/?$;!." &"/1$;!." &"/#$+%)(%'#($'#(#'#("'#&'#/' 8!:ƒ!! )`),
    peg$decode(`%%;!/?#;!." &"/1$;!." &"/#$+#)(#'#("'#&'#/' 8!:Ɠ!! )`),
    peg$decode(";¾"),
    peg$decode(`%;/^#$%;B/,#;ó/#$+")("'#&'#06*%;B/,#;ó/#$+")("'#&'#&/($8":Ɣ"!!)("'#&'#`),
    peg$decode(";ô.# &; "),
    peg$decode(`%2ƕ""6ƕ7Ɩ/L#;</C$2Ɨ""6Ɨ7Ƙ.) &2ƙ""6ƙ7ƚ/($8#:ƛ#! )(#'#("'#&'#`),
    peg$decode(`%;/^#$%;B/,#; /#$+")("'#&'#06*%;B/,#; /#$+")("'#&'#&/($8":Ɯ"!!)("'#&'#`),
    peg$decode(`%;6/5#;0/,$;÷/#$+#)(#'#("'#&'#`),
    peg$decode("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"),
    peg$decode("$;%0#*;%&"),
    peg$decode(`%;ú/;#28""6879/,$;û/#$+#)(#'#("'#&'#`),
    peg$decode(`%3Ɲ""5%7ƞ.) &3Ɵ""5$7Ơ/' 8!:ơ!! )`),
    peg$decode(`%;ü/J#%28""6879/,#;^/#$+")("'#&'#." &"/#$+")("'#&'#`),
    peg$decode("%;\\.) &;X.# &;/' 8!:Ƣ!! )"),
    peg$decode(';".S &;!.M &2F""6F7G.A &2J""6J7K.5 &2H""6H7I.) &2N""6N7O'),
    peg$decode('2L""6L7M. &2B""6B7C. &2<""6<7=.} &2R""6R7S.q &2T""6T7U.e &2V""6V7W.Y &2P""6P7Q.M &2@""6@7A.A &2D""6D7E.5 &22""6273.) &2>""6>7?'),
    peg$decode(`%;Ā/b#28""6879/S$;û/J$%2ƣ""6ƣ7Ƥ/,#;ì/#$+")("'#&'#." &"/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%3ƥ""5%7Ʀ.) &3Ƨ""5$7ƨ/' 8!:ơ!! )`),
    peg$decode(`%3±""5#7².6 &3³""5#7´.* &$;+0#*;+&/' 8!:Ʃ!! )`),
    peg$decode(`%;Ą/#2F""6F7G/x$;ă/o$2F""6F7G/\`$;ă/W$2F""6F7G/H$;ă/?$2F""6F7G/0$;ą/'$8):ƪ) )()'#(('#(''#(&'#(%'#($'#(#'#("'#&'#`),
    peg$decode(`%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#("'#&'#`),
    peg$decode(`%;ă/,#;ă/#$+")("'#&'#`),
    peg$decode(`%;ă/5#;ă/,$;ă/#$+#)(#'#("'#&'#`),
    peg$decode(`%;q/T#$;m0#*;m&/D$%; /,#;ø/#$+")("'#&'#." &"/#$+#)(#'#("'#&'#`),
    peg$decode(`%2ƫ""6ƫ7Ƭ.) &2ƭ""6ƭ7Ʈ/w#;0/n$;Ĉ/e$$%;B/2#;ĉ.# &; /#$+")("'#&'#0<*%;B/2#;ĉ.# &; /#$+")("'#&'#&/#$+$)($'#(#'#("'#&'#`),
    peg$decode(";.# &;L"),
    peg$decode(`%2Ư""6Ư7ư/5#;</,$;Ċ/#$+#)(#'#("'#&'#`),
    peg$decode(`%;D/S#;,/J$2:""6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#("'#&'#`)
  ];
  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected = [];
  let peg$silentFails = 0;
  let peg$result;
  if (options.startRule !== void 0) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
    }
    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }
  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }
  function location2() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }
  function peg$literalExpectation(text1, ignoreCase) {
    return { type: "literal", text: text1, ignoreCase };
  }
  function peg$classExpectation(parts2, inverted, ignoreCase) {
    return { type: "class", parts: parts2, inverted, ignoreCase };
  }
  function peg$endExpectation() {
    return { type: "end" };
  }
  function peg$computePosDetails(pos) {
    let details = peg$posDetailsCache[pos];
    let p2;
    if (details) {
      return details;
    } else {
      p2 = pos - 1;
      while (!peg$posDetailsCache[p2]) {
        p2--;
      }
      details = peg$posDetailsCache[p2];
      details = {
        line: details.line,
        column: details.column
      };
      while (p2 < pos) {
        if (input.charCodeAt(p2) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p2++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos) {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }
  function peg$fail(expected1) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected1);
  }
  function peg$buildStructuredError(expected1, found, location1) {
    return new SyntaxError2(SyntaxError2.buildMessage(expected1, found), expected1, found, location1);
  }
  function peg$decode(s2) {
    return s2.split("").map((ch) => ch.charCodeAt(0) - 32);
  }
  function peg$parseRule(index) {
    const bc = peg$bytecode[index];
    let ip = 0;
    const ips = [];
    let end = bc.length;
    const ends = [];
    const stack = [];
    let params;
    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;
          case 1:
            stack.push(void 0);
            ip++;
            break;
          case 2:
            stack.push(null);
            ip++;
            break;
          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;
          case 4:
            stack.push([]);
            ip++;
            break;
          case 5:
            stack.push(peg$currPos);
            ip++;
            break;
          case 6:
            stack.pop();
            ip++;
            break;
          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;
          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;
          case 9:
            stack.splice(-2, 1);
            ip++;
            break;
          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;
          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;
          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;
          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);
              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }
            break;
          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }
            break;
          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }
            break;
          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }
            break;
          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }
            break;
          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;
          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += peg$consts[bc[ip + 1]].length;
            ip += 2;
            break;
          case 23:
            stack.push(peg$FAILED);
            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]]);
            }
            ip += 2;
            break;
          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;
          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;
          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]).map(function(p2) {
              return stack[stack.length - 1 - p2];
            });
            stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
            ip += 4 + bc[ip + 3];
            break;
          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;
          case 28:
            peg$silentFails++;
            ip++;
            break;
          case 29:
            peg$silentFails--;
            ip++;
            break;
          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }
      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }
    return stack[0];
  }
  options.data = {};
  function list(head, tail) {
    return [head].concat(tail);
  }
  peg$result = peg$parseRule(peg$startRuleIndex);
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}
const parse$1 = peg$parse;
var Grammar;
(function(Grammar2) {
  function parse2(input, startRule) {
    const options = { startRule };
    try {
      parse$1(input, options);
    } catch (e2) {
      options.data = -1;
    }
    return options.data;
  }
  Grammar2.parse = parse2;
  function nameAddrHeaderParse(nameAddrHeader) {
    const parsedNameAddrHeader = Grammar2.parse(nameAddrHeader, "Name_Addr_Header");
    return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : void 0;
  }
  Grammar2.nameAddrHeaderParse = nameAddrHeaderParse;
  function URIParse(uri) {
    const parsedUri = Grammar2.parse(uri, "SIP_URI");
    return parsedUri !== -1 ? parsedUri : void 0;
  }
  Grammar2.URIParse = URIParse;
})(Grammar || (Grammar = {}));
var C;
(function(C2) {
  C2.ACK = "ACK";
  C2.BYE = "BYE";
  C2.CANCEL = "CANCEL";
  C2.INFO = "INFO";
  C2.INVITE = "INVITE";
  C2.MESSAGE = "MESSAGE";
  C2.NOTIFY = "NOTIFY";
  C2.OPTIONS = "OPTIONS";
  C2.REGISTER = "REGISTER";
  C2.UPDATE = "UPDATE";
  C2.SUBSCRIBE = "SUBSCRIBE";
  C2.PUBLISH = "PUBLISH";
  C2.REFER = "REFER";
  C2.PRACK = "PRACK";
})(C || (C = {}));
const REASON_PHRASE = {
  100: "Trying",
  180: "Ringing",
  181: "Call Is Being Forwarded",
  182: "Queued",
  183: "Session Progress",
  199: "Early Dialog Terminated",
  200: "OK",
  202: "Accepted",
  204: "No Notification",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Moved Temporarily",
  305: "Use Proxy",
  380: "Alternative Service",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  410: "Gone",
  412: "Conditional Request Failed",
  413: "Request Entity Too Large",
  414: "Request-URI Too Long",
  415: "Unsupported Media Type",
  416: "Unsupported URI Scheme",
  417: "Unknown Resource-Priority",
  420: "Bad Extension",
  421: "Extension Required",
  422: "Session Interval Too Small",
  423: "Interval Too Brief",
  428: "Use Identity Header",
  429: "Provide Referrer Identity",
  430: "Flow Failed",
  433: "Anonymity Disallowed",
  436: "Bad Identity-Info",
  437: "Unsupported Certificate",
  438: "Invalid Identity Header",
  439: "First Hop Lacks Outbound Support",
  440: "Max-Breadth Exceeded",
  469: "Bad Info Package",
  470: "Consent Needed",
  478: "Unresolvable Destination",
  480: "Temporarily Unavailable",
  481: "Call/Transaction Does Not Exist",
  482: "Loop Detected",
  483: "Too Many Hops",
  484: "Address Incomplete",
  485: "Ambiguous",
  486: "Busy Here",
  487: "Request Terminated",
  488: "Not Acceptable Here",
  489: "Bad Event",
  491: "Request Pending",
  493: "Undecipherable",
  494: "Security Agreement Required",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Server Time-out",
  505: "Version Not Supported",
  513: "Message Too Large",
  580: "Precondition Failure",
  600: "Busy Everywhere",
  603: "Decline",
  604: "Does Not Exist Anywhere",
  606: "Not Acceptable"
};
function createRandomToken(size, base = 32) {
  let token = "";
  for (let i2 = 0; i2 < size; i2++) {
    const r2 = Math.floor(Math.random() * base);
    token += r2.toString(base);
  }
  return token;
}
function getReasonPhrase(code) {
  return REASON_PHRASE[code] || "";
}
function newTag() {
  return createRandomToken(10);
}
function headerize(str) {
  const exceptions = {
    "Call-Id": "Call-ID",
    Cseq: "CSeq",
    "Min-Se": "Min-SE",
    Rack: "RAck",
    Rseq: "RSeq",
    "Www-Authenticate": "WWW-Authenticate"
  };
  const name2 = str.toLowerCase().replace(/_/g, "-").split("-");
  const parts2 = name2.length;
  let hname = "";
  for (let part = 0; part < parts2; part++) {
    if (part !== 0) {
      hname += "-";
    }
    hname += name2[part].charAt(0).toUpperCase() + name2[part].substring(1);
  }
  if (exceptions[hname]) {
    hname = exceptions[hname];
  }
  return hname;
}
function utf8Length$1(str) {
  return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
}
class IncomingMessage2 {
  constructor() {
    this.headers = {};
  }
  /**
   * Insert a header of the given name and value into the last position of the
   * header array.
   * @param name - header name
   * @param value - header value
   */
  addHeader(name2, value2) {
    const header = { raw: value2 };
    name2 = headerize(name2);
    if (this.headers[name2]) {
      this.headers[name2].push(header);
    } else {
      this.headers[name2] = [header];
    }
  }
  /**
   * Get the value of the given header name at the given position.
   * @param name - header name
   * @returns Returns the specified header, undefined if header doesn't exist.
   */
  getHeader(name2) {
    const header = this.headers[headerize(name2)];
    if (header) {
      if (header[0]) {
        return header[0].raw;
      }
    } else {
      return;
    }
  }
  /**
   * Get the header/s of the given name.
   * @param name - header name
   * @returns Array - with all the headers of the specified name.
   */
  getHeaders(name2) {
    const header = this.headers[headerize(name2)];
    const result = [];
    if (!header) {
      return [];
    }
    for (const headerPart of header) {
      result.push(headerPart.raw);
    }
    return result;
  }
  /**
   * Verify the existence of the given header.
   * @param name - header name
   * @returns true if header with given name exists, false otherwise
   */
  hasHeader(name2) {
    return !!this.headers[headerize(name2)];
  }
  /**
   * Parse the given header on the given index.
   * @param name - header name
   * @param idx - header index
   * @returns Parsed header object, undefined if the
   *   header is not present or in case of a parsing error.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseHeader(name2, idx = 0) {
    name2 = headerize(name2);
    if (!this.headers[name2]) {
      return;
    } else if (idx >= this.headers[name2].length) {
      return;
    }
    const header = this.headers[name2][idx];
    const value2 = header.raw;
    if (header.parsed) {
      return header.parsed;
    }
    const parsed = Grammar.parse(value2, name2.replace(/-/g, "_"));
    if (parsed === -1) {
      this.headers[name2].splice(idx, 1);
      return;
    } else {
      header.parsed = parsed;
      return parsed;
    }
  }
  /**
   * Message Header attribute selector. Alias of parseHeader.
   * @param name - header name
   * @param idx - header index
   * @returns Parsed header object, undefined if the
   *   header is not present or in case of a parsing error.
   *
   * @example
   * message.s('via',3).port
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  s(name2, idx = 0) {
    return this.parseHeader(name2, idx);
  }
  /**
   * Replace the value of the given header by the value.
   * @param name - header name
   * @param value - header value
   */
  setHeader(name2, value2) {
    this.headers[headerize(name2)] = [{ raw: value2 }];
  }
  toString() {
    return this.data;
  }
}
class IncomingRequestMessage2 extends IncomingMessage2 {
  constructor() {
    super();
  }
}
class IncomingResponseMessage2 extends IncomingMessage2 {
  constructor() {
    super();
  }
}
class OutgoingRequestMessage2 {
  constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {
    this.headers = {};
    this.extraHeaders = [];
    this.options = OutgoingRequestMessage2.getDefaultOptions();
    if (options) {
      this.options = Object.assign(Object.assign({}, this.options), options);
      if (this.options.optionTags && this.options.optionTags.length) {
        this.options.optionTags = this.options.optionTags.slice();
      }
      if (this.options.routeSet && this.options.routeSet.length) {
        this.options.routeSet = this.options.routeSet.slice();
      }
    }
    if (extraHeaders && extraHeaders.length) {
      this.extraHeaders = extraHeaders.slice();
    }
    if (body) {
      this.body = {
        body: body.content,
        contentType: body.contentType
      };
    }
    this.method = method;
    this.ruri = ruri.clone();
    this.fromURI = fromURI.clone();
    this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();
    this.from = OutgoingRequestMessage2.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);
    this.toURI = toURI.clone();
    this.toTag = this.options.toTag;
    this.to = OutgoingRequestMessage2.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);
    this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15);
    this.cseq = this.options.cseq;
    this.setHeader("route", this.options.routeSet);
    this.setHeader("via", "");
    this.setHeader("to", this.to.toString());
    this.setHeader("from", this.from.toString());
    this.setHeader("cseq", this.cseq + " " + this.method);
    this.setHeader("call-id", this.callId);
    this.setHeader("max-forwards", "70");
  }
  /** Get a copy of the default options. */
  static getDefaultOptions() {
    return {
      callId: "",
      callIdPrefix: "",
      cseq: 1,
      toDisplayName: "",
      toTag: "",
      fromDisplayName: "",
      fromTag: "",
      forceRport: false,
      hackViaTcp: false,
      optionTags: ["outbound"],
      routeSet: [],
      userAgentString: "sip.js",
      viaHost: ""
    };
  }
  static makeNameAddrHeader(uri, displayName, tag) {
    const parameters = {};
    if (tag) {
      parameters.tag = tag;
    }
    return new NameAddrHeader2(uri, displayName, parameters);
  }
  /**
   * Get the value of the given header name at the given position.
   * @param name - header name
   * @returns Returns the specified header, undefined if header doesn't exist.
   */
  getHeader(name2) {
    const header = this.headers[headerize(name2)];
    if (header) {
      if (header[0]) {
        return header[0];
      }
    } else {
      const regexp = new RegExp("^\\s*" + name2 + "\\s*:", "i");
      for (const exHeader of this.extraHeaders) {
        if (regexp.test(exHeader)) {
          return exHeader.substring(exHeader.indexOf(":") + 1).trim();
        }
      }
    }
    return;
  }
  /**
   * Get the header/s of the given name.
   * @param name - header name
   * @returns Array with all the headers of the specified name.
   */
  getHeaders(name2) {
    const result = [];
    const headerArray = this.headers[headerize(name2)];
    if (headerArray) {
      for (const headerPart of headerArray) {
        result.push(headerPart);
      }
    } else {
      const regexp = new RegExp("^\\s*" + name2 + "\\s*:", "i");
      for (const exHeader of this.extraHeaders) {
        if (regexp.test(exHeader)) {
          result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
        }
      }
    }
    return result;
  }
  /**
   * Verify the existence of the given header.
   * @param name - header name
   * @returns true if header with given name exists, false otherwise
   */
  hasHeader(name2) {
    if (this.headers[headerize(name2)]) {
      return true;
    } else {
      const regexp = new RegExp("^\\s*" + name2 + "\\s*:", "i");
      for (const extraHeader of this.extraHeaders) {
        if (regexp.test(extraHeader)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Replace the the given header by the given value.
   * @param name - header name
   * @param value - header value
   */
  setHeader(name2, value2) {
    this.headers[headerize(name2)] = value2 instanceof Array ? value2 : [value2];
  }
  /**
   * The Via header field indicates the transport used for the transaction
   * and identifies the location where the response is to be sent.  A Via
   * header field value is added only after the transport that will be
   * used to reach the next hop has been selected (which may involve the
   * usage of the procedures in [4]).
   *
   * When the UAC creates a request, it MUST insert a Via into that
   * request.  The protocol name and protocol version in the header field
   * MUST be SIP and 2.0, respectively.  The Via header field value MUST
   * contain a branch parameter.  This parameter is used to identify the
   * transaction created by that request.  This parameter is used by both
   * the client and the server.
   * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
   * @param branchParameter - The branch parameter.
   * @param transport - The sent protocol transport.
   */
  setViaHeader(branch, transport) {
    if (this.options.hackViaTcp) {
      transport = "TCP";
    }
    let via = "SIP/2.0/" + transport;
    via += " " + this.options.viaHost + ";branch=" + branch;
    if (this.options.forceRport) {
      via += ";rport";
    }
    this.setHeader("via", via);
    this.branch = branch;
  }
  toString() {
    let msg = "";
    msg += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";
    for (const header in this.headers) {
      if (this.headers[header]) {
        for (const headerPart of this.headers[header]) {
          msg += header + ": " + headerPart + "\r\n";
        }
      }
    }
    for (const header of this.extraHeaders) {
      msg += header.trim() + "\r\n";
    }
    msg += "Supported: " + this.options.optionTags.join(", ") + "\r\n";
    msg += "User-Agent: " + this.options.userAgentString + "\r\n";
    if (this.body) {
      if (typeof this.body === "string") {
        msg += "Content-Length: " + utf8Length$1(this.body) + "\r\n\r\n";
        msg += this.body;
      } else {
        if (this.body.body && this.body.contentType) {
          msg += "Content-Type: " + this.body.contentType + "\r\n";
          msg += "Content-Length: " + utf8Length$1(this.body.body) + "\r\n\r\n";
          msg += this.body.body;
        } else {
          msg += "Content-Length: 0\r\n\r\n";
        }
      }
    } else {
      msg += "Content-Length: 0\r\n\r\n";
    }
    return msg;
  }
}
function contentTypeToContentDisposition(contentType) {
  if (contentType === "application/sdp") {
    return "session";
  } else {
    return "render";
  }
}
function fromBodyLegacy(bodyLegacy) {
  const content2 = typeof bodyLegacy === "string" ? bodyLegacy : bodyLegacy.body;
  const contentType = typeof bodyLegacy === "string" ? "application/sdp" : bodyLegacy.contentType;
  const contentDisposition = contentTypeToContentDisposition(contentType);
  const body = { contentDisposition, contentType, content: content2 };
  return body;
}
function isBody(body) {
  return body && typeof body.content === "string" && typeof body.contentType === "string" && body.contentDisposition === void 0 ? true : typeof body.contentDisposition === "string";
}
function getBody(message2) {
  let contentDisposition;
  let contentType;
  let content2;
  if (message2 instanceof IncomingRequestMessage2) {
    if (message2.body) {
      const parse2 = message2.parseHeader("Content-Disposition");
      contentDisposition = parse2 ? parse2.type : void 0;
      contentType = message2.parseHeader("Content-Type");
      content2 = message2.body;
    }
  }
  if (message2 instanceof IncomingResponseMessage2) {
    if (message2.body) {
      const parse2 = message2.parseHeader("Content-Disposition");
      contentDisposition = parse2 ? parse2.type : void 0;
      contentType = message2.parseHeader("Content-Type");
      content2 = message2.body;
    }
  }
  if (message2 instanceof OutgoingRequestMessage2) {
    if (message2.body) {
      contentDisposition = message2.getHeader("Content-Disposition");
      contentType = message2.getHeader("Content-Type");
      if (typeof message2.body === "string") {
        if (!contentType) {
          throw new Error("Header content type header does not equal body content type.");
        }
        content2 = message2.body;
      } else {
        if (contentType && contentType !== message2.body.contentType) {
          throw new Error("Header content type header does not equal body content type.");
        }
        contentType = message2.body.contentType;
        content2 = message2.body.body;
      }
    }
  }
  if (isBody(message2)) {
    contentDisposition = message2.contentDisposition;
    contentType = message2.contentType;
    content2 = message2.content;
  }
  if (!content2) {
    return void 0;
  }
  if (contentType && !contentDisposition) {
    contentDisposition = contentTypeToContentDisposition(contentType);
  }
  if (!contentDisposition) {
    throw new Error("Content disposition undefined.");
  }
  if (!contentType) {
    throw new Error("Content type undefined.");
  }
  return {
    contentDisposition,
    contentType,
    content: content2
  };
}
class Md52 {
  constructor() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state = new Int32Array(4);
    this._buffer = new ArrayBuffer(68);
    this._buffer8 = new Uint8Array(this._buffer, 0, 68);
    this._buffer32 = new Uint32Array(this._buffer, 0, 17);
    this.start();
  }
  static hashStr(str, raw = false) {
    return this.onePassHasher.start().appendStr(str).end(raw);
  }
  static hashAsciiStr(str, raw = false) {
    return this.onePassHasher.start().appendAsciiStr(str).end(raw);
  }
  static _hex(x) {
    const hc = Md52.hexChars;
    const ho = Md52.hexOut;
    let n2;
    let offset;
    let j;
    let i2;
    for (i2 = 0; i2 < 4; i2 += 1) {
      offset = i2 * 8;
      n2 = x[i2];
      for (j = 0; j < 8; j += 2) {
        ho[offset + 1 + j] = hc.charAt(n2 & 15);
        n2 >>>= 4;
        ho[offset + 0 + j] = hc.charAt(n2 & 15);
        n2 >>>= 4;
      }
    }
    return ho.join("");
  }
  static _md5cycle(x, k) {
    let a2 = x[0];
    let b = x[1];
    let c2 = x[2];
    let d = x[3];
    a2 += (b & c2 | ~b & d) + k[0] - 680876936 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[1] - 389564586 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[2] + 606105819 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[3] - 1044525330 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & c2 | ~b & d) + k[4] - 176418897 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[5] + 1200080426 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[6] - 1473231341 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[7] - 45705983 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & c2 | ~b & d) + k[8] + 1770035416 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[9] - 1958414417 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[10] - 42063 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[11] - 1990404162 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & c2 | ~b & d) + k[12] + 1804603682 | 0;
    a2 = (a2 << 7 | a2 >>> 25) + b | 0;
    d += (a2 & b | ~a2 & c2) + k[13] - 40341101 | 0;
    d = (d << 12 | d >>> 20) + a2 | 0;
    c2 += (d & a2 | ~d & b) + k[14] - 1502002290 | 0;
    c2 = (c2 << 17 | c2 >>> 15) + d | 0;
    b += (c2 & d | ~c2 & a2) + k[15] + 1236535329 | 0;
    b = (b << 22 | b >>> 10) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[1] - 165796510 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[6] - 1069501632 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[11] + 643717713 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[0] - 373897302 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[5] - 701558691 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[10] + 38016083 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[15] - 660478335 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[4] - 405537848 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[9] + 568446438 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[14] - 1019803690 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[3] - 187363961 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[8] + 1163531501 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b & d | c2 & ~d) + k[13] - 1444681467 | 0;
    a2 = (a2 << 5 | a2 >>> 27) + b | 0;
    d += (a2 & c2 | b & ~c2) + k[2] - 51403784 | 0;
    d = (d << 9 | d >>> 23) + a2 | 0;
    c2 += (d & b | a2 & ~b) + k[7] + 1735328473 | 0;
    c2 = (c2 << 14 | c2 >>> 18) + d | 0;
    b += (c2 & a2 | d & ~a2) + k[12] - 1926607734 | 0;
    b = (b << 20 | b >>> 12) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[5] - 378558 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[8] - 2022574463 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[11] + 1839030562 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[14] - 35309556 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[1] - 1530992060 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[4] + 1272893353 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[7] - 155497632 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[10] - 1094730640 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[13] + 681279174 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[0] - 358537222 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[3] - 722521979 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[6] + 76029189 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (b ^ c2 ^ d) + k[9] - 640364487 | 0;
    a2 = (a2 << 4 | a2 >>> 28) + b | 0;
    d += (a2 ^ b ^ c2) + k[12] - 421815835 | 0;
    d = (d << 11 | d >>> 21) + a2 | 0;
    c2 += (d ^ a2 ^ b) + k[15] + 530742520 | 0;
    c2 = (c2 << 16 | c2 >>> 16) + d | 0;
    b += (c2 ^ d ^ a2) + k[2] - 995338651 | 0;
    b = (b << 23 | b >>> 9) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[0] - 198630844 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[7] + 1126891415 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[14] - 1416354905 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[5] - 57434055 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[12] + 1700485571 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[3] - 1894986606 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[10] - 1051523 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[1] - 2054922799 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[8] + 1873313359 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[15] - 30611744 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[6] - 1560198380 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[13] + 1309151649 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    a2 += (c2 ^ (b | ~d)) + k[4] - 145523070 | 0;
    a2 = (a2 << 6 | a2 >>> 26) + b | 0;
    d += (b ^ (a2 | ~c2)) + k[11] - 1120210379 | 0;
    d = (d << 10 | d >>> 22) + a2 | 0;
    c2 += (a2 ^ (d | ~b)) + k[2] + 718787259 | 0;
    c2 = (c2 << 15 | c2 >>> 17) + d | 0;
    b += (d ^ (c2 | ~a2)) + k[9] - 343485551 | 0;
    b = (b << 21 | b >>> 11) + c2 | 0;
    x[0] = a2 + x[0] | 0;
    x[1] = b + x[1] | 0;
    x[2] = c2 + x[2] | 0;
    x[3] = d + x[3] | 0;
  }
  start() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state.set(Md52.stateIdentity);
    return this;
  }
  // Char to code point to to array conversion:
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
  // #Example.3A_Fixing_charCodeAt_to_handle_non-Basic-Multilingual-Plane_characters_if_their_presence_earlier_in_the_string_is_unknown
  appendStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let code;
    let i2;
    for (i2 = 0; i2 < str.length; i2 += 1) {
      code = str.charCodeAt(i2);
      if (code < 128) {
        buf8[bufLen++] = code;
      } else if (code < 2048) {
        buf8[bufLen++] = (code >>> 6) + 192;
        buf8[bufLen++] = code & 63 | 128;
      } else if (code < 55296 || code > 56319) {
        buf8[bufLen++] = (code >>> 12) + 224;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      } else {
        code = (code - 55296) * 1024 + (str.charCodeAt(++i2) - 56320) + 65536;
        if (code > 1114111) {
          throw new Error("Unicode standard supports code points up to U+10FFFF");
        }
        buf8[bufLen++] = (code >>> 18) + 240;
        buf8[bufLen++] = code >>> 12 & 63 | 128;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      }
      if (bufLen >= 64) {
        this._dataLength += 64;
        Md52._md5cycle(this._state, buf32);
        bufLen -= 64;
        buf32[0] = buf32[16];
      }
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendAsciiStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i2;
    let j = 0;
    for (; ; ) {
      i2 = Math.min(str.length - j, 64 - bufLen);
      while (i2--) {
        buf8[bufLen++] = str.charCodeAt(j++);
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md52._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendByteArray(input) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i2;
    let j = 0;
    for (; ; ) {
      i2 = Math.min(input.length - j, 64 - bufLen);
      while (i2--) {
        buf8[bufLen++] = input[j++];
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md52._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  getState() {
    const self2 = this;
    const s2 = self2._state;
    return {
      buffer: String.fromCharCode.apply(null, self2._buffer8),
      buflen: self2._bufferLength,
      length: self2._dataLength,
      state: [s2[0], s2[1], s2[2], s2[3]]
    };
  }
  setState(state) {
    const buf = state.buffer;
    const x = state.state;
    const s2 = this._state;
    let i2;
    this._dataLength = state.length;
    this._bufferLength = state.buflen;
    s2[0] = x[0];
    s2[1] = x[1];
    s2[2] = x[2];
    s2[3] = x[3];
    for (i2 = 0; i2 < buf.length; i2 += 1) {
      this._buffer8[i2] = buf.charCodeAt(i2);
    }
  }
  end(raw = false) {
    const bufLen = this._bufferLength;
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    const i2 = (bufLen >> 2) + 1;
    let dataBitsLen;
    this._dataLength += bufLen;
    buf8[bufLen] = 128;
    buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
    buf32.set(Md52.buffer32Identity.subarray(i2), i2);
    if (bufLen > 55) {
      Md52._md5cycle(this._state, buf32);
      buf32.set(Md52.buffer32Identity);
    }
    dataBitsLen = this._dataLength * 8;
    if (dataBitsLen <= 4294967295) {
      buf32[14] = dataBitsLen;
    } else {
      const matches2 = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
      if (matches2 === null) {
        return;
      }
      const lo = parseInt(matches2[2], 16);
      const hi = parseInt(matches2[1], 16) || 0;
      buf32[14] = lo;
      buf32[15] = hi;
    }
    Md52._md5cycle(this._state, buf32);
    return raw ? this._state : Md52._hex(this._state);
  }
}
Md52.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
Md52.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
Md52.hexChars = "0123456789abcdef";
Md52.hexOut = [];
Md52.onePassHasher = new Md52();
if (Md52.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
  console.error("Md5 self test failed.");
}
function MD5(s2) {
  return Md52.hashStr(s2);
}
class DigestAuthentication2 {
  /**
   * Constructor.
   * @param loggerFactory - LoggerFactory.
   * @param username - Username.
   * @param password - Password.
   */
  constructor(loggerFactory, ha1, username, password) {
    this.logger = loggerFactory.getLogger("sipjs.digestauthentication");
    this.username = username;
    this.password = password;
    this.ha1 = ha1;
    this.nc = 0;
    this.ncHex = "00000000";
  }
  /**
   * Performs Digest authentication given a SIP request and the challenge
   * received in a response to that request.
   * @param request -
   * @param challenge -
   * @returns true if credentials were successfully generated, false otherwise.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  authenticate(request, challenge, body) {
    this.algorithm = challenge.algorithm;
    this.realm = challenge.realm;
    this.nonce = challenge.nonce;
    this.opaque = challenge.opaque;
    this.stale = challenge.stale;
    if (this.algorithm) {
      if (this.algorithm !== "MD5") {
        this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
        return false;
      }
    } else {
      this.algorithm = "MD5";
    }
    if (!this.realm) {
      this.logger.warn("challenge without Digest realm, authentication aborted");
      return false;
    }
    if (!this.nonce) {
      this.logger.warn("challenge without Digest nonce, authentication aborted");
      return false;
    }
    if (challenge.qop) {
      if (challenge.qop.indexOf("auth") > -1) {
        this.qop = "auth";
      } else if (challenge.qop.indexOf("auth-int") > -1) {
        this.qop = "auth-int";
      } else {
        this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
        return false;
      }
    } else {
      this.qop = void 0;
    }
    this.method = request.method;
    this.uri = request.ruri;
    this.cnonce = createRandomToken(12);
    this.nc += 1;
    this.updateNcHex();
    if (this.nc === 4294967296) {
      this.nc = 1;
      this.ncHex = "00000001";
    }
    this.calculateResponse(body);
    return true;
  }
  /**
   * Return the Proxy-Authorization or WWW-Authorization header value.
   */
  toString() {
    const authParams = [];
    if (!this.response) {
      throw new Error("response field does not exist, cannot generate Authorization header");
    }
    authParams.push("algorithm=" + this.algorithm);
    authParams.push('username="' + this.username + '"');
    authParams.push('realm="' + this.realm + '"');
    authParams.push('nonce="' + this.nonce + '"');
    authParams.push('uri="' + this.uri + '"');
    authParams.push('response="' + this.response + '"');
    if (this.opaque) {
      authParams.push('opaque="' + this.opaque + '"');
    }
    if (this.qop) {
      authParams.push("qop=" + this.qop);
      authParams.push('cnonce="' + this.cnonce + '"');
      authParams.push("nc=" + this.ncHex);
    }
    return "Digest " + authParams.join(", ");
  }
  /**
   * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
   */
  updateNcHex() {
    const hex = Number(this.nc).toString(16);
    this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
  }
  /**
   * Generate Digest 'response' value.
   */
  calculateResponse(body) {
    let ha1, ha2;
    ha1 = this.ha1;
    if (ha1 === "" || ha1 === void 0) {
      ha1 = MD5(this.username + ":" + this.realm + ":" + this.password);
    }
    if (this.qop === "auth") {
      ha2 = MD5(this.method + ":" + this.uri);
      this.response = MD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
    } else if (this.qop === "auth-int") {
      ha2 = MD5(this.method + ":" + this.uri + ":" + MD5(body ? body : ""));
      this.response = MD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
    } else if (this.qop === void 0) {
      ha2 = MD5(this.method + ":" + this.uri);
      this.response = MD5(ha1 + ":" + this.nonce + ":" + ha2);
    }
  }
}
function constructOutgoingResponse(message2, options) {
  const CRLF = "\r\n";
  if (options.statusCode < 100 || options.statusCode > 699) {
    throw new TypeError("Invalid statusCode: " + options.statusCode);
  }
  const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(options.statusCode);
  let response = "SIP/2.0 " + options.statusCode + " " + reasonPhrase + CRLF;
  if (options.statusCode >= 100 && options.statusCode < 200) ;
  if (options.statusCode === 100) ;
  const fromHeader = "From: " + message2.getHeader("From") + CRLF;
  const callIdHeader = "Call-ID: " + message2.callId + CRLF;
  const cSeqHeader = "CSeq: " + message2.cseq + " " + message2.method + CRLF;
  const viaHeaders = message2.getHeaders("via").reduce((previous, current2) => {
    return previous + "Via: " + current2 + CRLF;
  }, "");
  let toHeader = "To: " + message2.getHeader("to");
  if (options.statusCode > 100 && !message2.parseHeader("to").hasParam("tag")) {
    let toTag = options.toTag;
    if (!toTag) {
      toTag = newTag();
    }
    toHeader += ";tag=" + toTag;
  }
  toHeader += CRLF;
  let supportedHeader = "";
  if (options.supported) {
    supportedHeader = "Supported: " + options.supported.join(", ") + CRLF;
  }
  let userAgentHeader = "";
  if (options.userAgent) {
    userAgentHeader = "User-Agent: " + options.userAgent + CRLF;
  }
  let extensionHeaders = "";
  if (options.extraHeaders) {
    extensionHeaders = options.extraHeaders.reduce((previous, current2) => {
      return previous + current2.trim() + CRLF;
    }, "");
  }
  response += viaHeaders;
  response += fromHeader;
  response += toHeader;
  response += cSeqHeader;
  response += callIdHeader;
  response += supportedHeader;
  response += userAgentHeader;
  response += extensionHeaders;
  if (options.body) {
    response += "Content-Type: " + options.body.contentType + CRLF;
    response += "Content-Length: " + utf8Length$1(options.body.content) + CRLF + CRLF;
    response += options.body.content;
  } else {
    response += "Content-Length: 0" + CRLF + CRLF;
  }
  return { message: response };
}
var Parser;
(function(Parser2) {
  function getHeader(data, headerStart) {
    let start = headerStart;
    let end = 0;
    let partialEnd = 0;
    if (data.substring(start, start + 2).match(/(^\r\n)/)) {
      return -2;
    }
    while (end === 0) {
      partialEnd = data.indexOf("\r\n", start);
      if (partialEnd === -1) {
        return partialEnd;
      }
      if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
        start = partialEnd + 2;
      } else {
        end = partialEnd;
      }
    }
    return end;
  }
  Parser2.getHeader = getHeader;
  function parseHeader(message2, data, headerStart, headerEnd) {
    const hcolonIndex = data.indexOf(":", headerStart);
    const headerName = data.substring(headerStart, hcolonIndex).trim();
    const headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
    let parsed;
    switch (headerName.toLowerCase()) {
      case "via":
      case "v":
        message2.addHeader("via", headerValue);
        if (message2.getHeaders("via").length === 1) {
          parsed = message2.parseHeader("Via");
          if (parsed) {
            message2.via = parsed;
            message2.viaBranch = parsed.branch;
          }
        } else {
          parsed = 0;
        }
        break;
      case "from":
      case "f":
        message2.setHeader("from", headerValue);
        parsed = message2.parseHeader("from");
        if (parsed) {
          message2.from = parsed;
          message2.fromTag = parsed.getParam("tag");
        }
        break;
      case "to":
      case "t":
        message2.setHeader("to", headerValue);
        parsed = message2.parseHeader("to");
        if (parsed) {
          message2.to = parsed;
          message2.toTag = parsed.getParam("tag");
        }
        break;
      case "record-route":
        parsed = Grammar.parse(headerValue, "Record_Route");
        if (parsed === -1) {
          parsed = void 0;
          break;
        }
        if (!(parsed instanceof Array)) {
          parsed = void 0;
          break;
        }
        parsed.forEach((header) => {
          message2.addHeader("record-route", headerValue.substring(header.position, header.offset));
          message2.headers["Record-Route"][message2.getHeaders("record-route").length - 1].parsed = header.parsed;
        });
        break;
      case "call-id":
      case "i":
        message2.setHeader("call-id", headerValue);
        parsed = message2.parseHeader("call-id");
        if (parsed) {
          message2.callId = headerValue;
        }
        break;
      case "contact":
      case "m":
        parsed = Grammar.parse(headerValue, "Contact");
        if (parsed === -1) {
          parsed = void 0;
          break;
        }
        if (!(parsed instanceof Array)) {
          parsed = void 0;
          break;
        }
        parsed.forEach((header) => {
          message2.addHeader("contact", headerValue.substring(header.position, header.offset));
          message2.headers.Contact[message2.getHeaders("contact").length - 1].parsed = header.parsed;
        });
        break;
      case "content-length":
      case "l":
        message2.setHeader("content-length", headerValue);
        parsed = message2.parseHeader("content-length");
        break;
      case "content-type":
      case "c":
        message2.setHeader("content-type", headerValue);
        parsed = message2.parseHeader("content-type");
        break;
      case "cseq":
        message2.setHeader("cseq", headerValue);
        parsed = message2.parseHeader("cseq");
        if (parsed) {
          message2.cseq = parsed.value;
        }
        if (message2 instanceof IncomingResponseMessage2) {
          message2.method = parsed.method;
        }
        break;
      case "max-forwards":
        message2.setHeader("max-forwards", headerValue);
        parsed = message2.parseHeader("max-forwards");
        break;
      case "www-authenticate":
        message2.setHeader("www-authenticate", headerValue);
        parsed = message2.parseHeader("www-authenticate");
        break;
      case "proxy-authenticate":
        message2.setHeader("proxy-authenticate", headerValue);
        parsed = message2.parseHeader("proxy-authenticate");
        break;
      case "refer-to":
      case "r":
        message2.setHeader("refer-to", headerValue);
        parsed = message2.parseHeader("refer-to");
        if (parsed) {
          message2.referTo = parsed;
        }
        break;
      default:
        message2.addHeader(headerName.toLowerCase(), headerValue);
        parsed = 0;
    }
    if (parsed === void 0) {
      return {
        error: "error parsing header '" + headerName + "'"
      };
    } else {
      return true;
    }
  }
  Parser2.parseHeader = parseHeader;
  function parseMessage(data, logger) {
    let headerStart = 0;
    let headerEnd = data.indexOf("\r\n");
    if (headerEnd === -1) {
      logger.warn("no CRLF found, not a SIP message, discarded");
      return;
    }
    const firstLine = data.substring(0, headerEnd);
    const parsed = Grammar.parse(firstLine, "Request_Response");
    let message2;
    if (parsed === -1) {
      logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
      return;
    } else if (!parsed.status_code) {
      message2 = new IncomingRequestMessage2();
      message2.method = parsed.method;
      message2.ruri = parsed.uri;
    } else {
      message2 = new IncomingResponseMessage2();
      message2.statusCode = parsed.status_code;
      message2.reasonPhrase = parsed.reason_phrase;
    }
    message2.data = data;
    headerStart = headerEnd + 2;
    let bodyStart;
    while (true) {
      headerEnd = getHeader(data, headerStart);
      if (headerEnd === -2) {
        bodyStart = headerStart + 2;
        break;
      } else if (headerEnd === -1) {
        logger.error("malformed message");
        return;
      }
      const parsedHeader = parseHeader(message2, data, headerStart, headerEnd);
      if (parsedHeader && parsedHeader !== true) {
        logger.error(parsedHeader.error);
        return;
      }
      headerStart = headerEnd + 2;
    }
    if (message2.hasHeader("content-length")) {
      message2.body = data.substr(bodyStart, Number(message2.getHeader("content-length")));
    } else {
      message2.body = data.substring(bodyStart);
    }
    return message2;
  }
  Parser2.parseMessage = parseMessage;
})(Parser || (Parser = {}));
class Dialog2 {
  /**
   * Dialog constructor.
   * @param core - User agent core.
   * @param dialogState - Initial dialog state.
   */
  constructor(core2, dialogState) {
    this.core = core2;
    this.dialogState = dialogState;
    this.core.dialogs.set(this.id, this);
  }
  /**
   * When a UAC receives a response that establishes a dialog, it
   * constructs the state of the dialog.  This state MUST be maintained
   * for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.2
   * @param outgoingRequestMessage - Outgoing request message for dialog.
   * @param incomingResponseMessage - Incoming response message creating dialog.
   */
  static initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {
    const secure = false;
    const routeSet = incomingResponseMessage.getHeaders("record-route").reverse();
    const contact2 = incomingResponseMessage.parseHeader("contact");
    if (!contact2) {
      throw new Error("Contact undefined.");
    }
    if (!(contact2 instanceof NameAddrHeader2)) {
      throw new Error("Contact not instance of NameAddrHeader.");
    }
    const remoteTarget = contact2.uri;
    const localSequenceNumber = outgoingRequestMessage.cseq;
    const remoteSequenceNumber = void 0;
    const callId = outgoingRequestMessage.callId;
    const localTag = outgoingRequestMessage.fromTag;
    const remoteTag = incomingResponseMessage.toTag;
    if (!callId) {
      throw new Error("Call id undefined.");
    }
    if (!localTag) {
      throw new Error("From tag undefined.");
    }
    if (!remoteTag) {
      throw new Error("To tag undefined.");
    }
    if (!outgoingRequestMessage.from) {
      throw new Error("From undefined.");
    }
    if (!outgoingRequestMessage.to) {
      throw new Error("To undefined.");
    }
    const localURI = outgoingRequestMessage.from.uri;
    const remoteURI = outgoingRequestMessage.to.uri;
    if (!incomingResponseMessage.statusCode) {
      throw new Error("Incoming response status code undefined.");
    }
    const early = incomingResponseMessage.statusCode < 200 ? true : false;
    const dialogState = {
      id: callId + localTag + remoteTag,
      early,
      callId,
      localTag,
      remoteTag,
      localSequenceNumber,
      remoteSequenceNumber,
      localURI,
      remoteURI,
      remoteTarget,
      routeSet,
      secure
    };
    return dialogState;
  }
  /**
   * The UAS then constructs the state of the dialog.  This state MUST be
   * maintained for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.1
   * @param incomingRequestMessage - Incoming request message creating dialog.
   * @param toTag - Tag in the To field in the response to the incoming request.
   */
  static initialDialogStateForUserAgentServer(incomingRequestMessage, toTag, early = false) {
    const secure = false;
    const routeSet = incomingRequestMessage.getHeaders("record-route");
    const contact2 = incomingRequestMessage.parseHeader("contact");
    if (!contact2) {
      throw new Error("Contact undefined.");
    }
    if (!(contact2 instanceof NameAddrHeader2)) {
      throw new Error("Contact not instance of NameAddrHeader.");
    }
    const remoteTarget = contact2.uri;
    const remoteSequenceNumber = incomingRequestMessage.cseq;
    const localSequenceNumber = void 0;
    const callId = incomingRequestMessage.callId;
    const localTag = toTag;
    const remoteTag = incomingRequestMessage.fromTag;
    const remoteURI = incomingRequestMessage.from.uri;
    const localURI = incomingRequestMessage.to.uri;
    const dialogState = {
      id: callId + localTag + remoteTag,
      early,
      callId,
      localTag,
      remoteTag,
      localSequenceNumber,
      remoteSequenceNumber,
      localURI,
      remoteURI,
      remoteTarget,
      routeSet,
      secure
    };
    return dialogState;
  }
  /** Destructor. */
  dispose() {
    this.core.dialogs.delete(this.id);
  }
  /**
   * A dialog is identified at each UA with a dialog ID, which consists of
   * a Call-ID value, a local tag and a remote tag.  The dialog ID at each
   * UA involved in the dialog is not the same.  Specifically, the local
   * tag at one UA is identical to the remote tag at the peer UA.  The
   * tags are opaque tokens that facilitate the generation of unique
   * dialog IDs.
   * https://tools.ietf.org/html/rfc3261#section-12
   */
  get id() {
    return this.dialogState.id;
  }
  /**
   * A dialog can also be in the "early" state, which occurs when it is
   * created with a provisional response, and then it transition to the
   * "confirmed" state when a 2xx final response received or is sent.
   *
   * Note: RFC 3261 is concise on when a dialog is "confirmed", but it
   * can be a point of confusion if an INVITE dialog is "confirmed" after
   * a 2xx is sent or after receiving the ACK for the 2xx response.
   * With careful reading it can be inferred a dialog is always is
   * "confirmed" when the 2xx is sent (regardless of type of dialog).
   * However a INVITE dialog does have additional considerations
   * when it is confirmed but an ACK has not yet been received (in
   * particular with regard to a callee sending BYE requests).
   */
  get early() {
    return this.dialogState.early;
  }
  /** Call identifier component of the dialog id. */
  get callId() {
    return this.dialogState.callId;
  }
  /** Local tag component of the dialog id. */
  get localTag() {
    return this.dialogState.localTag;
  }
  /** Remote tag component of the dialog id. */
  get remoteTag() {
    return this.dialogState.remoteTag;
  }
  /** Local sequence number (used to order requests from the UA to its peer). */
  get localSequenceNumber() {
    return this.dialogState.localSequenceNumber;
  }
  /** Remote sequence number (used to order requests from its peer to the UA). */
  get remoteSequenceNumber() {
    return this.dialogState.remoteSequenceNumber;
  }
  /** Local URI. */
  get localURI() {
    return this.dialogState.localURI;
  }
  /** Remote URI. */
  get remoteURI() {
    return this.dialogState.remoteURI;
  }
  /** Remote target. */
  get remoteTarget() {
    return this.dialogState.remoteTarget;
  }
  /**
   * Route set, which is an ordered list of URIs. The route set is the
   * list of servers that need to be traversed to send a request to the peer.
   */
  get routeSet() {
    return this.dialogState.routeSet;
  }
  /**
   * If the request was sent over TLS, and the Request-URI contained
   * a SIPS URI, the "secure" flag is set to true. *NOT IMPLEMENTED*
   */
  get secure() {
    return this.dialogState.secure;
  }
  /** The user agent core servicing this dialog. */
  get userAgentCore() {
    return this.core;
  }
  /** Confirm the dialog. Only matters if dialog is currently early. */
  confirm() {
    this.dialogState.early = false;
  }
  /**
   * Requests sent within a dialog, as any other requests, are atomic.  If
   * a particular request is accepted by the UAS, all the state changes
   * associated with it are performed.  If the request is rejected, none
   * of the state changes are performed.
   *
   *    Note that some requests, such as INVITEs, affect several pieces of
   *    state.
   *
   * https://tools.ietf.org/html/rfc3261#section-12.2.2
   * @param message - Incoming request message within this dialog.
   */
  receiveRequest(message2) {
    if (message2.method === C.ACK) {
      return;
    }
    if (this.remoteSequenceNumber) {
      if (message2.cseq <= this.remoteSequenceNumber) {
        throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
      }
      this.dialogState.remoteSequenceNumber = message2.cseq;
    }
    if (!this.remoteSequenceNumber) {
      this.dialogState.remoteSequenceNumber = message2.cseq;
    }
  }
  /**
   * If the dialog identifier in the 2xx response matches the dialog
   * identifier of an existing dialog, the dialog MUST be transitioned to
   * the "confirmed" state, and the route set for the dialog MUST be
   * recomputed based on the 2xx response using the procedures of Section
   * 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
   * constructed using the procedures of Section 12.1.2.
   *
   * Note that the only piece of state that is recomputed is the route
   * set.  Other pieces of state such as the highest sequence numbers
   * (remote and local) sent within the dialog are not recomputed.  The
   * route set only is recomputed for backwards compatibility.  RFC
   * 2543 did not mandate mirroring of the Record-Route header field in
   * a 1xx, only 2xx.  However, we cannot update the entire state of
   * the dialog, since mid-dialog requests may have been sent within
   * the early dialog, modifying the sequence numbers, for example.
   *
   *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4
   */
  recomputeRouteSet(message2) {
    this.dialogState.routeSet = message2.getHeaders("record-route").reverse();
  }
  /**
   * A request within a dialog is constructed by using many of the
   * components of the state stored as part of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.2.1.1
   * @param method - Outgoing request method.
   */
  createOutgoingRequestMessage(method, options) {
    const toUri = this.remoteURI;
    const toTag = this.remoteTag;
    const fromUri = this.localURI;
    const fromTag = this.localTag;
    const callId = this.callId;
    let cseq;
    if (options && options.cseq) {
      cseq = options.cseq;
    } else if (!this.dialogState.localSequenceNumber) {
      cseq = this.dialogState.localSequenceNumber = 1;
    } else {
      cseq = this.dialogState.localSequenceNumber += 1;
    }
    const ruri = this.remoteTarget;
    const routeSet = this.routeSet;
    const extraHeaders = options && options.extraHeaders;
    const body = options && options.body;
    const message2 = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {
      callId,
      cseq,
      fromTag,
      toTag,
      routeSet
    }, extraHeaders, body);
    return message2;
  }
  /**
   * Increment the local sequence number by one.
   * It feels like this should be protected, but the current authentication handling currently
   * needs this to keep the dialog in sync when "auto re-sends" request messages.
   * @internal
   */
  incrementLocalSequenceNumber() {
    if (!this.dialogState.localSequenceNumber) {
      throw new Error("Local sequence number undefined.");
    }
    this.dialogState.localSequenceNumber += 1;
  }
  /**
   * If the remote sequence number was not empty, but the sequence number
   * of the request is lower than the remote sequence number, the request
   * is out of order and MUST be rejected with a 500 (Server Internal
   * Error) response.
   * https://tools.ietf.org/html/rfc3261#section-12.2.2
   * @param request - Incoming request to guard.
   * @returns True if the program execution is to continue in the branch in question.
   *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.
   */
  sequenceGuard(message2) {
    if (message2.method === C.ACK) {
      return true;
    }
    if (this.remoteSequenceNumber && message2.cseq <= this.remoteSequenceNumber) {
      this.core.replyStateless(message2, { statusCode: 500 });
      return false;
    }
    return true;
  }
}
var SessionState$1;
(function(SessionState2) {
  SessionState2["Initial"] = "Initial";
  SessionState2["Early"] = "Early";
  SessionState2["AckWait"] = "AckWait";
  SessionState2["Confirmed"] = "Confirmed";
  SessionState2["Terminated"] = "Terminated";
})(SessionState$1 || (SessionState$1 = {}));
var SignalingState;
(function(SignalingState2) {
  SignalingState2["Initial"] = "Initial";
  SignalingState2["HaveLocalOffer"] = "HaveLocalOffer";
  SignalingState2["HaveRemoteOffer"] = "HaveRemoteOffer";
  SignalingState2["Stable"] = "Stable";
  SignalingState2["Closed"] = "Closed";
})(SignalingState || (SignalingState = {}));
const T1 = 500;
const T2 = 4e3;
const T4 = 5e3;
const Timers = {
  T1,
  T2,
  TIMER_B: 64 * T1,
  TIMER_D: 0 * T1,
  TIMER_F: 64 * T1,
  TIMER_H: 64 * T1,
  TIMER_I: 0 * T4,
  TIMER_J: 0 * T1,
  TIMER_K: 0 * T4,
  TIMER_L: 64 * T1,
  TIMER_M: 64 * T1,
  TIMER_N: 64 * T1,
  PROVISIONAL_RESPONSE_INTERVAL: 6e4
  // See RFC 3261 Section 13.3.1.1
};
class Exception2 extends Error {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}
class TransactionStateError2 extends Exception2 {
  constructor(message2) {
    super(message2 ? message2 : "Transaction state error.");
  }
}
let TransportError$1 = class TransportError2 extends Exception2 {
  constructor(message2) {
    super(message2 ? message2 : "Unspecified transport error.");
  }
};
class Transaction2 {
  constructor(_transport, _user, _id, _state, loggerCategory) {
    this._transport = _transport;
    this._user = _user;
    this._id = _id;
    this._state = _state;
    this.listeners = new Array();
    this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
    this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);
  }
  /**
   * Destructor.
   * Once the transaction is in the "terminated" state, it is destroyed
   * immediately and there is no need to call `dispose`. However, if a
   * transaction needs to be ended prematurely, the transaction user may
   * do so by calling this method (for example, perhaps the UA is shutting down).
   * No state transition will occur upon calling this method, all outstanding
   * transmission timers will be cancelled, and use of the transaction after
   * calling `dispose` is undefined.
   */
  dispose() {
    this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);
  }
  /** Transaction id. */
  get id() {
    return this._id;
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    throw new Error("Invalid kind.");
  }
  /** Transaction state. */
  get state() {
    return this._state;
  }
  /** Transaction transport. */
  get transport() {
    return this._transport;
  }
  /**
   * Sets up a function that will be called whenever the transaction state changes.
   * @param listener - Callback function.
   * @param options - An options object that specifies characteristics about the listener.
   *                  If once true, indicates that the listener should be invoked at most once after being added.
   *                  If once true, the listener would be automatically removed when invoked.
   */
  addStateChangeListener(listener, options) {
    const onceWrapper = () => {
      this.removeStateChangeListener(onceWrapper);
      listener();
    };
    (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);
  }
  /**
   * This is currently public so tests may spy on it.
   * @internal
   */
  notifyStateChangeListeners() {
    this.listeners.slice().forEach((listener) => listener());
  }
  /**
   * Removes a listener previously registered with addStateListener.
   * @param listener - Callback function.
   */
  removeStateChangeListener(listener) {
    this.listeners = this.listeners.filter((l2) => l2 !== listener);
  }
  logTransportError(error, message2) {
    this.logger.error(error.message);
    this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`);
    this.logger.error(message2);
  }
  /**
   * Pass message to transport for transmission. If transport fails,
   * the transaction user is notified by callback to onTransportError().
   * @returns
   * Rejects with `TransportError` if transport fails.
   */
  send(message2) {
    return this.transport.send(message2).catch((error) => {
      if (error instanceof TransportError$1) {
        this.onTransportError(error);
        throw error;
      }
      let transportError;
      if (error && typeof error.message === "string") {
        transportError = new TransportError$1(error.message);
      } else {
        transportError = new TransportError$1();
      }
      this.onTransportError(transportError);
      throw transportError;
    });
  }
  setState(state) {
    this.logger.debug(`State change to "${state}" on ${this.typeToString()} with id ${this.id}.`);
    this._state = state;
    if (this._user.onStateChange) {
      this._user.onStateChange(state);
    }
    this.notifyStateChangeListeners();
  }
  typeToString() {
    return "UnknownType";
  }
}
class ClientTransaction2 extends Transaction2 {
  constructor(_request, transport, user, state, loggerCategory) {
    super(transport, user, ClientTransaction2.makeId(_request), state, loggerCategory);
    this._request = _request;
    this.user = user;
    _request.setViaHeader(this.id, transport.protocol);
  }
  static makeId(request) {
    if (request.method === "CANCEL") {
      if (!request.branch) {
        throw new Error("Outgoing CANCEL request without a branch.");
      }
      return request.branch;
    } else {
      return "z9hG4bK" + Math.floor(Math.random() * 1e7);
    }
  }
  /** The outgoing request the transaction handling. */
  get request() {
    return this._request;
  }
  /**
   * A 408 to non-INVITE will always arrive too late to be useful ([3]),
   * The client already has full knowledge of the timeout. The only
   * information this message would convey is whether or not the server
   * believed the transaction timed out. However, with the current design
   * of the NIT, a client cannot do anything with this knowledge. Thus,
   * the 408 is simply wasting network resources and contributes to the
   * response bombardment illustrated in [3].
   * https://tools.ietf.org/html/rfc4320#section-4.1
   */
  onRequestTimeout() {
    if (this.user.onRequestTimeout) {
      this.user.onRequestTimeout();
    }
  }
}
var TransactionState;
(function(TransactionState2) {
  TransactionState2["Accepted"] = "Accepted";
  TransactionState2["Calling"] = "Calling";
  TransactionState2["Completed"] = "Completed";
  TransactionState2["Confirmed"] = "Confirmed";
  TransactionState2["Proceeding"] = "Proceeding";
  TransactionState2["Terminated"] = "Terminated";
  TransactionState2["Trying"] = "Trying";
})(TransactionState || (TransactionState = {}));
class InviteClientTransaction2 extends ClientTransaction2 {
  /**
   * Constructor.
   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
   * Then `toString` is called on the outgoing request and the message is sent via the transport.
   * After construction the transaction will be in the "calling" state and the transaction id
   * will equal the branch parameter set in the Via header of the outgoing request.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1
   * @param request - The outgoing INVITE request.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState.Calling, "sip.transaction.ict");
    this.ackRetransmissionCache = /* @__PURE__ */ new Map();
    this.B = setTimeout(() => this.timerB(), Timers.TIMER_B);
    this.send(request.toString()).catch((error) => {
      this.logTransportError(error, "Failed to send initial outgoing request.");
    });
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.B) {
      clearTimeout(this.B);
      this.B = void 0;
    }
    if (this.D) {
      clearTimeout(this.D);
      this.D = void 0;
    }
    if (this.M) {
      clearTimeout(this.M);
      this.M = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "ict";
  }
  /**
   * ACK a 2xx final response.
   *
   * The transaction includes the ACK only if the final response was not a 2xx response (the
   * transaction will generate and send the ACK to the transport automagically). If the
   * final response was a 2xx, the ACK is not considered part of the transaction (the
   * transaction user needs to generate and send the ACK).
   *
   * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
   * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
   * by the transaction layer (instead of the UAC core). The "standard" approach is for
   * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
   * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
   * and any retransmissions of those ACKs as needed.
   *
   * @param ack - The outgoing ACK request.
   */
  ackResponse(ack) {
    const toTag = ack.toTag;
    if (!toTag) {
      throw new Error("To tag undefined.");
    }
    const id = "z9hG4bK" + Math.floor(Math.random() * 1e7);
    ack.setViaHeader(id, this.transport.protocol);
    this.ackRetransmissionCache.set(toTag, ack);
    this.send(ack.toString()).catch((error) => {
      this.logTransportError(error, "Failed to send ACK to 2xx response.");
    });
  }
  /**
   * Handler for incoming responses from the transport which match this transaction.
   * @param response - The incoming response.
   */
  receiveResponse(response) {
    const statusCode = response.statusCode;
    if (!statusCode || statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    switch (this.state) {
      case TransactionState.Calling:
        if (statusCode >= 100 && statusCode <= 199) {
          this.stateTransition(TransactionState.Proceeding);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 200 && statusCode <= 299) {
          this.ackRetransmissionCache.set(response.toTag, void 0);
          this.stateTransition(TransactionState.Accepted);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 300 && statusCode <= 699) {
          this.stateTransition(TransactionState.Completed);
          this.ack(response);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState.Proceeding:
        if (statusCode >= 100 && statusCode <= 199) {
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 200 && statusCode <= 299) {
          this.ackRetransmissionCache.set(response.toTag, void 0);
          this.stateTransition(TransactionState.Accepted);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 300 && statusCode <= 699) {
          this.stateTransition(TransactionState.Completed);
          this.ack(response);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState.Accepted:
        if (statusCode >= 200 && statusCode <= 299) {
          if (!this.ackRetransmissionCache.has(response.toTag)) {
            this.ackRetransmissionCache.set(response.toTag, void 0);
            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }
            return;
          }
          const ack = this.ackRetransmissionCache.get(response.toTag);
          if (ack) {
            this.send(ack.toString()).catch((error) => {
              this.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
            });
            return;
          }
          return;
        }
        break;
      case TransactionState.Completed:
        if (statusCode >= 300 && statusCode <= 699) {
          this.ack(response);
          return;
        }
        break;
      case TransactionState.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `Received unexpected ${statusCode} response while in state ${this.state}.`;
    this.logger.warn(message2);
    return;
  }
  /**
   * The client transaction SHOULD inform the TU that a transport failure
   * has occurred, and the client transaction SHOULD transition directly
   * to the "Terminated" state.  The TU will handle the failover
   * mechanisms described in [4].
   * https://tools.ietf.org/html/rfc3261#section-17.1.4
   * @param error - The error.
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
    this.stateTransition(TransactionState.Terminated, true);
  }
  /** For logging. */
  typeToString() {
    return "INVITE client transaction";
  }
  ack(response) {
    const ruri = this.request.ruri;
    const callId = this.request.callId;
    const cseq = this.request.cseq;
    const from = this.request.getHeader("from");
    const to = response.getHeader("to");
    const via = this.request.getHeader("via");
    const route = this.request.getHeader("route");
    if (!from) {
      throw new Error("From undefined.");
    }
    if (!to) {
      throw new Error("To undefined.");
    }
    if (!via) {
      throw new Error("Via undefined.");
    }
    let ack = `ACK ${ruri} SIP/2.0\r
`;
    if (route) {
      ack += `Route: ${route}\r
`;
    }
    ack += `Via: ${via}\r
`;
    ack += `To: ${to}\r
`;
    ack += `From: ${from}\r
`;
    ack += `Call-ID: ${callId}\r
`;
    ack += `CSeq: ${cseq} ACK\r
`;
    ack += `Max-Forwards: 70\r
`;
    ack += `Content-Length: 0\r
\r
`;
    this.send(ack).catch((error) => {
      this.logTransportError(error, "Failed to send ACK to non-2xx response.");
    });
    return;
  }
  /**
   * Execute a state transition.
   * @param newState - New state.
   */
  stateTransition(newState, dueToTransportError = false) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState.Calling:
        invalidStateTransition();
        break;
      case TransactionState.Proceeding:
        if (this.state !== TransactionState.Calling) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Accepted:
      case TransactionState.Completed:
        if (this.state !== TransactionState.Calling && this.state !== TransactionState.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Terminated:
        if (this.state !== TransactionState.Calling && this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed) {
          if (!dueToTransportError) {
            invalidStateTransition();
          }
        }
        break;
      default:
        invalidStateTransition();
    }
    if (this.B) {
      clearTimeout(this.B);
      this.B = void 0;
    }
    if (newState === TransactionState.Proceeding) ;
    if (newState === TransactionState.Completed) {
      this.D = setTimeout(() => this.timerD(), Timers.TIMER_D);
    }
    if (newState === TransactionState.Accepted) {
      this.M = setTimeout(() => this.timerM(), Timers.TIMER_M);
    }
    if (newState === TransactionState.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * When timer A fires, the client transaction MUST retransmit the
   * request by passing it to the transport layer, and MUST reset the
   * timer with a value of 2*T1.
   * When timer A fires 2*T1 seconds later, the request MUST be
   * retransmitted again (assuming the client transaction is still in this
   * state). This process MUST continue so that the request is
   * retransmitted with intervals that double after each transmission.
   * These retransmissions SHOULD only be done while the client
   * transaction is in the "Calling" state.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
   */
  timerA() {
  }
  /**
   * If the client transaction is still in the "Calling" state when timer
   * B fires, the client transaction SHOULD inform the TU that a timeout
   * has occurred.  The client transaction MUST NOT generate an ACK.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
   */
  timerB() {
    this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState.Calling) {
      this.onRequestTimeout();
      this.stateTransition(TransactionState.Terminated);
    }
  }
  /**
   * If Timer D fires while the client transaction is in the "Completed" state,
   * the client transaction MUST move to the "Terminated" state.
   * https://tools.ietf.org/html/rfc6026#section-8.4
   */
  timerD() {
    this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState.Completed) {
      this.stateTransition(TransactionState.Terminated);
    }
  }
  /**
   * If Timer M fires while the client transaction is in the "Accepted"
   * state, the client transaction MUST move to the "Terminated" state.
   * https://tools.ietf.org/html/rfc6026#section-8.4
   */
  timerM() {
    this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState.Accepted) {
      this.stateTransition(TransactionState.Terminated);
    }
  }
}
class ServerTransaction2 extends Transaction2 {
  constructor(_request, transport, user, state, loggerCategory) {
    super(transport, user, _request.viaBranch, state, loggerCategory);
    this._request = _request;
    this.user = user;
  }
  /** The incoming request the transaction handling. */
  get request() {
    return this._request;
  }
}
class InviteServerTransaction2 extends ServerTransaction2 {
  /**
   * Constructor.
   * Upon construction, a "100 Trying" reply will be immediately sent.
   * After construction the transaction will be in the "proceeding" state and the transaction
   * `id` will equal the branch parameter set in the Via header of the incoming request.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   * @param request - Incoming INVITE request from the transport.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState.Proceeding, "sip.transaction.ist");
  }
  /**
   * Destructor.
   */
  dispose() {
    this.stopProgressExtensionTimer();
    if (this.H) {
      clearTimeout(this.H);
      this.H = void 0;
    }
    if (this.I) {
      clearTimeout(this.I);
      this.I = void 0;
    }
    if (this.L) {
      clearTimeout(this.L);
      this.L = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "ist";
  }
  /**
   * Receive requests from transport matching this transaction.
   * @param request - Request matching this transaction.
   */
  receiveRequest(request) {
    switch (this.state) {
      case TransactionState.Proceeding:
        if (request.method === C.INVITE) {
          if (this.lastProvisionalResponse) {
            this.send(this.lastProvisionalResponse).catch((error) => {
              this.logTransportError(error, "Failed to send retransmission of provisional response.");
            });
          }
          return;
        }
        break;
      case TransactionState.Accepted:
        if (request.method === C.INVITE) {
          return;
        }
        break;
      case TransactionState.Completed:
        if (request.method === C.INVITE) {
          if (!this.lastFinalResponse) {
            throw new Error("Last final response undefined.");
          }
          this.send(this.lastFinalResponse).catch((error) => {
            this.logTransportError(error, "Failed to send retransmission of final response.");
          });
          return;
        }
        if (request.method === C.ACK) {
          this.stateTransition(TransactionState.Confirmed);
          return;
        }
        break;
      case TransactionState.Confirmed:
        if (request.method === C.INVITE || request.method === C.ACK) {
          return;
        }
        break;
      case TransactionState.Terminated:
        if (request.method === C.INVITE || request.method === C.ACK) {
          return;
        }
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `INVITE server transaction received unexpected ${request.method} request while in state ${this.state}.`;
    this.logger.warn(message2);
    return;
  }
  /**
   * Receive responses from TU for this transaction.
   * @param statusCode - Status code of response.
   * @param response - Response.
   */
  receiveResponse(statusCode, response) {
    if (statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    switch (this.state) {
      case TransactionState.Proceeding:
        if (statusCode >= 100 && statusCode <= 199) {
          this.lastProvisionalResponse = response;
          if (statusCode > 100) {
            this.startProgressExtensionTimer();
          }
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send 1xx response.");
          });
          return;
        }
        if (statusCode >= 200 && statusCode <= 299) {
          this.lastFinalResponse = response;
          this.stateTransition(TransactionState.Accepted);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send 2xx response.");
          });
          return;
        }
        if (statusCode >= 300 && statusCode <= 699) {
          this.lastFinalResponse = response;
          this.stateTransition(TransactionState.Completed);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send non-2xx final response.");
          });
          return;
        }
        break;
      case TransactionState.Accepted:
        if (statusCode >= 200 && statusCode <= 299) {
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send 2xx response.");
          });
          return;
        }
        break;
      case TransactionState.Completed:
        break;
      case TransactionState.Confirmed:
        break;
      case TransactionState.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;
    this.logger.error(message2);
    throw new Error(message2);
  }
  /**
   * Retransmit the last 2xx response. This is a noop if not in the "accepted" state.
   */
  retransmitAcceptedResponse() {
    if (this.state === TransactionState.Accepted && this.lastFinalResponse) {
      this.send(this.lastFinalResponse).catch((error) => {
        this.logTransportError(error, "Failed to send 2xx response.");
      });
    }
  }
  /**
   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
   * inform the TU that a failure has occurred, and MUST remain in the current state.
   * https://tools.ietf.org/html/rfc6026#section-8.8
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
  }
  /** For logging. */
  typeToString() {
    return "INVITE server transaction";
  }
  /**
   * Execute a state transition.
   * @param newState - New state.
   */
  stateTransition(newState) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState.Proceeding:
        invalidStateTransition();
        break;
      case TransactionState.Accepted:
      case TransactionState.Completed:
        if (this.state !== TransactionState.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Confirmed:
        if (this.state !== TransactionState.Completed) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Terminated:
        if (this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed && this.state !== TransactionState.Confirmed) {
          invalidStateTransition();
        }
        break;
      default:
        invalidStateTransition();
    }
    this.stopProgressExtensionTimer();
    if (newState === TransactionState.Accepted) {
      this.L = setTimeout(() => this.timerL(), Timers.TIMER_L);
    }
    if (newState === TransactionState.Completed) {
      this.H = setTimeout(() => this.timerH(), Timers.TIMER_H);
    }
    if (newState === TransactionState.Confirmed) {
      this.I = setTimeout(() => this.timerI(), Timers.TIMER_I);
    }
    if (newState === TransactionState.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
   */
  startProgressExtensionTimer() {
    if (this.progressExtensionTimer === void 0) {
      this.progressExtensionTimer = setInterval(() => {
        this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`);
        if (!this.lastProvisionalResponse) {
          throw new Error("Last provisional response undefined.");
        }
        this.send(this.lastProvisionalResponse).catch((error) => {
          this.logTransportError(error, "Failed to send retransmission of provisional response.");
        });
      }, Timers.PROVISIONAL_RESPONSE_INTERVAL);
    }
  }
  /**
   * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
   */
  stopProgressExtensionTimer() {
    if (this.progressExtensionTimer !== void 0) {
      clearInterval(this.progressExtensionTimer);
      this.progressExtensionTimer = void 0;
    }
  }
  /**
   * While in the "Proceeding" state, if the TU passes a response with status code
   * from 300 to 699 to the server transaction, the response MUST be passed to the
   * transport layer for transmission, and the state machine MUST enter the "Completed" state.
   * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
   * reliable transports. If timer G fires, the response is passed to the transport layer once
   * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
   * when timer G fires, the response is passed to the transport again for transmission, and
   * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
   * it is reset with the value of T2.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   */
  timerG() {
  }
  /**
   * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
   * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
   * indicate to the TU that a transaction failure has occurred.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   */
  timerH() {
    this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`);
    if (this.state === TransactionState.Completed) {
      this.logger.warn("ACK to negative final response was never received, terminating transaction.");
      this.stateTransition(TransactionState.Terminated);
    }
  }
  /**
   * Once timer I fires, the server MUST transition to the "Terminated" state.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   */
  timerI() {
    this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`);
    this.stateTransition(TransactionState.Terminated);
  }
  /**
   * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
   * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
   * it MUST be destroyed immediately. Timer L reflects the amount of time the server
   * transaction could receive 2xx responses for retransmission from the
   * TU while it is waiting to receive an ACK.
   * https://tools.ietf.org/html/rfc6026#section-7.1
   * https://tools.ietf.org/html/rfc6026#section-8.7
   */
  timerL() {
    this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`);
    if (this.state === TransactionState.Accepted) {
      this.stateTransition(TransactionState.Terminated);
    }
  }
}
class NonInviteClientTransaction2 extends ClientTransaction2 {
  /**
   * Constructor
   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
   * Then `toString` is called on the outgoing request and the message is sent via the transport.
   * After construction the transaction will be in the "calling" state and the transaction id
   * will equal the branch parameter set in the Via header of the outgoing request.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2
   * @param request - The outgoing Non-INVITE request.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState.Trying, "sip.transaction.nict");
    this.F = setTimeout(() => this.timerF(), Timers.TIMER_F);
    this.send(request.toString()).catch((error) => {
      this.logTransportError(error, "Failed to send initial outgoing request.");
    });
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.F) {
      clearTimeout(this.F);
      this.F = void 0;
    }
    if (this.K) {
      clearTimeout(this.K);
      this.K = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "nict";
  }
  /**
   * Handler for incoming responses from the transport which match this transaction.
   * @param response - The incoming response.
   */
  receiveResponse(response) {
    const statusCode = response.statusCode;
    if (!statusCode || statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    switch (this.state) {
      case TransactionState.Trying:
        if (statusCode >= 100 && statusCode <= 199) {
          this.stateTransition(TransactionState.Proceeding);
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState.Completed);
          if (statusCode === 408) {
            this.onRequestTimeout();
            return;
          }
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState.Proceeding:
        if (statusCode >= 100 && statusCode <= 199) {
          if (this.user.receiveResponse) {
            return this.user.receiveResponse(response);
          }
        }
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState.Completed);
          if (statusCode === 408) {
            this.onRequestTimeout();
            return;
          }
          if (this.user.receiveResponse) {
            this.user.receiveResponse(response);
          }
          return;
        }
        break;
      case TransactionState.Completed:
        return;
      case TransactionState.Terminated:
        return;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `Non-INVITE client transaction received unexpected ${statusCode} response while in state ${this.state}.`;
    this.logger.warn(message2);
    return;
  }
  /**
   * The client transaction SHOULD inform the TU that a transport failure has occurred,
   * and the client transaction SHOULD transition directly to the "Terminated" state.
   * The TU will handle the fail over mechanisms described in [4].
   * https://tools.ietf.org/html/rfc3261#section-17.1.4
   * @param error - Transport error
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
    this.stateTransition(TransactionState.Terminated, true);
  }
  /** For logging. */
  typeToString() {
    return "non-INVITE client transaction";
  }
  /**
   * Execute a state transition.
   * @param newState - New state.
   */
  stateTransition(newState, dueToTransportError = false) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState.Trying:
        invalidStateTransition();
        break;
      case TransactionState.Proceeding:
        if (this.state !== TransactionState.Trying) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Completed:
        if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Terminated:
        if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding && this.state !== TransactionState.Completed) {
          if (!dueToTransportError) {
            invalidStateTransition();
          }
        }
        break;
      default:
        invalidStateTransition();
    }
    if (newState === TransactionState.Completed) {
      if (this.F) {
        clearTimeout(this.F);
        this.F = void 0;
      }
      this.K = setTimeout(() => this.timerK(), Timers.TIMER_K);
    }
    if (newState === TransactionState.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * If Timer F fires while the client transaction is still in the
   * "Trying" state, the client transaction SHOULD inform the TU about the
   * timeout, and then it SHOULD enter the "Terminated" state.
   * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
   * a timeout, and the client transaction MUST transition to the terminated state.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
   */
  timerF() {
    this.logger.debug(`Timer F expired for non-INVITE client transaction ${this.id}.`);
    if (this.state === TransactionState.Trying || this.state === TransactionState.Proceeding) {
      this.onRequestTimeout();
      this.stateTransition(TransactionState.Terminated);
    }
  }
  /**
   * If Timer K fires while in this (COMPLETED) state, the client transaction
   * MUST transition to the "Terminated" state.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
   */
  timerK() {
    if (this.state === TransactionState.Completed) {
      this.stateTransition(TransactionState.Terminated);
    }
  }
}
class NonInviteServerTransaction2 extends ServerTransaction2 {
  /**
   * Constructor.
   * After construction the transaction will be in the "trying": state and the transaction
   * `id` will equal the branch parameter set in the Via header of the incoming request.
   * https://tools.ietf.org/html/rfc3261#section-17.2.2
   * @param request - Incoming Non-INVITE request from the transport.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  constructor(request, transport, user) {
    super(request, transport, user, TransactionState.Trying, "sip.transaction.nist");
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.J) {
      clearTimeout(this.J);
      this.J = void 0;
    }
    super.dispose();
  }
  /** Transaction kind. Deprecated. */
  get kind() {
    return "nist";
  }
  /**
   * Receive requests from transport matching this transaction.
   * @param request - Request matching this transaction.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  receiveRequest(request) {
    switch (this.state) {
      case TransactionState.Trying:
        break;
      case TransactionState.Proceeding:
        if (!this.lastResponse) {
          throw new Error("Last response undefined.");
        }
        this.send(this.lastResponse).catch((error) => {
          this.logTransportError(error, "Failed to send retransmission of provisional response.");
        });
        break;
      case TransactionState.Completed:
        if (!this.lastResponse) {
          throw new Error("Last response undefined.");
        }
        this.send(this.lastResponse).catch((error) => {
          this.logTransportError(error, "Failed to send retransmission of final response.");
        });
        break;
      case TransactionState.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
  }
  /**
   * Receive responses from TU for this transaction.
   * @param statusCode - Status code of response. 101-199 not allowed per RFC 4320.
   * @param response - Response to send.
   */
  receiveResponse(statusCode, response) {
    if (statusCode < 100 || statusCode > 699) {
      throw new Error(`Invalid status code ${statusCode}`);
    }
    if (statusCode > 100 && statusCode <= 199) {
      throw new Error("Provisional response other than 100 not allowed.");
    }
    switch (this.state) {
      case TransactionState.Trying:
        this.lastResponse = response;
        if (statusCode >= 100 && statusCode < 200) {
          this.stateTransition(TransactionState.Proceeding);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send provisional response.");
          });
          return;
        }
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState.Completed);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send final response.");
          });
          return;
        }
        break;
      case TransactionState.Proceeding:
        this.lastResponse = response;
        if (statusCode >= 200 && statusCode <= 699) {
          this.stateTransition(TransactionState.Completed);
          this.send(response).catch((error) => {
            this.logTransportError(error, "Failed to send final response.");
          });
          return;
        }
        break;
      case TransactionState.Completed:
        return;
      case TransactionState.Terminated:
        break;
      default:
        throw new Error(`Invalid state ${this.state}`);
    }
    const message2 = `Non-INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;
    this.logger.error(message2);
    throw new Error(message2);
  }
  /**
   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
   * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
   * https://tools.ietf.org/html/rfc3261#section-17.2.4
   */
  onTransportError(error) {
    if (this.user.onTransportError) {
      this.user.onTransportError(error);
    }
    this.stateTransition(TransactionState.Terminated, true);
  }
  /** For logging. */
  typeToString() {
    return "non-INVITE server transaction";
  }
  stateTransition(newState, dueToTransportError = false) {
    const invalidStateTransition = () => {
      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);
    };
    switch (newState) {
      case TransactionState.Trying:
        invalidStateTransition();
        break;
      case TransactionState.Proceeding:
        if (this.state !== TransactionState.Trying) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Completed:
        if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {
          invalidStateTransition();
        }
        break;
      case TransactionState.Terminated:
        if (this.state !== TransactionState.Proceeding && this.state !== TransactionState.Completed) {
          if (!dueToTransportError) {
            invalidStateTransition();
          }
        }
        break;
      default:
        invalidStateTransition();
    }
    if (newState === TransactionState.Completed) {
      this.J = setTimeout(() => this.timerJ(), Timers.TIMER_J);
    }
    if (newState === TransactionState.Terminated) {
      this.dispose();
    }
    this.setState(newState);
  }
  /**
   * The server transaction remains in this state until Timer J fires,
   * at which point it MUST transition to the "Terminated" state.
   * https://tools.ietf.org/html/rfc3261#section-17.2.2
   */
  timerJ() {
    this.logger.debug(`Timer J expired for NON-INVITE server transaction ${this.id}.`);
    if (this.state === TransactionState.Completed) {
      this.stateTransition(TransactionState.Terminated);
    }
  }
}
class UserAgentClient2 {
  constructor(transactionConstructor, core2, message2, delegate) {
    this.transactionConstructor = transactionConstructor;
    this.core = core2;
    this.message = message2;
    this.delegate = delegate;
    this.challenged = false;
    this.stale = false;
    this.logger = this.loggerFactory.getLogger("sip.user-agent-client");
    this.init();
  }
  dispose() {
    this.transaction.dispose();
  }
  get loggerFactory() {
    return this.core.loggerFactory;
  }
  /** The transaction associated with this request. */
  get transaction() {
    if (!this._transaction) {
      throw new Error("Transaction undefined.");
    }
    return this._transaction;
  }
  /**
   * Since requests other than INVITE are responded to immediately, sending a
   * CANCEL for a non-INVITE request would always create a race condition.
   * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
   * https://tools.ietf.org/html/rfc3261#section-9.1
   * @param options - Cancel options bucket.
   */
  cancel(reason, options = {}) {
    if (!this.transaction) {
      throw new Error("Transaction undefined.");
    }
    if (!this.message.to) {
      throw new Error("To undefined.");
    }
    if (!this.message.from) {
      throw new Error("From undefined.");
    }
    const message2 = this.core.makeOutgoingRequestMessage(C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
      toTag: this.message.toTag,
      fromTag: this.message.fromTag,
      callId: this.message.callId,
      cseq: this.message.cseq
    }, options.extraHeaders);
    message2.branch = this.message.branch;
    if (this.message.headers.Route) {
      message2.headers.Route = this.message.headers.Route;
    }
    if (reason) {
      message2.setHeader("Reason", reason);
    }
    if (this.transaction.state === TransactionState.Proceeding) {
      new UserAgentClient2(NonInviteClientTransaction2, this.core, message2);
    } else {
      this.transaction.addStateChangeListener(() => {
        if (this.transaction && this.transaction.state === TransactionState.Proceeding) {
          new UserAgentClient2(NonInviteClientTransaction2, this.core, message2);
        }
      }, { once: true });
    }
    return message2;
  }
  /**
   * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
   * response is received, the UAC SHOULD follow the authorization
   * procedures of Section 22.2 and Section 22.3 to retry the request with
   * credentials.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3.5
   * 22 Usage of HTTP Authentication
   * https://tools.ietf.org/html/rfc3261#section-22
   * 22.1 Framework
   * https://tools.ietf.org/html/rfc3261#section-22.1
   * 22.2 User-to-User Authentication
   * https://tools.ietf.org/html/rfc3261#section-22.2
   * 22.3 Proxy-to-User Authentication
   * https://tools.ietf.org/html/rfc3261#section-22.3
   *
   * FIXME: This "guard for and retry the request with credentials"
   * implementation is not complete and at best minimally passable.
   * @param response - The incoming response to guard.
   * @param dialog - If defined, the dialog within which the response was received.
   * @returns True if the program execution is to continue in the branch in question.
   *          Otherwise the request is retried with credentials and current request processing must stop.
   */
  authenticationGuard(message2, dialog) {
    const statusCode = message2.statusCode;
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    if (statusCode !== 401 && statusCode !== 407) {
      return true;
    }
    let challenge;
    let authorizationHeaderName;
    if (statusCode === 401) {
      challenge = message2.parseHeader("www-authenticate");
      authorizationHeaderName = "authorization";
    } else {
      challenge = message2.parseHeader("proxy-authenticate");
      authorizationHeaderName = "proxy-authorization";
    }
    if (!challenge) {
      this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
      return true;
    }
    if (this.challenged && (this.stale || challenge.stale !== true)) {
      this.logger.warn(statusCode + " apparently in authentication loop, cannot authenticate");
      return true;
    }
    if (!this.credentials) {
      this.credentials = this.core.configuration.authenticationFactory();
      if (!this.credentials) {
        this.logger.warn("Unable to obtain credentials, cannot authenticate");
        return true;
      }
    }
    if (!this.credentials.authenticate(this.message, challenge)) {
      return true;
    }
    this.challenged = true;
    if (challenge.stale) {
      this.stale = true;
    }
    let cseq = this.message.cseq += 1;
    if (dialog && dialog.localSequenceNumber) {
      dialog.incrementLocalSequenceNumber();
      cseq = this.message.cseq = dialog.localSequenceNumber;
    }
    this.message.setHeader("cseq", cseq + " " + this.message.method);
    this.message.setHeader(authorizationHeaderName, this.credentials.toString());
    this.init();
    return false;
  }
  /**
   * 8.1.3.1 Transaction Layer Errors
   * In some cases, the response returned by the transaction layer will
   * not be a SIP message, but rather a transaction layer error.  When a
   * timeout error is received from the transaction layer, it MUST be
   * treated as if a 408 (Request Timeout) status code has been received.
   * If a fatal transport error is reported by the transport layer
   * (generally, due to fatal ICMP errors in UDP or connection failures in
   * TCP), the condition MUST be treated as a 503 (Service Unavailable)
   * status code.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
   */
  onRequestTimeout() {
    this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
    const message2 = new IncomingResponseMessage2();
    message2.statusCode = 408;
    message2.reasonPhrase = "Request Timeout";
    this.receiveResponse(message2);
    return;
  }
  /**
   * 8.1.3.1 Transaction Layer Errors
   * In some cases, the response returned by the transaction layer will
   * not be a SIP message, but rather a transaction layer error.  When a
   * timeout error is received from the transaction layer, it MUST be
   * treated as if a 408 (Request Timeout) status code has been received.
   * If a fatal transport error is reported by the transport layer
   * (generally, due to fatal ICMP errors in UDP or connection failures in
   * TCP), the condition MUST be treated as a 503 (Service Unavailable)
   * status code.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
   * @param error - Transport error
   */
  onTransportError(error) {
    this.logger.error(error.message);
    this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
    const message2 = new IncomingResponseMessage2();
    message2.statusCode = 503;
    message2.reasonPhrase = "Service Unavailable";
    this.receiveResponse(message2);
  }
  /**
   * Receive a response from the transaction layer.
   * @param message - Incoming response message.
   */
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2)) {
      return;
    }
    const statusCode = message2.statusCode ? message2.statusCode.toString() : "";
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    switch (true) {
      case /^100$/.test(statusCode):
        if (this.delegate && this.delegate.onTrying) {
          this.delegate.onTrying({ message: message2 });
        }
        break;
      case /^1[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onProgress) {
          this.delegate.onProgress({ message: message2 });
        }
        break;
      case /^2[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onAccept) {
          this.delegate.onAccept({ message: message2 });
        }
        break;
      case /^3[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onRedirect) {
          this.delegate.onRedirect({ message: message2 });
        }
        break;
      case /^[4-6][0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onReject) {
          this.delegate.onReject({ message: message2 });
        }
        break;
      default:
        throw new Error(`Invalid status code ${statusCode}`);
    }
  }
  init() {
    const user = {
      loggerFactory: this.loggerFactory,
      onRequestTimeout: () => this.onRequestTimeout(),
      onStateChange: (newState) => {
        if (newState === TransactionState.Terminated) {
          this.core.userAgentClients.delete(userAgentClientId);
          if (transaction === this._transaction) {
            this.dispose();
          }
        }
      },
      onTransportError: (error) => this.onTransportError(error),
      receiveResponse: (message2) => this.receiveResponse(message2)
    };
    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);
    this._transaction = transaction;
    const userAgentClientId = transaction.id + transaction.request.method;
    this.core.userAgentClients.set(userAgentClientId, this);
  }
}
class ByeUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.BYE, options);
    super(NonInviteClientTransaction2, dialog.userAgentCore, message2, delegate);
    dialog.dispose();
  }
}
class UserAgentServer2 {
  constructor(transactionConstructor, core2, message2, delegate) {
    this.transactionConstructor = transactionConstructor;
    this.core = core2;
    this.message = message2;
    this.delegate = delegate;
    this.logger = this.loggerFactory.getLogger("sip.user-agent-server");
    this.toTag = message2.toTag ? message2.toTag : newTag();
    this.init();
  }
  dispose() {
    this.transaction.dispose();
  }
  get loggerFactory() {
    return this.core.loggerFactory;
  }
  /** The transaction associated with this request. */
  get transaction() {
    if (!this._transaction) {
      throw new Error("Transaction undefined.");
    }
    return this._transaction;
  }
  accept(options = { statusCode: 200 }) {
    if (!this.acceptable) {
      throw new TransactionStateError2(`${this.message.method} not acceptable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 200 || statusCode > 299) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const response = this.reply(options);
    return response;
  }
  progress(options = { statusCode: 180 }) {
    if (!this.progressable) {
      throw new TransactionStateError2(`${this.message.method} not progressable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 101 || statusCode > 199) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const response = this.reply(options);
    return response;
  }
  redirect(contacts, options = { statusCode: 302 }) {
    if (!this.redirectable) {
      throw new TransactionStateError2(`${this.message.method} not redirectable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 300 || statusCode > 399) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const contactHeaders = new Array();
    contacts.forEach((contact2) => contactHeaders.push(`Contact: ${contact2.toString()}`));
    options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);
    const response = this.reply(options);
    return response;
  }
  reject(options = { statusCode: 480 }) {
    if (!this.rejectable) {
      throw new TransactionStateError2(`${this.message.method} not rejectable in state ${this.transaction.state}.`);
    }
    const statusCode = options.statusCode;
    if (statusCode < 400 || statusCode > 699) {
      throw new TypeError(`Invalid statusCode: ${statusCode}`);
    }
    const response = this.reply(options);
    return response;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trying(options) {
    if (!this.tryingable) {
      throw new TransactionStateError2(`${this.message.method} not tryingable in state ${this.transaction.state}.`);
    }
    const response = this.reply({ statusCode: 100 });
    return response;
  }
  /**
   * If the UAS did not find a matching transaction for the CANCEL
   * according to the procedure above, it SHOULD respond to the CANCEL
   * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction
   * for the original request still exists, the behavior of the UAS on
   * receiving a CANCEL request depends on whether it has already sent a
   * final response for the original request.  If it has, the CANCEL
   * request has no effect on the processing of the original request, no
   * effect on any session state, and no effect on the responses generated
   * for the original request.  If the UAS has not issued a final response
   * for the original request, its behavior depends on the method of the
   * original request.  If the original request was an INVITE, the UAS
   * SHOULD immediately respond to the INVITE with a 487 (Request
   * Terminated).  A CANCEL request has no impact on the processing of
   * transactions with any other method defined in this specification.
   * https://tools.ietf.org/html/rfc3261#section-9.2
   * @param request - Incoming CANCEL request.
   */
  receiveCancel(message2) {
    if (this.delegate && this.delegate.onCancel) {
      this.delegate.onCancel(message2);
    }
  }
  get acceptable() {
    if (this.transaction instanceof InviteServerTransaction2) {
      return this.transaction.state === TransactionState.Proceeding || this.transaction.state === TransactionState.Accepted;
    }
    if (this.transaction instanceof NonInviteServerTransaction2) {
      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;
    }
    throw new Error("Unknown transaction type.");
  }
  get progressable() {
    if (this.transaction instanceof InviteServerTransaction2) {
      return this.transaction.state === TransactionState.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction2) {
      return false;
    }
    throw new Error("Unknown transaction type.");
  }
  get redirectable() {
    if (this.transaction instanceof InviteServerTransaction2) {
      return this.transaction.state === TransactionState.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction2) {
      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;
    }
    throw new Error("Unknown transaction type.");
  }
  get rejectable() {
    if (this.transaction instanceof InviteServerTransaction2) {
      return this.transaction.state === TransactionState.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction2) {
      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;
    }
    throw new Error("Unknown transaction type.");
  }
  get tryingable() {
    if (this.transaction instanceof InviteServerTransaction2) {
      return this.transaction.state === TransactionState.Proceeding;
    }
    if (this.transaction instanceof NonInviteServerTransaction2) {
      return this.transaction.state === TransactionState.Trying;
    }
    throw new Error("Unknown transaction type.");
  }
  /**
   * When a UAS wishes to construct a response to a request, it follows
   * the general procedures detailed in the following subsections.
   * Additional behaviors specific to the response code in question, which
   * are not detailed in this section, may also be required.
   *
   * Once all procedures associated with the creation of a response have
   * been completed, the UAS hands the response back to the server
   * transaction from which it received the request.
   * https://tools.ietf.org/html/rfc3261#section-8.2.6
   * @param statusCode - Status code to reply with.
   * @param options - Reply options bucket.
   */
  reply(options) {
    if (!options.toTag && options.statusCode !== 100) {
      options.toTag = this.toTag;
    }
    options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;
    options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;
    const response = constructOutgoingResponse(this.message, options);
    this.transaction.receiveResponse(options.statusCode, response.message);
    return response;
  }
  init() {
    const user = {
      loggerFactory: this.loggerFactory,
      onStateChange: (newState) => {
        if (newState === TransactionState.Terminated) {
          this.core.userAgentServers.delete(userAgentServerId);
          this.dispose();
        }
      },
      onTransportError: (error) => {
        this.logger.error(error.message);
        if (this.delegate && this.delegate.onTransportError) {
          this.delegate.onTransportError(error);
        } else {
          this.logger.error("User agent server response transport error.");
        }
      }
    };
    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);
    this._transaction = transaction;
    const userAgentServerId = transaction.id;
    this.core.userAgentServers.set(transaction.id, this);
  }
}
class ByeUserAgentServer2 extends UserAgentServer2 {
  constructor(dialog, message2, delegate) {
    super(NonInviteServerTransaction2, dialog.userAgentCore, message2, delegate);
  }
}
class InfoUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.INFO, options);
    super(NonInviteClientTransaction2, dialog.userAgentCore, message2, delegate);
  }
}
class InfoUserAgentServer2 extends UserAgentServer2 {
  constructor(dialog, message2, delegate) {
    super(NonInviteServerTransaction2, dialog.userAgentCore, message2, delegate);
  }
}
class MessageUserAgentClient2 extends UserAgentClient2 {
  constructor(core2, message2, delegate) {
    super(NonInviteClientTransaction2, core2, message2, delegate);
  }
}
class MessageUserAgentServer2 extends UserAgentServer2 {
  constructor(core2, message2, delegate) {
    super(NonInviteServerTransaction2, core2, message2, delegate);
  }
}
class NotifyUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.NOTIFY, options);
    super(NonInviteClientTransaction2, dialog.userAgentCore, message2, delegate);
  }
}
function instanceOfDialog(object) {
  return object.userAgentCore !== void 0;
}
class NotifyUserAgentServer2 extends UserAgentServer2 {
  /**
   * NOTIFY UAS constructor.
   * @param dialogOrCore - Dialog for in dialog NOTIFY, UserAgentCore for out of dialog NOTIFY (deprecated).
   * @param message - Incoming NOTIFY request message.
   */
  constructor(dialogOrCore, message2, delegate) {
    const userAgentCore = instanceOfDialog(dialogOrCore) ? dialogOrCore.userAgentCore : dialogOrCore;
    super(NonInviteServerTransaction2, userAgentCore, message2, delegate);
  }
}
class PrackUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.PRACK, options);
    super(NonInviteClientTransaction2, dialog.userAgentCore, message2, delegate);
    dialog.signalingStateTransition(message2);
  }
}
class PrackUserAgentServer2 extends UserAgentServer2 {
  constructor(dialog, message2, delegate) {
    super(NonInviteServerTransaction2, dialog.userAgentCore, message2, delegate);
    dialog.signalingStateTransition(message2);
    this.dialog = dialog;
  }
  /**
   * Update the dialog signaling state on a 2xx response.
   * @param options - Options bucket.
   */
  accept(options = { statusCode: 200 }) {
    if (options.body) {
      this.dialog.signalingStateTransition(options.body);
    }
    return super.accept(options);
  }
}
class ReInviteUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.INVITE, options);
    super(InviteClientTransaction2, dialog.userAgentCore, message2, delegate);
    this.delegate = delegate;
    dialog.signalingStateTransition(message2);
    dialog.reinviteUserAgentClient = this;
    this.dialog = dialog;
  }
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2, this.dialog)) {
      return;
    }
    const statusCode = message2.statusCode ? message2.statusCode.toString() : "";
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    switch (true) {
      case /^100$/.test(statusCode):
        if (this.delegate && this.delegate.onTrying) {
          this.delegate.onTrying({ message: message2 });
        }
        break;
      case /^1[0-9]{2}$/.test(statusCode):
        if (this.delegate && this.delegate.onProgress) {
          this.delegate.onProgress({
            message: message2,
            session: this.dialog,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            prack: (options) => {
              throw new Error("Unimplemented.");
            }
          });
        }
        break;
      case /^2[0-9]{2}$/.test(statusCode):
        this.dialog.signalingStateTransition(message2);
        if (this.delegate && this.delegate.onAccept) {
          this.delegate.onAccept({
            message: message2,
            session: this.dialog,
            ack: (options) => {
              const outgoingAckRequest = this.dialog.ack(options);
              return outgoingAckRequest;
            }
          });
        }
        break;
      case /^3[0-9]{2}$/.test(statusCode):
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentClient = void 0;
        if (this.delegate && this.delegate.onRedirect) {
          this.delegate.onRedirect({ message: message2 });
        }
        break;
      case /^[4-6][0-9]{2}$/.test(statusCode):
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentClient = void 0;
        if (this.delegate && this.delegate.onReject) {
          this.delegate.onReject({ message: message2 });
        }
        break;
      default:
        throw new Error(`Invalid status code ${statusCode}`);
    }
  }
}
class ReInviteUserAgentServer2 extends UserAgentServer2 {
  constructor(dialog, message2, delegate) {
    super(InviteServerTransaction2, dialog.userAgentCore, message2, delegate);
    dialog.reinviteUserAgentServer = this;
    this.dialog = dialog;
  }
  /**
   * Update the dialog signaling state on a 2xx response.
   * @param options - Options bucket.
   */
  accept(options = { statusCode: 200 }) {
    options.extraHeaders = options.extraHeaders || [];
    options.extraHeaders = options.extraHeaders.concat(this.dialog.routeSet.map((route) => `Record-Route: ${route}`));
    const response = super.accept(options);
    const session2 = this.dialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      this.dialog.signalingStateTransition(options.body);
    }
    this.dialog.reConfirm();
    return result;
  }
  /**
   * Update the dialog signaling state on a 1xx response.
   * @param options - Progress options bucket.
   */
  progress(options = { statusCode: 180 }) {
    const response = super.progress(options);
    const session2 = this.dialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      this.dialog.signalingStateTransition(options.body);
    }
    return result;
  }
  /**
   * TODO: Not Yet Supported
   * @param contacts - Contacts to redirect to.
   * @param options - Redirect options bucket.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  redirect(contacts, options = { statusCode: 302 }) {
    this.dialog.signalingStateRollback();
    this.dialog.reinviteUserAgentServer = void 0;
    throw new Error("Unimplemented.");
  }
  /**
   * 3.1 Background on Re-INVITE Handling by UASs
   * An error response to a re-INVITE has the following semantics.  As
   * specified in Section 12.2.2 of RFC 3261 [RFC3261], if a re-INVITE is
   * rejected, no state changes are performed.
   * https://tools.ietf.org/html/rfc6141#section-3.1
   * @param options - Reject options bucket.
   */
  reject(options = { statusCode: 488 }) {
    this.dialog.signalingStateRollback();
    this.dialog.reinviteUserAgentServer = void 0;
    return super.reject(options);
  }
}
class ReferUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.REFER, options);
    super(NonInviteClientTransaction2, dialog.userAgentCore, message2, delegate);
  }
}
function instanceOfSessionDialog(object) {
  return object.userAgentCore !== void 0;
}
class ReferUserAgentServer2 extends UserAgentServer2 {
  /**
   * REFER UAS constructor.
   * @param dialogOrCore - Dialog for in dialog REFER, UserAgentCore for out of dialog REFER.
   * @param message - Incoming REFER request message.
   */
  constructor(dialogOrCore, message2, delegate) {
    const userAgentCore = instanceOfSessionDialog(dialogOrCore) ? dialogOrCore.userAgentCore : dialogOrCore;
    super(NonInviteServerTransaction2, userAgentCore, message2, delegate);
  }
}
class SessionDialog2 extends Dialog2 {
  constructor(initialTransaction, core2, state, delegate) {
    super(core2, state);
    this.initialTransaction = initialTransaction;
    this._signalingState = SignalingState.Initial;
    this.ackWait = false;
    this.ackProcessing = false;
    this.delegate = delegate;
    if (initialTransaction instanceof InviteServerTransaction2) {
      this.ackWait = true;
    }
    if (!this.early) {
      this.start2xxRetransmissionTimer();
    }
    this.signalingStateTransition(initialTransaction.request);
    this.logger = core2.loggerFactory.getLogger("sip.invite-dialog");
    this.logger.log(`INVITE dialog ${this.id} constructed`);
  }
  dispose() {
    super.dispose();
    this._signalingState = SignalingState.Closed;
    this._offer = void 0;
    this._answer = void 0;
    if (this.invite2xxTimer) {
      clearTimeout(this.invite2xxTimer);
      this.invite2xxTimer = void 0;
    }
    this.logger.log(`INVITE dialog ${this.id} destroyed`);
  }
  // FIXME: Need real state machine
  get sessionState() {
    if (this.early) {
      return SessionState$1.Early;
    } else if (this.ackWait) {
      return SessionState$1.AckWait;
    } else if (this._signalingState === SignalingState.Closed) {
      return SessionState$1.Terminated;
    } else {
      return SessionState$1.Confirmed;
    }
  }
  /** The state of the offer/answer exchange. */
  get signalingState() {
    return this._signalingState;
  }
  /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */
  get offer() {
    return this._offer;
  }
  /** The current answer. Undefined unless signaling state Stable. */
  get answer() {
    return this._answer;
  }
  /** Confirm the dialog. Only matters if dialog is currently early. */
  confirm() {
    if (this.early) {
      this.start2xxRetransmissionTimer();
    }
    super.confirm();
  }
  /** Re-confirm the dialog. Only matters if handling re-INVITE request. */
  reConfirm() {
    if (this.reinviteUserAgentServer) {
      this.startReInvite2xxRetransmissionTimer();
    }
  }
  /**
   * The UAC core MUST generate an ACK request for each 2xx received from
   * the transaction layer.  The header fields of the ACK are constructed
   * in the same way as for any request sent within a dialog (see Section
   * 12) with the exception of the CSeq and the header fields related to
   * authentication.  The sequence number of the CSeq header field MUST be
   * the same as the INVITE being acknowledged, but the CSeq method MUST
   * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
   * the 2xx contains an offer (based on the rules above), the ACK MUST
   * carry an answer in its body.  If the offer in the 2xx response is not
   * acceptable, the UAC core MUST generate a valid answer in the ACK and
   * then send a BYE immediately.
   * https://tools.ietf.org/html/rfc3261#section-13.2.2.4
   * @param options - ACK options bucket.
   */
  ack(options = {}) {
    this.logger.log(`INVITE dialog ${this.id} sending ACK request`);
    let transaction;
    if (this.reinviteUserAgentClient) {
      if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction2)) {
        throw new Error("Transaction not instance of InviteClientTransaction.");
      }
      transaction = this.reinviteUserAgentClient.transaction;
      this.reinviteUserAgentClient = void 0;
    } else {
      if (!(this.initialTransaction instanceof InviteClientTransaction2)) {
        throw new Error("Initial transaction not instance of InviteClientTransaction.");
      }
      transaction = this.initialTransaction;
    }
    const message2 = this.createOutgoingRequestMessage(C.ACK, {
      cseq: transaction.request.cseq,
      extraHeaders: options.extraHeaders,
      body: options.body
    });
    transaction.ackResponse(message2);
    this.signalingStateTransition(message2);
    return { message: message2 };
  }
  /**
   * Terminating a Session
   *
   * This section describes the procedures for terminating a session
   * established by SIP.  The state of the session and the state of the
   * dialog are very closely related.  When a session is initiated with an
   * INVITE, each 1xx or 2xx response from a distinct UAS creates a
   * dialog, and if that response completes the offer/answer exchange, it
   * also creates a session.  As a result, each session is "associated"
   * with a single dialog - the one which resulted in its creation.  If an
   * initial INVITE generates a non-2xx final response, that terminates
   * all sessions (if any) and all dialogs (if any) that were created
   * through responses to the request.  By virtue of completing the
   * transaction, a non-2xx final response also prevents further sessions
   * from being created as a result of the INVITE.  The BYE request is
   * used to terminate a specific session or attempted session.  In this
   * case, the specific session is the one with the peer UA on the other
   * side of the dialog.  When a BYE is received on a dialog, any session
   * associated with that dialog SHOULD terminate.  A UA MUST NOT send a
   * BYE outside of a dialog.  The caller's UA MAY send a BYE for either
   * confirmed or early dialogs, and the callee's UA MAY send a BYE on
   * confirmed dialogs, but MUST NOT send a BYE on early dialogs.
   *
   * However, the callee's UA MUST NOT send a BYE on a confirmed dialog
   * until it has received an ACK for its 2xx response or until the server
   * transaction times out.  If no SIP extensions have defined other
   * application layer states associated with the dialog, the BYE also
   * terminates the dialog.
   *
   * https://tools.ietf.org/html/rfc3261#section-15
   * FIXME: Make these proper Exceptions...
   * @param options - BYE options bucket.
   * @returns
   * Throws `Error` if callee's UA attempts a BYE on an early dialog.
   * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog
   *                while it's waiting on the ACK for its 2xx response.
   */
  bye(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending BYE request`);
    if (this.initialTransaction instanceof InviteServerTransaction2) {
      if (this.early) {
        throw new Error("UAS MUST NOT send a BYE on early dialogs.");
      }
      if (this.ackWait && this.initialTransaction.state !== TransactionState.Terminated) {
        throw new Error("UAS MUST NOT send a BYE on a confirmed dialog until it has received an ACK for its 2xx response or until the server transaction times out.");
      }
    }
    return new ByeUserAgentClient2(this, delegate, options);
  }
  /**
   * An INFO request can be associated with an Info Package (see
   * Section 5), or associated with a legacy INFO usage (see Section 2).
   *
   * The construction of the INFO request is the same as any other
   * non-target refresh request within an existing invite dialog usage as
   * described in Section 12.2 of RFC 3261.
   * https://tools.ietf.org/html/rfc6086#section-4.2.1
   * @param options - Options bucket.
   */
  info(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending INFO request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    return new InfoUserAgentClient2(this, delegate, options);
  }
  /**
   * Modifying an Existing Session
   *
   * A successful INVITE request (see Section 13) establishes both a
   * dialog between two user agents and a session using the offer-answer
   * model.  Section 12 explains how to modify an existing dialog using a
   * target refresh request (for example, changing the remote target URI
   * of the dialog).  This section describes how to modify the actual
   * session.  This modification can involve changing addresses or ports,
   * adding a media stream, deleting a media stream, and so on.  This is
   * accomplished by sending a new INVITE request within the same dialog
   * that established the session.  An INVITE request sent within an
   * existing dialog is known as a re-INVITE.
   *
   *    Note that a single re-INVITE can modify the dialog and the
   *    parameters of the session at the same time.
   *
   * Either the caller or callee can modify an existing session.
   * https://tools.ietf.org/html/rfc3261#section-14
   * @param options - Options bucket
   */
  invite(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending INVITE request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    if (this.reinviteUserAgentClient) {
      throw new Error("There is an ongoing re-INVITE client transaction.");
    }
    if (this.reinviteUserAgentServer) {
      throw new Error("There is an ongoing re-INVITE server transaction.");
    }
    return new ReInviteUserAgentClient2(this, delegate, options);
  }
  /**
   * A UAC MAY associate a MESSAGE request with an existing dialog.  If a
   * MESSAGE request is sent within a dialog, it is "associated" with any
   * media session or sessions associated with that dialog.
   * https://tools.ietf.org/html/rfc3428#section-4
   * @param options - Options bucket.
   */
  message(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    const message2 = this.createOutgoingRequestMessage(C.MESSAGE, options);
    return new MessageUserAgentClient2(this.core, message2, delegate);
  }
  /**
   * The NOTIFY mechanism defined in [2] MUST be used to inform the agent
   * sending the REFER of the status of the reference.
   * https://tools.ietf.org/html/rfc3515#section-2.4.4
   * @param options - Options bucket.
   */
  notify(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    return new NotifyUserAgentClient2(this, delegate, options);
  }
  /**
   * Assuming the response is to be transmitted reliably, the UAC MUST
   * create a new request with method PRACK.  This request is sent within
   * the dialog associated with the provisional response (indeed, the
   * provisional response may have created the dialog).  PRACK requests
   * MAY contain bodies, which are interpreted according to their type and
   * disposition.
   * https://tools.ietf.org/html/rfc3262#section-4
   * @param options - Options bucket.
   */
  prack(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending PRACK request`);
    return new PrackUserAgentClient2(this, delegate, options);
  }
  /**
   * REFER is a SIP request and is constructed as defined in [1].  A REFER
   * request MUST contain exactly one Refer-To header field value.
   * https://tools.ietf.org/html/rfc3515#section-2.4.1
   * @param options - Options bucket.
   */
  refer(delegate, options) {
    this.logger.log(`INVITE dialog ${this.id} sending REFER request`);
    if (this.early) {
      throw new Error("Dialog not confirmed.");
    }
    return new ReferUserAgentClient2(this, delegate, options);
  }
  /**
   * Requests sent within a dialog, as any other requests, are atomic.  If
   * a particular request is accepted by the UAS, all the state changes
   * associated with it are performed.  If the request is rejected, none
   * of the state changes are performed.
   * https://tools.ietf.org/html/rfc3261#section-12.2.2
   * @param message - Incoming request message within this dialog.
   */
  receiveRequest(message2) {
    this.logger.log(`INVITE dialog ${this.id} received ${message2.method} request`);
    if (message2.method === C.ACK) {
      if (this.ackWait) {
        if (this.initialTransaction instanceof InviteClientTransaction2) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        if (this.initialTransaction.request.cseq !== message2.cseq) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        this.ackWait = false;
      } else {
        if (!this.reinviteUserAgentServer) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        if (this.reinviteUserAgentServer.transaction.request.cseq !== message2.cseq) {
          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message2.method} request, dropping.`);
          return;
        }
        this.reinviteUserAgentServer = void 0;
      }
      this.signalingStateTransition(message2);
      if (this.delegate && this.delegate.onAck) {
        const promiseOrVoid = this.delegate.onAck({ message: message2 });
        if (promiseOrVoid instanceof Promise) {
          this.ackProcessing = true;
          promiseOrVoid.then(() => this.ackProcessing = false).catch(() => this.ackProcessing = false);
        }
      }
      return;
    }
    if (!this.sequenceGuard(message2)) {
      this.logger.log(`INVITE dialog ${this.id} rejected out of order ${message2.method} request.`);
      return;
    }
    super.receiveRequest(message2);
    if (message2.method === C.INVITE) {
      const warning2 = () => {
        const reason = this.ackWait ? "waiting for initial ACK" : "processing initial ACK";
        this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${reason}`);
        let msg = "RFC 5407 suggests the following to avoid this race condition... ";
        msg += " Note: Implementation issues are outside the scope of this document,";
        msg += " but the following tip is provided for avoiding race conditions of";
        msg += " this type.  The caller can delay sending re-INVITE F6 for some period";
        msg += " of time (2 seconds, perhaps), after which the caller can reasonably";
        msg += " assume that its ACK has been received.  Implementors can decouple the";
        msg += " actions of the user (e.g., pressing the hold button) from the actions";
        msg += " of the protocol (the sending of re-INVITE F6), so that the UA can";
        msg += " behave like this.  In this case, it is the implementor's choice as to";
        msg += " how long to wait.  In most cases, such an implementation may be";
        msg += " useful to prevent the type of race condition shown in this section.";
        msg += " This document expresses no preference about whether or not they";
        msg += " should wait for an ACK to be delivered.  After considering the impact";
        msg += " on user experience, implementors should decide whether or not to wait";
        msg += " for a while, because the user experience depends on the";
        msg += " implementation and has no direct bearing on protocol behavior.";
        this.logger.warn(msg);
        return;
      };
      const retryAfter = Math.floor(Math.random() * 10) + 1;
      const extraHeaders = [`Retry-After: ${retryAfter}`];
      if (this.ackProcessing) {
        this.core.replyStateless(message2, { statusCode: 500, extraHeaders });
        warning2();
        return;
      }
      if (this.ackWait && this.signalingState !== SignalingState.Stable) {
        this.core.replyStateless(message2, { statusCode: 500, extraHeaders });
        warning2();
        return;
      }
      if (this.reinviteUserAgentServer) {
        this.core.replyStateless(message2, { statusCode: 500, extraHeaders });
        return;
      }
      if (this.reinviteUserAgentClient) {
        this.core.replyStateless(message2, { statusCode: 491 });
        return;
      }
    }
    if (message2.method === C.INVITE) {
      const contact2 = message2.parseHeader("contact");
      if (!contact2) {
        throw new Error("Contact undefined.");
      }
      if (!(contact2 instanceof NameAddrHeader2)) {
        throw new Error("Contact not instance of NameAddrHeader.");
      }
      this.dialogState.remoteTarget = contact2.uri;
    }
    switch (message2.method) {
      case C.BYE:
        {
          const uas = new ByeUserAgentServer2(this, message2);
          this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();
          this.dispose();
        }
        break;
      case C.INFO:
        {
          const uas = new InfoUserAgentServer2(this, message2);
          this.delegate && this.delegate.onInfo ? this.delegate.onInfo(uas) : uas.reject({
            statusCode: 469,
            extraHeaders: ["Recv-Info:"]
          });
        }
        break;
      case C.INVITE:
        {
          const uas = new ReInviteUserAgentServer2(this, message2);
          this.signalingStateTransition(message2);
          this.delegate && this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject({ statusCode: 488 });
        }
        break;
      case C.MESSAGE:
        {
          const uas = new MessageUserAgentServer2(this.core, message2);
          this.delegate && this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();
        }
        break;
      case C.NOTIFY:
        {
          const uas = new NotifyUserAgentServer2(this, message2);
          this.delegate && this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.accept();
        }
        break;
      case C.PRACK:
        {
          const uas = new PrackUserAgentServer2(this, message2);
          this.delegate && this.delegate.onPrack ? this.delegate.onPrack(uas) : uas.accept();
        }
        break;
      case C.REFER:
        {
          const uas = new ReferUserAgentServer2(this, message2);
          this.delegate && this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject();
        }
        break;
      case C.UPDATE:
        {
          this.logger.log(`INVITE dialog ${this.id} received ${message2.method} request, 处理 UPDATE method`);
          this.core.replyStateless(message2, { statusCode: 200 });
        }
        break;
      default:
        {
          this.logger.log(`INVITE dialog ${this.id} received unimplemented ${message2.method} request`);
          this.core.replyStateless(message2, { statusCode: 501 });
        }
        break;
    }
  }
  /**
   * Guard against out of order reliable provisional responses and retransmissions.
   * Returns false if the response should be discarded, otherwise true.
   * @param message - Incoming response message within this dialog.
   */
  reliableSequenceGuard(message2) {
    const statusCode = message2.statusCode;
    if (!statusCode) {
      throw new Error("Status code undefined");
    }
    if (statusCode > 100 && statusCode < 200) {
      const requireHeader = message2.getHeader("require");
      const rseqHeader = message2.getHeader("rseq");
      const rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : void 0;
      if (rseq) {
        if (this.rseq && this.rseq + 1 !== rseq) {
          return false;
        }
        this.rseq = this.rseq ? this.rseq + 1 : rseq;
      }
    }
    return true;
  }
  /**
   * If not in a stable signaling state, rollback to prior stable signaling state.
   */
  signalingStateRollback() {
    if (this._signalingState === SignalingState.HaveLocalOffer || this.signalingState === SignalingState.HaveRemoteOffer) {
      if (this._rollbackOffer && this._rollbackAnswer) {
        this._signalingState = SignalingState.Stable;
        this._offer = this._rollbackOffer;
        this._answer = this._rollbackAnswer;
      }
    }
  }
  /**
   * Update the signaling state of the dialog.
   * @param message - The message to base the update off of.
   */
  signalingStateTransition(message2) {
    const body = getBody(message2);
    if (!body || body.contentDisposition !== "session") {
      return;
    }
    if (this._signalingState === SignalingState.Stable) {
      this._rollbackOffer = this._offer;
      this._rollbackAnswer = this._answer;
    }
    if (message2 instanceof IncomingRequestMessage2) {
      switch (this._signalingState) {
        case SignalingState.Initial:
        case SignalingState.Stable:
          this._signalingState = SignalingState.HaveRemoteOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState.HaveLocalOffer:
          this._signalingState = SignalingState.Stable;
          this._answer = body;
          break;
        case SignalingState.HaveRemoteOffer:
          break;
        case SignalingState.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
    if (message2 instanceof IncomingResponseMessage2) {
      switch (this._signalingState) {
        case SignalingState.Initial:
        case SignalingState.Stable:
          this._signalingState = SignalingState.HaveRemoteOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState.HaveLocalOffer:
          this._signalingState = SignalingState.Stable;
          this._answer = body;
          break;
        case SignalingState.HaveRemoteOffer:
          break;
        case SignalingState.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
    if (message2 instanceof OutgoingRequestMessage2) {
      switch (this._signalingState) {
        case SignalingState.Initial:
        case SignalingState.Stable:
          this._signalingState = SignalingState.HaveLocalOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState.HaveLocalOffer:
          break;
        case SignalingState.HaveRemoteOffer:
          this._signalingState = SignalingState.Stable;
          this._answer = body;
          break;
        case SignalingState.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
    if (isBody(message2)) {
      switch (this._signalingState) {
        case SignalingState.Initial:
        case SignalingState.Stable:
          this._signalingState = SignalingState.HaveLocalOffer;
          this._offer = body;
          this._answer = void 0;
          break;
        case SignalingState.HaveLocalOffer:
          break;
        case SignalingState.HaveRemoteOffer:
          this._signalingState = SignalingState.Stable;
          this._answer = body;
          break;
        case SignalingState.Closed:
          break;
        default:
          throw new Error("Unexpected signaling state.");
      }
    }
  }
  start2xxRetransmissionTimer() {
    if (this.initialTransaction instanceof InviteServerTransaction2) {
      const transaction = this.initialTransaction;
      let timeout2 = Timers.T1;
      const retransmission = () => {
        if (!this.ackWait) {
          this.invite2xxTimer = void 0;
          return;
        }
        this.logger.log("No ACK for 2xx response received, attempting retransmission");
        transaction.retransmitAcceptedResponse();
        timeout2 = Math.min(timeout2 * 2, Timers.T2);
        this.invite2xxTimer = setTimeout(retransmission, timeout2);
      };
      this.invite2xxTimer = setTimeout(retransmission, timeout2);
      const stateChanged = () => {
        if (transaction.state === TransactionState.Terminated) {
          transaction.removeStateChangeListener(stateChanged);
          if (this.invite2xxTimer) {
            clearTimeout(this.invite2xxTimer);
            this.invite2xxTimer = void 0;
          }
          if (this.ackWait) {
            if (this.delegate && this.delegate.onAckTimeout) {
              this.delegate.onAckTimeout();
            } else {
              this.bye();
            }
          }
        }
      };
      transaction.addStateChangeListener(stateChanged);
    }
  }
  // FIXME: Refactor
  startReInvite2xxRetransmissionTimer() {
    if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction2) {
      const transaction = this.reinviteUserAgentServer.transaction;
      let timeout2 = Timers.T1;
      const retransmission = () => {
        if (!this.reinviteUserAgentServer) {
          this.invite2xxTimer = void 0;
          return;
        }
        this.logger.log("No ACK for 2xx response received, attempting retransmission");
        transaction.retransmitAcceptedResponse();
        timeout2 = Math.min(timeout2 * 2, Timers.T2);
        this.invite2xxTimer = setTimeout(retransmission, timeout2);
      };
      this.invite2xxTimer = setTimeout(retransmission, timeout2);
      const stateChanged = () => {
        if (transaction.state === TransactionState.Terminated) {
          transaction.removeStateChangeListener(stateChanged);
          if (this.invite2xxTimer) {
            clearTimeout(this.invite2xxTimer);
            this.invite2xxTimer = void 0;
          }
          if (this.reinviteUserAgentServer) ;
        }
      };
      transaction.addStateChangeListener(stateChanged);
    }
  }
}
var SubscriptionState$1;
(function(SubscriptionState2) {
  SubscriptionState2["Initial"] = "Initial";
  SubscriptionState2["NotifyWait"] = "NotifyWait";
  SubscriptionState2["Pending"] = "Pending";
  SubscriptionState2["Active"] = "Active";
  SubscriptionState2["Terminated"] = "Terminated";
})(SubscriptionState$1 || (SubscriptionState$1 = {}));
const AllowedMethods = [
  C.ACK,
  C.BYE,
  C.CANCEL,
  C.INFO,
  C.INVITE,
  C.MESSAGE,
  C.NOTIFY,
  C.OPTIONS,
  C.PRACK,
  C.REFER,
  C.REGISTER,
  C.UPDATE,
  C.SUBSCRIBE
];
class ReSubscribeUserAgentClient2 extends UserAgentClient2 {
  constructor(dialog, delegate, options) {
    const message2 = dialog.createOutgoingRequestMessage(C.SUBSCRIBE, options);
    super(NonInviteClientTransaction2, dialog.userAgentCore, message2, delegate);
    this.dialog = dialog;
  }
  waitNotifyStop() {
    return;
  }
  /**
   * Receive a response from the transaction layer.
   * @param message - Incoming response message.
   */
  receiveResponse(message2) {
    if (message2.statusCode && message2.statusCode >= 200 && message2.statusCode < 300) {
      const expires = message2.getHeader("Expires");
      if (!expires) {
        this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
      } else {
        const subscriptionExpiresReceived = Number(expires);
        if (this.dialog.subscriptionExpires > subscriptionExpiresReceived) {
          this.dialog.subscriptionExpires = subscriptionExpiresReceived;
        }
      }
    }
    if (message2.statusCode && message2.statusCode >= 400 && message2.statusCode < 700) {
      const errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];
      if (errorCodes.includes(message2.statusCode)) {
        this.dialog.terminate();
      }
    }
    super.receiveResponse(message2);
  }
}
class SubscriptionDialog2 extends Dialog2 {
  constructor(subscriptionEvent, subscriptionExpires, subscriptionState, core2, state, delegate) {
    super(core2, state);
    this.delegate = delegate;
    this._autoRefresh = false;
    this._subscriptionEvent = subscriptionEvent;
    this._subscriptionExpires = subscriptionExpires;
    this._subscriptionExpiresInitial = subscriptionExpires;
    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1e3);
    this._subscriptionRefresh = void 0;
    this._subscriptionRefreshLastSet = void 0;
    this._subscriptionState = subscriptionState;
    this.logger = core2.loggerFactory.getLogger("sip.subscribe-dialog");
    this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);
  }
  /**
   * When a UAC receives a response that establishes a dialog, it
   * constructs the state of the dialog.  This state MUST be maintained
   * for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.2
   * @param outgoingRequestMessage - Outgoing request message for dialog.
   * @param incomingResponseMessage - Incoming response message creating dialog.
   */
  static initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {
    const secure = false;
    const routeSet = incomingNotifyRequestMessage.getHeaders("record-route");
    const contact2 = incomingNotifyRequestMessage.parseHeader("contact");
    if (!contact2) {
      throw new Error("Contact undefined.");
    }
    if (!(contact2 instanceof NameAddrHeader2)) {
      throw new Error("Contact not instance of NameAddrHeader.");
    }
    const remoteTarget = contact2.uri;
    const localSequenceNumber = outgoingSubscribeRequestMessage.cseq;
    const remoteSequenceNumber = void 0;
    const callId = outgoingSubscribeRequestMessage.callId;
    const localTag = outgoingSubscribeRequestMessage.fromTag;
    const remoteTag = incomingNotifyRequestMessage.fromTag;
    if (!callId) {
      throw new Error("Call id undefined.");
    }
    if (!localTag) {
      throw new Error("From tag undefined.");
    }
    if (!remoteTag) {
      throw new Error("To tag undefined.");
    }
    if (!outgoingSubscribeRequestMessage.from) {
      throw new Error("From undefined.");
    }
    if (!outgoingSubscribeRequestMessage.to) {
      throw new Error("To undefined.");
    }
    const localURI = outgoingSubscribeRequestMessage.from.uri;
    const remoteURI = outgoingSubscribeRequestMessage.to.uri;
    const early = false;
    const dialogState = {
      id: callId + localTag + remoteTag,
      early,
      callId,
      localTag,
      remoteTag,
      localSequenceNumber,
      remoteSequenceNumber,
      localURI,
      remoteURI,
      remoteTarget,
      routeSet,
      secure
    };
    return dialogState;
  }
  dispose() {
    super.dispose();
    if (this.N) {
      clearTimeout(this.N);
      this.N = void 0;
    }
    this.refreshTimerClear();
    this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);
  }
  get autoRefresh() {
    return this._autoRefresh;
  }
  set autoRefresh(autoRefresh) {
    this._autoRefresh = true;
    this.refreshTimerSet();
  }
  get subscriptionEvent() {
    return this._subscriptionEvent;
  }
  /** Number of seconds until subscription expires. */
  get subscriptionExpires() {
    const secondsSinceLastSet = Math.floor(Date.now() / 1e3) - this._subscriptionExpiresLastSet;
    const secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;
    return Math.max(secondsUntilExpires, 0);
  }
  set subscriptionExpires(expires) {
    if (expires < 0) {
      throw new Error("Expires must be greater than or equal to zero.");
    }
    this._subscriptionExpires = expires;
    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1e3);
    if (this.autoRefresh) {
      const refresh = this.subscriptionRefresh;
      if (refresh === void 0 || refresh >= expires) {
        this.refreshTimerSet();
      }
    }
  }
  get subscriptionExpiresInitial() {
    return this._subscriptionExpiresInitial;
  }
  /** Number of seconds until subscription auto refresh. */
  get subscriptionRefresh() {
    if (this._subscriptionRefresh === void 0 || this._subscriptionRefreshLastSet === void 0) {
      return void 0;
    }
    const secondsSinceLastSet = Math.floor(Date.now() / 1e3) - this._subscriptionRefreshLastSet;
    const secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;
    return Math.max(secondsUntilExpires, 0);
  }
  get subscriptionState() {
    return this._subscriptionState;
  }
  /**
   * Receive in dialog request message from transport.
   * @param message -  The incoming request message.
   */
  receiveRequest(message2) {
    this.logger.log(`SUBSCRIBE dialog ${this.id} received ${message2.method} request`);
    if (!this.sequenceGuard(message2)) {
      this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${message2.method} request.`);
      return;
    }
    super.receiveRequest(message2);
    switch (message2.method) {
      case C.NOTIFY:
        this.onNotify(message2);
        break;
      default:
        this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${message2.method} request`);
        this.core.replyStateless(message2, { statusCode: 501 });
        break;
    }
  }
  /**
   * 4.1.2.2.  Refreshing of Subscriptions
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
   */
  refresh() {
    const allowHeader = "Allow: " + AllowedMethods.toString();
    const options = {};
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.extraHeaders.push(allowHeader);
    options.extraHeaders.push("Event: " + this.subscriptionEvent);
    options.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial);
    options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
    return this.subscribe(void 0, options);
  }
  /**
   * 4.1.2.2.  Refreshing of Subscriptions
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
   * @param delegate - Delegate to handle responses.
   * @param options - Options bucket.
   */
  subscribe(delegate, options = {}) {
    if (this.subscriptionState !== SubscriptionState$1.Pending && this.subscriptionState !== SubscriptionState$1.Active) {
      throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state "pending" or "active".`);
    }
    this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);
    const uac = new ReSubscribeUserAgentClient2(this, delegate, options);
    if (this.N) {
      clearTimeout(this.N);
      this.N = void 0;
    }
    this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);
    return uac;
  }
  /**
   * 4.4.1.  Dialog Creation and Termination
   * A subscription is destroyed after a notifier sends a NOTIFY request
   * with a "Subscription-State" of "terminated", or in certain error
   * situations described elsewhere in this document.
   * https://tools.ietf.org/html/rfc6665#section-4.4.1
   */
  terminate() {
    this.stateTransition(SubscriptionState$1.Terminated);
    this.onTerminated();
  }
  /**
   * 4.1.2.3.  Unsubscribing
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.3
   */
  unsubscribe() {
    const allowHeader = "Allow: " + AllowedMethods.toString();
    const options = {};
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.extraHeaders.push(allowHeader);
    options.extraHeaders.push("Event: " + this.subscriptionEvent);
    options.extraHeaders.push("Expires: 0");
    options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
    return this.subscribe(void 0, options);
  }
  /**
   * Handle in dialog NOTIFY requests.
   * This does not include the first NOTIFY which created the dialog.
   * @param message - The incoming NOTIFY request message.
   */
  onNotify(message2) {
    const event = message2.parseHeader("Event").event;
    if (!event || event !== this.subscriptionEvent) {
      this.core.replyStateless(message2, { statusCode: 489 });
      return;
    }
    if (this.N) {
      clearTimeout(this.N);
      this.N = void 0;
    }
    const subscriptionState = message2.parseHeader("Subscription-State");
    if (!subscriptionState || !subscriptionState.state) {
      this.core.replyStateless(message2, { statusCode: 489 });
      return;
    }
    const state = subscriptionState.state;
    const expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : void 0;
    switch (state) {
      case "pending":
        this.stateTransition(SubscriptionState$1.Pending, expires);
        break;
      case "active":
        this.stateTransition(SubscriptionState$1.Active, expires);
        break;
      case "terminated":
        this.stateTransition(SubscriptionState$1.Terminated, expires);
        break;
      default:
        this.logger.warn("Unrecognized subscription state.");
        break;
    }
    const uas = new NotifyUserAgentServer2(this, message2);
    if (this.delegate && this.delegate.onNotify) {
      this.delegate.onNotify(uas);
    } else {
      uas.accept();
    }
  }
  onRefresh(request) {
    if (this.delegate && this.delegate.onRefresh) {
      this.delegate.onRefresh(request);
    }
  }
  onTerminated() {
    if (this.delegate && this.delegate.onTerminated) {
      this.delegate.onTerminated();
    }
  }
  refreshTimerClear() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = void 0;
    }
  }
  refreshTimerSet() {
    this.refreshTimerClear();
    if (this.autoRefresh && this.subscriptionExpires > 0) {
      const refresh = this.subscriptionExpires * 900;
      this._subscriptionRefresh = Math.floor(refresh / 1e3);
      this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1e3);
      this.refreshTimer = setTimeout(() => {
        this.refreshTimer = void 0;
        this._subscriptionRefresh = void 0;
        this._subscriptionRefreshLastSet = void 0;
        this.onRefresh(this.refresh());
      }, refresh);
    }
  }
  stateTransition(newState, newExpires) {
    const invalidStateTransition = () => {
      this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${newState}`);
    };
    switch (newState) {
      case SubscriptionState$1.Initial:
        invalidStateTransition();
        return;
      case SubscriptionState$1.NotifyWait:
        invalidStateTransition();
        return;
      case SubscriptionState$1.Pending:
        if (this.subscriptionState !== SubscriptionState$1.NotifyWait && this.subscriptionState !== SubscriptionState$1.Pending) {
          invalidStateTransition();
          return;
        }
        break;
      case SubscriptionState$1.Active:
        if (this.subscriptionState !== SubscriptionState$1.NotifyWait && this.subscriptionState !== SubscriptionState$1.Pending && this.subscriptionState !== SubscriptionState$1.Active) {
          invalidStateTransition();
          return;
        }
        break;
      case SubscriptionState$1.Terminated:
        if (this.subscriptionState !== SubscriptionState$1.NotifyWait && this.subscriptionState !== SubscriptionState$1.Pending && this.subscriptionState !== SubscriptionState$1.Active) {
          invalidStateTransition();
          return;
        }
        break;
      default:
        invalidStateTransition();
        return;
    }
    if (newState === SubscriptionState$1.Pending) {
      if (newExpires) {
        this.subscriptionExpires = newExpires;
      }
    }
    if (newState === SubscriptionState$1.Active) {
      if (newExpires) {
        this.subscriptionExpires = newExpires;
      }
    }
    if (newState === SubscriptionState$1.Terminated) {
      this.dispose();
    }
    this._subscriptionState = newState;
  }
  /**
   * When refreshing a subscription, a subscriber starts Timer N, set to
   * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires
   * prior to the receipt of a NOTIFY request, the subscriber considers
   * the subscription terminated.  If the subscriber receives a success
   * response to the SUBSCRIBE request that indicates that no NOTIFY
   * request will be generated -- such as the 204 response defined for use
   * with the optional extension described in [RFC5839] -- then it MUST
   * cancel Timer N.
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
   */
  timerN() {
    this.logger.warn(`Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.`);
    if (this.subscriptionState !== SubscriptionState$1.Terminated) {
      this.stateTransition(SubscriptionState$1.Terminated);
      this.onTerminated();
    }
  }
}
var Levels;
(function(Levels2) {
  Levels2[Levels2["error"] = 0] = "error";
  Levels2[Levels2["warn"] = 1] = "warn";
  Levels2[Levels2["log"] = 2] = "log";
  Levels2[Levels2["debug"] = 3] = "debug";
})(Levels || (Levels = {}));
class Logger4 {
  constructor(logger, category, label) {
    this.logger = logger;
    this.category = category;
    this.label = label;
  }
  error(content2) {
    this.genericLog(Levels.error, content2);
  }
  warn(content2) {
    this.genericLog(Levels.warn, content2);
  }
  log(content2) {
    this.genericLog(Levels.log, content2);
  }
  debug(content2) {
    this.genericLog(Levels.debug, content2);
  }
  genericLog(level, content2) {
    this.logger.genericLog(level, this.category, this.label, content2);
  }
  get level() {
    return this.logger.level;
  }
  set level(newLevel) {
    this.logger.level = newLevel;
  }
}
class LoggerFactory2 {
  constructor() {
    this.builtinEnabled = true;
    this._level = Levels.log;
    this.loggers = {};
    this.logger = this.getLogger("sip:loggerfactory");
  }
  get level() {
    return this._level;
  }
  set level(newLevel) {
    if (newLevel >= 0 && newLevel <= 3) {
      this._level = newLevel;
    } else if (newLevel > 3) {
      this._level = 3;
    } else if (Levels.hasOwnProperty(newLevel)) {
      this._level = newLevel;
    } else {
      this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get connector() {
    return this._connector;
  }
  set connector(value2) {
    if (!value2) {
      this._connector = void 0;
    } else if (typeof value2 === "function") {
      this._connector = value2;
    } else {
      this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value2));
    }
  }
  getLogger(category, label) {
    if (label && this.level === 3) {
      return new Logger4(this, category, label);
    } else if (this.loggers[category]) {
      return this.loggers[category];
    } else {
      const logger = new Logger4(this, category);
      this.loggers[category] = logger;
      return logger;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  genericLog(levelToLog, category, label, content2) {
    if (this.level >= levelToLog) {
      if (this.builtinEnabled) {
        this.print(levelToLog, category, label, content2);
      }
    }
    if (this.connector) {
      this.connector(Levels[levelToLog], category, label, content2);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  print(levelToLog, category, label, content2) {
    if (typeof content2 === "string") {
      const prefix = [/* @__PURE__ */ new Date(), category];
      if (label) {
        prefix.push(label);
      }
      content2 = prefix.concat(content2).join(" | ");
    }
    switch (levelToLog) {
      case Levels.error:
        console.error(content2);
        break;
      case Levels.warn:
        console.warn(content2);
        break;
      case Levels.log:
        console.log(content2);
        break;
      case Levels.debug:
        console.debug(content2);
        break;
    }
  }
}
class InviteUserAgentClient2 extends UserAgentClient2 {
  constructor(core2, message2, delegate) {
    super(InviteClientTransaction2, core2, message2, delegate);
    this.confirmedDialogAcks = /* @__PURE__ */ new Map();
    this.confirmedDialogs = /* @__PURE__ */ new Map();
    this.earlyDialogs = /* @__PURE__ */ new Map();
    this.delegate = delegate;
  }
  dispose() {
    this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());
    this.earlyDialogs.clear();
    super.dispose();
  }
  /**
   * Special case for transport error while sending ACK.
   * @param error - Transport error
   */
  onTransportError(error) {
    if (this.transaction.state === TransactionState.Calling) {
      return super.onTransportError(error);
    }
    this.logger.error(error.message);
    this.logger.error("User agent client request transport error while sending ACK.");
  }
  /**
   * Once the INVITE has been passed to the INVITE client transaction, the
   * UAC waits for responses for the INVITE.
   * https://tools.ietf.org/html/rfc3261#section-13.2.2
   * @param incomingResponse - Incoming response to INVITE request.
   */
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2)) {
      return;
    }
    const statusCode = message2.statusCode ? message2.statusCode.toString() : "";
    if (!statusCode) {
      throw new Error("Response status code undefined.");
    }
    switch (true) {
      case /^100$/.test(statusCode):
        if (this.delegate && this.delegate.onTrying) {
          this.delegate.onTrying({ message: message2 });
        }
        return;
      case /^1[0-9]{2}$/.test(statusCode):
        {
          if (!message2.toTag) {
            this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
            return;
          }
          const contact2 = message2.parseHeader("contact");
          if (!contact2) {
            this.logger.error("Non-100 1xx INVITE response received without a Contact header field, dropping.");
            return;
          }
          const dialogState = Dialog2.initialDialogStateForUserAgentClient(this.message, message2);
          let earlyDialog = this.earlyDialogs.get(dialogState.id);
          if (!earlyDialog) {
            const transaction = this.transaction;
            if (!(transaction instanceof InviteClientTransaction2)) {
              throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            earlyDialog = new SessionDialog2(transaction, this.core, dialogState);
            this.earlyDialogs.set(earlyDialog.id, earlyDialog);
          }
          if (!earlyDialog.reliableSequenceGuard(message2)) {
            this.logger.warn("1xx INVITE reliable response received out of order or is a retransmission, dropping.");
            return;
          }
          if (earlyDialog.signalingState === SignalingState.Initial || earlyDialog.signalingState === SignalingState.HaveLocalOffer) {
            earlyDialog.signalingStateTransition(message2);
          }
          const session2 = earlyDialog;
          if (this.delegate && this.delegate.onProgress) {
            this.delegate.onProgress({
              message: message2,
              session: session2,
              prack: (options) => {
                const outgoingPrackRequest = session2.prack(void 0, options);
                return outgoingPrackRequest;
              }
            });
          }
        }
        return;
      case /^2[0-9]{2}$/.test(statusCode):
        {
          if (!message2.toTag) {
            this.logger.error("2xx INVITE response received without a to tag, dropping.");
            return;
          }
          const contact2 = message2.parseHeader("contact");
          if (!contact2) {
            this.logger.error("2xx INVITE response received without a Contact header field, dropping.");
            return;
          }
          const dialogState = Dialog2.initialDialogStateForUserAgentClient(this.message, message2);
          let dialog = this.confirmedDialogs.get(dialogState.id);
          if (dialog) {
            const outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);
            if (outgoingAckRequest) {
              const transaction = this.transaction;
              if (!(transaction instanceof InviteClientTransaction2)) {
                throw new Error("Client transaction not instance of InviteClientTransaction.");
              }
              transaction.ackResponse(outgoingAckRequest.message);
            }
            return;
          }
          dialog = this.earlyDialogs.get(dialogState.id);
          if (dialog) {
            dialog.confirm();
            dialog.recomputeRouteSet(message2);
            this.earlyDialogs.delete(dialog.id);
            this.confirmedDialogs.set(dialog.id, dialog);
          } else {
            const transaction = this.transaction;
            if (!(transaction instanceof InviteClientTransaction2)) {
              throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            dialog = new SessionDialog2(transaction, this.core, dialogState);
            this.confirmedDialogs.set(dialog.id, dialog);
          }
          if (dialog.signalingState === SignalingState.Initial || dialog.signalingState === SignalingState.HaveLocalOffer) {
            dialog.signalingStateTransition(message2);
          }
          const session2 = dialog;
          if (this.delegate && this.delegate.onAccept) {
            this.delegate.onAccept({
              message: message2,
              session: session2,
              ack: (options) => {
                const outgoingAckRequest = session2.ack(options);
                this.confirmedDialogAcks.set(session2.id, outgoingAckRequest);
                return outgoingAckRequest;
              }
            });
          } else {
            const outgoingAckRequest = session2.ack();
            this.confirmedDialogAcks.set(session2.id, outgoingAckRequest);
          }
        }
        return;
      case /^3[0-9]{2}$/.test(statusCode):
        this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());
        this.earlyDialogs.clear();
        if (this.delegate && this.delegate.onRedirect) {
          this.delegate.onRedirect({ message: message2 });
        }
        return;
      case /^[4-6][0-9]{2}$/.test(statusCode):
        this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());
        this.earlyDialogs.clear();
        if (this.delegate && this.delegate.onReject) {
          this.delegate.onReject({ message: message2 });
        }
        return;
      default:
        throw new Error(`Invalid status code ${statusCode}`);
    }
  }
}
class InviteUserAgentServer2 extends UserAgentServer2 {
  constructor(core2, message2, delegate) {
    super(InviteServerTransaction2, core2, message2, delegate);
    this.core = core2;
  }
  dispose() {
    if (this.earlyDialog) {
      this.earlyDialog.dispose();
    }
    super.dispose();
  }
  /**
   * 13.3.1.4 The INVITE is Accepted
   * The UAS core generates a 2xx response.  This response establishes a
   * dialog, and therefore follows the procedures of Section 12.1.1 in
   * addition to those of Section 8.2.6.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.4
   * @param options - Accept options bucket.
   */
  accept(options = { statusCode: 200 }) {
    if (!this.acceptable) {
      throw new TransactionStateError2(`${this.message.method} not acceptable in state ${this.transaction.state}.`);
    }
    if (!this.confirmedDialog) {
      if (this.earlyDialog) {
        this.earlyDialog.confirm();
        this.confirmedDialog = this.earlyDialog;
        this.earlyDialog = void 0;
      } else {
        const transaction = this.transaction;
        if (!(transaction instanceof InviteServerTransaction2)) {
          throw new Error("Transaction not instance of InviteClientTransaction.");
        }
        const state = Dialog2.initialDialogStateForUserAgentServer(this.message, this.toTag);
        this.confirmedDialog = new SessionDialog2(transaction, this.core, state);
      }
    }
    const recordRouteHeader = this.message.getHeaders("record-route").map((header) => `Record-Route: ${header}`);
    const contactHeader = `Contact: ${this.core.configuration.contact.toString()}`;
    const allowHeader = "Allow: " + AllowedMethods.toString();
    if (!options.body) {
      if (this.confirmedDialog.signalingState === SignalingState.Stable) {
        options.body = this.confirmedDialog.answer;
      } else if (this.confirmedDialog.signalingState === SignalingState.Initial || this.confirmedDialog.signalingState === SignalingState.HaveRemoteOffer) {
        throw new Error("Response must have a body.");
      }
    }
    options.statusCode = options.statusCode || 200;
    options.extraHeaders = options.extraHeaders || [];
    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
    options.extraHeaders.push(allowHeader);
    options.extraHeaders.push(contactHeader);
    const response = super.accept(options);
    const session2 = this.confirmedDialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      if (this.confirmedDialog.signalingState !== SignalingState.Stable) {
        this.confirmedDialog.signalingStateTransition(options.body);
      }
    }
    return result;
  }
  /**
   * 13.3.1.1 Progress
   * If the UAS is not able to answer the invitation immediately, it can
   * choose to indicate some kind of progress to the UAC (for example, an
   * indication that a phone is ringing).  This is accomplished with a
   * provisional response between 101 and 199.  These provisional
   * responses establish early dialogs and therefore follow the procedures
   * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY
   * send as many provisional responses as it likes.  Each of these MUST
   * indicate the same dialog ID.  However, these will not be delivered
   * reliably.
   *
   * If the UAS desires an extended period of time to answer the INVITE,
   * it will need to ask for an "extension" in order to prevent proxies
   * from canceling the transaction.  A proxy has the option of canceling
   * a transaction when there is a gap of 3 minutes between responses in a
   * transaction.  To prevent cancellation, the UAS MUST send a non-100
   * provisional response at every minute, to handle the possibility of
   * lost provisional responses.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.1
   * @param options - Progress options bucket.
   */
  progress(options = { statusCode: 180 }) {
    if (!this.progressable) {
      throw new TransactionStateError2(`${this.message.method} not progressable in state ${this.transaction.state}.`);
    }
    if (!this.earlyDialog) {
      const transaction = this.transaction;
      if (!(transaction instanceof InviteServerTransaction2)) {
        throw new Error("Transaction not instance of InviteClientTransaction.");
      }
      const state = Dialog2.initialDialogStateForUserAgentServer(this.message, this.toTag, true);
      this.earlyDialog = new SessionDialog2(transaction, this.core, state);
    }
    const recordRouteHeader = this.message.getHeaders("record-route").map((header) => `Record-Route: ${header}`);
    const contactHeader = `Contact: ${this.core.configuration.contact}`;
    options.extraHeaders = options.extraHeaders || [];
    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
    options.extraHeaders.push(contactHeader);
    const response = super.progress(options);
    const session2 = this.earlyDialog;
    const result = Object.assign(Object.assign({}, response), { session: session2 });
    if (options.body) {
      if (this.earlyDialog.signalingState !== SignalingState.Stable) {
        this.earlyDialog.signalingStateTransition(options.body);
      }
    }
    return result;
  }
  /**
   * 13.3.1.2 The INVITE is Redirected
   * If the UAS decides to redirect the call, a 3xx response is sent.  A
   * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved
   * Temporarily) response SHOULD contain a Contact header field
   * containing one or more URIs of new addresses to be tried.  The
   * response is passed to the INVITE server transaction, which will deal
   * with its retransmissions.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.2
   * @param contacts - Contacts to redirect to.
   * @param options - Redirect options bucket.
   */
  redirect(contacts, options = { statusCode: 302 }) {
    return super.redirect(contacts, options);
  }
  /**
   * 13.3.1.3 The INVITE is Rejected
   * A common scenario occurs when the callee is currently not willing or
   * able to take additional calls at this end system.  A 486 (Busy Here)
   * SHOULD be returned in such a scenario.
   * https://tools.ietf.org/html/rfc3261#section-13.3.1.3
   * @param options - Reject options bucket.
   */
  reject(options = { statusCode: 486 }) {
    return super.reject(options);
  }
}
class PublishUserAgentClient2 extends UserAgentClient2 {
  constructor(core2, message2, delegate) {
    super(NonInviteClientTransaction2, core2, message2, delegate);
  }
}
class RegisterUserAgentClient2 extends UserAgentClient2 {
  constructor(core2, message2, delegate) {
    super(NonInviteClientTransaction2, core2, message2, delegate);
  }
}
class RegisterUserAgentServer2 extends UserAgentServer2 {
  constructor(core2, message2, delegate) {
    super(NonInviteServerTransaction2, core2, message2, delegate);
    this.core = core2;
  }
}
class SubscribeUserAgentClient2 extends UserAgentClient2 {
  constructor(core2, message2, delegate) {
    const event = message2.getHeader("Event");
    if (!event) {
      throw new Error("Event undefined");
    }
    const expires = message2.getHeader("Expires");
    if (!expires) {
      throw new Error("Expires undefined");
    }
    super(NonInviteClientTransaction2, core2, message2, delegate);
    this.delegate = delegate;
    this.subscriberId = message2.callId + message2.fromTag + event;
    this.subscriptionExpiresRequested = this.subscriptionExpires = Number(expires);
    this.subscriptionEvent = event;
    this.subscriptionState = SubscriptionState$1.NotifyWait;
    this.waitNotifyStart();
  }
  /**
   * Destructor.
   * Note that Timer N may live on waiting for an initial NOTIFY and
   * the delegate may still receive that NOTIFY. If you don't want
   * that behavior then either clear the delegate so the delegate
   * doesn't get called (a 200 will be sent in response to the NOTIFY)
   * or call `waitNotifyStop` which will clear Timer N and remove this
   * UAC from the core (a 481 will be sent in response to the NOTIFY).
   */
  dispose() {
    super.dispose();
  }
  /**
   * Handle out of dialog NOTIFY associated with SUBSCRIBE request.
   * This is the first NOTIFY received after the SUBSCRIBE request.
   * @param uas - User agent server handling the subscription creating NOTIFY.
   */
  onNotify(uas) {
    const event = uas.message.parseHeader("Event").event;
    if (!event || event !== this.subscriptionEvent) {
      this.logger.warn(`Failed to parse event.`);
      uas.reject({ statusCode: 489 });
      return;
    }
    const subscriptionState = uas.message.parseHeader("Subscription-State");
    if (!subscriptionState || !subscriptionState.state) {
      this.logger.warn("Failed to parse subscription state.");
      uas.reject({ statusCode: 489 });
      return;
    }
    const state = subscriptionState.state;
    switch (state) {
      case "pending":
        break;
      case "active":
        break;
      case "terminated":
        break;
      default:
        this.logger.warn(`Invalid subscription state ${state}`);
        uas.reject({ statusCode: 489 });
        return;
    }
    if (state !== "terminated") {
      const contact2 = uas.message.parseHeader("contact");
      if (!contact2) {
        this.logger.warn("Failed to parse contact.");
        uas.reject({ statusCode: 489 });
        return;
      }
    }
    if (this.dialog) {
      throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");
    }
    this.waitNotifyStop();
    this.subscriptionExpires = subscriptionState.expires ? Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) : this.subscriptionExpires;
    switch (state) {
      case "pending":
        this.subscriptionState = SubscriptionState$1.Pending;
        break;
      case "active":
        this.subscriptionState = SubscriptionState$1.Active;
        break;
      case "terminated":
        this.subscriptionState = SubscriptionState$1.Terminated;
        break;
      default:
        throw new Error(`Unrecognized state ${state}.`);
    }
    if (this.subscriptionState !== SubscriptionState$1.Terminated) {
      const dialogState = SubscriptionDialog2.initialDialogStateForSubscription(this.message, uas.message);
      this.dialog = new SubscriptionDialog2(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);
    }
    if (this.delegate && this.delegate.onNotify) {
      const request = uas;
      const subscription = this.dialog;
      this.delegate.onNotify({ request, subscription });
    } else {
      uas.accept();
    }
  }
  waitNotifyStart() {
    if (!this.N) {
      this.core.subscribers.set(this.subscriberId, this);
      this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);
    }
  }
  waitNotifyStop() {
    if (this.N) {
      this.core.subscribers.delete(this.subscriberId);
      clearTimeout(this.N);
      this.N = void 0;
    }
  }
  /**
   * Receive a response from the transaction layer.
   * @param message - Incoming response message.
   */
  receiveResponse(message2) {
    if (!this.authenticationGuard(message2)) {
      return;
    }
    if (message2.statusCode && message2.statusCode >= 200 && message2.statusCode < 300) {
      const expires = message2.getHeader("Expires");
      if (!expires) {
        this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
      } else {
        const subscriptionExpiresReceived = Number(expires);
        if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {
          this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request");
        }
        if (subscriptionExpiresReceived < this.subscriptionExpires) {
          this.subscriptionExpires = subscriptionExpiresReceived;
        }
      }
      if (this.dialog) {
        if (this.dialog.subscriptionExpires > this.subscriptionExpires) {
          this.dialog.subscriptionExpires = this.subscriptionExpires;
        }
      }
    }
    if (message2.statusCode && message2.statusCode >= 300 && message2.statusCode < 700) {
      this.waitNotifyStop();
    }
    super.receiveResponse(message2);
  }
  /**
   * To ensure that subscribers do not wait indefinitely for a
   * subscription to be established, a subscriber starts a Timer N, set to
   * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires
   * prior to the receipt of a NOTIFY request, the subscriber considers
   * the subscription failed, and cleans up any state associated with the
   * subscription attempt.
   * https://tools.ietf.org/html/rfc6665#section-4.1.2.4
   */
  timerN() {
    this.logger.warn(`Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.`);
    this.waitNotifyStop();
    if (this.delegate && this.delegate.onNotifyTimeout) {
      this.delegate.onNotifyTimeout();
    }
  }
}
class SubscribeUserAgentServer2 extends UserAgentServer2 {
  constructor(core2, message2, delegate) {
    super(NonInviteServerTransaction2, core2, message2, delegate);
    this.core = core2;
  }
}
const acceptedBodyTypes = ["application/sdp", "application/dtmf-relay"];
class UserAgentCore2 {
  /**
   * Constructor.
   * @param configuration - Configuration.
   * @param delegate - Delegate.
   */
  constructor(configuration, delegate = {}) {
    this.userAgentClients = /* @__PURE__ */ new Map();
    this.userAgentServers = /* @__PURE__ */ new Map();
    this.configuration = configuration;
    this.delegate = delegate;
    this.dialogs = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Map();
    this.logger = configuration.loggerFactory.getLogger("sip.user-agent-core");
  }
  /** Destructor. */
  dispose() {
    this.reset();
  }
  /** Reset. */
  reset() {
    this.dialogs.forEach((dialog) => dialog.dispose());
    this.dialogs.clear();
    this.subscribers.forEach((subscriber) => subscriber.dispose());
    this.subscribers.clear();
    this.userAgentClients.forEach((uac) => uac.dispose());
    this.userAgentClients.clear();
    this.userAgentServers.forEach((uac) => uac.dispose());
    this.userAgentServers.clear();
  }
  /** Logger factory. */
  get loggerFactory() {
    return this.configuration.loggerFactory;
  }
  /** Transport. */
  get transport() {
    const transport = this.configuration.transportAccessor();
    if (!transport) {
      throw new Error("Transport undefined.");
    }
    return transport;
  }
  /**
   * Send INVITE.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  invite(request, delegate) {
    return new InviteUserAgentClient2(this, request, delegate);
  }
  /**
   * Send MESSAGE.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  message(request, delegate) {
    return new MessageUserAgentClient2(this, request, delegate);
  }
  /**
   * Send PUBLISH.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  publish(request, delegate) {
    return new PublishUserAgentClient2(this, request, delegate);
  }
  /**
   * Send REGISTER.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  register(request, delegate) {
    return new RegisterUserAgentClient2(this, request, delegate);
  }
  /**
   * Send SUBSCRIBE.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  subscribe(request, delegate) {
    return new SubscribeUserAgentClient2(this, request, delegate);
  }
  /**
   * Send a request.
   * @param request - Outgoing request.
   * @param delegate - Request delegate.
   */
  request(request, delegate) {
    return new UserAgentClient2(NonInviteClientTransaction2, this, request, delegate);
  }
  /**
   * Outgoing request message factory function.
   * @param method - Method.
   * @param requestURI - Request-URI.
   * @param fromURI - From URI.
   * @param toURI - To URI.
   * @param options - Request options.
   * @param extraHeaders - Extra headers to add.
   * @param body - Message body.
   */
  makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {
    const callIdPrefix = this.configuration.sipjsId;
    const fromDisplayName = this.configuration.displayName;
    const forceRport = this.configuration.viaForceRport;
    const hackViaTcp = this.configuration.hackViaTcp;
    const optionTags = this.configuration.supportedOptionTags.slice();
    if (method === C.REGISTER) {
      optionTags.push("path", "gruu");
    }
    if (method === C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {
      optionTags.push("gruu");
    }
    const routeSet = this.configuration.routeSet;
    const userAgentString = this.configuration.userAgentHeaderFieldValue;
    const viaHost = this.configuration.viaHost;
    const defaultOptions2 = {
      callIdPrefix,
      forceRport,
      fromDisplayName,
      hackViaTcp,
      optionTags,
      routeSet,
      userAgentString,
      viaHost
    };
    const requestOptions = Object.assign(Object.assign({}, defaultOptions2), options);
    return new OutgoingRequestMessage2(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);
  }
  /**
   * Handle an incoming request message from the transport.
   * @param message - Incoming request message from transport layer.
   */
  receiveIncomingRequestFromTransport(message2) {
    this.receiveRequestFromTransport(message2);
  }
  /**
   * Handle an incoming response message from the transport.
   * @param message - Incoming response message from transport layer.
   */
  receiveIncomingResponseFromTransport(message2) {
    this.receiveResponseFromTransport(message2);
  }
  /**
   * A stateless UAS is a UAS that does not maintain transaction state.
   * It replies to requests normally, but discards any state that would
   * ordinarily be retained by a UAS after a response has been sent.  If a
   * stateless UAS receives a retransmission of a request, it regenerates
   * the response and re-sends it, just as if it were replying to the first
   * instance of the request. A UAS cannot be stateless unless the request
   * processing for that method would always result in the same response
   * if the requests are identical. This rules out stateless registrars,
   * for example.  Stateless UASs do not use a transaction layer; they
   * receive requests directly from the transport layer and send responses
   * directly to the transport layer.
   * https://tools.ietf.org/html/rfc3261#section-8.2.7
   * @param message - Incoming request message to reply to.
   * @param statusCode - Status code to reply with.
   */
  replyStateless(message2, options) {
    const userAgent = this.configuration.userAgentHeaderFieldValue;
    const supported = this.configuration.supportedOptionTagsResponse;
    options = Object.assign(Object.assign({}, options), { userAgent, supported });
    const response = constructOutgoingResponse(message2, options);
    this.transport.send(response.message).catch((error) => {
      if (error instanceof Error) {
        this.logger.error(error.message);
      }
      this.logger.error(`Transport error occurred sending stateless reply to ${message2.method} request.`);
    });
    return response;
  }
  /**
   * In Section 18.2.1, replace the last paragraph with:
   *
   * Next, the server transport attempts to match the request to a
   * server transaction.  It does so using the matching rules described
   * in Section 17.2.3.  If a matching server transaction is found, the
   * request is passed to that transaction for processing.  If no match
   * is found, the request is passed to the core, which may decide to
   * construct a new server transaction for that request.
   * https://tools.ietf.org/html/rfc6026#section-8.10
   * @param message - Incoming request message from transport layer.
   */
  receiveRequestFromTransport(message2) {
    const transactionId = message2.viaBranch;
    const uas = this.userAgentServers.get(transactionId);
    if (message2.method === C.ACK) {
      if (uas && uas.transaction.state === TransactionState.Accepted) {
        if (uas instanceof InviteUserAgentServer2) {
          this.logger.warn(`Discarding out of dialog ACK after 2xx response sent on transaction ${transactionId}.`);
          return;
        }
      }
    }
    if (message2.method === C.CANCEL) {
      if (uas) {
        this.replyStateless(message2, { statusCode: 200 });
        if (uas.transaction instanceof InviteServerTransaction2 && uas.transaction.state === TransactionState.Proceeding) {
          if (uas instanceof InviteUserAgentServer2) {
            uas.receiveCancel(message2);
          }
        }
      } else {
        this.replyStateless(message2, { statusCode: 481 });
      }
      return;
    }
    if (uas) {
      uas.transaction.receiveRequest(message2);
      return;
    }
    this.receiveRequest(message2);
    return;
  }
  /**
   * UAC and UAS procedures depend strongly on two factors.  First, based
   * on whether the request or response is inside or outside of a dialog,
   * and second, based on the method of a request.  Dialogs are discussed
   * thoroughly in Section 12; they represent a peer-to-peer relationship
   * between user agents and are established by specific SIP methods, such
   * as INVITE.
   * @param message - Incoming request message.
   */
  receiveRequest(message2) {
    if (!AllowedMethods.includes(message2.method)) {
      const allowHeader = "Allow: " + AllowedMethods.toString();
      this.replyStateless(message2, {
        statusCode: 405,
        extraHeaders: [allowHeader]
      });
      return;
    }
    if (!message2.ruri) {
      throw new Error("Request-URI undefined.");
    }
    if (message2.ruri.scheme !== "sip") {
      this.replyStateless(message2, { statusCode: 416 });
      return;
    }
    const ruri = message2.ruri;
    const ruriMatches = (uri) => {
      return !!uri && uri.user === ruri.user;
    };
    if (!ruriMatches(this.configuration.aor) && !(ruriMatches(this.configuration.contact.uri) || ruriMatches(this.configuration.contact.pubGruu) || ruriMatches(this.configuration.contact.tempGruu))) {
      this.logger.warn("Request-URI does not point to us.");
      if (message2.method !== C.ACK) {
        this.replyStateless(message2, { statusCode: 404 });
      }
      return;
    }
    if (message2.method === C.INVITE) {
      if (!message2.hasHeader("Contact")) {
        this.replyStateless(message2, {
          statusCode: 400,
          reasonPhrase: "Missing Contact Header"
        });
        return;
      }
    }
    if (!message2.toTag) {
      const transactionId = message2.viaBranch;
      if (!this.userAgentServers.has(transactionId)) {
        const mergedRequest = Array.from(this.userAgentServers.values()).some((uas) => uas.transaction.request.fromTag === message2.fromTag && uas.transaction.request.callId === message2.callId && uas.transaction.request.cseq === message2.cseq);
        if (mergedRequest) {
          this.replyStateless(message2, { statusCode: 482 });
          return;
        }
      }
    }
    if (message2.toTag) {
      this.receiveInsideDialogRequest(message2);
    } else {
      this.receiveOutsideDialogRequest(message2);
    }
    return;
  }
  /**
   * Once a dialog has been established between two UAs, either of them
   * MAY initiate new transactions as needed within the dialog.  The UA
   * sending the request will take the UAC role for the transaction.  The
   * UA receiving the request will take the UAS role.  Note that these may
   * be different roles than the UAs held during the transaction that
   * established the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.2
   * @param message - Incoming request message.
   */
  receiveInsideDialogRequest(message2) {
    if (message2.method === C.NOTIFY) {
      const event = message2.parseHeader("Event");
      if (!event || !event.event) {
        this.replyStateless(message2, { statusCode: 489 });
        return;
      }
      const subscriberId = message2.callId + message2.toTag + event.event;
      const subscriber = this.subscribers.get(subscriberId);
      if (subscriber) {
        const uas = new NotifyUserAgentServer2(this, message2);
        subscriber.onNotify(uas);
        return;
      }
    }
    const dialogId = message2.callId + message2.toTag + message2.fromTag;
    const dialog = this.dialogs.get(dialogId);
    if (dialog) {
      if (message2.method === C.OPTIONS) {
        const allowHeader = "Allow: " + AllowedMethods.toString();
        const acceptHeader = "Accept: " + acceptedBodyTypes.toString();
        this.replyStateless(message2, {
          statusCode: 200,
          extraHeaders: [allowHeader, acceptHeader]
        });
        return;
      }
      dialog.receiveRequest(message2);
      return;
    }
    if (message2.method === C.ACK) {
      return;
    }
    this.replyStateless(message2, { statusCode: 481 });
    return;
  }
  /**
   * Assuming all of the checks in the previous subsections are passed,
   * the UAS processing becomes method-specific.
   *  https://tools.ietf.org/html/rfc3261#section-8.2.5
   * @param message - Incoming request message.
   */
  receiveOutsideDialogRequest(message2) {
    switch (message2.method) {
      case C.ACK:
        break;
      case C.BYE:
        this.replyStateless(message2, { statusCode: 481 });
        break;
      case C.CANCEL:
        throw new Error(`Unexpected out of dialog request method ${message2.method}.`);
      case C.INFO:
        this.replyStateless(message2, { statusCode: 405 });
        break;
      case C.INVITE:
        {
          const uas = new InviteUserAgentServer2(this, message2);
          this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();
        }
        break;
      case C.MESSAGE:
        {
          const uas = new MessageUserAgentServer2(this, message2);
          this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();
        }
        break;
      case C.NOTIFY:
        {
          const uas = new NotifyUserAgentServer2(this, message2);
          this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.reject({ statusCode: 405 });
        }
        break;
      case C.OPTIONS:
        {
          const allowHeader = "Allow: " + AllowedMethods.toString();
          const acceptHeader = "Accept: " + acceptedBodyTypes.toString();
          this.replyStateless(message2, {
            statusCode: 200,
            extraHeaders: [allowHeader, acceptHeader]
          });
        }
        break;
      case C.REFER:
        {
          const uas = new ReferUserAgentServer2(this, message2);
          this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject({ statusCode: 405 });
        }
        break;
      case C.REGISTER:
        {
          const uas = new RegisterUserAgentServer2(this, message2);
          this.delegate.onRegister ? this.delegate.onRegister(uas) : uas.reject({ statusCode: 405 });
        }
        break;
      case C.SUBSCRIBE:
        {
          const uas = new SubscribeUserAgentServer2(this, message2);
          this.delegate.onSubscribe ? this.delegate.onSubscribe(uas) : uas.reject({ statusCode: 480 });
        }
        break;
      default:
        throw new Error(`Unexpected out of dialog request method ${message2.method}.`);
    }
    return;
  }
  /**
   * Responses are first processed by the transport layer and then passed
   * up to the transaction layer.  The transaction layer performs its
   * processing and then passes the response up to the TU.  The majority
   * of response processing in the TU is method specific.  However, there
   * are some general behaviors independent of the method.
   * https://tools.ietf.org/html/rfc3261#section-8.1.3
   * @param message - Incoming response message from transport layer.
   */
  receiveResponseFromTransport(message2) {
    if (message2.getHeaders("via").length > 1) {
      this.logger.warn("More than one Via header field present in the response, dropping");
      return;
    }
    const userAgentClientId = message2.viaBranch + message2.method;
    const userAgentClient = this.userAgentClients.get(userAgentClientId);
    if (userAgentClient) {
      userAgentClient.transaction.receiveResponse(message2);
    } else {
      this.logger.warn(`Discarding unmatched ${message2.statusCode} response to ${message2.method} ${userAgentClientId}.`);
    }
  }
}
class ContentTypeUnsupportedError2 extends Exception2 {
  constructor(message2) {
    super(message2 ? message2 : "Unsupported content type.");
  }
}
class RequestPendingError2 extends Exception2 {
  /** @internal */
  constructor(message2) {
    super(message2 ? message2 : "Request pending.");
  }
}
class SessionDescriptionHandlerError2 extends Exception2 {
  constructor(message2) {
    super(message2 ? message2 : "Unspecified session description handler error.");
  }
}
class SessionTerminatedError2 extends Exception2 {
  constructor() {
    super("The session has terminated.");
  }
}
class StateTransitionError2 extends Exception2 {
  constructor(message2) {
    super(message2 ? message2 : "An error occurred during state transition.");
  }
}
class Ack2 {
  /** @internal */
  constructor(incomingAckRequest) {
    this.incomingAckRequest = incomingAckRequest;
  }
  /** Incoming ACK request message. */
  get request() {
    return this.incomingAckRequest.message;
  }
}
class Bye2 {
  /** @internal */
  constructor(incomingByeRequest) {
    this.incomingByeRequest = incomingByeRequest;
  }
  /** Incoming BYE request message. */
  get request() {
    return this.incomingByeRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingByeRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingByeRequest.reject(options);
    return Promise.resolve();
  }
}
class EmitterImpl2 {
  constructor() {
    this.listeners = new Array();
  }
  /**
   * Sets up a function that will be called whenever the target changes.
   * @param listener - Callback function.
   * @param options - An options object that specifies characteristics about the listener.
   *                  If once true, indicates that the listener should be invoked at most once after being added.
   *                  If once true, the listener would be automatically removed when invoked.
   */
  addListener(listener, options) {
    const onceWrapper = (data) => {
      this.removeListener(onceWrapper);
      listener(data);
    };
    (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);
  }
  /**
   * Emit change.
   * @param data - Data to emit.
   */
  emit(data) {
    this.listeners.slice().forEach((listener) => listener(data));
  }
  /**
   * Removes all listeners previously registered with addListener.
   */
  removeAllListeners() {
    this.listeners = [];
  }
  /**
   * Removes a listener previously registered with addListener.
   * @param listener - Callback function.
   */
  removeListener(listener) {
    this.listeners = this.listeners.filter((l2) => l2 !== listener);
  }
  /**
   * Registers a listener.
   * @param listener - Callback function.
   * @deprecated Use addListener.
   */
  on(listener) {
    return this.addListener(listener);
  }
  /**
   * Unregisters a listener.
   * @param listener - Callback function.
   * @deprecated Use removeListener.
   */
  off(listener) {
    return this.removeListener(listener);
  }
  /**
   * Registers a listener then unregisters the listener after one event emission.
   * @param listener - Callback function.
   * @deprecated Use addListener.
   */
  once(listener) {
    return this.addListener(listener, { once: true });
  }
}
class Info2 {
  /** @internal */
  constructor(incomingInfoRequest) {
    this.incomingInfoRequest = incomingInfoRequest;
  }
  /** Incoming MESSAGE request message. */
  get request() {
    return this.incomingInfoRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingInfoRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingInfoRequest.reject(options);
    return Promise.resolve();
  }
}
class Message2 {
  /** @internal */
  constructor(incomingMessageRequest) {
    this.incomingMessageRequest = incomingMessageRequest;
  }
  /** Incoming MESSAGE request message. */
  get request() {
    return this.incomingMessageRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingMessageRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingMessageRequest.reject(options);
    return Promise.resolve();
  }
}
class Notification2 {
  /** @internal */
  constructor(incomingNotifyRequest) {
    this.incomingNotifyRequest = incomingNotifyRequest;
  }
  /** Incoming NOTIFY request message. */
  get request() {
    return this.incomingNotifyRequest.message;
  }
  /** Accept the request. */
  accept(options) {
    this.incomingNotifyRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingNotifyRequest.reject(options);
    return Promise.resolve();
  }
}
class Referral2 {
  /** @internal */
  constructor(incomingReferRequest, session2) {
    this.incomingReferRequest = incomingReferRequest;
    this.session = session2;
  }
  get referTo() {
    const referTo = this.incomingReferRequest.message.parseHeader("refer-to");
    if (!(referTo instanceof NameAddrHeader2)) {
      throw new Error("Failed to parse Refer-To header.");
    }
    return referTo;
  }
  get referredBy() {
    return this.incomingReferRequest.message.getHeader("referred-by");
  }
  get replaces() {
    const value2 = this.referTo.uri.getHeader("replaces");
    if (value2 instanceof Array) {
      return value2[0];
    }
    return value2;
  }
  /** Incoming REFER request message. */
  get request() {
    return this.incomingReferRequest.message;
  }
  /** Accept the request. */
  accept(options = { statusCode: 202 }) {
    this.incomingReferRequest.accept(options);
    return Promise.resolve();
  }
  /** Reject the request. */
  reject(options) {
    this.incomingReferRequest.reject(options);
    return Promise.resolve();
  }
  /**
   * Creates an inviter which may be used to send an out of dialog INVITE request.
   *
   * @remarks
   * This a helper method to create an Inviter which will execute the referral
   * of the `Session` which was referred. The appropriate headers are set and
   * the referred `Session` is linked to the new `Session`. Note that only a
   * single instance of the `Inviter` will be created and returned (if called
   * more than once a reference to the same `Inviter` will be returned every time).
   *
   * @param options - Options bucket.
   * @param modifiers - Session description handler modifiers.
   */
  makeInviter(options) {
    if (this.inviter) {
      return this.inviter;
    }
    const targetURI = this.referTo.uri.clone();
    targetURI.clearHeaders();
    options = options || {};
    const extraHeaders = (options.extraHeaders || []).slice();
    const replaces = this.replaces;
    if (replaces) {
      extraHeaders.push("Replaces: " + decodeURIComponent(replaces));
    }
    const referredBy = this.referredBy;
    if (referredBy) {
      extraHeaders.push("Referred-By: " + referredBy);
    }
    options.extraHeaders = extraHeaders;
    this.inviter = this.session.userAgent._makeInviter(targetURI, options);
    this.inviter._referred = this.session;
    this.session._referral = this.inviter;
    return this.inviter;
  }
}
var SessionState;
(function(SessionState2) {
  SessionState2["Initial"] = "Initial";
  SessionState2["Establishing"] = "Establishing";
  SessionState2["Established"] = "Established";
  SessionState2["Terminating"] = "Terminating";
  SessionState2["Terminated"] = "Terminated";
})(SessionState || (SessionState = {}));
class Session2 {
  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @internal
   */
  constructor(userAgent, options = {}) {
    this.pendingReinvite = false;
    this.pendingReinviteAck = false;
    this._state = SessionState.Initial;
    this.delegate = options.delegate;
    this._stateEventEmitter = new EmitterImpl2();
    this._userAgent = userAgent;
  }
  /**
   * Destructor.
   */
  dispose() {
    this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`);
    delete this.userAgent._sessions[this.id];
    if (this._sessionDescriptionHandler) {
      this._sessionDescriptionHandler.close();
    }
    switch (this.state) {
      case SessionState.Initial:
        break;
      case SessionState.Establishing:
        break;
      case SessionState.Established:
        return new Promise((resolve) => {
          this._bye({
            // wait for the response to the BYE before resolving
            onAccept: () => resolve(),
            onRedirect: () => resolve(),
            onReject: () => resolve()
          });
        });
      case SessionState.Terminating:
        break;
      case SessionState.Terminated:
        break;
      default:
        throw new Error("Unknown state.");
    }
    return Promise.resolve();
  }
  /**
   * The asserted identity of the remote user.
   */
  get assertedIdentity() {
    return this._assertedIdentity;
  }
  /**
   * The confirmed session dialog.
   */
  get dialog() {
    return this._dialog;
  }
  /**
   * A unique identifier for this session.
   */
  get id() {
    return this._id;
  }
  /**
   * The session being replace by this one.
   */
  get replacee() {
    return this._replacee;
  }
  /**
   * Session description handler.
   * @remarks
   * If `this` is an instance of `Invitation`,
   * `sessionDescriptionHandler` will be defined when the session state changes to "established".
   * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,
   * `sessionDescriptionHandler` will be defined when the session state changes to "establishing".
   * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,
   * `sessionDescriptionHandler` will be defined when the session state changes to "established".
   * Otherwise `undefined`.
   */
  get sessionDescriptionHandler() {
    return this._sessionDescriptionHandler;
  }
  /**
   * Session description handler factory.
   */
  get sessionDescriptionHandlerFactory() {
    return this.userAgent.configuration.sessionDescriptionHandlerFactory;
  }
  /**
   * SDH modifiers for the initial INVITE transaction.
   * @remarks
   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().
   */
  get sessionDescriptionHandlerModifiers() {
    return this._sessionDescriptionHandlerModifiers || [];
  }
  set sessionDescriptionHandlerModifiers(modifiers) {
    this._sessionDescriptionHandlerModifiers = modifiers.slice();
  }
  /**
   * SDH options for the initial INVITE transaction.
   * @remarks
   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().
   */
  get sessionDescriptionHandlerOptions() {
    return this._sessionDescriptionHandlerOptions || {};
  }
  set sessionDescriptionHandlerOptions(options) {
    this._sessionDescriptionHandlerOptions = Object.assign({}, options);
  }
  /**
   * SDH modifiers for re-INVITE transactions.
   * @remarks
   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Session.invite().
   */
  get sessionDescriptionHandlerModifiersReInvite() {
    return this._sessionDescriptionHandlerModifiersReInvite || [];
  }
  set sessionDescriptionHandlerModifiersReInvite(modifiers) {
    this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();
  }
  /**
   * SDH options for re-INVITE transactions.
   * @remarks
   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
   * May be set directly at anytime.
   * May optionally be set via constructor option.
   * May optionally be set via options passed to Session.invite().
   */
  get sessionDescriptionHandlerOptionsReInvite() {
    return this._sessionDescriptionHandlerOptionsReInvite || {};
  }
  set sessionDescriptionHandlerOptionsReInvite(options) {
    this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);
  }
  /**
   * Session state.
   */
  get state() {
    return this._state;
  }
  /**
   * Session state change emitter.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * The user agent.
   */
  get userAgent() {
    return this._userAgent;
  }
  /**
   * End the {@link Session}. Sends a BYE.
   * @param options - Options bucket. See {@link SessionByeOptions} for details.
   */
  bye(options = {}) {
    let message2 = "Session.bye() may only be called if established session.";
    switch (this.state) {
      case SessionState.Initial:
        if (typeof this.cancel === "function") {
          message2 += " However Inviter.invite() has not yet been called.";
          message2 += " Perhaps you should have called Inviter.cancel()?";
        } else if (typeof this.reject === "function") {
          message2 += " However Invitation.accept() has not yet been called.";
          message2 += " Perhaps you should have called Invitation.reject()?";
        }
        break;
      case SessionState.Establishing:
        if (typeof this.cancel === "function") {
          message2 += " However a dialog does not yet exist.";
          message2 += " Perhaps you should have called Inviter.cancel()?";
        } else if (typeof this.reject === "function") {
          message2 += " However Invitation.accept() has not yet been called (or not yet resolved).";
          message2 += " Perhaps you should have called Invitation.reject()?";
        }
        break;
      case SessionState.Established: {
        const requestDelegate = options.requestDelegate;
        const requestOptions = this.copyRequestOptions(options.requestOptions);
        return this._bye(requestDelegate, requestOptions);
      }
      case SessionState.Terminating:
        message2 += " However this session is already terminating.";
        if (typeof this.cancel === "function") {
          message2 += " Perhaps you have already called Inviter.cancel()?";
        } else if (typeof this.reject === "function") {
          message2 += " Perhaps you have already called Session.bye()?";
        }
        break;
      case SessionState.Terminated:
        message2 += " However this session is already terminated.";
        break;
      default:
        throw new Error("Unknown state");
    }
    this.logger.error(message2);
    return Promise.reject(new Error(`Invalid session state ${this.state}`));
  }
  /**
   * Share {@link Info} with peer. Sends an INFO.
   * @param options - Options bucket. See {@link SessionInfoOptions} for details.
   */
  info(options = {}) {
    if (this.state !== SessionState.Established) {
      const message2 = "Session.info() may only be called if established session.";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const requestDelegate = options.requestDelegate;
    const requestOptions = this.copyRequestOptions(options.requestOptions);
    return this._info(requestDelegate, requestOptions);
  }
  /**
   * Renegotiate the session. Sends a re-INVITE.
   * @param options - Options bucket. See {@link SessionInviteOptions} for details.
   */
  invite(options = {}) {
    this.logger.log("Session.invite");
    if (this.state !== SessionState.Established) {
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    if (this.pendingReinvite) {
      return Promise.reject(new RequestPendingError2("Reinvite in progress. Please wait until complete, then try again."));
    }
    this.pendingReinvite = true;
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;
    }
    const delegate = {
      onAccept: (response) => {
        const body = getBody(response.message);
        if (!body) {
          this.logger.error("Received 2xx response to re-INVITE without a session description");
          this.ackAndBye(response, 400, "Missing session description");
          this.stateTransition(SessionState.Terminated);
          this.pendingReinvite = false;
          return;
        }
        if (options.withoutSdp) {
          const answerOptions = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
          };
          this.setOfferAndGetAnswer(body, answerOptions).then((answerBody) => {
            response.ack({ body: answerBody });
          }).catch((error) => {
            this.logger.error("Failed to handle offer in 2xx response to re-INVITE");
            this.logger.error(error.message);
            if (this.state === SessionState.Terminated) {
              response.ack();
            } else {
              this.ackAndBye(response, 488, "Bad Media Description");
              this.stateTransition(SessionState.Terminated);
            }
          }).then(() => {
            this.pendingReinvite = false;
            if (options.requestDelegate && options.requestDelegate.onAccept) {
              options.requestDelegate.onAccept(response);
            }
          });
        } else {
          const answerOptions = {
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
          };
          this.setAnswer(body, answerOptions).then(() => {
            response.ack();
          }).catch((error) => {
            this.logger.error("Failed to handle answer in 2xx response to re-INVITE");
            this.logger.error(error.message);
            if (this.state !== SessionState.Terminated) {
              this.ackAndBye(response, 488, "Bad Media Description");
              this.stateTransition(SessionState.Terminated);
            } else {
              response.ack();
            }
          }).then(() => {
            this.pendingReinvite = false;
            if (options.requestDelegate && options.requestDelegate.onAccept) {
              options.requestDelegate.onAccept(response);
            }
          });
        }
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onProgress: (response) => {
        return;
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onRedirect: (response) => {
        return;
      },
      onReject: (response) => {
        this.logger.warn("Received a non-2xx response to re-INVITE");
        this.pendingReinvite = false;
        if (options.withoutSdp) {
          if (options.requestDelegate && options.requestDelegate.onReject) {
            options.requestDelegate.onReject(response);
          }
        } else {
          this.rollbackOffer().catch((error) => {
            this.logger.error("Failed to rollback offer on non-2xx response to re-INVITE");
            this.logger.error(error.message);
            if (this.state !== SessionState.Terminated) {
              if (!this.dialog) {
                throw new Error("Dialog undefined.");
              }
              const extraHeaders = [];
              extraHeaders.push("Reason: " + this.getReasonHeaderValue(500, "Internal Server Error"));
              this.dialog.bye(void 0, { extraHeaders });
              this.stateTransition(SessionState.Terminated);
            }
          }).then(() => {
            if (options.requestDelegate && options.requestDelegate.onReject) {
              options.requestDelegate.onReject(response);
            }
          });
        }
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onTrying: (response) => {
        return;
      }
    };
    const requestOptions = options.requestOptions || {};
    requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();
    requestOptions.extraHeaders.push("Allow: " + AllowedMethods.toString());
    requestOptions.extraHeaders.push("Contact: " + this._contact);
    if (options.withoutSdp) {
      if (!this.dialog) {
        this.pendingReinvite = false;
        throw new Error("Dialog undefined.");
      }
      return Promise.resolve(this.dialog.invite(delegate, requestOptions));
    }
    const offerOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
    };
    return this.getOffer(offerOptions).then((offerBody) => {
      if (!this.dialog) {
        this.pendingReinvite = false;
        throw new Error("Dialog undefined.");
      }
      requestOptions.body = offerBody;
      return this.dialog.invite(delegate, requestOptions);
    }).catch((error) => {
      this.logger.error(error.message);
      this.logger.error("Failed to send re-INVITE");
      this.pendingReinvite = false;
      throw error;
    });
  }
  /**
   * Deliver a {@link Message}. Sends a MESSAGE.
   * @param options - Options bucket. See {@link SessionMessageOptions} for details.
   */
  message(options = {}) {
    if (this.state !== SessionState.Established) {
      const message2 = "Session.message() may only be called if established session.";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const requestDelegate = options.requestDelegate;
    const requestOptions = this.copyRequestOptions(options.requestOptions);
    return this._message(requestDelegate, requestOptions);
  }
  /**
   * Proffer a {@link Referral}. Send a REFER.
   * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.
   * @param options - Options bucket. See {@link SessionReferOptions} for details.
   */
  refer(referTo, options = {}) {
    if (this.state !== SessionState.Established) {
      const message2 = "Session.refer() may only be called if established session.";
      this.logger.error(message2);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const requestDelegate = options.requestDelegate;
    const requestOptions = this.copyRequestOptions(options.requestOptions);
    requestOptions.extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) : this.referExtraHeaders(this.referToString(referTo));
    return this._refer(options.onNotify, requestDelegate, requestOptions);
  }
  /**
   * Send BYE.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _bye(delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    const dialog = this.dialog;
    switch (dialog.sessionState) {
      case SessionState$1.Initial:
        throw new Error(`Invalid dialog state ${dialog.sessionState}`);
      case SessionState$1.Early:
        throw new Error(`Invalid dialog state ${dialog.sessionState}`);
      case SessionState$1.AckWait: {
        this.stateTransition(SessionState.Terminating);
        return new Promise((resolve) => {
          dialog.delegate = {
            // When ACK shows up, say BYE.
            onAck: () => {
              const request = dialog.bye(delegate, options);
              this.stateTransition(SessionState.Terminated);
              resolve(request);
              return Promise.resolve();
            },
            // Or the server transaction times out before the ACK arrives.
            onAckTimeout: () => {
              const request = dialog.bye(delegate, options);
              this.stateTransition(SessionState.Terminated);
              resolve(request);
            }
          };
        });
      }
      case SessionState$1.Confirmed: {
        const request = dialog.bye(delegate, options);
        this.stateTransition(SessionState.Terminated);
        return Promise.resolve(request);
      }
      case SessionState$1.Terminated:
        throw new Error(`Invalid dialog state ${dialog.sessionState}`);
      default:
        throw new Error("Unrecognized state.");
    }
  }
  /**
   * Send INFO.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _info(delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    return Promise.resolve(this.dialog.info(delegate, options));
  }
  /**
   * Send MESSAGE.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _message(delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    return Promise.resolve(this.dialog.message(delegate, options));
  }
  /**
   * Send REFER.
   * @param onNotify - Notification callback.
   * @param delegate - Request delegate.
   * @param options - Request options bucket.
   * @internal
   */
  _refer(onNotify, delegate, options) {
    if (!this.dialog) {
      return Promise.reject(new Error("Session dialog undefined."));
    }
    this.onNotify = onNotify;
    return Promise.resolve(this.dialog.refer(delegate, options));
  }
  /**
   * Send ACK and then BYE. There are unrecoverable errors which can occur
   * while handling dialog forming and in-dialog INVITE responses and when
   * they occur we ACK the response and send a BYE.
   * Note that the BYE is sent in the dialog associated with the response
   * which is not necessarily `this.dialog`. And, accordingly, the
   * session state is not transitioned to terminated and session is not closed.
   * @param inviteResponse - The response causing the error.
   * @param statusCode - Status code for he reason phrase.
   * @param reasonPhrase - Reason phrase for the BYE.
   * @internal
   */
  ackAndBye(response, statusCode, reasonPhrase) {
    response.ack();
    const extraHeaders = [];
    if (statusCode) {
      extraHeaders.push("Reason: " + this.getReasonHeaderValue(statusCode, reasonPhrase));
    }
    response.session.bye(void 0, { extraHeaders });
  }
  /**
   * Handle in dialog ACK request.
   * @internal
   */
  onAckRequest(request) {
    this.logger.log("Session.onAckRequest");
    if (this.state !== SessionState.Established && this.state !== SessionState.Terminating) {
      this.logger.error(`ACK received while in state ${this.state}, dropping request`);
      return Promise.resolve();
    }
    const dialog = this.dialog;
    if (!dialog) {
      throw new Error("Dialog undefined.");
    }
    const answerOptions = {
      sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers
    };
    if (this.delegate && this.delegate.onAck) {
      const ack = new Ack2(request);
      this.delegate.onAck(ack);
    }
    this.pendingReinviteAck = false;
    switch (dialog.signalingState) {
      case SignalingState.Initial: {
        this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);
        const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
        dialog.bye(void 0, { extraHeaders });
        this.stateTransition(SessionState.Terminated);
        return Promise.resolve();
      }
      case SignalingState.Stable: {
        const body = getBody(request.message);
        if (!body) {
          return Promise.resolve();
        }
        if (body.contentDisposition === "render") {
          this._renderbody = body.content;
          this._rendertype = body.contentType;
          return Promise.resolve();
        }
        if (body.contentDisposition !== "session") {
          return Promise.resolve();
        }
        return this.setAnswer(body, answerOptions).catch((error) => {
          this.logger.error(error.message);
          const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
          dialog.bye(void 0, { extraHeaders });
          this.stateTransition(SessionState.Terminated);
        });
      }
      case SignalingState.HaveLocalOffer: {
        this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);
        const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
        dialog.bye(void 0, { extraHeaders });
        this.stateTransition(SessionState.Terminated);
        return Promise.resolve();
      }
      case SignalingState.HaveRemoteOffer: {
        this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);
        const extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
        dialog.bye(void 0, { extraHeaders });
        this.stateTransition(SessionState.Terminated);
        return Promise.resolve();
      }
      case SignalingState.Closed:
        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);
      default:
        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);
    }
  }
  /**
   * Handle in dialog BYE request.
   * @internal
   */
  onByeRequest(request) {
    this.logger.log("Session.onByeRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`BYE received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onBye) {
      const bye = new Bye2(request);
      this.delegate.onBye(bye);
    } else {
      request.accept();
    }
    this.stateTransition(SessionState.Terminated);
  }
  /**
   * Handle in dialog INFO request.
   * @internal
   */
  onInfoRequest(request) {
    this.logger.log("Session.onInfoRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`INFO received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onInfo) {
      const info = new Info2(request);
      this.delegate.onInfo(info);
    } else {
      request.accept();
    }
  }
  /**
   * Handle in dialog INVITE request.
   * @internal
   */
  onInviteRequest(request) {
    this.logger.log("Session.onInviteRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`INVITE received while in state ${this.state}, dropping request`);
      return;
    }
    this.pendingReinviteAck = true;
    const extraHeaders = ["Contact: " + this._contact];
    if (request.message.hasHeader("P-Asserted-Identity")) {
      const header = request.message.getHeader("P-Asserted-Identity");
      if (!header) {
        throw new Error("Header undefined.");
      }
      this._assertedIdentity = Grammar.nameAddrHeaderParse(header);
    }
    const options = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
    };
    if (this.delegate && this.delegate.beforeGenerateResponseOfferAnswerInDialog) {
      this.delegate.beforeGenerateResponseOfferAnswerInDialog(
        request.message,
        options.sessionDescriptionHandlerOptions
      );
    }
    this.generateResponseOfferAnswerInDialog(options).then((body) => {
      const outgoingResponse = request.accept({ statusCode: 200, extraHeaders, body });
      if (this.delegate && this.delegate.onInvite) {
        this.delegate.onInvite(request.message, outgoingResponse.message, 200);
      }
    }).catch((error) => {
      this.logger.error(error.message);
      this.logger.error("Failed to handle to re-INVITE request");
      if (!this.dialog) {
        throw new Error("Dialog undefined.");
      }
      this.logger.error(this.dialog.signalingState);
      if (this.dialog.signalingState === SignalingState.Stable) {
        const outgoingResponse = request.reject({ statusCode: 488 });
        if (this.delegate && this.delegate.onInvite) {
          this.delegate.onInvite(request.message, outgoingResponse.message, 488);
        }
        return;
      }
      this.rollbackOffer().then(() => {
        const outgoingResponse = request.reject({ statusCode: 488 });
        if (this.delegate && this.delegate.onInvite) {
          this.delegate.onInvite(request.message, outgoingResponse.message, 488);
        }
      }).catch((errorRollback) => {
        this.logger.error(errorRollback.message);
        this.logger.error("Failed to rollback offer on re-INVITE request");
        const outgoingResponse = request.reject({ statusCode: 488 });
        if (this.state !== SessionState.Terminated) {
          if (!this.dialog) {
            throw new Error("Dialog undefined.");
          }
          const extraHeadersBye = [];
          extraHeadersBye.push("Reason: " + this.getReasonHeaderValue(500, "Internal Server Error"));
          this.dialog.bye(void 0, { extraHeaders });
          this.stateTransition(SessionState.Terminated);
        }
        if (this.delegate && this.delegate.onInvite) {
          this.delegate.onInvite(request.message, outgoingResponse.message, 488);
        }
      });
    });
  }
  /**
   * Handle in dialog MESSAGE request.
   * @internal
   */
  onMessageRequest(request) {
    this.logger.log("Session.onMessageRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate.onMessage) {
      const message2 = new Message2(request);
      this.delegate.onMessage(message2);
    } else {
      request.accept();
    }
  }
  /**
   * Handle in dialog NOTIFY request.
   * @internal
   */
  onNotifyRequest(request) {
    this.logger.log("Session.onNotifyRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.onNotify) {
      const notification = new Notification2(request);
      this.onNotify(notification);
      return;
    }
    if (this.delegate && this.delegate.onNotify) {
      const notification = new Notification2(request);
      this.delegate.onNotify(notification);
    } else {
      request.accept();
    }
  }
  /**
   * Handle in dialog PRACK request.
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onPrackRequest(request) {
    this.logger.log("Session.onPrackRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`PRACK received while in state ${this.state}, dropping request`);
      return;
    }
    throw new Error("Unimplemented.");
  }
  /**
   * Handle in dialog REFER request.
   * @internal
   */
  onReferRequest(request) {
    this.logger.log("Session.onReferRequest");
    if (this.state !== SessionState.Established) {
      this.logger.error(`REFER received while in state ${this.state}, dropping request`);
      return;
    }
    if (!request.message.hasHeader("refer-to")) {
      this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting.");
      request.reject();
      return;
    }
    const referral = new Referral2(request, this);
    if (this.delegate && this.delegate.onRefer) {
      this.delegate.onRefer(referral);
    } else {
      this.logger.log("No delegate available to handle REFER, automatically accepting and following.");
      referral.accept().then(() => referral.makeInviter(this._referralInviterOptions).invite()).catch((error) => {
        this.logger.error(error.message);
      });
    }
  }
  /**
   * Generate an offer or answer for a response to an INVITE request.
   * If a remote offer was provided in the request, set the remote
   * description and get a local answer. If a remote offer was not
   * provided, generates a local offer.
   * @internal
   */
  generateResponseOfferAnswer(request, options) {
    if (this.dialog) {
      return this.generateResponseOfferAnswerInDialog(options);
    }
    const body = getBody(request.message);
    if (!body || body.contentDisposition !== "session") {
      return this.getOffer(options);
    } else {
      return this.setOfferAndGetAnswer(body, options);
    }
  }
  /**
   * Generate an offer or answer for a response to an INVITE request
   * when a dialog (early or otherwise) has already been established.
   * This method may NOT be called if a dialog has yet to be established.
   * @internal
   */
  generateResponseOfferAnswerInDialog(options) {
    if (!this.dialog) {
      throw new Error("Dialog undefined.");
    }
    switch (this.dialog.signalingState) {
      case SignalingState.Initial:
        return this.getOffer(options);
      case SignalingState.HaveLocalOffer:
        return Promise.resolve(void 0);
      case SignalingState.HaveRemoteOffer:
        if (!this.dialog.offer) {
          throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);
        }
        return this.setOfferAndGetAnswer(this.dialog.offer, options);
      case SignalingState.Stable:
        if (this.state !== SessionState.Established) {
          return Promise.resolve(void 0);
        }
        return this.getOffer(options);
      case SignalingState.Closed:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      default:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
    }
  }
  /**
   * Get local offer.
   * @internal
   */
  getOffer(options) {
    const sdh = this.setupSessionDescriptionHandler();
    const sdhOptions = options.sessionDescriptionHandlerOptions;
    const sdhModifiers = options.sessionDescriptionHandlerModifiers;
    try {
      return sdh.getDescription(sdhOptions, sdhModifiers).then((bodyAndContentType) => fromBodyLegacy(bodyAndContentType)).catch((error) => {
        this.logger.error("Session.getOffer: SDH getDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.getOffer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.getOffer: SDH getDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * Rollback local/remote offer.
   * @internal
   */
  rollbackOffer() {
    const sdh = this.setupSessionDescriptionHandler();
    if (sdh.rollbackDescription === void 0) {
      return Promise.resolve();
    }
    try {
      return sdh.rollbackDescription().catch((error) => {
        this.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.rollbackOffer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * Set remote answer.
   * @internal
   */
  setAnswer(answer, options) {
    const sdh = this.setupSessionDescriptionHandler();
    const sdhOptions = options.sessionDescriptionHandlerOptions;
    const sdhModifiers = options.sessionDescriptionHandlerModifiers;
    try {
      if (!sdh.hasDescription(answer.contentType)) {
        return Promise.reject(new ContentTypeUnsupportedError2());
      }
    } catch (error) {
      this.logger.error("Session.setAnswer: SDH hasDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
    try {
      return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch((error) => {
        this.logger.error("Session.setAnswer: SDH setDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.setAnswer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.setAnswer: SDH setDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * Set remote offer and get local answer.
   * @internal
   */
  setOfferAndGetAnswer(offer, options) {
    const sdh = this.setupSessionDescriptionHandler();
    const sdhOptions = options.sessionDescriptionHandlerOptions;
    const sdhModifiers = options.sessionDescriptionHandlerModifiers;
    try {
      if (!sdh.hasDescription(offer.contentType)) {
        return Promise.reject(new ContentTypeUnsupportedError2());
      }
    } catch (error) {
      this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
    try {
      return sdh.setDescription(offer.content, sdhOptions, sdhModifiers).then(() => sdh.getDescription(sdhOptions, sdhModifiers)).then((bodyAndContentType) => fromBodyLegacy(bodyAndContentType)).catch((error) => {
        this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");
        const e2 = error instanceof Error ? error : new Error("Session.setOfferAndGetAnswer unknown error.");
        this.logger.error(e2.message);
        throw e2;
      });
    } catch (error) {
      this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");
      const e2 = error instanceof Error ? error : new Error(error);
      this.logger.error(e2.message);
      return Promise.reject(e2);
    }
  }
  /**
   * SDH for confirmed dialog.
   * @internal
   */
  setSessionDescriptionHandler(sdh) {
    if (this._sessionDescriptionHandler) {
      throw new Error("Session description handler defined.");
    }
    this._sessionDescriptionHandler = sdh;
  }
  /**
   * SDH for confirmed dialog.
   * @internal
   */
  setupSessionDescriptionHandler() {
    var _a;
    if (this._sessionDescriptionHandler) {
      return this._sessionDescriptionHandler;
    }
    this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);
    if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {
      this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);
    }
    return this._sessionDescriptionHandler;
  }
  /**
   * Transition session state.
   * @internal
   */
  stateTransition(newState) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case SessionState.Initial:
        if (newState !== SessionState.Establishing && newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState.Establishing:
        if (newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState.Established:
        if (newState !== SessionState.Terminating && newState !== SessionState.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState.Terminating:
        if (newState !== SessionState.Terminated) {
          invalidTransition();
        }
        break;
      case SessionState.Terminated:
        invalidTransition();
        break;
      default:
        throw new Error("Unrecognized state.");
    }
    this._state = newState;
    this.logger.log(`Session ${this.id} transitioned to state ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === SessionState.Terminated) {
      this.dispose();
    }
  }
  copyRequestOptions(requestOptions = {}) {
    const extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : void 0;
    const body = requestOptions.body ? {
      contentDisposition: requestOptions.body.contentDisposition || "render",
      contentType: requestOptions.body.contentType || "text/plain",
      content: requestOptions.body.content || ""
    } : void 0;
    return {
      extraHeaders,
      body
    };
  }
  getReasonHeaderValue(code, reason) {
    const cause = code;
    let text = getReasonPhrase(code);
    if (!text && reason) {
      text = reason;
    }
    return "SIP;cause=" + cause + ';text="' + text + '"';
  }
  referExtraHeaders(referTo) {
    const extraHeaders = [];
    extraHeaders.push("Referred-By: <" + this.userAgent.configuration.uri + ">");
    extraHeaders.push("Contact: " + this._contact);
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());
    extraHeaders.push("Refer-To: " + referTo);
    return extraHeaders;
  }
  referToString(target) {
    let referTo;
    if (target instanceof URI2) {
      referTo = target.toString();
    } else {
      if (!target.dialog) {
        throw new Error("Dialog undefined.");
      }
      const displayName = target.remoteIdentity.friendlyName;
      const remoteTarget = target.dialog.remoteTarget.toString();
      const callId = target.dialog.callId;
      const remoteTag = target.dialog.remoteTag;
      const localTag = target.dialog.localTag;
      const replaces = encodeURIComponent(`${callId};to-tag=${remoteTag};from-tag=${localTag}`);
      referTo = `"${displayName}" <${remoteTarget}?Replaces=${replaces}>`;
    }
    return referTo;
  }
}
var SIPExtension;
(function(SIPExtension2) {
  SIPExtension2["Required"] = "Required";
  SIPExtension2["Supported"] = "Supported";
  SIPExtension2["Unsupported"] = "Unsupported";
})(SIPExtension || (SIPExtension = {}));
const UserAgentRegisteredOptionTags = {
  "100rel": true,
  "199": true,
  answermode: true,
  "early-session": true,
  eventlist: true,
  explicitsub: true,
  "from-change": true,
  "geolocation-http": true,
  "geolocation-sip": true,
  gin: true,
  gruu: true,
  histinfo: true,
  ice: true,
  join: true,
  "multiple-refer": true,
  norefersub: true,
  nosub: true,
  outbound: true,
  path: true,
  policy: true,
  precondition: true,
  pref: true,
  privacy: true,
  "recipient-list-invite": true,
  "recipient-list-message": true,
  "recipient-list-subscribe": true,
  replaces: true,
  "resource-priority": true,
  "sdp-anat": true,
  "sec-agree": true,
  tdialog: true,
  timer: true,
  uui: true
  // RFC 7433
};
class Invitation2 extends Session2 {
  /** @internal */
  constructor(userAgent, incomingInviteRequest) {
    super(userAgent);
    this.incomingInviteRequest = incomingInviteRequest;
    this.disposed = false;
    this.expiresTimer = void 0;
    this.isCanceled = false;
    this.rel100 = "none";
    this.rseq = Math.floor(Math.random() * 1e4);
    this.userNoAnswerTimer = void 0;
    this.waitingForPrack = false;
    this.logger = userAgent.getLogger("sip.Invitation");
    const incomingRequestMessage = this.incomingInviteRequest.message;
    const requireHeader = incomingRequestMessage.getHeader("require");
    if (requireHeader && requireHeader.toLowerCase().includes("100rel")) {
      this.rel100 = "required";
    }
    const supportedHeader = incomingRequestMessage.getHeader("supported");
    if (supportedHeader && supportedHeader.toLowerCase().includes("100rel")) {
      this.rel100 = "supported";
    }
    incomingRequestMessage.toTag = incomingInviteRequest.toTag;
    if (typeof incomingRequestMessage.toTag !== "string") {
      throw new TypeError("toTag should have been a string.");
    }
    this.userNoAnswerTimer = setTimeout(() => {
      incomingInviteRequest.reject({ statusCode: 480 });
      this.stateTransition(SessionState.Terminated);
    }, this.userAgent.configuration.noAnswerTimeout ? this.userAgent.configuration.noAnswerTimeout * 1e3 : 6e4);
    if (incomingRequestMessage.hasHeader("expires")) {
      const expires = Number(incomingRequestMessage.getHeader("expires") || 0) * 1e3;
      this.expiresTimer = setTimeout(() => {
        if (this.state === SessionState.Initial) {
          incomingInviteRequest.reject({ statusCode: 487 });
          this.stateTransition(SessionState.Terminated);
        }
      }, expires);
    }
    const assertedIdentity = this.request.getHeader("P-Asserted-Identity");
    if (assertedIdentity) {
      this._assertedIdentity = Grammar.nameAddrHeaderParse(assertedIdentity);
    }
    this._contact = this.userAgent.contact.toString();
    const contentDisposition = incomingRequestMessage.parseHeader("Content-Disposition");
    if (contentDisposition && contentDisposition.type === "render") {
      this._renderbody = incomingRequestMessage.body;
      this._rendertype = incomingRequestMessage.getHeader("Content-Type");
    }
    this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag;
    this.userAgent._sessions[this._id] = this;
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    if (this.expiresTimer) {
      clearTimeout(this.expiresTimer);
      this.expiresTimer = void 0;
    }
    if (this.userNoAnswerTimer) {
      clearTimeout(this.userNoAnswerTimer);
      this.userNoAnswerTimer = void 0;
    }
    this.prackNeverArrived();
    switch (this.state) {
      case SessionState.Initial:
        return this.reject().then(() => super.dispose());
      case SessionState.Establishing:
        return this.reject().then(() => super.dispose());
      case SessionState.Established:
        return super.dispose();
      case SessionState.Terminating:
        return super.dispose();
      case SessionState.Terminated:
        return super.dispose();
      default:
        throw new Error("Unknown state.");
    }
  }
  /**
   * If true, a first provisional response after the 100 Trying
   * will be sent automatically. This is false it the UAC required
   * reliable provisional responses (100rel in Require header) or
   * the user agent configuration has specified to not send an
   * initial response, otherwise it is true. The provisional is sent by
   * calling `progress()` without any options.
   */
  get autoSendAnInitialProvisionalResponse() {
    return this.rel100 !== "required" && this.userAgent.configuration.sendInitialProvisionalResponse;
  }
  /**
   * Initial incoming INVITE request message body.
   */
  get body() {
    return this.incomingInviteRequest.message.body;
  }
  /**
   * The identity of the local user.
   */
  get localIdentity() {
    return this.request.to;
  }
  /**
   * The identity of the remote user.
   */
  get remoteIdentity() {
    return this.request.from;
  }
  /**
   * Initial incoming INVITE request message.
   */
  get request() {
    return this.incomingInviteRequest.message;
  }
  /**
   * Accept the invitation.
   *
   * @remarks
   * Accept the incoming INVITE request to start a Session.
   * Replies to the INVITE request with a 200 Ok response.
   * Resolves once the response sent, otherwise rejects.
   *
   * This method may reject for a variety of reasons including
   * the receipt of a CANCEL request before `accept` is able
   * to construct a response.
   * @param options - Options bucket.
   */
  accept(options = {}) {
    this.logger.log("Invitation.accept");
    if (this.state !== SessionState.Initial) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    this.stateTransition(SessionState.Establishing);
    return this.sendAccept(options).then(({ message: message2, session: session2 }) => {
      session2.delegate = {
        onAck: (ackRequest) => this.onAckRequest(ackRequest),
        onAckTimeout: () => this.onAckTimeout(),
        onBye: (byeRequest) => this.onByeRequest(byeRequest),
        onInfo: (infoRequest) => this.onInfoRequest(infoRequest),
        onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),
        onMessage: (messageRequest) => this.onMessageRequest(messageRequest),
        onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),
        onPrack: (prackRequest) => this.onPrackRequest(prackRequest),
        _onCancel: (messageRequest) => this._onCancel(messageRequest),
        onRefer: (referRequest) => this.onReferRequest(referRequest)
      };
      this._dialog = session2;
      this.stateTransition(SessionState.Established);
      if (this._replacee) {
        this._replacee._bye();
      }
    }).catch((error) => this.handleResponseError(error));
  }
  /**
   * Indicate progress processing the invitation.
   *
   * @remarks
   * Report progress to the the caller.
   * Replies to the INVITE request with a 1xx provisional response.
   * Resolves once the response sent, otherwise rejects.
   * @param options - Options bucket.
   */
  progress(options = {}) {
    this.logger.log("Invitation.progress");
    if (this.state !== SessionState.Initial) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    const statusCode = options.statusCode || 180;
    if (statusCode < 100 || statusCode > 199) {
      throw new TypeError("Invalid statusCode: " + statusCode);
    }
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    if (this.waitingForPrack) {
      this.logger.warn("Unexpected call for progress while waiting for prack, ignoring");
      return Promise.resolve();
    }
    if (options.statusCode === 100) {
      return this.sendProgressTrying().then(() => {
        return;
      }).catch((error) => this.handleResponseError(error));
    }
    if (!(this.rel100 === "required") && !(this.rel100 === "supported" && options.rel100) && !(this.rel100 === "supported" && this.userAgent.configuration.sipExtension100rel === SIPExtension.Required)) {
      return this.sendProgress(options).then(() => {
        return;
      }).catch((error) => this.handleResponseError(error));
    }
    return this.sendProgressReliableWaitForPrack(options).then(() => {
      return;
    }).catch((error) => this.handleResponseError(error));
  }
  /**
   * Reject the invitation.
   *
   * @remarks
   * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.
   * Resolves once the response sent, otherwise rejects.
   *
   * The expectation is that this method is used to reject an INVITE request.
   * That is indeed the case - a call to `progress` followed by `reject` is
   * a typical way to "decline" an incoming INVITE request. However it may
   * also be called after calling `accept` (but only before it completes)
   * which will reject the call and cause `accept` to reject.
   * @param options - Options bucket.
   */
  reject(options = {}) {
    this.logger.log("Invitation.reject");
    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    const statusCode = options.statusCode || 480;
    const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(statusCode);
    const extraHeaders = options.extraHeaders || [];
    if (statusCode < 300 || statusCode > 699) {
      throw new TypeError("Invalid statusCode: " + statusCode);
    }
    const body = options.body ? fromBodyLegacy(options.body) : void 0;
    statusCode < 400 ? this.incomingInviteRequest.redirect([], { statusCode, reasonPhrase, extraHeaders, body }) : this.incomingInviteRequest.reject({ statusCode, reasonPhrase, extraHeaders, body });
    this.stateTransition(SessionState.Terminated);
    return Promise.resolve();
  }
  /**
   * Handle CANCEL request.
   *
   * @param message - CANCEL message.
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _onCancel(message2) {
    this.logger.log("Invitation._onCancel");
    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {
      this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);
      return;
    }
    if (this.delegate && this.delegate._onCancel) {
      this.delegate._onCancel(message2);
    }
    this.isCanceled = true;
    this.incomingInviteRequest.reject({ statusCode: 487 });
    this.stateTransition(SessionState.Terminated);
  }
  /**
   * Helper function to handle offer/answer in a PRACK.
   */
  handlePrackOfferAnswer(request) {
    if (!this.dialog) {
      throw new Error("Dialog undefined.");
    }
    const body = getBody(request.message);
    if (!body || body.contentDisposition !== "session") {
      return Promise.resolve(void 0);
    }
    const options = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    switch (this.dialog.signalingState) {
      case SignalingState.Initial:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      case SignalingState.Stable:
        return this.setAnswer(body, options).then(() => void 0);
      case SignalingState.HaveLocalOffer:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      case SignalingState.HaveRemoteOffer:
        return this.setOfferAndGetAnswer(body, options);
      case SignalingState.Closed:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
      default:
        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);
    }
  }
  /**
   * A handler for errors which occur while attempting to send 1xx and 2xx responses.
   * In all cases, an attempt is made to reject the request if it is still outstanding.
   * And while there are a variety of things which can go wrong and we log something here
   * for all errors, there are a handful of common exceptions we pay some extra attention to.
   * @param error - The error which occurred.
   */
  handleResponseError(error) {
    let statusCode = 480;
    if (error instanceof Error) {
      this.logger.error(error.message);
    } else {
      this.logger.error(error);
    }
    if (error instanceof ContentTypeUnsupportedError2) {
      this.logger.error("A session description handler occurred while sending response (content type unsupported");
      statusCode = 415;
    } else if (error instanceof SessionDescriptionHandlerError2) {
      this.logger.error("A session description handler occurred while sending response");
    } else if (error instanceof SessionTerminatedError2) {
      this.logger.error("Session ended before response could be formulated and sent (while waiting for PRACK)");
    } else if (error instanceof TransactionStateError2) {
      this.logger.error("Session changed state before response could be formulated and sent");
    }
    if (this.state === SessionState.Initial || this.state === SessionState.Establishing) {
      try {
        this.incomingInviteRequest.reject({ statusCode });
        this.stateTransition(SessionState.Terminated);
      } catch (e2) {
        this.logger.error("An error occurred attempting to reject the request while handling another error");
        throw e2;
      }
    }
    if (this.isCanceled) {
      this.logger.warn("An error occurred while attempting to formulate and send a response to an incoming INVITE. However a CANCEL was received and processed while doing so which can (and often does) result in errors occurring as the session terminates in the meantime. Said error is being ignored.");
      return;
    }
    throw error;
  }
  /**
   * Callback for when ACK for a 2xx response is never received.
   * @param session - Session the ACK never arrived for.
   */
  onAckTimeout() {
    this.logger.log("Invitation.onAckTimeout");
    if (!this.dialog) {
      throw new Error("Dialog undefined.");
    }
    this.logger.log("No ACK received for an extended period of time, terminating session");
    this.dialog.bye();
    this.stateTransition(SessionState.Terminated);
  }
  /**
   * A version of `accept` which resolves a session when the 200 Ok response is sent.
   * @param options - Options bucket.
   */
  sendAccept(options = {}) {
    const responseOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    const extraHeaders = options.extraHeaders || [];
    if (this.waitingForPrack) {
      return this.waitForArrivalOfPrack().then(() => clearTimeout(this.userNoAnswerTimer)).then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)).then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body, extraHeaders }));
    }
    clearTimeout(this.userNoAnswerTimer);
    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body, extraHeaders }));
  }
  /**
   * A version of `progress` which resolves when the provisional response is sent.
   * @param options - Options bucket.
   */
  sendProgress(options = {}) {
    const statusCode = options.statusCode || 180;
    const reasonPhrase = options.reasonPhrase;
    const extraHeaders = (options.extraHeaders || []).slice();
    const body = options.body ? fromBodyLegacy(options.body) : void 0;
    if (statusCode === 183 && !body) {
      return this.sendProgressWithSDP(options);
    }
    try {
      const progressResponse = this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });
      this._dialog = progressResponse.session;
      return Promise.resolve(progressResponse);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  /**
   * A version of `progress` which resolves when the provisional response with sdp is sent.
   * @param options - Options bucket.
   */
  sendProgressWithSDP(options = {}) {
    const responseOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    const statusCode = options.statusCode || 183;
    const reasonPhrase = options.reasonPhrase;
    const extraHeaders = (options.extraHeaders || []).slice();
    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((body) => this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body })).then((progressResponse) => {
      this._dialog = progressResponse.session;
      return progressResponse;
    });
  }
  /**
   * A version of `progress` which resolves when the reliable provisional response is sent.
   * @param options - Options bucket.
   */
  sendProgressReliable(options = {}) {
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.extraHeaders.push("Require: 100rel");
    options.extraHeaders.push("RSeq: " + Math.floor(Math.random() * 1e4));
    return this.sendProgressWithSDP(options);
  }
  /**
   * A version of `progress` which resolves when the reliable provisional response is acknowledged.
   * @param options - Options bucket.
   */
  sendProgressReliableWaitForPrack(options = {}) {
    const responseOptions = {
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
    };
    const statusCode = options.statusCode || 183;
    const reasonPhrase = options.reasonPhrase;
    const extraHeaders = (options.extraHeaders || []).slice();
    extraHeaders.push("Require: 100rel");
    extraHeaders.push("RSeq: " + this.rseq++);
    let body;
    return new Promise((resolve, reject) => {
      this.waitingForPrack = true;
      this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((offerAnswer) => {
        body = offerAnswer;
        return this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });
      }).then((progressResponse) => {
        this._dialog = progressResponse.session;
        let prackRequest;
        let prackResponse;
        progressResponse.session.delegate = {
          onPrack: (request) => {
            prackRequest = request;
            clearTimeout(prackWaitTimeoutTimer);
            clearTimeout(rel1xxRetransmissionTimer);
            if (!this.waitingForPrack) {
              return;
            }
            this.waitingForPrack = false;
            this.handlePrackOfferAnswer(prackRequest).then((prackResponseBody) => {
              try {
                prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });
                this.prackArrived();
                resolve({ prackRequest, prackResponse, progressResponse });
              } catch (error) {
                reject(error);
              }
            }).catch((error) => reject(error));
          }
        };
        const prackWaitTimeout = () => {
          if (!this.waitingForPrack) {
            return;
          }
          this.waitingForPrack = false;
          this.logger.warn("No PRACK received, rejecting INVITE.");
          clearTimeout(rel1xxRetransmissionTimer);
          this.reject({ statusCode: 504 }).then(() => reject(new SessionTerminatedError2())).catch((error) => reject(error));
        };
        const prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers.T1 * 64);
        const rel1xxRetransmission = () => {
          try {
            this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });
          } catch (error) {
            this.waitingForPrack = false;
            reject(error);
            return;
          }
          rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout2 *= 2);
        };
        let timeout2 = Timers.T1;
        let rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout2);
      }).catch((error) => {
        this.waitingForPrack = false;
        reject(error);
      });
    });
  }
  /**
   * A version of `progress` which resolves when a 100 Trying provisional response is sent.
   */
  sendProgressTrying() {
    try {
      const progressResponse = this.incomingInviteRequest.trying();
      return Promise.resolve(progressResponse);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  /**
   * When attempting to accept the INVITE, an invitation waits
   * for any outstanding PRACK to arrive before sending the 200 Ok.
   * It will be waiting on this Promise to resolve which lets it know
   * the PRACK has arrived and it may proceed to send the 200 Ok.
   */
  waitForArrivalOfPrack() {
    if (this.waitingForPrackPromise) {
      throw new Error("Already waiting for PRACK");
    }
    this.waitingForPrackPromise = new Promise((resolve, reject) => {
      this.waitingForPrackResolve = resolve;
      this.waitingForPrackReject = reject;
    });
    return this.waitingForPrackPromise;
  }
  /**
   * Here we are resolving the promise which in turn will cause
   * the accept to proceed (it may still fail for other reasons, but...).
   */
  prackArrived() {
    if (this.waitingForPrackResolve) {
      this.waitingForPrackResolve();
    }
    this.waitingForPrackPromise = void 0;
    this.waitingForPrackResolve = void 0;
    this.waitingForPrackReject = void 0;
  }
  /**
   * Here we are rejecting the promise which in turn will cause
   * the accept to fail and the session to transition to "terminated".
   */
  prackNeverArrived() {
    if (this.waitingForPrackReject) {
      this.waitingForPrackReject(new SessionTerminatedError2());
    }
    this.waitingForPrackPromise = void 0;
    this.waitingForPrackResolve = void 0;
    this.waitingForPrackReject = void 0;
  }
}
class Inviter2 extends Session2 {
  /**
   * Constructs a new instance of the `Inviter` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param options - Options bucket. See {@link InviterOptions} for details.
   */
  constructor(userAgent, targetURI, options = {}) {
    super(userAgent, options);
    this.disposed = false;
    this.earlyMedia = false;
    this.earlyMediaSessionDescriptionHandlers = /* @__PURE__ */ new Map();
    this.isCanceled = false;
    this.inviteWithoutSdp = false;
    this.logger = userAgent.getLogger("sip.Inviter");
    this.earlyMedia = options.earlyMedia !== void 0 ? options.earlyMedia : this.earlyMedia;
    this.fromTag = newTag();
    this.inviteWithoutSdp = options.inviteWithoutSdp !== void 0 ? options.inviteWithoutSdp : this.inviteWithoutSdp;
    const inviterOptions = Object.assign({}, options);
    inviterOptions.params = Object.assign({}, options.params);
    const anonymous = options.anonymous || false;
    const contact2 = userAgent.contact.toString({
      anonymous,
      // Do not add ;ob in initial forming dialog requests if the
      // registration over the current connection got a GRUU URI.
      outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu
    });
    if (anonymous && userAgent.configuration.uri) {
      inviterOptions.params.fromDisplayName = "Anonymous";
      inviterOptions.params.fromUri = "sip:anonymous@anonymous.invalid";
    }
    let fromURI = userAgent.userAgentCore.configuration.aor;
    if (inviterOptions.params.fromUri) {
      fromURI = typeof inviterOptions.params.fromUri === "string" ? Grammar.URIParse(inviterOptions.params.fromUri) : inviterOptions.params.fromUri;
    }
    if (!fromURI) {
      throw new TypeError("Invalid from URI: " + inviterOptions.params.fromUri);
    }
    let toURI = targetURI;
    if (inviterOptions.params.toUri) {
      toURI = typeof inviterOptions.params.toUri === "string" ? Grammar.URIParse(inviterOptions.params.toUri) : inviterOptions.params.toUri;
    }
    if (!toURI) {
      throw new TypeError("Invalid to URI: " + inviterOptions.params.toUri);
    }
    const messageOptions = Object.assign({}, inviterOptions.params);
    messageOptions.fromTag = this.fromTag;
    const extraHeaders = (inviterOptions.extraHeaders || []).slice();
    if (anonymous && userAgent.configuration.uri) {
      extraHeaders.push("P-Preferred-Identity: " + userAgent.configuration.uri.toString());
      extraHeaders.push("Privacy: id");
    }
    extraHeaders.push("Contact: " + contact2);
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "UPDATE", "INFO", "NOTIFY", "REFER"].toString());
    if (userAgent.configuration.sipExtension100rel === SIPExtension.Required) {
      extraHeaders.push("Require: 100rel");
    }
    if (userAgent.configuration.sipExtensionReplaces === SIPExtension.Required) {
      extraHeaders.push("Require: replaces");
    }
    inviterOptions.extraHeaders = extraHeaders;
    const body = void 0;
    this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body);
    this._contact = contact2;
    this._referralInviterOptions = inviterOptions;
    this._renderbody = options.renderbody;
    this._rendertype = options.rendertype;
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    if (options.sessionDescriptionHandlerModifiersReInvite) {
      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;
    }
    if (options.sessionDescriptionHandlerOptionsReInvite) {
      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;
    }
    this._id = this.outgoingRequestMessage.callId + this.fromTag;
    this.userAgent._sessions[this._id] = this;
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    this.disposeEarlyMedia();
    switch (this.state) {
      case SessionState.Initial:
        return this.cancel().then(() => super.dispose());
      case SessionState.Establishing:
        return this.cancel().then(() => super.dispose());
      case SessionState.Established:
        return super.dispose();
      case SessionState.Terminating:
        return super.dispose();
      case SessionState.Terminated:
        return super.dispose();
      default:
        throw new Error("Unknown state.");
    }
  }
  /**
   * Initial outgoing INVITE request message body.
   */
  get body() {
    return this.outgoingRequestMessage.body;
  }
  /**
   * The identity of the local user.
   */
  get localIdentity() {
    return this.outgoingRequestMessage.from;
  }
  /**
   * The identity of the remote user.
   */
  get remoteIdentity() {
    return this.outgoingRequestMessage.to;
  }
  /**
   * Initial outgoing INVITE request message.
   */
  get request() {
    return this.outgoingRequestMessage;
  }
  /**
   * Cancels the INVITE request.
   *
   * @remarks
   * Sends a CANCEL request.
   * Resolves once the response sent, otherwise rejects.
   *
   * After sending a CANCEL request the expectation is that a 487 final response
   * will be received for the INVITE. However a 200 final response to the INVITE
   * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before
   * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect
   * is that this method will terminate the session regardless of the race.
   * @param options - Options bucket.
   */
  cancel(options = {}) {
    this.logger.log("Inviter.cancel");
    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {
      const error = new Error(`Invalid session state ${this.state}`);
      this.logger.error(error.message);
      return Promise.reject(error);
    }
    this.isCanceled = true;
    this.stateTransition(SessionState.Terminating);
    function getCancelReason(code, reason) {
      if (code && code < 200 || code > 699) {
        throw new TypeError("Invalid statusCode: " + code);
      } else if (code) {
        const cause = code;
        const text = getReasonPhrase(code) || reason;
        return "SIP;cause=" + cause + ';text="' + text + '"';
      }
    }
    if (this.outgoingInviteRequest) {
      let cancelReason;
      if (options.statusCode && options.reasonPhrase) {
        cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);
      }
      this.outgoingInviteRequest.cancel(cancelReason, options);
    } else {
      this.logger.warn("Canceled session before INVITE was sent");
      this.stateTransition(SessionState.Terminated);
    }
    return Promise.resolve();
  }
  /**
   * Sends the INVITE request.
   *
   * @remarks
   * TLDR...
   *  1) Only one offer/answer exchange permitted during initial INVITE.
   *  2) No "early media" if the initial offer is in an INVITE (default behavior).
   *  3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
   *
   * 1) Only one offer/answer exchange permitted during initial INVITE.
   *
   * Our implementation replaces the following bullet point...
   *
   * o  After having sent or received an answer to the first offer, the
   *    UAC MAY generate subsequent offers in requests based on rules
   *    specified for that method, but only if it has received answers
   *    to any previous offers, and has not sent any offers to which it
   *    hasn't gotten an answer.
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   *
   * ...with...
   *
   * o  After having sent or received an answer to the first offer, the
   *    UAC MUST NOT generate subsequent offers in requests based on rules
   *    specified for that method.
   *
   * ...which in combination with this bullet point...
   *
   * o  Once the UAS has sent or received an answer to the initial
   *    offer, it MUST NOT generate subsequent offers in any responses
   *    to the initial INVITE.  This means that a UAS based on this
   *    specification alone can never generate subsequent offers until
   *    completion of the initial transaction.
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   *
   * ...ensures that EXACTLY ONE offer/answer exchange will occur
   * during an initial out of dialog INVITE request made by our UAC.
   *
   *
   * 2) No "early media" if the initial offer is in an INVITE (default behavior).
   *
   * While our implementation adheres to the following bullet point...
   *
   * o  If the initial offer is in an INVITE, the answer MUST be in a
   *    reliable non-failure message from UAS back to UAC which is
   *    correlated to that INVITE.  For this specification, that is
   *    only the final 2xx response to that INVITE.  That same exact
   *    answer MAY also be placed in any provisional responses sent
   *    prior to the answer.  The UAC MUST treat the first session
   *    description it receives as the answer, and MUST ignore any
   *    session descriptions in subsequent responses to the initial
   *    INVITE.
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   *
   * We have made the following implementation decision with regard to early media...
   *
   * o  If the initial offer is in the INVITE, the answer from the
   *    UAS back to the UAC will establish a media session only
   *    only after the final 2xx response to that INVITE is received.
   *
   * The reason for this decision is rooted in a restriction currently
   * inherent in WebRTC. Specifically, while a SIP INVITE request with an
   * initial offer may fork resulting in more than one provisional answer,
   * there is currently no easy/good way to to "fork" an offer generated
   * by a peer connection. In particular, a WebRTC offer currently may only
   * be matched with one answer and we have no good way to know which
   * "provisional answer" is going to be the "final answer". So we have
   * decided to punt and not create any "early media" sessions in this case.
   *
   * The upshot is that if you want "early media", you must not put the
   * initial offer in the INVITE. Instead, force the UAS to provide the
   * initial offer by sending an INVITE without an offer. In the WebRTC
   * case this allows us to create a unique peer connection with a unique
   * answer for every provisional offer with "early media" on all of them.
   *
   *
   * 3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
   *
   * The default behavior may be altered and "early media" utilized if the
   * initial offer is in the an INVITE by setting the `earlyMedia` options.
   * However in that case the INVITE request MUST NOT fork. This allows for
   * "early media" in environments where the forking behavior of the SIP
   * servers being utilized is configured to disallow forking.
   */
  invite(options = {}) {
    this.logger.log("Inviter.invite");
    if (this.state !== SessionState.Initial) {
      return super.invite(options);
    }
    if (options.sessionDescriptionHandlerModifiers) {
      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }
    if (options.sessionDescriptionHandlerOptions) {
      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    }
    if (options.withoutSdp || this.inviteWithoutSdp) {
      if (this._renderbody && this._rendertype) {
        this.outgoingRequestMessage.body = { contentType: this._rendertype, body: this._renderbody };
      }
      this.stateTransition(SessionState.Establishing);
      return Promise.resolve(this.sendInvite(options));
    }
    const offerOptions = {
      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
    };
    return this.getOffer(offerOptions).then((body) => {
      this.outgoingRequestMessage.body = { body: body.content, contentType: body.contentType };
      this.stateTransition(SessionState.Establishing);
      return this.sendInvite(options);
    }).catch((error) => {
      this.logger.log(error.message);
      this.stateTransition(SessionState.Terminated);
      throw error;
    });
  }
  /**
   * 13.2.1 Creating the Initial INVITE
   *
   * Since the initial INVITE represents a request outside of a dialog,
   * its construction follows the procedures of Section 8.1.1.  Additional
   * processing is required for the specific case of INVITE.
   *
   * An Allow header field (Section 20.5) SHOULD be present in the INVITE.
   * It indicates what methods can be invoked within a dialog, on the UA
   * sending the INVITE, for the duration of the dialog.  For example, a
   * UA capable of receiving INFO requests within a dialog [34] SHOULD
   * include an Allow header field listing the INFO method.
   *
   * A Supported header field (Section 20.37) SHOULD be present in the
   * INVITE.  It enumerates all the extensions understood by the UAC.
   *
   * An Accept (Section 20.1) header field MAY be present in the INVITE.
   * It indicates which Content-Types are acceptable to the UA, in both
   * the response received by it, and in any subsequent requests sent to
   * it within dialogs established by the INVITE.  The Accept header field
   * is especially useful for indicating support of various session
   * description formats.
   *
   * The UAC MAY add an Expires header field (Section 20.19) to limit the
   * validity of the invitation.  If the time indicated in the Expires
   * header field is reached and no final answer for the INVITE has been
   * received, the UAC core SHOULD generate a CANCEL request for the
   * INVITE, as per Section 9.
   *
   * A UAC MAY also find it useful to add, among others, Subject (Section
   * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)
   * header fields.  They all contain information related to the INVITE.
   *
   * The UAC MAY choose to add a message body to the INVITE.  Section
   * 8.1.1.10 deals with how to construct the header fields -- Content-
   * Type among others -- needed to describe the message body.
   *
   * https://tools.ietf.org/html/rfc3261#section-13.2.1
   */
  sendInvite(options = {}) {
    this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {
      onAccept: (inviteResponse) => {
        if (this.dialog) {
          this.logger.log("Additional confirmed dialog, sending ACK and BYE");
          this.ackAndBye(inviteResponse);
          return;
        }
        if (this.isCanceled) {
          this.logger.log("Canceled session accepted, sending ACK and BYE");
          this.ackAndBye(inviteResponse);
          this.stateTransition(SessionState.Terminated);
          return;
        }
        this.notifyReferer(inviteResponse);
        this.onAccept(inviteResponse).then(() => {
          this.disposeEarlyMedia();
        }).catch(() => {
          this.disposeEarlyMedia();
        }).then(() => {
          if (options.requestDelegate && options.requestDelegate.onAccept) {
            options.requestDelegate.onAccept(inviteResponse);
          }
        });
      },
      onProgress: (inviteResponse) => {
        if (this.isCanceled) {
          return;
        }
        this.notifyReferer(inviteResponse);
        this.onProgress(inviteResponse).catch(() => {
          this.disposeEarlyMedia();
        }).then(() => {
          if (options.requestDelegate && options.requestDelegate.onProgress) {
            options.requestDelegate.onProgress(inviteResponse);
          }
        });
      },
      onRedirect: (inviteResponse) => {
        this.notifyReferer(inviteResponse);
        this.onRedirect(inviteResponse);
        if (options.requestDelegate && options.requestDelegate.onRedirect) {
          options.requestDelegate.onRedirect(inviteResponse);
        }
      },
      onReject: (inviteResponse) => {
        this.notifyReferer(inviteResponse);
        this.onReject(inviteResponse);
        if (options.requestDelegate && options.requestDelegate.onReject) {
          options.requestDelegate.onReject(inviteResponse);
        }
      },
      onTrying: (inviteResponse) => {
        this.notifyReferer(inviteResponse);
        this.onTrying(inviteResponse);
        if (options.requestDelegate && options.requestDelegate.onTrying) {
          options.requestDelegate.onTrying(inviteResponse);
        }
      }
    });
    return this.outgoingInviteRequest;
  }
  disposeEarlyMedia() {
    this.earlyMediaSessionDescriptionHandlers.forEach((sessionDescriptionHandler) => {
      sessionDescriptionHandler.close();
    });
    this.earlyMediaSessionDescriptionHandlers.clear();
  }
  notifyReferer(response) {
    if (!this._referred) {
      return;
    }
    if (!(this._referred instanceof Session2)) {
      throw new Error("Referred session not instance of session");
    }
    if (!this._referred.dialog) {
      return;
    }
    if (!response.message.statusCode) {
      throw new Error("Status code undefined.");
    }
    if (!response.message.reasonPhrase) {
      throw new Error("Reason phrase undefined.");
    }
    const statusCode = response.message.statusCode;
    const reasonPhrase = response.message.reasonPhrase;
    const body = `SIP/2.0 ${statusCode} ${reasonPhrase}`.trim();
    const outgoingNotifyRequest = this._referred.dialog.notify(void 0, {
      extraHeaders: ["Event: refer", "Subscription-State: terminated"],
      body: {
        contentDisposition: "render",
        contentType: "message/sipfrag",
        content: body
      }
    });
    outgoingNotifyRequest.delegate = {
      onReject: () => {
        this._referred = void 0;
      }
    };
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 2xx response.
   */
  onAccept(inviteResponse) {
    this.logger.log("Inviter.onAccept");
    if (this.state !== SessionState.Establishing) {
      this.logger.error(`Accept received while in state ${this.state}, dropping response`);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    const response = inviteResponse.message;
    const session2 = inviteResponse.session;
    if (response.hasHeader("P-Asserted-Identity")) {
      this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
    }
    session2.delegate = {
      onAck: (ackRequest) => this.onAckRequest(ackRequest),
      onBye: (byeRequest) => this.onByeRequest(byeRequest),
      onInfo: (infoRequest) => this.onInfoRequest(infoRequest),
      onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),
      onMessage: (messageRequest) => this.onMessageRequest(messageRequest),
      onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),
      onPrack: (prackRequest) => this.onPrackRequest(prackRequest),
      onRefer: (referRequest) => this.onReferRequest(referRequest)
    };
    this._dialog = session2;
    switch (session2.signalingState) {
      case SignalingState.Initial:
        this.logger.error("Received 2xx response to INVITE without a session description");
        this.ackAndBye(inviteResponse, 400, "Missing session description");
        this.stateTransition(SessionState.Terminated);
        return Promise.reject(new Error("Bad Media Description"));
      case SignalingState.HaveLocalOffer:
        this.logger.error("Received 2xx response to INVITE without a session description");
        this.ackAndBye(inviteResponse, 400, "Missing session description");
        this.stateTransition(SessionState.Terminated);
        return Promise.reject(new Error("Bad Media Description"));
      case SignalingState.HaveRemoteOffer: {
        if (!this._dialog.offer) {
          throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);
        }
        const options = {
          sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
          sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
        };
        return this.setOfferAndGetAnswer(this._dialog.offer, options).then((body) => {
          inviteResponse.ack({ body });
          this.stateTransition(SessionState.Established);
        }).catch((error) => {
          this.ackAndBye(inviteResponse, 488, "Invalid session description");
          this.stateTransition(SessionState.Terminated);
          throw error;
        });
      }
      case SignalingState.Stable: {
        if (this.earlyMediaSessionDescriptionHandlers.size > 0) {
          const sdh = this.earlyMediaSessionDescriptionHandlers.get(session2.id);
          if (!sdh) {
            throw new Error("Session description handler undefined.");
          }
          this.setSessionDescriptionHandler(sdh);
          this.earlyMediaSessionDescriptionHandlers.delete(session2.id);
          inviteResponse.ack();
          this.stateTransition(SessionState.Established);
          return Promise.resolve();
        }
        if (this.earlyMediaDialog) {
          if (this.earlyMediaDialog !== session2) {
            if (this.earlyMedia) {
              const message2 = "You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly the end point which accepted the INVITE (confirmed dialog) does not match the end point with which early media has been setup (early dialog) and thus this session is unable to proceed. In accordance with the SIP specifications, the SIP servers your end point is connected to determine if an INVITE forks and the forking behavior of those servers cannot be controlled by this library. If you wish to use early media with this library you must configure those servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow this library to function with any INVITE requests which do fork.";
              this.logger.error(message2);
            }
            const error = new Error("Early media dialog does not equal confirmed dialog, terminating session");
            this.logger.error(error.message);
            this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
            this.stateTransition(SessionState.Terminated);
            return Promise.reject(error);
          }
          inviteResponse.ack();
          this.stateTransition(SessionState.Established);
          return Promise.resolve();
        }
        const answer = session2.answer;
        if (!answer) {
          throw new Error("Answer is undefined.");
        }
        const options = {
          sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
          sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
        };
        return this.setAnswer(answer, options).then(() => {
          let ackOptions;
          if (this._renderbody && this._rendertype) {
            ackOptions = {
              body: { contentDisposition: "render", contentType: this._rendertype, content: this._renderbody }
            };
          }
          inviteResponse.ack(ackOptions);
          this.stateTransition(SessionState.Established);
        }).catch((error) => {
          this.logger.error(error.message);
          this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
          this.stateTransition(SessionState.Terminated);
          throw error;
        });
      }
      case SignalingState.Closed:
        return Promise.reject(new Error("Terminated."));
      default:
        throw new Error("Unknown session signaling state.");
    }
  }
  /**
   * Handle provisional response to initial INVITE.
   * @param inviteResponse - 1xx response.
   */
  onProgress(inviteResponse) {
    var _a;
    this.logger.log("Inviter.onProgress");
    if (this.state !== SessionState.Establishing) {
      this.logger.error(`Progress received while in state ${this.state}, dropping response`);
      return Promise.reject(new Error(`Invalid session state ${this.state}`));
    }
    if (!this.outgoingInviteRequest) {
      throw new Error("Outgoing INVITE request undefined.");
    }
    const response = inviteResponse.message;
    const session2 = inviteResponse.session;
    if (response.hasHeader("P-Asserted-Identity")) {
      this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
    }
    const requireHeader = response.getHeader("require");
    const rseqHeader = response.getHeader("rseq");
    const rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : void 0;
    const responseReliable = !!rseq;
    const extraHeaders = [];
    if (responseReliable) {
      extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
    }
    switch (session2.signalingState) {
      case SignalingState.Initial:
        if (responseReliable) {
          this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.");
          inviteResponse.prack({ extraHeaders });
        }
        return Promise.resolve();
      case SignalingState.HaveLocalOffer:
        if (responseReliable) {
          inviteResponse.prack({ extraHeaders });
        }
        return Promise.resolve();
      case SignalingState.HaveRemoteOffer:
        if (!responseReliable) {
          this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response.");
          return Promise.resolve();
        }
        {
          const sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});
          if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {
            this.delegate.onSessionDescriptionHandler(sdh, true);
          }
          this.earlyMediaSessionDescriptionHandlers.set(session2.id, sdh);
          return sdh.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(() => sdh.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)).then((description) => {
            const body = {
              contentDisposition: "session",
              contentType: description.contentType,
              content: description.body
            };
            inviteResponse.prack({ extraHeaders, body });
          }).catch((error) => {
            this.stateTransition(SessionState.Terminated);
            throw error;
          });
        }
      case SignalingState.Stable:
        if (responseReliable) {
          inviteResponse.prack({ extraHeaders });
        }
        if (this.earlyMedia && !this.earlyMediaDialog) {
          this.earlyMediaDialog = session2;
          const answer = session2.answer;
          if (!answer) {
            throw new Error("Answer is undefined.");
          }
          const options = {
            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
          };
          return this.setAnswer(answer, options).catch((error) => {
            this.stateTransition(SessionState.Terminated);
            throw error;
          });
        }
        return Promise.resolve();
      case SignalingState.Closed:
        return Promise.reject(new Error("Terminated."));
      default:
        throw new Error("Unknown session signaling state.");
    }
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 3xx response.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onRedirect(inviteResponse) {
    this.logger.log("Inviter.onRedirect");
    if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {
      this.logger.error(`Redirect received while in state ${this.state}, dropping response`);
      return;
    }
    this.stateTransition(SessionState.Terminated);
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 4xx, 5xx, or 6xx response.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onReject(inviteResponse) {
    this.logger.log("Inviter.onReject");
    if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {
      this.logger.error(`Reject received while in state ${this.state}, dropping response`);
      return;
    }
    this.stateTransition(SessionState.Terminated);
  }
  /**
   * Handle final response to initial INVITE.
   * @param inviteResponse - 100 response.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onTrying(inviteResponse) {
    this.logger.log("Inviter.onTrying");
    if (this.state !== SessionState.Establishing) {
      this.logger.error(`Trying received while in state ${this.state}, dropping response`);
      return;
    }
  }
}
class Messager2 {
  /**
   * Constructs a new instance of the `Messager` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param content - Content for the body of the message.
   * @param contentType - Content type of the body of the message.
   * @param options - Options bucket. See {@link MessagerOptions} for details.
   */
  constructor(userAgent, targetURI, content2, contentType = "text/plain", options = {}) {
    this.logger = userAgent.getLogger("sip.Messager");
    options.params = options.params || {};
    let fromURI = userAgent.userAgentCore.configuration.aor;
    if (options.params.fromUri) {
      fromURI = typeof options.params.fromUri === "string" ? Grammar.URIParse(options.params.fromUri) : options.params.fromUri;
    }
    if (!fromURI) {
      throw new TypeError("Invalid from URI: " + options.params.fromUri);
    }
    let toURI = targetURI;
    if (options.params.toUri) {
      toURI = typeof options.params.toUri === "string" ? Grammar.URIParse(options.params.toUri) : options.params.toUri;
    }
    if (!toURI) {
      throw new TypeError("Invalid to URI: " + options.params.toUri);
    }
    const params = options.params ? Object.assign({}, options.params) : {};
    const extraHeaders = (options.extraHeaders || []).slice();
    const contentDisposition = "render";
    const body = {
      contentDisposition,
      contentType,
      content: content2
    };
    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.MESSAGE, targetURI, fromURI, toURI, params, extraHeaders, body);
    this.userAgent = userAgent;
  }
  /**
   * Send the message.
   */
  message(options = {}) {
    this.userAgent.userAgentCore.request(this.request, options.requestDelegate);
    return Promise.resolve();
  }
}
var PublisherState;
(function(PublisherState2) {
  PublisherState2["Initial"] = "Initial";
  PublisherState2["Published"] = "Published";
  PublisherState2["Unpublished"] = "Unpublished";
  PublisherState2["Terminated"] = "Terminated";
})(PublisherState || (PublisherState = {}));
class Publisher {
  /**
   * Constructs a new instance of the `Publisher` class.
   *
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param eventType - The event type identifying the published document.
   * @param options - Options bucket. See {@link PublisherOptions} for details.
   */
  constructor(userAgent, targetURI, eventType, options = {}) {
    this.disposed = false;
    this._state = PublisherState.Initial;
    this._stateEventEmitter = new EmitterImpl2();
    this.userAgent = userAgent;
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.contentType = options.contentType || "text/plain";
    if (typeof options.expires !== "number" || options.expires % 1 !== 0) {
      options.expires = 3600;
    } else {
      options.expires = Number(options.expires);
    }
    if (typeof options.unpublishOnClose !== "boolean") {
      options.unpublishOnClose = true;
    }
    this.target = targetURI;
    this.event = eventType;
    this.options = options;
    this.pubRequestExpires = options.expires;
    this.logger = userAgent.getLogger("sip.Publisher");
    const params = options.params || {};
    const fromURI = params.fromUri ? params.fromUri : userAgent.userAgentCore.configuration.aor;
    const toURI = params.toUri ? params.toUri : targetURI;
    let body;
    if (options.body && options.contentType) {
      const contentDisposition = "render";
      const contentType = options.contentType;
      const content2 = options.body;
      body = {
        contentDisposition,
        contentType,
        content: content2
      };
    }
    const extraHeaders = (options.extraHeaders || []).slice();
    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.PUBLISH, targetURI, fromURI, toURI, params, extraHeaders, body);
    this.id = this.target.toString() + ":" + this.event;
    this.userAgent._publishers[this.id] = this;
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    this.logger.log(`Publisher ${this.id} in state ${this.state} is being disposed`);
    delete this.userAgent._publishers[this.id];
    if (this.options.unpublishOnClose && this.state === PublisherState.Published) {
      return this.unpublish();
    }
    if (this.publishRefreshTimer) {
      clearTimeout(this.publishRefreshTimer);
      this.publishRefreshTimer = void 0;
    }
    this.pubRequestBody = void 0;
    this.pubRequestExpires = 0;
    this.pubRequestEtag = void 0;
    return Promise.resolve();
  }
  /** The publication state. */
  get state() {
    return this._state;
  }
  /** Emits when the publisher state changes. */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * Publish.
   * @param content - Body to publish
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  publish(content2, options = {}) {
    if (this.publishRefreshTimer) {
      clearTimeout(this.publishRefreshTimer);
      this.publishRefreshTimer = void 0;
    }
    this.options.body = content2;
    this.pubRequestBody = this.options.body;
    if (this.pubRequestExpires === 0) {
      if (this.options.expires === void 0) {
        throw new Error("Expires undefined.");
      }
      this.pubRequestExpires = this.options.expires;
      this.pubRequestEtag = void 0;
    }
    this.sendPublishRequest();
    return Promise.resolve();
  }
  /**
   * Unpublish.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unpublish(options = {}) {
    if (this.publishRefreshTimer) {
      clearTimeout(this.publishRefreshTimer);
      this.publishRefreshTimer = void 0;
    }
    this.pubRequestBody = void 0;
    this.pubRequestExpires = 0;
    if (this.pubRequestEtag !== void 0) {
      this.sendPublishRequest();
    }
    return Promise.resolve();
  }
  /** @internal */
  receiveResponse(response) {
    const statusCode = response.statusCode || 0;
    switch (true) {
      case /^1[0-9]{2}$/.test(statusCode.toString()):
        break;
      case /^2[0-9]{2}$/.test(statusCode.toString()):
        if (response.hasHeader("SIP-ETag")) {
          this.pubRequestEtag = response.getHeader("SIP-ETag");
        } else {
          this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH");
        }
        if (response.hasHeader("Expires")) {
          const expires = Number(response.getHeader("Expires"));
          if (typeof expires === "number" && expires >= 0 && expires <= this.pubRequestExpires) {
            this.pubRequestExpires = expires;
          } else {
            this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
          }
        } else {
          this.logger.warn("Expires header missing in a 200-class response to PUBLISH");
        }
        if (this.pubRequestExpires !== 0) {
          this.publishRefreshTimer = setTimeout(() => this.refreshRequest(), this.pubRequestExpires * 900);
          if (this._state !== PublisherState.Published) {
            this.stateTransition(PublisherState.Published);
          }
        } else {
          this.stateTransition(PublisherState.Unpublished);
        }
        break;
      case /^412$/.test(statusCode.toString()):
        if (this.pubRequestEtag !== void 0 && this.pubRequestExpires !== 0) {
          this.logger.warn("412 response to PUBLISH, recovering");
          this.pubRequestEtag = void 0;
          if (this.options.body === void 0) {
            throw new Error("Body undefined.");
          }
          this.publish(this.options.body);
        } else {
          this.logger.warn("412 response to PUBLISH, recovery failed");
          this.pubRequestExpires = 0;
          this.stateTransition(PublisherState.Unpublished);
          this.stateTransition(PublisherState.Terminated);
        }
        break;
      case /^423$/.test(statusCode.toString()):
        if (this.pubRequestExpires !== 0 && response.hasHeader("Min-Expires")) {
          const minExpires = Number(response.getHeader("Min-Expires"));
          if (typeof minExpires === "number" || minExpires > this.pubRequestExpires) {
            this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover");
            this.pubRequestExpires = minExpires;
            if (this.options.body === void 0) {
              throw new Error("Body undefined.");
            }
            this.publish(this.options.body);
          } else {
            this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH");
            this.pubRequestExpires = 0;
            this.stateTransition(PublisherState.Unpublished);
            this.stateTransition(PublisherState.Terminated);
          }
        } else {
          this.logger.warn("423 response to PUBLISH, recovery failed");
          this.pubRequestExpires = 0;
          this.stateTransition(PublisherState.Unpublished);
          this.stateTransition(PublisherState.Terminated);
        }
        break;
      default:
        this.pubRequestExpires = 0;
        this.stateTransition(PublisherState.Unpublished);
        this.stateTransition(PublisherState.Terminated);
        break;
    }
    if (this.pubRequestExpires === 0) {
      if (this.publishRefreshTimer) {
        clearTimeout(this.publishRefreshTimer);
        this.publishRefreshTimer = void 0;
      }
      this.pubRequestBody = void 0;
      this.pubRequestEtag = void 0;
    }
  }
  /** @internal */
  send() {
    return this.userAgent.userAgentCore.publish(this.request, {
      onAccept: (response) => this.receiveResponse(response.message),
      onProgress: (response) => this.receiveResponse(response.message),
      onRedirect: (response) => this.receiveResponse(response.message),
      onReject: (response) => this.receiveResponse(response.message),
      onTrying: (response) => this.receiveResponse(response.message)
    });
  }
  refreshRequest() {
    if (this.publishRefreshTimer) {
      clearTimeout(this.publishRefreshTimer);
      this.publishRefreshTimer = void 0;
    }
    this.pubRequestBody = void 0;
    if (this.pubRequestEtag === void 0) {
      throw new Error("Etag undefined");
    }
    if (this.pubRequestExpires === 0) {
      throw new Error("Expires zero");
    }
    this.sendPublishRequest();
  }
  sendPublishRequest() {
    const reqOptions = Object.assign({}, this.options);
    reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();
    reqOptions.extraHeaders.push("Event: " + this.event);
    reqOptions.extraHeaders.push("Expires: " + this.pubRequestExpires);
    if (this.pubRequestEtag !== void 0) {
      reqOptions.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
    }
    const ruri = this.target;
    const params = this.options.params || {};
    let bodyAndContentType;
    if (this.pubRequestBody !== void 0) {
      if (this.options.contentType === void 0) {
        throw new Error("Content type undefined.");
      }
      bodyAndContentType = {
        body: this.pubRequestBody,
        contentType: this.options.contentType
      };
    }
    let body;
    if (bodyAndContentType) {
      body = fromBodyLegacy(bodyAndContentType);
    }
    this.request = this.userAgent.userAgentCore.makeOutgoingRequestMessage(C.PUBLISH, ruri, params.fromUri ? params.fromUri : this.userAgent.userAgentCore.configuration.aor, params.toUri ? params.toUri : this.target, params, reqOptions.extraHeaders, body);
    return this.send();
  }
  /**
   * Transition publication state.
   */
  stateTransition(newState) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case PublisherState.Initial:
        if (newState !== PublisherState.Published && newState !== PublisherState.Unpublished && newState !== PublisherState.Terminated) {
          invalidTransition();
        }
        break;
      case PublisherState.Published:
        if (newState !== PublisherState.Unpublished && newState !== PublisherState.Terminated) {
          invalidTransition();
        }
        break;
      case PublisherState.Unpublished:
        if (newState !== PublisherState.Published && newState !== PublisherState.Terminated) {
          invalidTransition();
        }
        break;
      case PublisherState.Terminated:
        invalidTransition();
        break;
      default:
        throw new Error("Unrecognized state.");
    }
    this._state = newState;
    this.logger.log(`Publication transitioned to state ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === PublisherState.Terminated) {
      this.dispose();
    }
  }
}
var RegistererState;
(function(RegistererState2) {
  RegistererState2["Initial"] = "Initial";
  RegistererState2["Registered"] = "Registered";
  RegistererState2["Unregistered"] = "Unregistered";
  RegistererState2["Terminated"] = "Terminated";
})(RegistererState || (RegistererState = {}));
class Registerer2 {
  /**
   * Constructs a new instance of the `Registerer` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param options - Options bucket. See {@link RegistererOptions} for details.
   */
  constructor(userAgent, options = {}) {
    this.disposed = false;
    this._contacts = [];
    this._retryAfter = void 0;
    this._state = RegistererState.Initial;
    this._waiting = false;
    this._stateEventEmitter = new EmitterImpl2();
    this._waitingEventEmitter = new EmitterImpl2();
    this.userAgent = userAgent;
    const defaultUserAgentRegistrar = userAgent.configuration.uri.clone();
    defaultUserAgentRegistrar.user = void 0;
    this.options = Object.assign(Object.assign(Object.assign({}, Registerer2.defaultOptions()), { registrar: defaultUserAgentRegistrar }), Registerer2.stripUndefinedProperties(options));
    this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();
    this.options.extraHeaders = (this.options.extraHeaders || []).slice();
    if (!this.options.registrar) {
      throw new Error("Registrar undefined.");
    }
    this.options.registrar = this.options.registrar.clone();
    if (this.options.regId && !this.options.instanceId) {
      this.options.instanceId = Registerer2.newUUID();
    } else if (!this.options.regId && this.options.instanceId) {
      this.options.regId = 1;
    }
    if (this.options.instanceId && Grammar.parse(this.options.instanceId, "uuid") === -1) {
      throw new Error("Invalid instanceId.");
    }
    if (this.options.regId && this.options.regId < 0) {
      throw new Error("Invalid regId.");
    }
    const registrar = this.options.registrar;
    const fromURI = this.options.params && this.options.params.fromUri || userAgent.userAgentCore.configuration.aor;
    const toURI = this.options.params && this.options.params.toUri || userAgent.configuration.uri;
    const params = this.options.params || {};
    const extraHeaders = (options.extraHeaders || []).slice();
    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, void 0);
    this.expires = this.options.expires || Registerer2.defaultExpires;
    if (this.expires < 0) {
      throw new Error("Invalid expires.");
    }
    this.refreshFrequency = this.options.refreshFrequency || Registerer2.defaultRefreshFrequency;
    if (this.refreshFrequency < 50 || this.refreshFrequency > 99) {
      throw new Error("Invalid refresh frequency. The value represents a percentage of the expiration time and should be between 50 and 99.");
    }
    this.logger = userAgent.getLogger("sip.Registerer");
    if (this.options.logConfiguration) {
      this.logger.log("Configuration:");
      Object.keys(this.options).forEach((key) => {
        const value2 = this.options[key];
        switch (key) {
          case "registrar":
            this.logger.log("· " + key + ": " + value2);
            break;
          default:
            this.logger.log("· " + key + ": " + JSON.stringify(value2));
        }
      });
    }
    this.id = this.request.callId + this.request.from.parameters.tag;
    this.userAgent._registerers[this.id] = this;
  }
  /** Default registerer options. */
  static defaultOptions() {
    return {
      expires: Registerer2.defaultExpires,
      extraContactHeaderParams: [],
      extraHeaders: [],
      logConfiguration: true,
      instanceId: "",
      params: {},
      regId: 0,
      registrar: new URI2("sip", "anonymous", "anonymous.invalid"),
      refreshFrequency: Registerer2.defaultRefreshFrequency
    };
  }
  // http://stackoverflow.com/users/109538/broofa
  static newUUID() {
    const UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
      const r2 = Math.floor(Math.random() * 16);
      const v = c2 === "x" ? r2 : r2 % 4 + 8;
      return v.toString(16);
    });
    return UUID;
  }
  /**
   * Strip properties with undefined values from options.
   * This is a work around while waiting for missing vs undefined to be addressed (or not)...
   * https://github.com/Microsoft/TypeScript/issues/13195
   * @param options - Options to reduce
   */
  static stripUndefinedProperties(options) {
    return Object.keys(options).reduce((object, key) => {
      if (options[key] !== void 0) {
        object[key] = options[key];
      }
      return object;
    }, {});
  }
  /** The registered contacts. */
  get contacts() {
    return this._contacts.slice();
  }
  /**
   * The number of seconds to wait before retrying to register.
   * @defaultValue `undefined`
   * @remarks
   * When the server rejects a registration request, if it provides a suggested
   * duration to wait before retrying, that value is available here when and if
   * the state transitions to `Unsubscribed`. It is also available during the
   * callback to `onReject` after a call to `register`. (Note that if the state
   * if already `Unsubscribed`, a rejected request created by `register` will
   * not cause the state to transition to `Unsubscribed`. One way to avoid this
   * case is to dispose of `Registerer` when unregistered and create a new
   * `Registerer` for any attempts to retry registering.)
   * @example
   * ```ts
   * // Checking for retry after on state change
   * registerer.stateChange.addListener((newState) => {
   *   switch (newState) {
   *     case RegistererState.Unregistered:
   *       const retryAfter = registerer.retryAfter;
   *       break;
   *   }
   * });
   *
   * // Checking for retry after on request rejection
   * registerer.register({
   *   requestDelegate: {
   *     onReject: () => {
   *       const retryAfter = registerer.retryAfter;
   *     }
   *   }
   * });
   * ```
   */
  get retryAfter() {
    return this._retryAfter;
  }
  /** The registration state. */
  get state() {
    return this._state;
  }
  /** Emits when the registerer state changes. */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /** Destructor. */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.disposed = true;
    this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`);
    delete this.userAgent._registerers[this.id];
    return new Promise((resolve) => {
      const doClose = () => {
        if (!this.waiting && this._state === RegistererState.Registered) {
          this.stateChange.addListener(() => {
            this.terminated();
            resolve();
          }, { once: true });
          this.unregister();
          return;
        }
        this.terminated();
        resolve();
      };
      if (this.waiting) {
        this.waitingChange.addListener(() => {
          doClose();
        }, { once: true });
      } else {
        doClose();
      }
    });
  }
  /**
   * Sends the REGISTER request.
   * @remarks
   * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.
   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
   */
  register(options = {}) {
    if (this.state === RegistererState.Terminated) {
      this.stateError();
      throw new Error("Registerer terminated. Unable to register.");
    }
    if (this.disposed) {
      this.stateError();
      throw new Error("Registerer disposed. Unable to register.");
    }
    if (this.waiting) {
      this.waitingWarning();
      const error = new RequestPendingError2("REGISTER request already in progress, waiting for final response");
      return Promise.reject(error);
    }
    if (options.requestOptions) {
      this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);
    }
    const extraHeaders = (this.options.extraHeaders || []).slice();
    extraHeaders.push("Contact: " + this.generateContactHeader(this.expires));
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());
    this.request.cseq++;
    this.request.setHeader("cseq", this.request.cseq + " REGISTER");
    this.request.extraHeaders = extraHeaders;
    this.waitingToggle(true);
    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
      onAccept: (response) => {
        let expires;
        if (response.message.hasHeader("expires")) {
          expires = Number(response.message.getHeader("expires"));
        }
        this._contacts = response.message.getHeaders("contact");
        let contacts = this._contacts.length;
        if (!contacts) {
          this.logger.error("No Contact header in response to REGISTER, dropping response.");
          this.unregistered();
          return;
        }
        let contact2;
        while (contacts--) {
          contact2 = response.message.parseHeader("contact", contacts);
          if (!contact2) {
            throw new Error("Contact undefined");
          }
          if (this.userAgent.contact.pubGruu && equivalentURI(contact2.uri, this.userAgent.contact.pubGruu)) {
            expires = Number(contact2.getParam("expires"));
            break;
          }
          if (this.userAgent.configuration.contactName === "") {
            if (contact2.uri.user === this.userAgent.contact.uri.user) {
              expires = Number(contact2.getParam("expires"));
              break;
            }
          } else {
            if (equivalentURI(contact2.uri, this.userAgent.contact.uri)) {
              expires = Number(contact2.getParam("expires"));
              break;
            }
          }
          contact2 = void 0;
        }
        if (contact2 === void 0) {
          this.logger.error("No Contact header pointing to us, dropping response");
          this.unregistered();
          this.waitingToggle(false);
          return;
        }
        if (expires === void 0) {
          this.logger.error("Contact pointing to us is missing expires parameter, dropping response");
          this.unregistered();
          this.waitingToggle(false);
          return;
        }
        if (contact2.hasParam("temp-gruu")) {
          const gruu = contact2.getParam("temp-gruu");
          if (gruu) {
            this.userAgent.contact.tempGruu = Grammar.URIParse(gruu.replace(/"/g, ""));
          }
        }
        if (contact2.hasParam("pub-gruu")) {
          const gruu = contact2.getParam("pub-gruu");
          if (gruu) {
            this.userAgent.contact.pubGruu = Grammar.URIParse(gruu.replace(/"/g, ""));
          }
        }
        this.registered(expires);
        if (options.requestDelegate && options.requestDelegate.onAccept) {
          options.requestDelegate.onAccept(response);
        }
        this.waitingToggle(false);
      },
      onProgress: (response) => {
        if (options.requestDelegate && options.requestDelegate.onProgress) {
          options.requestDelegate.onProgress(response);
        }
      },
      onRedirect: (response) => {
        this.logger.error("Redirect received. Not supported.");
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onRedirect) {
          options.requestDelegate.onRedirect(response);
        }
        this.waitingToggle(false);
      },
      onReject: (response) => {
        if (response.message.statusCode === 423) {
          if (!response.message.hasHeader("min-expires")) {
            this.logger.error("423 response received for REGISTER without Min-Expires, dropping response");
            this.unregistered();
            this.waitingToggle(false);
            return;
          }
          this.expires = Number(response.message.getHeader("min-expires"));
          this.waitingToggle(false);
          this.register();
          return;
        }
        this.logger.warn(`Failed to register, status code ${response.message.statusCode}`);
        let retryAfterDuration = NaN;
        if (response.message.statusCode === 500 || response.message.statusCode === 503) {
          const header = response.message.getHeader("retry-after");
          if (header) {
            retryAfterDuration = Number.parseInt(header, void 0);
          }
        }
        this._retryAfter = isNaN(retryAfterDuration) ? void 0 : retryAfterDuration;
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onReject) {
          options.requestDelegate.onReject(response);
        }
        this._retryAfter = void 0;
        this.waitingToggle(false);
      },
      onTrying: (response) => {
        if (options.requestDelegate && options.requestDelegate.onTrying) {
          options.requestDelegate.onTrying(response);
        }
      }
    });
    return Promise.resolve(outgoingRegisterRequest);
  }
  /**
   * Sends the REGISTER request with expires equal to zero.
   * @remarks
   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
   */
  unregister(options = {}) {
    if (this.state === RegistererState.Terminated) {
      this.stateError();
      throw new Error("Registerer terminated. Unable to register.");
    }
    if (this.disposed) {
      if (this.state !== RegistererState.Registered) {
        this.stateError();
        throw new Error("Registerer disposed. Unable to register.");
      }
    }
    if (this.waiting) {
      this.waitingWarning();
      const error = new RequestPendingError2("REGISTER request already in progress, waiting for final response");
      return Promise.reject(error);
    }
    if (this._state !== RegistererState.Registered && !options.all) {
      this.logger.warn("Not currently registered, but sending an unregister anyway.");
    }
    const extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();
    this.request.extraHeaders = extraHeaders;
    if (options.all) {
      extraHeaders.push("Contact: *");
      extraHeaders.push("Expires: 0");
    } else {
      extraHeaders.push("Contact: " + this.generateContactHeader(0));
    }
    this.request.cseq++;
    this.request.setHeader("cseq", this.request.cseq + " REGISTER");
    if (this.registrationTimer !== void 0) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = void 0;
    }
    this.waitingToggle(true);
    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
      onAccept: (response) => {
        this._contacts = response.message.getHeaders("contact");
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onAccept) {
          options.requestDelegate.onAccept(response);
        }
        this.waitingToggle(false);
      },
      onProgress: (response) => {
        if (options.requestDelegate && options.requestDelegate.onProgress) {
          options.requestDelegate.onProgress(response);
        }
      },
      onRedirect: (response) => {
        this.logger.error("Unregister redirected. Not currently supported.");
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onRedirect) {
          options.requestDelegate.onRedirect(response);
        }
        this.waitingToggle(false);
      },
      onReject: (response) => {
        this.logger.error(`Unregister rejected with status code ${response.message.statusCode}`);
        this.unregistered();
        if (options.requestDelegate && options.requestDelegate.onReject) {
          options.requestDelegate.onReject(response);
        }
        this.waitingToggle(false);
      },
      onTrying: (response) => {
        if (options.requestDelegate && options.requestDelegate.onTrying) {
          options.requestDelegate.onTrying(response);
        }
      }
    });
    return Promise.resolve(outgoingRegisterRequest);
  }
  /**
   * Clear registration timers.
   */
  clearTimers() {
    if (this.registrationTimer !== void 0) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = void 0;
    }
    if (this.registrationExpiredTimer !== void 0) {
      clearTimeout(this.registrationExpiredTimer);
      this.registrationExpiredTimer = void 0;
    }
  }
  /**
   * Generate Contact Header
   */
  generateContactHeader(expires) {
    let contact2 = this.userAgent.contact.toString();
    if (this.options.regId && this.options.instanceId) {
      contact2 += ";reg-id=" + this.options.regId;
      contact2 += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
    }
    if (this.options.extraContactHeaderParams) {
      this.options.extraContactHeaderParams.forEach((header) => {
        contact2 += ";" + header;
      });
    }
    contact2 += ";expires=" + expires;
    return contact2;
  }
  /**
   * Helper function, called when registered.
   */
  registered(expires) {
    this.clearTimers();
    this.registrationTimer = setTimeout(() => {
      this.registrationTimer = void 0;
      this.register();
    }, this.refreshFrequency / 100 * expires * 1e3);
    this.registrationExpiredTimer = setTimeout(() => {
      this.logger.warn("Registration expired");
      this.unregistered();
    }, expires * 1e3);
    if (this._state !== RegistererState.Registered) {
      this.stateTransition(RegistererState.Registered);
    }
  }
  /**
   * Helper function, called when unregistered.
   */
  unregistered() {
    this.clearTimers();
    if (this._state !== RegistererState.Unregistered) {
      this.stateTransition(RegistererState.Unregistered);
    }
  }
  /**
   * Helper function, called when terminated.
   */
  terminated() {
    this.clearTimers();
    if (this._state !== RegistererState.Terminated) {
      this.stateTransition(RegistererState.Terminated);
    }
  }
  /**
   * Transition registration state.
   */
  stateTransition(newState) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case RegistererState.Initial:
        if (newState !== RegistererState.Registered && newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {
          invalidTransition();
        }
        break;
      case RegistererState.Registered:
        if (newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {
          invalidTransition();
        }
        break;
      case RegistererState.Unregistered:
        if (newState !== RegistererState.Registered && newState !== RegistererState.Terminated) {
          invalidTransition();
        }
        break;
      case RegistererState.Terminated:
        invalidTransition();
        break;
      default:
        throw new Error("Unrecognized state.");
    }
    this._state = newState;
    this.logger.log(`Registration transitioned to state ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === RegistererState.Terminated) {
      this.dispose();
    }
  }
  /** True if the registerer is currently waiting for final response to a REGISTER request. */
  get waiting() {
    return this._waiting;
  }
  /** Emits when the registerer waiting state changes. */
  get waitingChange() {
    return this._waitingEventEmitter;
  }
  /**
   * Toggle waiting.
   */
  waitingToggle(waiting2) {
    if (this._waiting === waiting2) {
      throw new Error(`Invalid waiting transition from ${this._waiting} to ${waiting2}`);
    }
    this._waiting = waiting2;
    this.logger.log(`Waiting toggled to ${this._waiting}`);
    this._waitingEventEmitter.emit(this._waiting);
  }
  /** Hopefully helpful as the standard behavior has been found to be unexpected. */
  waitingWarning() {
    let message2 = "An attempt was made to send a REGISTER request while a prior one was still in progress.";
    message2 += " RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response";
    message2 += " from the registrar for the previous one or the previous REGISTER request has timed out.";
    message2 += " Note that if the transport disconnects, you still must wait for the prior request to time out before";
    message2 += " sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.";
    this.logger.warn(message2);
  }
  /** Hopefully helpful as the standard behavior has been found to be unexpected. */
  stateError() {
    const reason = this.state === RegistererState.Terminated ? "is in 'Terminated' state" : "has been disposed";
    let message2 = `An attempt was made to send a REGISTER request when the Registerer ${reason}.`;
    message2 += " The Registerer transitions to 'Terminated' when Registerer.dispose() is called.";
    message2 += " Perhaps you called UserAgent.stop() which dipsoses of all Registerers?";
    this.logger.error(message2);
  }
}
Registerer2.defaultExpires = 600;
Registerer2.defaultRefreshFrequency = 99;
var SubscriptionState;
(function(SubscriptionState2) {
  SubscriptionState2["Initial"] = "Initial";
  SubscriptionState2["NotifyWait"] = "NotifyWait";
  SubscriptionState2["Subscribed"] = "Subscribed";
  SubscriptionState2["Terminated"] = "Terminated";
})(SubscriptionState || (SubscriptionState = {}));
class Subscription {
  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @internal
   */
  constructor(userAgent, options = {}) {
    this._disposed = false;
    this._state = SubscriptionState.Initial;
    this._logger = userAgent.getLogger("sip.Subscription");
    this._stateEventEmitter = new EmitterImpl2();
    this._userAgent = userAgent;
    this.delegate = options.delegate;
  }
  /**
   * Destructor.
   */
  dispose() {
    if (this._disposed) {
      return Promise.resolve();
    }
    this._disposed = true;
    this._stateEventEmitter.removeAllListeners();
    return Promise.resolve();
  }
  /**
   * The subscribed subscription dialog.
   */
  get dialog() {
    return this._dialog;
  }
  /**
   * True if disposed.
   * @internal
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Subscription state. See {@link SubscriptionState} for details.
   */
  get state() {
    return this._state;
  }
  /**
   * Emits when the subscription `state` property changes.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /** @internal */
  stateTransition(newState) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case SubscriptionState.Initial:
        if (newState !== SubscriptionState.NotifyWait && newState !== SubscriptionState.Terminated) {
          invalidTransition();
        }
        break;
      case SubscriptionState.NotifyWait:
        if (newState !== SubscriptionState.Subscribed && newState !== SubscriptionState.Terminated) {
          invalidTransition();
        }
        break;
      case SubscriptionState.Subscribed:
        if (newState !== SubscriptionState.Terminated) {
          invalidTransition();
        }
        break;
      case SubscriptionState.Terminated:
        invalidTransition();
        break;
      default:
        throw new Error("Unrecognized state.");
    }
    if (this._state === newState) {
      return;
    }
    this._state = newState;
    this._logger.log(`Subscription ${this._dialog ? this._dialog.id : void 0} transitioned to ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === SubscriptionState.Terminated) {
      this.dispose();
    }
  }
}
class Subscriber extends Subscription {
  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - The request URI identifying the subscribed event.
   * @param eventType - The event type identifying the subscribed event.
   * @param options - Options bucket. See {@link SubscriberOptions} for details.
   */
  constructor(userAgent, targetURI, eventType, options = {}) {
    super(userAgent, options);
    this.body = void 0;
    this.logger = userAgent.getLogger("sip.Subscriber");
    if (options.body) {
      this.body = {
        body: options.body,
        contentType: options.contentType ? options.contentType : "application/sdp"
      };
    }
    this.targetURI = targetURI;
    this.event = eventType;
    if (options.expires === void 0) {
      this.expires = 3600;
    } else if (typeof options.expires !== "number") {
      this.logger.warn(`Option "expires" must be a number. Using default of 3600.`);
      this.expires = 3600;
    } else {
      this.expires = options.expires;
    }
    this.extraHeaders = (options.extraHeaders || []).slice();
    this.subscriberRequest = this.initSubscriberRequest();
    this.outgoingRequestMessage = this.subscriberRequest.message;
    this.id = this.outgoingRequestMessage.callId + this.outgoingRequestMessage.from.parameters.tag + this.event;
    this._userAgent._subscriptions[this.id] = this;
  }
  /**
   * Destructor.
   * @internal
   */
  dispose() {
    if (this.disposed) {
      return Promise.resolve();
    }
    this.logger.log(`Subscription ${this.id} in state ${this.state} is being disposed`);
    delete this._userAgent._subscriptions[this.id];
    if (this.retryAfterTimer) {
      clearTimeout(this.retryAfterTimer);
      this.retryAfterTimer = void 0;
    }
    this.subscriberRequest.dispose();
    return super.dispose().then(() => {
      if (this.state !== SubscriptionState.Subscribed) {
        return;
      }
      if (!this._dialog) {
        throw new Error("Dialog undefined.");
      }
      if (this._dialog.subscriptionState === SubscriptionState$1.Pending || this._dialog.subscriptionState === SubscriptionState$1.Active) {
        const dialog = this._dialog;
        return new Promise((resolve, reject) => {
          dialog.delegate = {
            onTerminated: () => resolve()
          };
          dialog.unsubscribe();
        });
      }
    });
  }
  /**
   * Subscribe to event notifications.
   *
   * @remarks
   * Send an initial SUBSCRIBE request if no subscription as been established.
   * Sends a re-SUBSCRIBE request if the subscription is "active".
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  subscribe(options = {}) {
    switch (this.subscriberRequest.state) {
      case SubscriptionState$1.Initial:
        if (this.state === SubscriptionState.Initial) {
          this.stateTransition(SubscriptionState.NotifyWait);
        }
        this.subscriberRequest.subscribe().then((result) => {
          if (result.success) {
            if (result.success.subscription) {
              this._dialog = result.success.subscription;
              this._dialog.delegate = {
                onNotify: (request) => this.onNotify(request),
                onRefresh: (request) => this.onRefresh(request),
                onTerminated: () => {
                  if (this.state !== SubscriptionState.Terminated) {
                    this.stateTransition(SubscriptionState.Terminated);
                  }
                }
              };
            }
            this.onNotify(result.success.request);
          } else if (result.failure) {
            this.unsubscribe();
          }
        });
        break;
      case SubscriptionState$1.NotifyWait:
        break;
      case SubscriptionState$1.Pending:
        break;
      case SubscriptionState$1.Active:
        if (this._dialog) {
          const request = this._dialog.refresh();
          request.delegate = {
            onAccept: (response) => this.onAccepted(response),
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onRedirect: (response) => this.unsubscribe(),
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onReject: (response) => this.unsubscribe()
          };
        }
        break;
      case SubscriptionState$1.Terminated:
        break;
    }
    return Promise.resolve();
  }
  /**
   * {@inheritDoc Subscription.unsubscribe}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unsubscribe(options = {}) {
    if (this.disposed) {
      return Promise.resolve();
    }
    switch (this.subscriberRequest.state) {
      case SubscriptionState$1.Initial:
        break;
      case SubscriptionState$1.NotifyWait:
        break;
      case SubscriptionState$1.Pending:
        if (this._dialog) {
          this._dialog.unsubscribe();
        }
        break;
      case SubscriptionState$1.Active:
        if (this._dialog) {
          this._dialog.unsubscribe();
        }
        break;
      case SubscriptionState$1.Terminated:
        break;
      default:
        throw new Error("Unknown state.");
    }
    this.stateTransition(SubscriptionState.Terminated);
    return Promise.resolve();
  }
  /**
   * Sends a re-SUBSCRIBE request if the subscription is "active".
   * @deprecated Use `subscribe` instead.
   * @internal
   */
  _refresh() {
    if (this.subscriberRequest.state === SubscriptionState$1.Active) {
      return this.subscribe();
    }
    return Promise.resolve();
  }
  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onAccepted(response) {
  }
  /** @internal */
  onNotify(request) {
    if (this.disposed) {
      request.accept();
      return;
    }
    if (this.state !== SubscriptionState.Subscribed) {
      this.stateTransition(SubscriptionState.Subscribed);
    }
    if (this.delegate && this.delegate.onNotify) {
      const notification = new Notification2(request);
      this.delegate.onNotify(notification);
    } else {
      request.accept();
    }
    const subscriptionState = request.message.parseHeader("Subscription-State");
    if (subscriptionState && subscriptionState.state) {
      switch (subscriptionState.state) {
        case "terminated":
          if (subscriptionState.reason) {
            this.logger.log(`Terminated subscription with reason ${subscriptionState.reason}`);
            switch (subscriptionState.reason) {
              case "deactivated":
              case "timeout":
                this.initSubscriberRequest();
                this.subscribe();
                return;
              case "probation":
              case "giveup":
                this.initSubscriberRequest();
                if (subscriptionState.params && subscriptionState.params["retry-after"]) {
                  this.retryAfterTimer = setTimeout(() => {
                    this.subscribe();
                  }, subscriptionState.params["retry-after"]);
                } else {
                  this.subscribe();
                }
                return;
            }
          }
          this.unsubscribe();
          break;
      }
    }
  }
  /** @internal */
  onRefresh(request) {
    request.delegate = {
      onAccept: (response) => this.onAccepted(response)
    };
  }
  initSubscriberRequest() {
    const options = {
      extraHeaders: this.extraHeaders,
      body: this.body ? fromBodyLegacy(this.body) : void 0
    };
    this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);
    this.subscriberRequest.delegate = {
      onAccept: (response) => this.onAccepted(response)
    };
    return this.subscriberRequest;
  }
}
class SubscriberRequest {
  constructor(core2, target, event, expires, options, delegate) {
    this.core = core2;
    this.target = target;
    this.event = event;
    this.expires = expires;
    this.subscribed = false;
    this.logger = core2.loggerFactory.getLogger("sip.Subscriber");
    this.delegate = delegate;
    const allowHeader = "Allow: " + AllowedMethods.toString();
    const extraHeaders = (options && options.extraHeaders || []).slice();
    extraHeaders.push(allowHeader);
    extraHeaders.push("Event: " + this.event);
    extraHeaders.push("Expires: " + this.expires);
    extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
    const body = options && options.body;
    this.message = core2.makeOutgoingRequestMessage(C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);
  }
  /** Destructor. */
  dispose() {
    if (this.request) {
      this.request.waitNotifyStop();
      this.request.dispose();
      this.request = void 0;
    }
  }
  /** Subscription state. */
  get state() {
    if (this.subscription) {
      return this.subscription.subscriptionState;
    } else if (this.subscribed) {
      return SubscriptionState$1.NotifyWait;
    } else {
      return SubscriptionState$1.Initial;
    }
  }
  /**
   * Establish subscription.
   * @param options Options bucket.
   */
  subscribe() {
    if (this.subscribed) {
      return Promise.reject(new Error("Not in initial state. Did you call subscribe more than once?"));
    }
    this.subscribed = true;
    return new Promise((resolve) => {
      if (!this.message) {
        throw new Error("Message undefined.");
      }
      this.request = this.core.subscribe(this.message, {
        // This SUBSCRIBE request will be confirmed with a final response.
        // 200-class responses indicate that the subscription has been accepted
        // and that a NOTIFY request will be sent immediately.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
        onAccept: (response) => {
          if (this.delegate && this.delegate.onAccept) {
            this.delegate.onAccept(response);
          }
        },
        // Due to the potential for out-of-order messages, packet loss, and
        // forking, the subscriber MUST be prepared to receive NOTIFY requests
        // before the SUBSCRIBE transaction has completed.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
        onNotify: (requestWithSubscription) => {
          this.subscription = requestWithSubscription.subscription;
          if (this.subscription) {
            this.subscription.autoRefresh = true;
          }
          resolve({ success: requestWithSubscription });
        },
        // If this Timer N expires prior to the receipt of a NOTIFY request,
        // the subscriber considers the subscription failed, and cleans up
        // any state associated with the subscription attempt.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
        onNotifyTimeout: () => {
          resolve({ failure: {} });
        },
        // This SUBSCRIBE request will be confirmed with a final response.
        // Non-200-class final responses indicate that no subscription or new
        // dialog usage has been created, and no subsequent NOTIFY request will
        // be sent.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
        onRedirect: (response) => {
          resolve({ failure: { response } });
        },
        // This SUBSCRIBE request will be confirmed with a final response.
        // Non-200-class final responses indicate that no subscription or new
        // dialog usage has been created, and no subsequent NOTIFY request will
        // be sent.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
        onReject: (response) => {
          resolve({ failure: { response } });
        }
      });
    });
  }
}
var TransportState;
(function(TransportState2) {
  TransportState2["Connecting"] = "Connecting";
  TransportState2["Connected"] = "Connected";
  TransportState2["Disconnecting"] = "Disconnecting";
  TransportState2["Disconnected"] = "Disconnected";
})(TransportState || (TransportState = {}));
var UserAgentState;
(function(UserAgentState2) {
  UserAgentState2["Started"] = "Started";
  UserAgentState2["Stopped"] = "Stopped";
})(UserAgentState || (UserAgentState = {}));
function defaultMediaStreamFactory() {
  return (constraints) => {
    if (!constraints.audio && !constraints.video) {
      return Promise.resolve(new MediaStream());
    }
    if (navigator.mediaDevices === void 0) {
      return Promise.reject(new Error("Media devices not available in insecure contexts."));
    }
    return navigator.mediaDevices.getUserMedia.call(navigator.mediaDevices, constraints);
  };
}
function defaultPeerConnectionConfiguration() {
  const configuration = {
    bundlePolicy: "balanced",
    certificates: void 0,
    iceCandidatePoolSize: 0,
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
    iceTransportPolicy: "all",
    peerIdentity: void 0,
    rtcpMuxPolicy: "require"
  };
  return configuration;
}
class SessionDescriptionHandler2 {
  /**
   * Constructor
   * @param logger - A logger
   * @param mediaStreamFactory - A factory to provide a MediaStream
   * @param options - Options passed from the SessionDescriptionHandleFactory
   */
  constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {
    logger.debug("SessionDescriptionHandler.constructor");
    this.logger = logger;
    this.mediaStreamFactory = mediaStreamFactory;
    this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;
    this._localMediaStream = new MediaStream();
    this._remoteMediaStream = new MediaStream();
    this._remoteScreenMediaStream = new MediaStream();
    this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);
    this.initPeerConnectionEventHandlers();
  }
  /**
   * The local media stream currently being sent.
   *
   * @remarks
   * The local media stream initially has no tracks, so the presence of tracks
   * should not be assumed. Furthermore, tracks may be added or removed if the
   * local media changes - for example, on upgrade from audio only to a video session.
   * At any given time there will be at most one audio track and one video track
   * (it's possible that this restriction may not apply to sub-classes).
   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event
   * to detect when a new track becomes available:
   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
   */
  get localMediaStream() {
    return this._localMediaStream;
  }
  /**
   * The remote media stream currently being received.
   *
   * @remarks
   * The remote media stream initially has no tracks, so the presence of tracks
   * should not be assumed. Furthermore, tracks may be added or removed if the
   * remote media changes - for example, on upgrade from audio only to a video session.
   * At any given time there will be at most one audio track and one video track
   * (it's possible that this restriction may not apply to sub-classes).
   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event
   * to detect when a new track becomes available:
   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
   */
  get remoteMediaStream() {
    return this._remoteMediaStream;
  }
  /**
   * The remote screen media stream currently being received.
   *
   * @remarks
   * 对方的屏幕共享媒体流将存储在这里
   */
  get remoteScreenMediaStream() {
    return this._remoteScreenMediaStream;
  }
  /**
   * The data channel. Undefined before it is created.
   */
  get dataChannel() {
    return this._dataChannel;
  }
  /**
   * The peer connection. Undefined if peer connection has closed.
   *
   * @remarks
   * While access to the underlying `RTCPeerConnection` is provided, note that
   * using methods with modify it may break the operation of this class.
   * In particular, this class depends on exclusive access to the
   * event handler properties. If you need access to the peer connection
   * events, either register for events using `addEventListener()` on
   * the `RTCPeerConnection` or set the `peerConnectionDelegate` on
   * this `SessionDescriptionHandler`.
   */
  get peerConnection() {
    return this._peerConnection;
  }
  /**
   * A delegate which provides access to the peer connection event handlers.
   *
   * @remarks
   * Setting the peer connection event handlers directly is not supported
   * and may break this class. As this class depends on exclusive access
   * to them, a delegate may be set which provides alternative access to
   * the event handlers in a fashion which is supported.
   */
  get peerConnectionDelegate() {
    return this._peerConnectionDelegate;
  }
  set peerConnectionDelegate(delegate) {
    this._peerConnectionDelegate = delegate;
  }
  // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
  static dispatchAddTrackEvent(stream, track) {
    stream.dispatchEvent(new MediaStreamTrackEvent("addtrack", { track }));
  }
  // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack
  static dispatchRemoveTrackEvent(stream, track) {
    stream.dispatchEvent(new MediaStreamTrackEvent("removetrack", { track }));
  }
  /**
   * Stop tracks and close peer connection.
   */
  close() {
    this.logger.debug("SessionDescriptionHandler.close");
    if (this._peerConnection === void 0) {
      return;
    }
    this._peerConnection.getReceivers().forEach((receiver) => {
      receiver.track && receiver.track.stop();
    });
    this._peerConnection.getSenders().forEach((sender) => {
      sender.track && sender.track.stop();
    });
    if (this._dataChannel) {
      this._dataChannel.close();
    }
    this._peerConnection.close();
    this._peerConnection = void 0;
  }
  /**
   * Creates an offer or answer.
   * @param options - Options bucket.
   * @param modifiers - Modifiers.
   */
  getDescription(options, modifiers) {
    var _a, _b;
    this.logger.debug("SessionDescriptionHandler.getDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;
    const iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart;
    const iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === void 0 ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;
    return this.getLocalMediaStream(options).then(() => this.updateDirection(options)).then(() => this.createDataChannel(options)).then(() => this.createLocalOfferOrAnswer(options)).then((sessionDescription) => this.applyModifiers(sessionDescription, modifiers)).then((sessionDescription) => this.setLocalSessionDescription(sessionDescription)).then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout)).then(() => this.getLocalSessionDescription()).then((sessionDescription) => {
      return {
        body: sessionDescription.sdp,
        contentType: "application/sdp"
      };
    }).catch((error) => {
      this.logger.error("SessionDescriptionHandler.getDescription failed - " + error);
      throw error;
    });
  }
  /**
   * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.
   * @param contentType - The content type that is in the SIP Message.
   */
  hasDescription(contentType) {
    this.logger.debug("SessionDescriptionHandler.hasDescription");
    return contentType === "application/sdp";
  }
  /**
   * Send DTMF via RTP (RFC 4733).
   * Returns true if DTMF send is successful, false otherwise.
   * @param tones - A string containing DTMF digits.
   * @param options - Options object to be used by sendDtmf.
   */
  sendDtmf(tones, options) {
    this.logger.debug("SessionDescriptionHandler.sendDtmf");
    if (this._peerConnection === void 0) {
      this.logger.error("SessionDescriptionHandler.sendDtmf failed - peer connection closed");
      return false;
    }
    const senders = this._peerConnection.getSenders();
    if (senders.length === 0) {
      this.logger.error("SessionDescriptionHandler.sendDtmf failed - no senders");
      return false;
    }
    const dtmfSender = senders[0].dtmf;
    if (!dtmfSender) {
      this.logger.error("SessionDescriptionHandler.sendDtmf failed - no DTMF sender");
      return false;
    }
    const duration2 = options === null || options === void 0 ? void 0 : options.duration;
    const interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;
    try {
      dtmfSender.insertDTMF(tones, duration2, interToneGap);
    } catch (e2) {
      this.logger.error(e2);
      return false;
    }
    this.logger.log("SessionDescriptionHandler.sendDtmf sent via RTP: " + tones.toString());
    return true;
  }
  /**
   * Sets an offer or answer.
   * @param sdp - The session description.
   * @param options - Options bucket.
   * @param modifiers - Modifiers.
   */
  setDescription(sdp, options, modifiers) {
    this.logger.debug("SessionDescriptionHandler.setDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;
    const type = this._peerConnection.signalingState === "have-local-offer" ? "answer" : "offer";
    return this.getLocalMediaStream(options).then(() => this.applyModifiers({ sdp, type }, modifiers)).then((sessionDescription) => this.setRemoteSessionDescription(sessionDescription)).catch((error) => {
      this.logger.error("SessionDescriptionHandler.setDescription failed - " + error);
      throw error;
    });
  }
  /**
   * Applies modifiers to SDP prior to setting the local or remote description.
   * @param sdp - SDP to modify.
   * @param modifiers - Modifiers to apply.
   */
  applyModifiers(sdp, modifiers) {
    this.logger.debug("SessionDescriptionHandler.applyModifiers");
    if (!modifiers || modifiers.length === 0) {
      return Promise.resolve(sdp);
    }
    return modifiers.reduce((cur, next) => cur.then(next), Promise.resolve(sdp)).then((modified) => {
      this.logger.debug("SessionDescriptionHandler.applyModifiers - modified sdp");
      if (!modified.sdp || !modified.type) {
        throw new Error("Invalid SDP.");
      }
      return { sdp: modified.sdp, type: modified.type };
    });
  }
  /**
   * Create a data channel.
   * @remarks
   * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.
   * Only creates a data channel if creating a local offer.
   * Only if one does not already exist.
   * @param options - Session description handler options.
   */
  createDataChannel(options) {
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {
      return Promise.resolve();
    }
    if (this._dataChannel) {
      return Promise.resolve();
    }
    switch (this._peerConnection.signalingState) {
      case "stable":
        this.logger.debug("SessionDescriptionHandler.createDataChannel - creating data channel");
        try {
          this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || "", options === null || options === void 0 ? void 0 : options.dataChannelOptions);
          if (this.onDataChannel) {
            this.onDataChannel(this._dataChannel);
          }
          return Promise.resolve();
        } catch (error) {
          return Promise.reject(error);
        }
      case "have-remote-offer":
        return Promise.resolve();
      case "have-local-offer":
      case "have-local-pranswer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
  }
  /**
   * Depending on current signaling state, create a local offer or answer.
   * @param options - Session description handler options.
   */
  createLocalOfferOrAnswer(options) {
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    const transceivers = this._peerConnection.getTransceivers();
    switch (this._peerConnection.signalingState) {
      case "stable":
        this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer");
        transceivers.forEach((transceiver) => {
          var _a;
          if ("setCodecPreferences" in transceiver) {
            const mediaType = (_a = transceiver.sender.track) == null ? void 0 : _a.kind;
            if (!mediaType) return;
            let codecs = RTCRtpSender.getCapabilities(mediaType).codecs;
            if (options.disabledCodecs) {
              const disabledCodecs = options.disabledCodecs;
              if (disabledCodecs.audio && mediaType === "audio") {
                codecs = codecs.filter((codec) => !disabledCodecs.audio.some((v) => codec.mimeType.includes(v)));
                if (disabledCodecs.audio.includes("opus")) {
                  codecs = codecs.filter(
                    (codec) => !codec.mimeType.includes("red") && !(codec.mimeType.includes("telephone-event") && codec.clockRate === 48e3)
                  );
                }
              }
              if (disabledCodecs.video && mediaType === "video") {
                codecs = codecs.filter(
                  (item) => !(item.sdpFmtpLine && item.sdpFmtpLine === "level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640020")
                );
                codecs = codecs.filter((codec) => !disabledCodecs.video.some((v) => codec.mimeType.includes(v)));
              }
              try {
                transceiver.setCodecPreferences(codecs);
              } catch (err) {
                return Promise.reject(new Error(err));
              }
            }
            try {
              transceiver.setCodecPreferences(codecs);
            } catch (err) {
              return Promise.reject(new Error(err == null ? void 0 : err.message));
            }
          } else {
            console.warn("your broswer not support setCodecPreferences");
          }
        });
        return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);
      case "have-remote-offer":
        this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer");
        transceivers.forEach((transceiver) => {
          var _a;
          if ("setCodecPreferences" in transceiver) {
            const mediaType = (_a = transceiver.receiver.track) == null ? void 0 : _a.kind;
            if (!mediaType) return;
            let codecs = RTCRtpSender.getCapabilities(mediaType).codecs;
            if (options.disabledCodecs) {
              const disabledCodecs = options.disabledCodecs;
              if (disabledCodecs.audio && mediaType === "audio") {
                codecs = codecs.filter((codec) => !disabledCodecs.audio.some((v) => codec.mimeType.includes(v)));
              }
              if (disabledCodecs.video && mediaType === "video") {
                codecs = codecs.filter((codec) => !disabledCodecs.video.some((v) => codec.mimeType.includes(v)));
              }
            }
            try {
              transceiver.setCodecPreferences(codecs);
            } catch (err) {
              return Promise.reject(new Error(err));
            }
          } else {
            console.warn("your broswer not support setCodecPreferences");
          }
        });
        return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);
      case "have-local-offer":
      case "have-local-pranswer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
  }
  /**
   * Get a media stream from the media stream factory and set the local media stream.
   * @param options - Session description handler options.
   */
  getLocalMediaStream(options) {
    this.logger.debug("SessionDescriptionHandler.getLocalMediaStream");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    let constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints);
    if (this.localMediaStreamConstraints) {
      constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;
      constraints.video = constraints.video || this.localMediaStreamConstraints.video;
      if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {
        return Promise.resolve();
      }
    } else {
      if (constraints.audio === void 0 && constraints.video === void 0) {
        constraints = { audio: true };
      }
    }
    this.localMediaStreamConstraints = constraints;
    return this.mediaStreamFactory(constraints, this).then((mediaStream) => this.setLocalMediaStream(mediaStream));
  }
  /**
   * Sets the peer connection's sender tracks and local media stream tracks.
   *
   * @remarks
   * Only the first audio and video tracks of the provided MediaStream are utilized.
   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.
   *
   * @param stream - Media stream containing tracks to be utilized.
   */
  setLocalMediaStream(stream) {
    this.logger.debug("SessionDescriptionHandler.setLocalMediaStream");
    if (!this._peerConnection) {
      throw new Error("Peer connection undefined.");
    }
    const pc = this._peerConnection;
    const localStream = this._localMediaStream;
    const trackUpdates = [];
    const updateTrack = (newTrack) => {
      const kind = newTrack.kind;
      if (kind !== "audio" && kind !== "video") {
        throw new Error(`Unknown new track kind ${kind}.`);
      }
      const sender = pc.getSenders().find((sender2) => sender2.track && sender2.track.kind === kind);
      if (sender) {
        trackUpdates.push(new Promise((resolve) => {
          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);
          resolve();
        }).then(() => sender.replaceTrack(newTrack).then(() => {
          const oldTrack = localStream.getTracks().find((localTrack) => localTrack.kind === kind);
          if (oldTrack) {
            oldTrack.stop();
            localStream.removeTrack(oldTrack);
            SessionDescriptionHandler2.dispatchRemoveTrackEvent(localStream, oldTrack);
          }
          localStream.addTrack(newTrack);
          SessionDescriptionHandler2.dispatchAddTrackEvent(localStream, newTrack);
        }).catch((error) => {
          this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);
          throw error;
        })));
      } else {
        trackUpdates.push(new Promise((resolve) => {
          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);
          resolve();
        }).then(() => {
          try {
            pc.addTrack(newTrack, localStream);
          } catch (error) {
            this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);
            throw error;
          }
          localStream.addTrack(newTrack);
          SessionDescriptionHandler2.dispatchAddTrackEvent(localStream, newTrack);
        }));
      }
    };
    const audioTracks = stream.getAudioTracks();
    if (audioTracks.length) {
      updateTrack(audioTracks[0]);
    }
    const videoTracks = stream.getVideoTracks();
    if (videoTracks.length) {
      updateTrack(videoTracks[0]);
    }
    return trackUpdates.reduce((p2, x) => p2.then(() => x), Promise.resolve());
  }
  /**
   * Gets the peer connection's local session description.
   */
  getLocalSessionDescription() {
    this.logger.debug("SessionDescriptionHandler.getLocalSessionDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    const sdp = this._peerConnection.localDescription;
    if (!sdp) {
      return Promise.reject(new Error("Failed to get local session description"));
    }
    return Promise.resolve(sdp);
  }
  /**
   * Sets the peer connection's local session description.
   * @param sessionDescription - sessionDescription The session description.
   */
  setLocalSessionDescription(sessionDescription) {
    this.logger.debug("SessionDescriptionHandler.setLocalSessionDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    return this._peerConnection.setLocalDescription(sessionDescription);
  }
  /**
   * Sets the peer connection's remote session description.
   * @param sessionDescription - The session description.
   */
  setRemoteSessionDescription(sessionDescription) {
    this.logger.debug("SessionDescriptionHandler.setRemoteSessionDescription");
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    const sdp = sessionDescription.sdp;
    let type;
    switch (this._peerConnection.signalingState) {
      case "stable":
        type = "offer";
        break;
      case "have-local-offer":
        type = "answer";
        break;
      case "have-local-pranswer":
      case "have-remote-offer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
    if (!sdp) {
      this.logger.error("SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp");
      return Promise.reject(new Error("SDP is undefined"));
    }
    return this._peerConnection.setRemoteDescription({ sdp, type });
  }
  /**
   * Sets a remote media stream track.
   *
   * @remarks
   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.
   *
   * @param track - Media stream track to be utilized.
   * @param ids - Media stream track id list to be utilized.
   */
  setRemoteTrack(track, ids) {
    this.logger.debug("SessionDescriptionHandler.setRemoteTrack");
    const remoteStream = this._remoteMediaStream;
    const remoteScreenStream = this._remoteScreenMediaStream;
    if (remoteStream.getTrackById(track.id)) {
      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);
    } else if (track.kind === "audio") {
      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);
      remoteStream.getAudioTracks().forEach((track2) => {
        track2.stop();
        remoteStream.removeTrack(track2);
        SessionDescriptionHandler2.dispatchRemoveTrackEvent(remoteStream, track2);
      });
      remoteStream.addTrack(track);
      SessionDescriptionHandler2.dispatchAddTrackEvent(remoteStream, track);
    } else if (track.kind === "video") {
      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);
      if (ids == null ? void 0 : ids.includes("stream_screen")) {
        if (remoteScreenStream.getVideoTracks().length > 0) return;
        remoteScreenStream.addTrack(track);
        SessionDescriptionHandler2.dispatchAddTrackEvent(remoteScreenStream, track);
      } else {
        remoteStream.addTrack(track);
        SessionDescriptionHandler2.dispatchAddTrackEvent(remoteStream, track);
      }
    }
  }
  /**
   * Depending on the current signaling state and the session hold state, update transceiver direction.
   * @param options - Session description handler options.
   */
  updateDirection(options) {
    if (this._peerConnection === void 0) {
      return Promise.reject(new Error("Peer connection closed."));
    }
    switch (this._peerConnection.signalingState) {
      case "stable":
        this.logger.debug("SessionDescriptionHandler.updateDirection - setting offer direction");
        {
          const directionToOffer = (currentDirection) => {
            switch (currentDirection) {
              case "inactive":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";
              case "recvonly":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";
              case "sendonly":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";
              case "sendrecv":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";
              case "stopped":
                return "stopped";
              default:
                throw new Error("Should never happen");
            }
          };
          this._peerConnection.getTransceivers().forEach((transceiver) => {
            if (transceiver.direction) {
              const offerDirection = directionToOffer(transceiver.direction);
              if (transceiver.direction !== offerDirection) {
                transceiver.direction = offerDirection;
              }
            }
          });
        }
        break;
      case "have-remote-offer":
        this.logger.debug("SessionDescriptionHandler.updateDirection - setting answer direction");
        {
          const offeredDirection = (() => {
            const description = this._peerConnection.remoteDescription;
            if (!description) {
              throw new Error("Failed to read remote offer");
            }
            const searchResult = /a=sendrecv\r\n|a=sendonly\r\n|a=recvonly\r\n|a=inactive\r\n/.exec(description.sdp);
            if (searchResult) {
              switch (searchResult[0]) {
                case "a=inactive\r\n":
                  return "inactive";
                case "a=recvonly\r\n":
                  return "recvonly";
                case "a=sendonly\r\n":
                  return "sendonly";
                case "a=sendrecv\r\n":
                  return "sendrecv";
                default:
                  throw new Error("Should never happen");
              }
            }
            return "sendrecv";
          })();
          const answerDirection = (() => {
            switch (offeredDirection) {
              case "inactive":
                return "inactive";
              case "recvonly":
                return "sendonly";
              case "sendonly":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";
              case "sendrecv":
                return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";
              default:
                throw new Error("Should never happen");
            }
          })();
          this._peerConnection.getTransceivers().forEach((transceiver) => {
            if (transceiver.direction) {
              if (transceiver.direction !== "stopped" && transceiver.direction !== answerDirection) {
                transceiver.direction = answerDirection;
              }
            }
          });
        }
        break;
      case "have-local-offer":
      case "have-local-pranswer":
      case "have-remote-pranswer":
      case "closed":
      default:
        return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
    }
    return Promise.resolve();
  }
  /**
   * Called when ICE gathering completes and resolves any waiting promise.
   */
  iceGatheringComplete() {
    this.logger.debug("SessionDescriptionHandler.iceGatheringComplete");
    if (this.iceGatheringCompleteTimeoutId !== void 0) {
      this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - clearing timeout");
      clearTimeout(this.iceGatheringCompleteTimeoutId);
      this.iceGatheringCompleteTimeoutId = void 0;
    }
    if (this.iceGatheringCompletePromise !== void 0) {
      this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - resolving promise");
      this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();
      this.iceGatheringCompletePromise = void 0;
      this.iceGatheringCompleteResolve = void 0;
      this.iceGatheringCompleteReject = void 0;
    }
  }
  /**
   * Wait for ICE gathering to complete.
   * @param restart - If true, waits if current state is "complete" (waits for transition to "complete").
   * @param timeout - Milliseconds after which waiting times out. No timeout if 0.
   */
  waitForIceGatheringComplete(restart = false, timeout2 = 0) {
    this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete");
    if (this._peerConnection === void 0) {
      return Promise.reject("Peer connection closed.");
    }
    if (!restart && this._peerConnection.iceGatheringState === "complete") {
      this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - already complete");
      return Promise.resolve();
    }
    if (this.iceGatheringCompletePromise !== void 0) {
      this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise");
      this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error("Promise superseded."));
      this.iceGatheringCompletePromise = void 0;
      this.iceGatheringCompleteResolve = void 0;
      this.iceGatheringCompleteReject = void 0;
    }
    this.iceGatheringCompletePromise = new Promise((resolve, reject) => {
      this.iceGatheringCompleteResolve = resolve;
      this.iceGatheringCompleteReject = reject;
      if (timeout2 > 0) {
        this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in " + timeout2);
        this.iceGatheringCompleteTimeoutId = setTimeout(() => {
          this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout");
          this.iceGatheringComplete();
        }, timeout2);
      }
    });
    return this.iceGatheringCompletePromise;
  }
  /**
   * Initializes the peer connection event handlers
   */
  initPeerConnectionEventHandlers() {
    this.logger.debug("SessionDescriptionHandler.initPeerConnectionEventHandlers");
    if (!this._peerConnection)
      throw new Error("Peer connection undefined.");
    const peerConnection = this._peerConnection;
    peerConnection.onconnectionstatechange = (event) => {
      var _a;
      const newState = peerConnection.connectionState;
      this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {
        this._peerConnectionDelegate.onconnectionstatechange(event);
      }
    };
    peerConnection.ondatachannel = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.ondatachannel`);
      this._dataChannel = event.channel;
      if (this.onDataChannel) {
        this.onDataChannel(this._dataChannel);
      }
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {
        this._peerConnectionDelegate.ondatachannel(event);
      }
    };
    peerConnection.onicecandidate = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onicecandidate`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {
        this._peerConnectionDelegate.onicecandidate(event);
      }
    };
    peerConnection.onicecandidateerror = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onicecandidateerror`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {
        this._peerConnectionDelegate.onicecandidateerror(event);
      }
    };
    peerConnection.oniceconnectionstatechange = (event) => {
      var _a;
      const newState = peerConnection.iceConnectionState;
      this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {
        this._peerConnectionDelegate.oniceconnectionstatechange(event);
      }
    };
    peerConnection.onicegatheringstatechange = (event) => {
      var _a;
      const newState = peerConnection.iceGatheringState;
      this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);
      if (newState === "complete") {
        this.iceGatheringComplete();
      }
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {
        this._peerConnectionDelegate.onicegatheringstatechange(event);
      }
    };
    peerConnection.onnegotiationneeded = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onnegotiationneeded`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {
        this._peerConnectionDelegate.onnegotiationneeded(event);
      }
    };
    peerConnection.onsignalingstatechange = (event) => {
      var _a;
      const newState = peerConnection.signalingState;
      this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {
        this._peerConnectionDelegate.onsignalingstatechange(event);
      }
    };
    peerConnection.onstatsended = (event) => {
      var _a;
      this.logger.debug(`SessionDescriptionHandler.onstatsended`);
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onstatsended) {
        this._peerConnectionDelegate.onstatsended(event);
      }
    };
    peerConnection.ontrack = (event) => {
      var _a;
      const kind = event.track.kind;
      const enabled = event.track.enabled ? "enabled" : "disabled";
      this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);
      this.setRemoteTrack(event.track, event.streams.map((stream) => stream.id));
      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {
        this._peerConnectionDelegate.ontrack(event);
      }
    };
  }
}
function defaultSessionDescriptionHandlerFactory(mediaStreamFactory) {
  return (session2, options) => {
    if (mediaStreamFactory === void 0) {
      mediaStreamFactory = defaultMediaStreamFactory();
    }
    const iceGatheringTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) !== void 0 ? options === null || options === void 0 ? void 0 : options.iceGatheringTimeout : 5e3;
    const sessionDescriptionHandlerConfiguration = {
      iceGatheringTimeout,
      peerConnectionConfiguration: Object.assign(Object.assign({}, defaultPeerConnectionConfiguration()), options === null || options === void 0 ? void 0 : options.peerConnectionConfiguration)
    };
    const logger = session2.userAgent.getLogger("sip.SessionDescriptionHandler");
    return new SessionDescriptionHandler2(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration);
  };
}
let Transport$1 = class Transport2 {
  constructor(logger, options) {
    this._state = TransportState.Disconnected;
    this.transitioningState = false;
    this._stateEventEmitter = new EmitterImpl2();
    this.logger = logger;
    if (options) {
      const optionsDeprecated = options;
      const wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;
      const maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;
      if (wsServersDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "wsServers" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (maxReconnectionAttemptsDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "maxReconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (wsServersDeprecated && !options.server) {
        if (typeof wsServersDeprecated === "string") {
          options.server = wsServersDeprecated;
        }
        if (wsServersDeprecated instanceof Array) {
          options.server = wsServersDeprecated[0];
        }
      }
    }
    this.configuration = Object.assign(Object.assign({}, Transport2.defaultOptions), options);
    const url2 = this.configuration.server;
    const parsed = Grammar.parse(url2, "absoluteURI");
    if (parsed === -1) {
      this.logger.error(`Invalid WebSocket Server URL "${url2}"`);
      throw new Error("Invalid WebSocket Server URL");
    }
    if (!["wss", "ws", "udp"].includes(parsed.scheme)) {
      this.logger.error(`Invalid scheme in WebSocket Server URL "${url2}"`);
      throw new Error("Invalid scheme in WebSocket Server URL");
    }
    this._protocol = parsed.scheme.toUpperCase();
  }
  dispose() {
    return this.disconnect();
  }
  /**
   * The protocol.
   *
   * @remarks
   * Formatted as defined for the Via header sent-protocol transport.
   * https://tools.ietf.org/html/rfc3261#section-20.42
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * The URL of the WebSocket Server.
   */
  get server() {
    return this.configuration.server;
  }
  /**
   * Transport state.
   */
  get state() {
    return this._state;
  }
  /**
   * Transport state change emitter.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * The WebSocket.
   */
  get ws() {
    return this._ws;
  }
  /**
   * Connect to network.
   * Resolves once connected. Otherwise rejects with an Error.
   */
  connect() {
    return this._connect();
  }
  /**
   * Disconnect from network.
   * Resolves once disconnected. Otherwise rejects with an Error.
   */
  disconnect() {
    return this._disconnect();
  }
  /**
   * Returns true if the `state` equals "Connected".
   * @remarks
   * This is equivalent to `state === TransportState.Connected`.
   */
  isConnected() {
    return this.state === TransportState.Connected;
  }
  /**
   * Sends a message.
   * Resolves once message is sent. Otherwise rejects with an Error.
   * @param message - Message to send.
   */
  send(message2) {
    return this._send(message2);
  }
  _connect() {
    this.logger.log(`Connecting ${this.server}`);
    switch (this.state) {
      case TransportState.Connecting:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));
        }
        if (!this.connectPromise) {
          throw new Error("Connect promise must be defined.");
        }
        return this.connectPromise;
      case TransportState.Connected:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));
        }
        if (this.connectPromise) {
          throw new Error("Connect promise must not be defined.");
        }
        return Promise.resolve();
      case TransportState.Disconnecting:
        if (this.connectPromise) {
          throw new Error("Connect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState.Connecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError2) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      case TransportState.Disconnected:
        if (this.connectPromise) {
          throw new Error("Connect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState.Connecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError2) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      default:
        throw new Error("Unknown state");
    }
    let ws;
    try {
      ws = new WebSocket(this.server, "sip");
      ws.binaryType = "arraybuffer";
      ws.addEventListener("close", (ev) => this.onWebSocketClose(ev, ws));
      ws.addEventListener("error", (ev) => this.onWebSocketError(ev, ws));
      ws.addEventListener("open", (ev) => this.onWebSocketOpen(ev, ws));
      ws.addEventListener("message", (ev) => this.onWebSocketMessage(ev, ws));
      this._ws = ws;
    } catch (error) {
      this._ws = void 0;
      this.logger.error("WebSocket construction failed.");
      this.logger.error(error);
      return new Promise((resolve, reject) => {
        this.connectResolve = resolve;
        this.connectReject = reject;
        this.transitionState(TransportState.Disconnected, error);
      });
    }
    this.connectPromise = new Promise((resolve, reject) => {
      this.connectResolve = resolve;
      this.connectReject = reject;
      this.connectTimeout = setTimeout(() => {
        this.logger.warn("Connect timed out. Exceeded time set in configuration.connectionTimeout: " + this.configuration.connectionTimeout + "s.");
        ws.close(1e3);
      }, this.configuration.connectionTimeout * 1e3);
    });
    return this.connectPromise;
  }
  _disconnect() {
    this.logger.log(`Disconnecting ${this.server}`);
    switch (this.state) {
      case TransportState.Connecting:
        if (this.disconnectPromise) {
          throw new Error("Disconnect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState.Disconnecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError2) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      case TransportState.Connected:
        if (this.disconnectPromise) {
          throw new Error("Disconnect promise must not be defined.");
        }
        try {
          this.transitionState(TransportState.Disconnecting);
        } catch (e2) {
          if (e2 instanceof StateTransitionError2) {
            return Promise.reject(e2);
          }
          throw e2;
        }
        break;
      case TransportState.Disconnecting:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));
        }
        if (!this.disconnectPromise) {
          throw new Error("Disconnect promise must be defined.");
        }
        return this.disconnectPromise;
      case TransportState.Disconnected:
        if (this.transitioningState) {
          return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));
        }
        if (this.disconnectPromise) {
          throw new Error("Disconnect promise must not be defined.");
        }
        return Promise.resolve();
      default:
        throw new Error("Unknown state");
    }
    if (!this._ws) {
      throw new Error("WebSocket must be defined.");
    }
    const ws = this._ws;
    this.disconnectPromise = new Promise((resolve, reject) => {
      this.disconnectResolve = resolve;
      this.disconnectReject = reject;
      try {
        ws.close(1e3);
      } catch (error) {
        this.logger.error("WebSocket close failed.");
        this.logger.error(error);
        throw error;
      }
    });
    return this.disconnectPromise;
  }
  _send(message2) {
    if (this.configuration.traceSip === true) {
      this.logger.log("Sending WebSocket message:\n\n" + message2 + "\n");
    }
    if (this._state !== TransportState.Connected) {
      return Promise.reject(new Error("Not connected."));
    }
    if (!this._ws) {
      throw new Error("WebSocket undefined.");
    }
    try {
      this._ws.send(message2);
    } catch (error) {
      if (error instanceof Error) {
        return Promise.reject(error);
      }
      return Promise.reject(new Error("WebSocket send failed."));
    }
    return Promise.resolve();
  }
  /**
   * WebSocket "onclose" event handler.
   * @param ev - Event.
   */
  onWebSocketClose(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    const message2 = `WebSocket closed ${this.server} (code: ${ev.code})`;
    const error = !this.disconnectPromise ? new Error(message2) : void 0;
    if (error) {
      this.logger.warn("WebSocket closed unexpectedly");
    }
    this.logger.log(message2);
    this._ws = void 0;
    this.transitionState(TransportState.Disconnected, error);
  }
  /**
   * WebSocket "onerror" event handler.
   * @param ev - Event.
   */
  onWebSocketError(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    this.logger.error("WebSocket error occurred.");
  }
  /**
   * WebSocket "onmessage" event handler.
   * @param ev - Event.
   */
  onWebSocketMessage(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    const data = ev.data;
    let finishedData;
    if (/^(\r\n)+$/.test(data)) {
      this.clearKeepAliveTimeout();
      if (this.configuration.traceSip === true) {
        this.logger.log("Received WebSocket message with CRLF Keep Alive response");
      }
      return;
    }
    if (!data) {
      this.logger.warn("Received empty message, discarding...");
      return;
    }
    if (typeof data !== "string") {
      try {
        finishedData = new TextDecoder().decode(new Uint8Array(data));
      } catch (err) {
        this.logger.error(err);
        this.logger.error("Received WebSocket binary message failed to be converted into string, message discarded");
        return;
      }
      if (this.configuration.traceSip === true) {
        this.logger.log("Received WebSocket binary message:\n\n" + finishedData + "\n");
      }
    } else {
      finishedData = data;
      if (this.configuration.traceSip === true) {
        this.logger.log("Received WebSocket text message:\n\n" + finishedData + "\n");
      }
    }
    if (this.state !== TransportState.Connected) {
      this.logger.warn("Received message while not connected, discarding...");
      return;
    }
    if (this.onMessage) {
      try {
        this.onMessage(finishedData);
      } catch (e2) {
        this.logger.error(e2);
        this.logger.error("Exception thrown by onMessage callback");
        throw e2;
      }
    }
  }
  /**
   * WebSocket "onopen" event handler.
   * @param ev - Event.
   */
  onWebSocketOpen(ev, ws) {
    if (ws !== this._ws) {
      return;
    }
    if (this._state === TransportState.Connecting) {
      this.logger.log(`WebSocket opened ${this.server}`);
      this.transitionState(TransportState.Connected);
    }
  }
  /**
   * Helper function to generate an Error.
   * @param state - State transitioning to.
   */
  transitionLoopDetectedError(state) {
    let message2 = `A state transition loop has been detected.`;
    message2 += ` An attempt to transition from ${this._state} to ${state} before the prior transition completed.`;
    message2 += ` Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?`;
    this.logger.error(message2);
    return new StateTransitionError2("Loop detected.");
  }
  /**
   * Transition transport state.
   * @internal
   */
  transitionState(newState, error) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    if (this.transitioningState) {
      throw this.transitionLoopDetectedError(newState);
    }
    this.transitioningState = true;
    switch (this._state) {
      case TransportState.Connecting:
        if (newState !== TransportState.Connected && newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {
          invalidTransition();
        }
        break;
      case TransportState.Connected:
        if (newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {
          invalidTransition();
        }
        break;
      case TransportState.Disconnecting:
        if (newState !== TransportState.Connecting && newState !== TransportState.Disconnected) {
          invalidTransition();
        }
        break;
      case TransportState.Disconnected:
        if (newState !== TransportState.Connecting) {
          invalidTransition();
        }
        break;
      default:
        throw new Error("Unknown state.");
    }
    const oldState = this._state;
    this._state = newState;
    const connectResolve = this.connectResolve;
    const connectReject = this.connectReject;
    if (oldState === TransportState.Connecting) {
      this.connectPromise = void 0;
      this.connectResolve = void 0;
      this.connectReject = void 0;
    }
    const disconnectResolve = this.disconnectResolve;
    const disconnectReject = this.disconnectReject;
    if (oldState === TransportState.Disconnecting) {
      this.disconnectPromise = void 0;
      this.disconnectResolve = void 0;
      this.disconnectReject = void 0;
    }
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
    this.logger.log(`Transitioned from ${oldState} to ${this._state}`);
    this._stateEventEmitter.emit(this._state);
    if (newState === TransportState.Connected) {
      this.startSendingKeepAlives();
      if (this.onConnect) {
        try {
          this.onConnect();
        } catch (e2) {
          this.logger.error(e2);
          this.logger.error("Exception thrown by onConnect callback");
          throw e2;
        }
      }
    }
    if (oldState === TransportState.Connected) {
      this.stopSendingKeepAlives();
      if (this.onDisconnect) {
        try {
          if (error) {
            this.onDisconnect(error);
          } else {
            this.onDisconnect();
          }
        } catch (e2) {
          this.logger.error(e2);
          this.logger.error("Exception thrown by onDisconnect callback");
          throw e2;
        }
      }
    }
    if (oldState === TransportState.Connecting) {
      if (!connectResolve) {
        throw new Error("Connect resolve undefined.");
      }
      if (!connectReject) {
        throw new Error("Connect reject undefined.");
      }
      newState === TransportState.Connected ? connectResolve() : connectReject(error || new Error("Connect aborted."));
    }
    if (oldState === TransportState.Disconnecting) {
      if (!disconnectResolve) {
        throw new Error("Disconnect resolve undefined.");
      }
      if (!disconnectReject) {
        throw new Error("Disconnect reject undefined.");
      }
      newState === TransportState.Disconnected ? disconnectResolve() : disconnectReject(error || new Error("Disconnect aborted."));
    }
    this.transitioningState = false;
  }
  // TODO: Review "KeepAlive Stuff".
  // It is not clear if it works and there are no tests for it.
  // It was blindly lifted the keep alive code unchanged from earlier transport code.
  //
  // From the RFC...
  //
  // SIP WebSocket Clients and Servers may keep their WebSocket
  // connections open by sending periodic WebSocket "Ping" frames as
  // described in [RFC6455], Section 5.5.2.
  // ...
  // The indication and use of the CRLF NAT keep-alive mechanism defined
  // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or
  // [RFC6223] are, of course, usable over the transport defined in this
  // specification.
  // https://tools.ietf.org/html/rfc7118#section-6
  //
  // and...
  //
  // The Ping frame contains an opcode of 0x9.
  // https://tools.ietf.org/html/rfc6455#section-5.5.2
  //
  // ==============================
  // KeepAlive Stuff
  // ==============================
  clearKeepAliveTimeout() {
    if (this.keepAliveDebounceTimeout) {
      clearTimeout(this.keepAliveDebounceTimeout);
    }
    this.keepAliveDebounceTimeout = void 0;
  }
  /**
   * Send a keep-alive (a double-CRLF sequence).
   */
  sendKeepAlive() {
    if (this.keepAliveDebounceTimeout) {
      return Promise.resolve();
    }
    this.keepAliveDebounceTimeout = setTimeout(() => {
      this.clearKeepAliveTimeout();
    }, this.configuration.keepAliveDebounce * 1e3);
    return this.send("\r\n\r\n");
  }
  /**
   * Start sending keep-alives.
   */
  startSendingKeepAlives() {
    const computeKeepAliveTimeout = (upperBound) => {
      const lowerBound = upperBound * 0.8;
      return 1e3 * (Math.random() * (upperBound - lowerBound) + lowerBound);
    };
    if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
      this.keepAliveInterval = setInterval(() => {
        this.sendKeepAlive();
        this.startSendingKeepAlives();
      }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
    }
  }
  /**
   * Stop sending keep-alives.
   */
  stopSendingKeepAlives() {
    if (this.keepAliveInterval) {
      clearInterval(this.keepAliveInterval);
    }
    if (this.keepAliveDebounceTimeout) {
      clearTimeout(this.keepAliveDebounceTimeout);
    }
    this.keepAliveInterval = void 0;
    this.keepAliveDebounceTimeout = void 0;
  }
};
Transport$1.defaultOptions = {
  server: "",
  connectionTimeout: 5,
  keepAliveInterval: 0,
  keepAliveDebounce: 10,
  traceSip: true
};
class UserAgent2 {
  /**
   * Constructs a new instance of the `UserAgent` class.
   * @param options - Options bucket. See {@link UserAgentOptions} for details.
   */
  constructor(options = {}) {
    this._publishers = {};
    this._registerers = {};
    this._sessions = {};
    this._subscriptions = {};
    this._state = UserAgentState.Stopped;
    this.unloadListener = () => {
      this.stop();
    };
    this._stateEventEmitter = new EmitterImpl2();
    this.delegate = options.delegate;
    this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent2.defaultOptions()), { sipjsId: createRandomToken(5) }), { uri: new URI2("sip", "anonymous." + createRandomToken(6), "anonymous.invalid") }), { viaHost: createRandomToken(12) + ".invalid" }), UserAgent2.stripUndefinedProperties(options));
    if (this.options.hackIpInContact) {
      if (typeof this.options.hackIpInContact === "boolean" && this.options.hackIpInContact) {
        const from = 1;
        const to = 254;
        const octet = Math.floor(Math.random() * (to - from + 1) + from);
        this.options.viaHost = "192.0.2." + octet;
      } else if (this.options.hackIpInContact) {
        this.options.viaHost = this.options.hackIpInContact;
      }
    }
    this.loggerFactory = new LoggerFactory2();
    this.logger = this.loggerFactory.getLogger("sip.UserAgent");
    this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;
    this.loggerFactory.connector = this.options.logConnector;
    switch (this.options.logLevel) {
      case "error":
        this.loggerFactory.level = Levels.error;
        break;
      case "warn":
        this.loggerFactory.level = Levels.warn;
        break;
      case "log":
        this.loggerFactory.level = Levels.log;
        break;
      case "debug":
        this.loggerFactory.level = Levels.debug;
        break;
    }
    if (this.options.logConfiguration) {
      this.logger.log("Configuration:");
      Object.keys(this.options).forEach((key) => {
        const value2 = this.options[key];
        switch (key) {
          case "uri":
          case "sessionDescriptionHandlerFactory":
            this.logger.log("· " + key + ": " + value2);
            break;
          case "authorizationPassword":
            this.logger.log("· " + key + ": NOT SHOWN");
            break;
          case "transportConstructor":
            this.logger.log("· " + key + ": " + value2.name);
            break;
          default:
            this.logger.log("· " + key + ": " + JSON.stringify(value2));
        }
      });
    }
    if (this.options.transportOptions) {
      const optionsDeprecated = this.options.transportOptions;
      const maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;
      const reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;
      if (maxReconnectionAttemptsDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "maxReconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (reconnectionTimeoutDeprecated !== void 0) {
        const deprecatedMessage = `The transport option "reconnectionTimeout" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
        this.logger.warn(deprecatedMessage);
      }
      if (options.reconnectionDelay === void 0 && reconnectionTimeoutDeprecated !== void 0) {
        this.options.reconnectionDelay = reconnectionTimeoutDeprecated;
      }
      if (options.reconnectionAttempts === void 0 && maxReconnectionAttemptsDeprecated !== void 0) {
        this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;
      }
    }
    if (options.reconnectionDelay !== void 0) {
      const deprecatedMessage = `The user agent option "reconnectionDelay" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
      this.logger.warn(deprecatedMessage);
    }
    if (options.reconnectionAttempts !== void 0) {
      const deprecatedMessage = `The user agent option "reconnectionAttempts" as has apparently been specified and has been deprecated. It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.`;
      this.logger.warn(deprecatedMessage);
    }
    this._transport = new this.options.transportConstructor(this.getLogger("sip.Transport"), this.options.transportOptions);
    this.initTransportCallbacks();
    this._contact = this.initContact();
    this._userAgentCore = this.initCore();
    if (this.options.autoStart) {
      this.start();
    }
  }
  /**
   * Create a URI instance from a string.
   * @param uri - The string to parse.
   *
   * @example
   * ```ts
   * const uri = UserAgent.makeURI("sip:edgar@example.com");
   * ```
   */
  static makeURI(uri) {
    return Grammar.URIParse(uri);
  }
  /** Default user agent options. */
  static defaultOptions() {
    return {
      allowLegacyNotifications: false,
      authorizationHa1: "",
      authorizationPassword: "",
      authorizationUsername: "",
      autoStart: false,
      autoStop: true,
      delegate: {},
      contactName: "",
      contactParams: { transport: "ws" },
      displayName: "",
      forceRport: false,
      hackAllowUnregisteredOptionTags: false,
      hackIpInContact: false,
      hackViaTcp: false,
      logBuiltinEnabled: true,
      logConfiguration: true,
      logConnector: () => {
      },
      logLevel: "log",
      noAnswerTimeout: 60,
      preloadedRouteSet: [],
      reconnectionAttempts: 0,
      reconnectionDelay: 4,
      sendInitialProvisionalResponse: true,
      sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory(),
      sessionDescriptionHandlerFactoryOptions: {},
      sipExtension100rel: SIPExtension.Unsupported,
      sipExtensionReplaces: SIPExtension.Unsupported,
      sipExtensionExtraSupported: [],
      sipjsId: "",
      transportConstructor: Transport$1,
      transportOptions: {},
      uri: new URI2("sip", "anonymous", "anonymous.invalid"),
      userAgentString: "SIP.js/" + LIBRARY_VERSION,
      viaHost: ""
    };
  }
  /**
   * Strip properties with undefined values from options.
   * This is a work around while waiting for missing vs undefined to be addressed (or not)...
   * https://github.com/Microsoft/TypeScript/issues/13195
   * @param options - Options to reduce
   */
  static stripUndefinedProperties(options) {
    return Object.keys(options).reduce((object, key) => {
      if (options[key] !== void 0) {
        object[key] = options[key];
      }
      return object;
    }, {});
  }
  /**
   * User agent configuration.
   */
  get configuration() {
    return this.options;
  }
  /**
   * User agent contact.
   */
  get contact() {
    return this._contact;
  }
  /**
   * User agent state.
   */
  get state() {
    return this._state;
  }
  /**
   * User agent state change emitter.
   */
  get stateChange() {
    return this._stateEventEmitter;
  }
  /**
   * User agent transport.
   */
  get transport() {
    return this._transport;
  }
  /**
   * User agent core.
   */
  get userAgentCore() {
    return this._userAgentCore;
  }
  /**
   * The logger.
   */
  getLogger(category, label) {
    return this.loggerFactory.getLogger(category, label);
  }
  /**
   * The logger factory.
   */
  getLoggerFactory() {
    return this.loggerFactory;
  }
  /**
   * True if transport is connected.
   */
  isConnected() {
    return this.transport.isConnected();
  }
  /**
   * Reconnect the transport.
   */
  reconnect() {
    if (this.state === UserAgentState.Stopped) {
      return Promise.reject(new Error("User agent stopped."));
    }
    return Promise.resolve().then(() => this.transport.connect());
  }
  /**
   * Start the user agent.
   *
   * @remarks
   * Resolves if transport connects, otherwise rejects.
   *
   * @example
   * ```ts
   * userAgent.start()
   *   .then(() => {
   *     // userAgent.isConnected() === true
   *   })
   *   .catch((error: Error) => {
   *     // userAgent.isConnected() === false
   *   });
   * ```
   */
  start() {
    if (this.state === UserAgentState.Started) {
      this.logger.warn(`User agent already started`);
      return Promise.resolve();
    }
    this.logger.log(`Starting ${this.configuration.uri}`);
    this.transitionState(UserAgentState.Started);
    if (this.options.autoStop) {
      const googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
      if (typeof window !== "undefined" && typeof window.addEventListener === "function" && !googleChromePackagedApp) {
        window.addEventListener("unload", this.unloadListener);
      }
    }
    return this.transport.connect();
  }
  /**
   * Stop the user agent.
   *
   * @remarks
   * Resolves when the user agent has completed a graceful shutdown.
   * ```txt
   * 1) Sessions terminate.
   * 2) Registerers unregister.
   * 3) Subscribers unsubscribe.
   * 4) Publishers unpublish.
   * 5) Transport disconnects.
   * 6) User Agent Core resets.
   * ```
   * NOTE: While this is a "graceful shutdown", it can also be very slow one if you
   * are waiting for the returned Promise to resolve. The disposal of the clients and
   * dialogs is done serially - waiting on one to finish before moving on to the next.
   * This can be slow if there are lot of subscriptions to unsubscribe for example.
   *
   * THE SLOW PACE IS INTENTIONAL!
   * While one could spin them all down in parallel, this could slam the remote server.
   * It is bad practice to denial of service attack (DoS attack) servers!!!
   * Moreover, production servers will automatically blacklist clients which send too
   * many requests in too short a period of time - dropping any additional requests.
   *
   * If a different approach to disposing is needed, one can implement whatever is
   * needed and execute that prior to calling `stop()`. Alternatively one may simply
   * not wait for the Promise returned by `stop()` to complete.
   */
  async stop() {
    if (this.state === UserAgentState.Stopped) {
      this.logger.warn(`User agent already stopped`);
      return Promise.resolve();
    }
    this.logger.log(`Stopping ${this.configuration.uri}`);
    this.transitionState(UserAgentState.Stopped);
    if (this.options.autoStop) {
      const googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
      if (typeof window !== "undefined" && window.removeEventListener && !googleChromePackagedApp) {
        window.removeEventListener("unload", this.unloadListener);
      }
    }
    const publishers = Object.assign({}, this._publishers);
    const registerers = Object.assign({}, this._registerers);
    const sessions = Object.assign({}, this._sessions);
    const subscriptions = Object.assign({}, this._subscriptions);
    const transport = this.transport;
    const userAgentCore = this.userAgentCore;
    this.logger.log(`Dispose of registerers`);
    for (const id in registerers) {
      if (registerers[id]) {
        await registerers[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._registerers[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of sessions`);
    for (const id in sessions) {
      if (sessions[id]) {
        await sessions[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._sessions[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of subscriptions`);
    for (const id in subscriptions) {
      if (subscriptions[id]) {
        await subscriptions[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._subscriptions[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of publishers`);
    for (const id in publishers) {
      if (publishers[id]) {
        await publishers[id].dispose().catch((error) => {
          this.logger.error(error.message);
          delete this._publishers[id];
          throw error;
        });
      }
    }
    this.logger.log(`Dispose of transport`);
    await transport.dispose().catch((error) => {
      this.logger.error(error.message);
      throw error;
    });
    this.logger.log(`Dispose of core`);
    userAgentCore.dispose();
  }
  /**
   * Used to avoid circular references.
   * @internal
   */
  _makeInviter(targetURI, options) {
    return new Inviter2(this, targetURI, options);
  }
  /**
   * Attempt reconnection up to `maxReconnectionAttempts` times.
   * @param reconnectionAttempt - Current attempt number.
   */
  attemptReconnection(reconnectionAttempt = 1) {
    const reconnectionAttempts = this.options.reconnectionAttempts;
    const reconnectionDelay = this.options.reconnectionDelay;
    if (reconnectionAttempt > reconnectionAttempts) {
      this.logger.log(`Maximum reconnection attempts reached`);
      return;
    }
    this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);
    setTimeout(() => {
      this.reconnect().then(() => {
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);
      }).catch((error) => {
        this.logger.error(error.message);
        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);
        this.attemptReconnection(++reconnectionAttempt);
      });
    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1e3);
  }
  /**
   * Initialize contact.
   */
  initContact() {
    const contactName = this.options.contactName !== "" ? this.options.contactName : createRandomToken(8);
    const contactParams = this.options.contactParams;
    const contact2 = {
      pubGruu: void 0,
      tempGruu: void 0,
      uri: new URI2("sip", contactName, this.options.viaHost, void 0, contactParams),
      toString: (contactToStringOptions = {}) => {
        const anonymous = contactToStringOptions.anonymous || false;
        const outbound = contactToStringOptions.outbound || false;
        let contactString = "<";
        if (anonymous) {
          contactString += this.contact.tempGruu || `sip:anonymous@anonymous.invalid;transport=${contactParams.transport ? contactParams.transport : "ws"}`;
        } else {
          contactString += this.contact.pubGruu || this.contact.uri;
        }
        if (outbound) {
          contactString += ";ob";
        }
        contactString += ">";
        return contactString;
      }
    };
    return contact2;
  }
  /**
   * Initialize user agent core.
   */
  initCore() {
    let supportedOptionTags = [];
    supportedOptionTags.push("outbound");
    if (this.options.sipExtension100rel === SIPExtension.Supported) {
      supportedOptionTags.push("100rel");
    }
    if (this.options.sipExtensionReplaces === SIPExtension.Supported) {
      supportedOptionTags.push("replaces");
    }
    if (this.options.sipExtensionExtraSupported) {
      supportedOptionTags.push(...this.options.sipExtensionExtraSupported);
    }
    if (!this.options.hackAllowUnregisteredOptionTags) {
      supportedOptionTags = supportedOptionTags.filter((optionTag) => UserAgentRegisteredOptionTags[optionTag]);
    }
    supportedOptionTags = Array.from(new Set(supportedOptionTags));
    const supportedOptionTagsResponse = supportedOptionTags.slice();
    if (this.contact.pubGruu || this.contact.tempGruu) {
      supportedOptionTagsResponse.push("gruu");
    }
    const userAgentCoreConfiguration = {
      aor: this.options.uri,
      contact: this.contact,
      displayName: this.options.displayName,
      loggerFactory: this.loggerFactory,
      hackViaTcp: this.options.hackViaTcp,
      routeSet: this.options.preloadedRouteSet,
      supportedOptionTags,
      supportedOptionTagsResponse,
      sipjsId: this.options.sipjsId,
      userAgentHeaderFieldValue: this.options.userAgentString,
      viaForceRport: this.options.forceRport,
      viaHost: this.options.viaHost,
      authenticationFactory: () => {
        const username = this.options.authorizationUsername ? this.options.authorizationUsername : this.options.uri.user;
        const password = this.options.authorizationPassword ? this.options.authorizationPassword : void 0;
        const ha1 = this.options.authorizationHa1 ? this.options.authorizationHa1 : void 0;
        return new DigestAuthentication2(this.getLoggerFactory(), ha1, username, password);
      },
      transportAccessor: () => this.transport
    };
    const userAgentCoreDelegate = {
      onInvite: (incomingInviteRequest) => {
        var _a;
        const invitation = new Invitation2(this, incomingInviteRequest);
        incomingInviteRequest.delegate = {
          onCancel: (cancel) => {
            invitation._onCancel(cancel);
          },
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onTransportError: (error) => {
            this.logger.error("A transport error has occurred while handling an incoming INVITE request.");
          }
        };
        incomingInviteRequest.trying();
        if (this.options.sipExtensionReplaces !== SIPExtension.Unsupported) {
          const message2 = incomingInviteRequest.message;
          const replaces = message2.parseHeader("replaces");
          if (replaces) {
            const callId = replaces.call_id;
            if (typeof callId !== "string") {
              throw new Error("Type of call id is not string");
            }
            const toTag = replaces.replaces_to_tag;
            if (typeof toTag !== "string") {
              throw new Error("Type of to tag is not string");
            }
            const fromTag = replaces.replaces_from_tag;
            if (typeof fromTag !== "string") {
              throw new Error("type of from tag is not string");
            }
            const targetDialogId = callId + toTag + fromTag;
            const targetDialog = this.userAgentCore.dialogs.get(targetDialogId);
            if (!targetDialog) {
              invitation.reject({ statusCode: 481 });
              return;
            }
            if (!targetDialog.early && replaces.early_only === true) {
              invitation.reject({ statusCode: 486 });
              return;
            }
            const targetSession = this._sessions[callId + fromTag] || this._sessions[callId + toTag] || void 0;
            if (!targetSession) {
              throw new Error("Session does not exist.");
            }
            invitation._replacee = targetSession;
          }
        }
        if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {
          if (invitation.autoSendAnInitialProvisionalResponse) {
            invitation.progress().then(() => {
              var _a2;
              if (((_a2 = this.delegate) === null || _a2 === void 0 ? void 0 : _a2.onInvite) === void 0) {
                throw new Error("onInvite undefined.");
              }
              this.delegate.onInvite(invitation);
            });
            return;
          }
          this.delegate.onInvite(invitation);
          return;
        }
        invitation.reject({ statusCode: 486 });
      },
      onMessage: (incomingMessageRequest) => {
        if (this.delegate && this.delegate.onMessage) {
          const message2 = new Message2(incomingMessageRequest);
          this.delegate.onMessage(message2);
        } else {
          incomingMessageRequest.accept();
        }
      },
      onNotify: (incomingNotifyRequest) => {
        if (this.delegate && this.delegate.onNotify) {
          const notification = new Notification2(incomingNotifyRequest);
          this.delegate.onNotify(notification);
        } else {
          if (this.options.allowLegacyNotifications) {
            incomingNotifyRequest.accept();
          } else {
            incomingNotifyRequest.reject({ statusCode: 481 });
          }
        }
      },
      onRefer: (incomingReferRequest) => {
        this.logger.warn("Received an out of dialog REFER request");
        if (this.delegate && this.delegate.onReferRequest) {
          this.delegate.onReferRequest(incomingReferRequest);
        } else {
          incomingReferRequest.reject({ statusCode: 405 });
        }
      },
      onRegister: (incomingRegisterRequest) => {
        this.logger.warn("Received an out of dialog REGISTER request");
        if (this.delegate && this.delegate.onRegisterRequest) {
          this.delegate.onRegisterRequest(incomingRegisterRequest);
        } else {
          incomingRegisterRequest.reject({ statusCode: 405 });
        }
      },
      onSubscribe: (incomingSubscribeRequest) => {
        this.logger.warn("Received an out of dialog SUBSCRIBE request");
        if (this.delegate && this.delegate.onSubscribeRequest) {
          this.delegate.onSubscribeRequest(incomingSubscribeRequest);
        } else {
          incomingSubscribeRequest.reject({ statusCode: 405 });
        }
      }
    };
    return new UserAgentCore2(userAgentCoreConfiguration, userAgentCoreDelegate);
  }
  initTransportCallbacks() {
    this.transport.onConnect = () => this.onTransportConnect();
    this.transport.onDisconnect = (error) => this.onTransportDisconnect(error);
    this.transport.onMessage = (message2) => this.onTransportMessage(message2);
  }
  onTransportConnect() {
    if (this.state === UserAgentState.Stopped) {
      return;
    }
    if (this.delegate && this.delegate.onConnect) {
      this.delegate.onConnect();
    }
  }
  onTransportDisconnect(error) {
    if (this.state === UserAgentState.Stopped) {
      return;
    }
    if (this.delegate && this.delegate.onDisconnect) {
      this.delegate.onDisconnect(error);
    }
    if (error && this.options.reconnectionAttempts > 0) {
      this.attemptReconnection();
    }
  }
  onTransportMessage(messageString) {
    const message2 = Parser.parseMessage(messageString, this.getLogger("sip.Parser"));
    if (!message2) {
      this.logger.warn("Failed to parse incoming message. Dropping.");
      return;
    }
    if (this.state === UserAgentState.Stopped && message2 instanceof IncomingRequestMessage2) {
      this.logger.warn(`Received ${message2.method} request while stopped. Dropping.`);
      return;
    }
    const hasMinimumHeaders = () => {
      const mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];
      for (const header of mandatoryHeaders) {
        if (!message2.hasHeader(header)) {
          this.logger.warn(`Missing mandatory header field : ${header}.`);
          return false;
        }
      }
      return true;
    };
    if (message2 instanceof IncomingRequestMessage2) {
      if (!hasMinimumHeaders()) {
        this.logger.warn(`Request missing mandatory header field. Dropping.`);
        return;
      }
      if (!message2.toTag && message2.callId.substr(0, 5) === this.options.sipjsId) {
        this.userAgentCore.replyStateless(message2, { statusCode: 482 });
        return;
      }
      const len = utf8Length$1(message2.body);
      const contentLength = message2.getHeader("content-length");
      if (contentLength && len < Number(contentLength)) {
        this.userAgentCore.replyStateless(message2, { statusCode: 400 });
        return;
      }
    }
    if (message2 instanceof IncomingResponseMessage2) {
      if (!hasMinimumHeaders()) {
        this.logger.warn(`Response missing mandatory header field. Dropping.`);
        return;
      }
      if (message2.getHeaders("via").length > 1) {
        this.logger.warn("More than one Via header field present in the response. Dropping.");
        return;
      }
      if (message2.via.host !== this.options.viaHost || message2.via.port !== void 0) {
        this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
        return;
      }
      const len = utf8Length$1(message2.body);
      const contentLength = message2.getHeader("content-length");
      if (contentLength && len < Number(contentLength)) {
        this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
        return;
      }
    }
    if (message2 instanceof IncomingRequestMessage2) {
      this.userAgentCore.receiveIncomingRequestFromTransport(message2);
      return;
    }
    if (message2 instanceof IncomingResponseMessage2) {
      this.userAgentCore.receiveIncomingResponseFromTransport(message2);
      return;
    }
    throw new Error("Invalid message type.");
  }
  /**
   * Transition state.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  transitionState(newState, error) {
    const invalidTransition = () => {
      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);
    };
    switch (this._state) {
      case UserAgentState.Started:
        if (newState !== UserAgentState.Stopped) {
          invalidTransition();
        }
        break;
      case UserAgentState.Stopped:
        if (newState !== UserAgentState.Started) {
          invalidTransition();
        }
        break;
      default:
        throw new Error("Unknown state.");
    }
    this.logger.log(`Transitioned from ${this._state} to ${newState}`);
    this._state = newState;
    this._stateEventEmitter.emit(this._state);
  }
}
function addScreenMarkModifier(e2) {
  return e2.split("m=").map((e3, n2, i2) => {
    if ("video" === e3.substring(0, 5) && n2 === i2.length - 1) {
      const n3 = e3.indexOf("a=msid:");
      if (n3 < 0) return e3;
      const i3 = e3.indexOf("\n", n3), r2 = e3.slice(n3 + 7, i3);
      return e3.replace(r2, "stream_screen screen_label");
    }
    return e3;
  }).join("m=");
}
function inactiveVideoModifer(e2) {
  return e2.split(/^m=/gm).map((e3) => "video" === e3.substring(0, 5) ? e3.replace(/a=sendrecv/, "a=inactive") : e3).join("m=");
}
function inactiveHoldVideoModifer(e2) {
  return e2.split(/^m=/gm).map((e3) => {
    if ("video" === e3.substring(0, 5) && !e3.includes("stream_screen")) {
      return e3.replace(/a=(sendonly|sendrecv|recvonly)/, "a=inactive");
    }
    return e3;
  }).join("m=");
}
function activeVideoModifer(e2) {
  return e2.split(/^m=/gm).map((e3) => "video" === e3.substring(0, 5) ? e3.replace(/a=inactive/, "a=sendrecv") : e3).join("m=");
}
function sendScreenModifer(e2) {
  return e2.split(/^m=/gm).map((e3, n2, i2) => "video" === e3.substring(0, 5) && n2 === i2.length - 1 ? e3.replace(/a=(inactive|recvonly)/, "a=sendrecv") : e3).join("m=");
}
function inactiveScreenModifer(e2) {
  return e2.split(/^m=/gm).map((e3, n2, i2) => "video" === e3.substring(0, 5) && n2 === i2.length - 1 ? e3.replace(/a=recvonly/, "a=inactive") : e3).join("m=");
}
var _PortSipSdk_instances, _PortSipSdk_username, _PortSipSdk_registererOption, _PortSipSdk_enumerateDevices, _PortSipSdk_audioSource, _PortSipSdk_videoSource, _PortSipSdk_audioOutput, _PortSipSdk_localScreenVideoTrack, _PortSipSdk_getSupportAudioCodecs, _PortSipSdk_getSupportVideoCodecs, _PortSipSdk_getPlayingVideotID, _PortSipSdk_getPlayingAudiotID, _PortSipSdk_compareTrackIsSame, _PortSipSdk_pendingRemoteAudioID_get, _PortSipSdk_pendingRemoteVideoID_get, _PortSipSdk_remoteMediaElementMarker, __classPrivateFieldSet = function(e2, t2, s2, i2, o2) {
  if ("m" === i2) throw new TypeError("Private method is not writable");
  if ("a" === i2 && !o2)
    throw new TypeError("Private accessor was defined without a setter");
  if ("function" == typeof t2 ? e2 !== t2 || !o2 : !t2.has(e2))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return "a" === i2 ? o2.call(e2, s2) : o2 ? o2.value = s2 : t2.set(e2, s2), s2;
}, __classPrivateFieldGet = function(e2, t2, s2, i2) {
  if ("a" === s2 && !i2)
    throw new TypeError("Private accessor was defined without a getter");
  if ("function" == typeof t2 ? e2 !== t2 || !i2 : !t2.has(e2))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return "m" === s2 ? i2 : "a" === s2 ? i2.call(e2) : i2 ? i2.value : t2.get(e2);
};
let uid = 1;
class PortSipSdk {
  getExtFromID(e2) {
    var t2;
    return null === (t2 = this.sessions.get(e2)) || void 0 === t2 ? void 0 : t2.ext;
  }
  async getStatistics(e2) {
    var t2;
    const s2 = this.sessions.get(e2);
    if (!(null === (t2 = null == s2 ? void 0 : s2.session) || void 0 === t2 ? void 0 : t2.sessionDescriptionHandler))
      return Promise.reject("not such sesion");
    {
      const t3 = s2.session.sessionDescriptionHandler.peerConnection;
      if (!t3) return Promise.reject(e2 + " peerConnection not exist");
      try {
        const e3 = await t3.getStats(), s3 = {};
        return e3.forEach((e4, t4) => s3[t4] = e4), s3;
      } catch (e3) {
        return Promise.reject("pc.getStats err：" + JSON.stringify(e3));
      }
    }
  }
  getVersion() {
    return "19.6.0";
  }
  constructor(e2, t2) {
    if (_PortSipSdk_instances.add(this), this.reconnectionDelay = 5, this.attemptingReconnection = false, this.shouldBeConnected = true, this.attemptReconnection = (e3 = 1) => {
      this.shouldBeConnected && (this.attemptingReconnection || (this.attemptingReconnection = true, setTimeout(
        () => {
          var t3;
          this.shouldBeConnected ? null === (t3 = this.userAgent) || void 0 === t3 || t3.reconnect().then(() => {
            console.log("Reconnect attempt succeeded"), this.attemptingReconnection = false;
          }).catch((t4) => {
            this.attemptingReconnection = false, console.error("Reconnect attempt failed", t4), this.attemptReconnection(++e3);
          }) : this.attemptingReconnection = false;
        },
        1 === e3 ? 0 : 1e3 * this.reconnectionDelay
      )));
    }, this.videoMaxBitrate = 1048576, this.videoResolusion = {
      width: { ideal: 1280 },
      height: { ideal: 720 }
    }, this.videoFrameRate = { frameRate: { ideal: 30 } }, _PortSipSdk_username.set(this, ""), _PortSipSdk_registererOption.set(this, {
      expires: 300,
      extraHeaders: []
    }), _PortSipSdk_enumerateDevices.set(this, []), _PortSipSdk_audioSource.set(this, ""), _PortSipSdk_videoSource.set(this, ""), _PortSipSdk_audioOutput.set(this, ""), _PortSipSdk_localScreenVideoTrack.set(this, null), this.disabledAudioCodecs = [], this.supportAudioCodec = __classPrivateFieldGet(
      this,
      _PortSipSdk_instances,
      "m",
      _PortSipSdk_getSupportAudioCodecs
    ).call(this), this.disabledVideoCodecs = [], this.supportVideoCodec = __classPrivateFieldGet(
      this,
      _PortSipSdk_instances,
      "m",
      _PortSipSdk_getSupportVideoCodecs
    ).call(this), Array.isArray(t2.remoteAudioID) && Array.isArray(t2.remoteVideoID)) {
      const e3 = t2.remoteAudioID.length, s2 = t2.remoteVideoID.length;
      if (e3 !== s2) throw Error("An audio tag must matches a video tag");
      if (s2 > 16)
        throw Error("The maximum number of media elements passed in is 16");
    }
    this.event = e2, this.sessions = /* @__PURE__ */ new Map(), this.subscribers = /* @__PURE__ */ new Map(), this.userAgent = null, this.registerer = null, this.UADelegate = {
      onConnect: () => {
        this.event.onConnect(), this.registerServer().then(() => {
          this.event.onRegisterSuccess();
        }).catch((e3) => {
          __classPrivateFieldSet(this, _PortSipSdk_username, "", "f"), this.event.onRegisterFailure(e3);
        });
      },
      onDisconnect: (e3) => {
        var t3;
        this.event.onDisconnect(
          (null == e3 ? void 0 : e3.message) || "user agent disconnect"
        ), null === (t3 = this.registerer) || void 0 === t3 || t3.unregister().then(() => {
          this.registerer = null;
        }).catch((e4) => console.error("unregister failed", e4)), e3 && this.attemptReconnection();
      },
      onInvite: (e3) => {
        var t3, s2, i2, o2;
        const n2 = null !== (t3 = e3.remoteIdentity.uri.user) && void 0 !== t3 ? t3 : "", r2 = e3.remoteIdentity.displayName, a2 = !!(null === (s2 = e3.request.getHeader("X-Host-Conference")) || void 0 === s2 ? void 0 : s2.includes("host=true")), d = !!(null === (i2 = e3.request.getHeader("X-Host-Conference")) || void 0 === i2 ? void 0 : i2.includes("require-pin=true")), c2 = uid++;
        e3.delegate = Object.assign(
          Object.assign({}, this.sessionDelegate(c2)),
          {
            _onCancel: (e4) => {
              const t4 = e4.getHeader("Reason");
              this.event.onInviteClosed(c2, t4);
            }
          }
        );
        const l2 = null !== (o2 = e3.body) && void 0 !== o2 ? o2 : "";
        let u2 = false;
        const v = Boolean(
          e3.request.getHeader("Alert-Info") || e3.request.getHeader("Call-Info")
        );
        /\r\nm=video /.test(l2) ? (this.initVideoCall(c2, n2), u2 = true) : this.initAudioCall(c2, n2);
        const h = this.sessions.get(c2);
        if (!h) throw new Error("session not exist");
        h.session = e3;
        let p2 = false;
        const m2 = e3.request.parseHeader("replaces"), S = null == m2 ? void 0 : m2.call_id;
        for (const { session: e4, id: t4 } of this.sessions.values())
          if (e4 && (null == e4 ? void 0 : e4.request.callId) === S) {
            this.hangUp(t4), this.answerCall(c2, false), p2 = true;
            break;
          }
        this.event.onInviteIncoming(c2, n2, r2, a2, true, u2, v, d, 0, p2);
        let g = false;
        e3.stateChange.addListener((t4) => {
          var s3, i3, o3;
          switch (t4) {
            case SessionState.Initial:
            case SessionState.Establishing:
              break;
            case SessionState.Established: {
              g = true;
              try {
                this.setupRemoteMedia(c2), this.setupLocalMedia(c2);
              } catch (e4) {
                console.warn(e4);
              }
              const t5 = null !== (o3 = null === (i3 = null === (s3 = e3.dialog) || void 0 === s3 ? void 0 : s3.offer) || void 0 === i3 ? void 0 : i3.content) && void 0 !== o3 ? o3 : "";
              t5.split(/^m=/gm).some(
                (e4) => "video" === e4.substring(0, 5) && e4.includes("a=inactive")
              ) && (h.constraints.video = false), this.event.onInviteConnected(
                c2,
                Boolean(h.constraints.video),
                "recieve",
                a2,
                d
              ), this.setSessionMediaProperty(c2, t5);
              break;
            }
            case SessionState.Terminating:
              break;
            case SessionState.Terminated:
              g && this.cleanupMedia(c2).catch((e4) => {
                console.warn(e4);
              }), this.sessions.delete(c2);
              break;
            default:
              throw new Error("Unknown session state.");
          }
        });
      },
      onMessage: (e3) => {
        var t3, s2, i2, o2, n2;
        e3.accept();
        const r2 = null !== (t3 = e3.request.getHeader("Content-Type")) && void 0 !== t3 ? t3 : "", a2 = null !== (s2 = e3.request.from.uri.user) && void 0 !== s2 ? s2 : "", d = null !== (i2 = e3.request.to.uri.user) && void 0 !== i2 ? i2 : "", c2 = null !== (n2 = null !== (o2 = e3.request.getHeader("x-push-id")) && void 0 !== o2 ? o2 : e3.request.getHeader("X-Push-Id")) && void 0 !== n2 ? n2 : "";
        this.event.onRecvOutOfDialogMessage(
          a2,
          e3.request.body,
          r2,
          c2,
          void 0,
          d
        );
      },
      onRefer: (e3) => {
        e3.accept().then(() => {
          e3.makeInviter().invite();
        });
      },
      onNotify: (e3) => {
        var t3, s2, i2, o2, n2;
        e3.accept();
        const r2 = null !== (t3 = e3.request.from.uri.user) && void 0 !== t3 ? t3 : "", a2 = null !== (s2 = e3.request.to.uri.user) && void 0 !== s2 ? s2 : "", d = null !== (i2 = e3.request.getHeader("Event")) && void 0 !== i2 ? i2 : "", c2 = e3.request.getHeader("Content-Type"), l2 = null !== (n2 = null !== (o2 = e3.request.getHeader("x-push-id")) && void 0 !== o2 ? o2 : e3.request.getHeader("X-Push-Id")) && void 0 !== n2 ? n2 : "";
        this.event.onRecvOutOfDialogNotify(r2, a2, e3.request.body, d, c2, l2);
      }
    }, this.sessionDelegate = (e3) => ({
      onInfo: (t3) => {
        var s2;
        t3.accept();
        const i2 = null !== (s2 = t3.request.from.uri.user) && void 0 !== s2 ? s2 : "";
        this.event.onRecvInfo(i2, t3.request.body), t3.request.body.includes("Signal=") && this.event.onRecvDtmfTone(e3, t3.request.body[7]);
      },
      beforeGenerateResponseOfferAnswerInDialog: (t3, s2) => {
        if (!t3.from.uri.user) return;
        const i2 = this.sessions.get(e3);
        if (!i2)
          throw new Error(
            "incoming in dialog INVITE request but session not exist"
          );
        const o2 = [];
        t3.body.split("m=").forEach((e4) => {
          if ("video" === e4.substring(0, 5)) {
            const t4 = e4.indexOf("a=msid:"), s3 = e4.indexOf("\n", t4), i3 = e4.slice(t4 + 7, s3);
            o2.push(i3);
            const n2 = e4.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
            (null == n2 ? void 0 : n2[0]) && o2.push(n2[0]);
          }
        });
        o2.some((e4) => e4.includes("video_label")) && !o2.some((e4) => e4.includes("a=inactive")) && (s2.constraints = Object.assign({}, i2.constraints, {
          video: Object.assign(
            Object.assign({}, this.videoResolusion),
            this.videoFrameRate
          )
        }));
      },
      onInvite: (t3) => {
        if (t3.from.uri.user) {
          const s2 = this.sessions.get(e3);
          if (!s2)
            throw new Error(
              "incoming in dialog INVITE request but session not exist"
            );
          const i2 = JSON.parse(
            JSON.stringify(null == s2 ? void 0 : s2.mediaProperty)
          ), o2 = this.setSessionMediaProperty(e3, t3.body);
          if (!o2) return;
          try {
            this.setupRemoteMedia(e3, o2);
          } catch (e4) {
            console.warn(e4);
          }
          const n2 = "sendrecv" === (null == s2 ? void 0 : s2.mediaProperty.audio) || "recvonly" === (null == s2 ? void 0 : s2.mediaProperty.audio), r2 = "sendrecv" === (null == s2 ? void 0 : s2.mediaProperty.video) || "recvonly" === (null == s2 ? void 0 : s2.mediaProperty.video), a2 = "sendonly" === (null == s2 ? void 0 : s2.mediaProperty.screen);
          s2.constraints = this.initConstraints(r2), this.event.onInviteUpdated(e3, n2, r2, a2), "sendonly" !== (null == s2 ? void 0 : s2.mediaProperty.audio) && "inactive" !== (null == s2 ? void 0 : s2.mediaProperty.audio) || this.event.onRemoteHold(e3), ("sendonly" !== i2.audio && "inactive" !== (null == s2 ? void 0 : s2.mediaProperty.audio) || "sendrecv" !== (null == s2 ? void 0 : s2.mediaProperty.audio) && "recvonly" !== (null == s2 ? void 0 : s2.mediaProperty.audio)) && ("inactive" !== i2.audio || "recvonly" !== (null == s2 ? void 0 : s2.mediaProperty.audio)) || this.event.onRemoteUnHold(e3);
        }
      },
      onBye: (t3) => {
        t3.accept(), this.event.onInviteClosed(e3);
      },
      onMessage: (t3) => {
        var s2;
        t3.accept();
        const i2 = null !== (s2 = t3.request.getHeader("Content-Type")) && void 0 !== s2 ? s2 : "";
        this.event.onRecvMessage(e3, t3.request.body, i2);
      }
    }), this.remoteAudioID = "string" == typeof t2.remoteAudioID ? t2.remoteAudioID : t2.remoteAudioID.map((e3) => ({
      id: e3,
      isPlaying: false,
      sessionID: 0
    })), this.remoteVideoID = "string" == typeof t2.remoteVideoID ? t2.remoteVideoID : t2.remoteVideoID ? t2.remoteVideoID.map((e3) => ({ id: e3, isPlaying: false, sessionID: 0 })) : t2.remoteVideoID, this.remoteScreenID = t2.remoteScreenID, this.localVideoID = t2.localVideoID;
  }
  async createUserAgent(e2, t2, s2, i2, o2 = "", n2 = "", r2, a2 = false, d = 300, c2 = "") {
    try {
      const l2 = {
        authorizationUsername: e2,
        authorizationPassword: t2,
        transportOptions: { server: i2 },
        uri: UserAgent2.makeURI(`sip:${e2}@${s2}`),
        delegate: this.UADelegate,
        logLevel: "error",
        displayName: o2,
        userAgentString: n2,
        sessionDescriptionHandlerFactoryOptions: {
          peerConnectionConfiguration: {
            bundlePolicy: "balanced",
            certificates: void 0,
            iceCandidatePoolSize: 0,
            iceServers: [],
            iceTransportPolicy: "all",
            peerIdentity: void 0,
            rtcpMuxPolicy: "require"
          }
        },
        sipExtension100rel: a2 ? SIPExtension.Supported : SIPExtension.Unsupported
      };
      this.userAgent = new UserAgent2(l2), __classPrivateFieldSet(
        this,
        _PortSipSdk_registererOption,
        { expires: d, extraHeaders: r2, instanceId: c2 },
        "f"
      ), await this.userAgent.start(), __classPrivateFieldSet(this, _PortSipSdk_username, e2, "f"), this.getDeviceList();
    } catch (e3) {
      throw new Error("created agent fail" + e3);
    }
  }
  registerServer() {
    return new Promise((e2, t2) => {
      if (!this.userAgent) return t2("user ugent not exist");
      this.registerer = new Registerer2(
        this.userAgent,
        Object.assign(
          {},
          __classPrivateFieldGet(this, _PortSipSdk_registererOption, "f")
        )
      ), this.registerer.register({
        requestDelegate: {
          onAccept: () => {
            e2("accpet");
          },
          onReject: (e3) => {
            t2(e3.message.reasonPhrase);
          }
        }
      }).catch(() => t2("send fail"));
    });
  }
  refreshRegistration() {
    return new Promise((e2, t2) => {
      if (!this.registerer) return t2("registerer not exist, create first");
      this.registerer.register({
        requestDelegate: {
          onAccept: () => {
            e2("accpet");
          },
          onReject: (e3) => {
            t2(e3.message.reasonPhrase);
          }
        }
      }).catch(() => t2("send fail"));
    });
  }
  unRegisterServer() {
    return !!this.userAgent && (this.userAgent.stop(), __classPrivateFieldSet(this, _PortSipSdk_username, "", "f"), true);
  }
  setSessionMediaProperty(e2, t2) {
    const s2 = this.sessions.get(e2);
    if (!s2) return;
    const i2 = JSON.parse(JSON.stringify(s2.mediaProperty));
    return t2.split("m=").map((e3) => {
      let t3 = e3.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
      t3 || (t3 = ["", "sendrecv"]), e3.startsWith("audio") ? s2.mediaProperty.audio = t3[1] : e3.startsWith("video") && (e3.includes("stream_screen") ? s2.mediaProperty.screen = t3[1] : s2.mediaProperty.video = t3[1]);
    }), JSON.stringify(i2) !== JSON.stringify(s2.mediaProperty);
  }
  initConstraints(e2) {
    return e2 ? {
      video: Object.assign(
        Object.assign(
          {
            deviceId: __classPrivateFieldGet(
              this,
              _PortSipSdk_videoSource,
              "f"
            ) ? {
              exact: __classPrivateFieldGet(
                this,
                _PortSipSdk_videoSource,
                "f"
              )
            } : void 0
          },
          this.videoResolusion
        ),
        this.videoFrameRate
      ),
      audio: {
        deviceId: __classPrivateFieldGet(this, _PortSipSdk_audioSource, "f") ? {
          exact: __classPrivateFieldGet(
            this,
            _PortSipSdk_audioSource,
            "f"
          )
        } : void 0
      }
    } : {
      video: false,
      audio: {
        deviceId: __classPrivateFieldGet(this, _PortSipSdk_audioSource, "f") ? {
          exact: __classPrivateFieldGet(
            this,
            _PortSipSdk_audioSource,
            "f"
          )
        } : void 0
      }
    };
  }
  initAudioCall(e2, t2) {
    this.sessions.get(e2) || this.sessions.set(e2, {
      ext: t2,
      session: null,
      id: e2,
      constraints: this.initConstraints(false),
      mediaProperty: { audio: "", video: "", screen: "" }
    });
  }
  initVideoCall(e2, t2) {
    this.sessions.get(e2) || this.sessions.set(e2, {
      ext: t2,
      id: e2,
      session: null,
      constraints: this.initConstraints(true),
      mediaProperty: { audio: "", video: "", screen: "" }
    });
  }
  setVideoBitrate(e2) {
    this.videoMaxBitrate = 1024 * e2;
  }
  setVideoResolution(e2, t2) {
    this.videoResolusion = { width: { ideal: e2 }, height: { ideal: t2 } };
  }
  setVideoFrameRate(e2) {
    this.videoFrameRate.frameRate.ideal = e2;
  }
  async call(e2, t2, s2 = false, i2 = []) {
    if (!this.userAgent) return Promise.reject(new Error("UserAgent is null"));
    const o2 = UserAgent2.makeURI(e2);
    if (!o2) return Promise.reject(new Error("Not valid URI"));
    const n2 = uid++, r2 = e2.split(":")[1].split("@")[0];
    t2 ? this.initVideoCall(n2, r2) : this.initAudioCall(n2, r2);
    const a2 = this.sessions.get(n2);
    if (!a2) return Promise.reject(new Error("Session initial fail"));
    let d;
    const c2 = {
      extraHeaders: [...i2],
      earlyMedia: true,
      sessionDescriptionHandlerOptions: { constraints: a2.constraints },
      sessionDescriptionHandlerModifiersReInvite: [
        (e3) => {
          var t3, s3;
          const i3 = null === (t3 = e3.sdp) || void 0 === t3 ? void 0 : t3.split("m=").find((e4) => e4.includes("stream_screen"));
          if ("offer" === e3.type && (d = null == i3 ? void 0 : i3.includes("sendonly"), (null == i3 ? void 0 : i3.includes("sendonly")) ? this.event.onRecieveShare(
            n2,
            r2,
            __classPrivateFieldGet(this, _PortSipSdk_username, "f")
          ) : (null == i3 ? void 0 : i3.includes("inactive")) && this.switchScreenShareRenderInRemote(false, n2)), "answer" === e3.type && d) {
            const t4 = addScreenMarkModifier(
              null !== (s3 = e3.sdp) && void 0 !== s3 ? s3 : ""
            );
            e3.sdp = t4;
          }
          return Promise.resolve(e3);
        }
      ]
    }, l2 = new Inviter2(this.userAgent, o2, c2);
    l2.delegate = this.sessionDelegate(n2), a2.session = l2;
    let u2 = false;
    l2.stateChange.addListener((e3) => {
      switch (e3) {
        case SessionState.Initial:
          break;
        case SessionState.Establishing:
          const e4 = a2.session.request.hasHeader("X-Auth-Token");
          this.event.onInviteStart(n2, r2, Boolean(a2.constraints.video), e4);
          break;
        case SessionState.Established:
          u2 = true;
          try {
            this.setupRemoteMedia(n2), this.setupLocalMedia(n2);
          } catch (e5) {
            console.warn(e5);
          }
          break;
        case SessionState.Terminating:
          break;
        case SessionState.Terminated:
          this.event.onInviteClosed(n2), u2 && this.cleanupMedia(n2).catch((e5) => {
            console.warn(e5);
          }), this.sessions.delete(n2);
          break;
        default:
          throw new Error("unkonw session state");
      }
    });
    let v = true;
    const h = {
      sessionDescriptionHandlerOptions: {
        constraints: a2.constraints,
        disabledCodecs: {
          audio: this.disabledAudioCodecs,
          video: this.disabledVideoCodecs
        }
      },
      requestDelegate: {
        onAccept: (e3) => {
          var t3, s3, i3, o3, r3;
          this.setSessionMediaProperty(n2, e3.message.body);
          const d2 = !!(null === (t3 = e3.message.getHeader("X-Host-Conference")) || void 0 === t3 ? void 0 : t3.includes("host=true")), c3 = !!(null === (s3 = e3.message.getHeader("X-Host-Conference")) || void 0 === s3 ? void 0 : s3.includes("require-pin=true")), u3 = e3.message.getHeader("X-Session-Id");
          (null !== (r3 = null === (o3 = null === (i3 = l2.dialog) || void 0 === i3 ? void 0 : i3.answer) || void 0 === o3 ? void 0 : o3.content) && void 0 !== r3 ? r3 : "").split(/^m=/gm).some(
            (e4) => "video" === e4.substring(0, 5) && e4.includes("a=inactive")
          ) && (a2.constraints.video = false), this.event.onInviteConnected(
            n2,
            Boolean(a2.constraints.video),
            "send",
            d2,
            c3,
            u3
          );
        },
        onTrying: () => {
          this.event.onInviteTrying(n2, Boolean(a2.constraints.video)), t2 && this.setupLocalMedia(n2);
        },
        onProgress: (e3) => {
          if (183 === e3.message.statusCode) {
            if (this.event.onInviteSessionProgress(
              n2,
              Boolean(a2.constraints.video)
            ), !v)
              return;
            const e4 = (() => {
              const e5 = __classPrivateFieldGet(
                this,
                _PortSipSdk_instances,
                "a",
                _PortSipSdk_pendingRemoteAudioID_get
              ), t4 = "string" == typeof e5 ? e5 : null == e5 ? void 0 : e5.id;
              let s3 = null;
              try {
                s3 = document.querySelector(`#${t4}`);
              } catch (e6) {
                console.error(e6);
              }
              return s3;
            })();
            if (null === e4)
              throw new Error("cann't found the remote audio element");
            const t3 = () => {
              var e5, t4;
              const s3 = new MediaStream();
              return null === (t4 = (null === (e5 = null == a2 ? void 0 : a2.session) || void 0 === e5 ? void 0 : e5.sessionDescriptionHandler).peerConnection) || void 0 === t4 || t4.getReceivers().forEach((e6) => {
                const t5 = e6.track;
                t5 && s3.addTrack(t5);
              }), s3;
            };
            this.setElementSrc(e4, t3(), n2), __classPrivateFieldGet(this, _PortSipSdk_audioOutput, "f") && (null == e4 || e4.setSinkId(
              __classPrivateFieldGet(this, _PortSipSdk_audioOutput, "f")
            ).catch((e5) => console.error(e5))), v = false;
          }
          180 === e3.message.statusCode && this.event.onInviteRinging(n2);
        },
        onReject: (e3) => {
          var t3;
          if (null === (t3 = a2.session) || void 0 === t3 ? void 0 : t3.isCanceled)
            return;
          const { statusCode: s3, reasonPhrase: i3 } = e3.message;
          this.event.onInviteFailure(n2, `${s3} ${i3}`);
        }
      },
      withoutSdp: s2
    };
    return l2.invite(h).then(() => n2);
  }
  async answerCall(e2, t2) {
    const s2 = this.sessions.get(e2);
    if (!((null == s2 ? void 0 : s2.session) instanceof Invitation2))
      return Promise.reject(new Error("Session not instance of Invitation"));
    let i2;
    s2.constraints = this.initConstraints(t2), t2 || (s2.constraints.video = false), console.log("answerCall", s2.constraints);
    try {
      i2 = await navigator.mediaDevices.getUserMedia(s2.constraints);
    } catch (t3) {
      t3 instanceof Error && t3.message.includes("video") && this.initAudioCall(e2, s2.ext);
    } finally {
      null == i2 || i2.getTracks().forEach((e3) => e3.stop());
    }
    const o2 = {
      sessionDescriptionHandlerOptions: {
        disabledCodecs: {
          audio: this.disabledAudioCodecs,
          video: this.disabledVideoCodecs
        },
        constraints: s2.constraints
      },
      sessionDescriptionHandlerModifiers: [
        (e3) => {
          var t3;
          if (!s2.constraints.video) {
            const s3 = inactiveVideoModifer(
              null !== (t3 = e3.sdp) && void 0 !== t3 ? t3 : ""
            );
            e3.sdp = s3;
          }
          return Promise.resolve(e3);
        }
      ]
    };
    let n2;
    return console.log("answerCall-option", o2), s2.session.sessionDescriptionHandlerModifiersReInvite = [
      (t3) => {
        var i3, o3;
        const r2 = null === (i3 = t3.sdp) || void 0 === i3 ? void 0 : i3.split("m=").find((e3) => e3.includes("stream_screen"));
        if (console.log("screenSDP", t3, r2), "offer" === t3.type && (n2 = null == r2 ? void 0 : r2.includes("sendonly"), (null == r2 ? void 0 : r2.includes("sendonly")) ? this.event.onRecieveShare(
          e2,
          s2.ext,
          __classPrivateFieldGet(this, _PortSipSdk_username, "f")
        ) : (null == r2 ? void 0 : r2.includes("inactive")) && this.switchScreenShareRenderInRemote(false, e2)), "answer" === t3.type && n2) {
          const e3 = addScreenMarkModifier(
            null !== (o3 = t3.sdp) && void 0 !== o3 ? o3 : ""
          );
          t3.sdp = e3;
        }
        return Promise.resolve(t3);
      }
    ], console.log("[webRTC-SDK]", "answerCall", o2), s2.session.accept(o2);
  }
  hangUp(e2, t2 = 486) {
    const s2 = this.sessions.get(e2);
    if (!s2 || null === s2.session) return Promise.reject("session not exist");
    switch (s2.session.state) {
      case SessionState.Initial:
      case SessionState.Establishing:
        return s2.session instanceof Inviter2 ? s2.session.cancel() : s2.session instanceof Invitation2 ? s2.session.reject({ statusCode: t2 }) : Promise.reject("unkonw call direction");
      case SessionState.Established:
        return s2.session.bye();
      case SessionState.Terminating:
        return Promise.reject("session is going over");
      case SessionState.Terminated:
        return Promise.reject("session is over");
      default:
        return Promise.reject("unknow session state");
    }
  }
  mute(e2, t2) {
    var s2, i2, o2;
    const n2 = this.sessions.get(e2);
    try {
      if (!n2 || null === n2.session) throw new Error("session not exist");
      null === (o2 = null === (i2 = null === (s2 = null == n2 ? void 0 : n2.session) || void 0 === s2 ? void 0 : s2.sessionDescriptionHandler) || void 0 === i2 ? void 0 : i2.peerConnection) || void 0 === o2 || o2.getSenders().forEach((e3) => {
        var s3;
        "audio" === (null === (s3 = null == e3 ? void 0 : e3.track) || void 0 === s3 ? void 0 : s3.kind) && (e3.track.enabled = !t2);
      });
    } catch (e3) {
      let t3 = "Mute fail";
      return "string" == typeof e3 && (t3 = e3), Promise.reject(new Error(t3));
    }
    return Promise.resolve();
  }
  sendVideo(e2, t2, s2) {
    return new Promise(async (i2, o2) => {
      var n2;
      const r2 = this.sessions.get(e2);
      if (!r2) return o2("session not exist");
      const a2 = null === (n2 = null == r2 ? void 0 : r2.session) || void 0 === n2 ? void 0 : n2.sessionDescriptionHandler, d = null == a2 ? void 0 : a2.peerConnection;
      if (!d) return o2("peerConnection not found");
      const c2 = d.getSenders();
      if (!t2) {
        if (s2) return i2("Can't help but use local video");
        {
          const e3 = c2.find((e4) => {
            var t3;
            return "video" === (null === (t3 = e4.track) || void 0 === t3 ? void 0 : t3.kind);
          });
          if (e3) {
            const t3 = e3.track;
            return t3 && (t3.enabled = false, t3.stop()), i2("stop video success");
          }
          return o2("video sender not found");
        }
      }
      try {
        r2.constraints = this.initConstraints(t2);
        const s3 = Object.assign(r2.constraints, { audio: false }), n3 = await navigator.mediaDevices.getUserMedia(s3), l2 = n3.getVideoTracks();
        if (0 === l2.length) return o2("no video track found in local stream");
        const u2 = l2[0];
        let v = c2.find((e3) => {
          var t3;
          return "video" === (null === (t3 = e3.track) || void 0 === t3 ? void 0 : t3.kind);
        });
        if (v)
          try {
            await v.replaceTrack(u2);
          } catch (e3) {
            return o2(`replaceTrack failed: ${e3}`);
          }
        else v = d.addTrack(u2, n3);
        const h = a2.localMediaStream, p2 = h.getVideoTracks()[0];
        p2 && (p2.stop(), h.removeTrack(p2)), h.addTrack(u2), this.setupLocalMedia(e2);
        return d.getSenders().forEach((e3) => console.log("Sender track:", e3.track)), i2("restore video success");
      } catch (e3) {
        return o2(e3);
      }
    });
  }
  hold(e2) {
    return new Promise((t2, s2) => {
      var i2, o2;
      const n2 = this.sessions.get(e2);
      if (!n2 || null === n2.session) return s2("session not exist");
      null === (o2 = null === (i2 = null == n2 ? void 0 : n2.session.sessionDescriptionHandler) || void 0 === i2 ? void 0 : i2.peerConnection) || void 0 === o2 || o2.getSenders().forEach((e3) => {
        const t3 = e3.getParameters();
        t3.encodings.forEach((e4) => {
          e4.active = false;
        }), e3.setParameters(t3);
      });
      const r2 = n2.session.sessionDescriptionHandlerModifiersReInvite;
      n2.session.invite({
        sessionDescriptionHandlerOptions: {
          hold: true,
          disabledCodecs: {
            audio: this.disabledAudioCodecs,
            video: this.disabledVideoCodecs
          }
        },
        sessionDescriptionHandlerModifiers: [
          (e3) => {
            var t3;
            if ("offer" === e3.type && n2.constraints.audio && !n2.constraints.video) {
              const s3 = inactiveHoldVideoModifer(
                null !== (t3 = e3.sdp) && void 0 !== t3 ? t3 : ""
              );
              e3.sdp = s3;
            }
            return Promise.resolve(e3);
          }
        ],
        requestDelegate: {
          onAccept: (s3) => {
            this.cleanupMedia(e2);
            s3.message.to.uri.user && this.setSessionMediaProperty(e2, s3.message.body), n2.session && (n2.session.sessionDescriptionHandlerModifiersReInvite = r2), t2(e2);
          },
          onReject: (e3) => {
            s2(
              `hold reject, reason: ${e3.message.statusCode}${e3.message.reasonPhrase}`
            );
          }
        }
      });
    });
  }
  unhold(e2) {
    return new Promise((t2, s2) => {
      var i2, o2;
      const n2 = this.sessions.get(e2);
      if (!n2 || null === n2.session) return s2("session not exist");
      null === (o2 = null === (i2 = null == n2 ? void 0 : n2.session.sessionDescriptionHandler) || void 0 === i2 ? void 0 : i2.peerConnection) || void 0 === o2 || o2.getSenders().forEach((e3) => {
        const t3 = e3.getParameters();
        t3.encodings.forEach((e4) => {
          e4.active = true;
        }), e3.setParameters(t3);
      });
      const r2 = n2.session.sessionDescriptionHandlerModifiersReInvite;
      return n2.session.invite({
        sessionDescriptionHandlerOptions: {
          hold: false,
          disabledCodecs: {
            audio: this.disabledAudioCodecs,
            video: this.disabledVideoCodecs
          }
        },
        sessionDescriptionHandlerModifiers: [
          (e3) => {
            var t3;
            if ("offer" === e3.type && n2.constraints.audio && !n2.constraints.video) {
              const s3 = inactiveHoldVideoModifer(
                null !== (t3 = e3.sdp) && void 0 !== t3 ? t3 : ""
              );
              e3.sdp = s3;
            }
            return Promise.resolve(e3);
          }
        ],
        requestDelegate: {
          onAccept: (s3) => {
            this.setupRemoteMedia(e2), this.setupLocalMedia(e2), n2.session && (n2.session.sessionDescriptionHandlerModifiersReInvite = r2), t2(e2);
            s3.message.to.uri.user && this.setSessionMediaProperty(e2, s3.message.body);
          },
          onReject: () => {
            s2("unhold reject");
          }
        }
      });
    });
  }
  sendDtmf(e2, t2) {
    const s2 = this.sessions.get(e2);
    if (!s2 || null === s2.session) return Promise.reject("session not exist");
    const i2 = {
      requestOptions: {
        body: {
          contentDisposition: "render",
          contentType: "application/dtmf-relay",
          content: "Signal=" + t2 + "\r\nDuration=160"
        }
      }
    };
    return s2.session.info(i2);
  }
  refer(e2, t2) {
    const s2 = this.sessions.get(e2);
    if (!s2 || null === s2.session) throw new Error("session not exist");
    const i2 = UserAgent2.makeURI(t2);
    return i2 ? s2.session.refer(i2, {
      onNotify: (t3) => {
        t3.accept(), t3.request.body.includes("200") ? this.event.onACTVTransferSuccess(e2) : t3.request.body.includes("100") ? this.event.onTransferTrying(e2) : t3.request.body.includes("180") || t3.request.body.includes("183") ? this.event.onTransferRinging(e2) : this.event.onACTVTransferFailure(e2);
      }
    }).catch((t3) => (this.event.onACTVTransferFailure(e2), t3)) : Promise.reject("refer target URI isn't valid URI.");
  }
  attendedRefer(e2, t2) {
    const s2 = this.sessions.get(e2);
    if (!s2 || null === s2.session) return Promise.reject("session not exist");
    const i2 = this.sessions.get(t2);
    return (null == i2 ? void 0 : i2.session) instanceof Session2 ? i2.session.dialog ? s2.session.refer(i2.session, {
      onNotify: (t3) => {
        t3.accept(), t3.request.body.includes("200") ? this.event.onACTVTransferSuccess(e2) : t3.request.body.includes("100") ? this.event.onTransferTrying(e2) : t3.request.body.includes("180") || t3.request.body.includes("183") ? this.event.onTransferRinging(e2) : this.event.onACTVTransferFailure(e2);
      }
    }).catch((e3) => (this.event.onACTVTransferFailure(t2), e3)) : (this.event.onACTVTransferFailure(t2), Promise.reject("refer target not established.")) : Promise.reject("refer target not a Session.");
  }
  updateCall(e2, t2, s2) {
    var i2, o2, n2, r2, a2;
    const d = this.sessions.get(e2);
    if (!d) return Promise.reject("session not exist");
    if (null === (n2 = null === (o2 = null === (i2 = d.session) || void 0 === i2 ? void 0 : i2.sessionDescriptionHandler) || void 0 === o2 ? void 0 : o2.peerConnection) || void 0 === n2 || n2.getSenders().forEach((e3) => {
      var s3;
      "audio" === (null === (s3 = e3.track) || void 0 === s3 ? void 0 : s3.kind) && (e3.track.enabled = t2);
    }), s2) {
      const t3 = d.constraints.video;
      return this.initVideoCall(e2, d.ext), d.constraints = this.initConstraints(s2), null === (r2 = d.session) || void 0 === r2 ? void 0 : r2.invite({
        sessionDescriptionHandlerOptions: {
          constraints: d.constraints,
          disabledCodecs: {
            audio: this.disabledAudioCodecs,
            video: this.disabledVideoCodecs
          }
        },
        sessionDescriptionHandlerModifiers: [
          (e3) => {
            var t4;
            if (d.constraints.video) {
              const s3 = activeVideoModifer(
                null !== (t4 = e3.sdp) && void 0 !== t4 ? t4 : ""
              );
              e3.sdp = s3;
            }
            return Promise.resolve(e3);
          }
        ],
        requestDelegate: {
          onAccept: (t4) => {
            this.setSessionMediaProperty(e2, t4.message.body);
            try {
              this.setupLocalMedia(e2), this.setupRemoteMedia(e2);
            } catch (e3) {
              console.error(e3);
            }
          },
          onReject: () => {
            d.constraints.video = t3;
          }
        }
      });
    }
    {
      const t3 = d.constraints.video;
      return this.initAudioCall(e2, d.ext), d.constraints = this.initConstraints(s2), null === (a2 = d.session) || void 0 === a2 ? void 0 : a2.invite({
        sessionDescriptionHandlerOptions: {
          constraints: d.constraints,
          disabledCodecs: {
            audio: this.disabledAudioCodecs,
            video: this.disabledVideoCodecs
          }
        },
        sessionDescriptionHandlerModifiers: [
          (e3) => {
            var t4;
            if (!d.constraints.video) {
              const s3 = inactiveVideoModifer(
                null !== (t4 = e3.sdp) && void 0 !== t4 ? t4 : ""
              );
              e3.sdp = s3;
            }
            return Promise.resolve(e3);
          }
        ],
        requestDelegate: {
          onAccept: (t4) => {
            this.setSessionMediaProperty(e2, t4.message.body);
            try {
              this.setupRemoteMedia(e2);
            } catch (e3) {
              console.warn(e3);
            }
          },
          onReject: () => {
            d.constraints.video = t3;
          }
        }
      });
    }
  }
  async getShareableArea(e2) {
    const t2 = this.sessions.get(e2);
    if (!t2 || null === t2.session) throw new Error("session no exist");
    try {
      const e3 = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: false
      });
      return __classPrivateFieldSet(
        this,
        _PortSipSdk_localScreenVideoTrack,
        e3.getVideoTracks()[0],
        "f"
      ), Promise.resolve();
    } catch (e3) {
      return Promise.reject(new Error("screen share error:" + e3));
    }
  }
  async startShareScreen(e2) {
    const t2 = this.sessions.get(e2);
    if (!t2 || null === t2.session) throw new Error("session no exist");
    if (!__classPrivateFieldGet(this, _PortSipSdk_localScreenVideoTrack, "f") || "ended" === __classPrivateFieldGet(this, _PortSipSdk_localScreenVideoTrack, "f").readyState)
      throw new Error("local screen share source can't be used");
    const s2 = (s3) => new Promise((i2, o2) => {
      var n2, r2, a2, d, c2;
      const l2 = null === (r2 = (null === (n2 = t2.session) || void 0 === n2 ? void 0 : n2.sessionDescriptionHandler).peerConnection) || void 0 === r2 ? void 0 : r2.getSenders(), u2 = null == l2 ? void 0 : l2.find(function(e3) {
        return null === e3.track;
      }), v = () => {
        var e3, s4;
        const i3 = null === (s4 = (null === (e3 = t2.session) || void 0 === e3 ? void 0 : e3.sessionDescriptionHandler).peerConnection) || void 0 === s4 ? void 0 : s4.getSenders(), o3 = null == i3 ? void 0 : i3.find(
          (e4) => e4.track && e4.track.label.match(
            /(screen|window|web-contents-media-stream)/
          )
        );
        if (!o3) return;
        const n3 = o3.getParameters();
        n3.encodings.forEach((e4) => e4.maxBitrate = this.videoMaxBitrate), o3.setParameters(n3);
      };
      u2 ? u2.replaceTrack(s3).then(() => {
        var s4;
        v(), null === (s4 = t2.session) || void 0 === s4 || s4.invite({
          sessionDescriptionHandlerOptions: {
            disabledCodecs: {
              audio: this.disabledAudioCodecs,
              video: this.disabledVideoCodecs
            }
          },
          sessionDescriptionHandlerModifiers: [
            (e3) => {
              var t3;
              let s5 = addScreenMarkModifier(
                null !== (t3 = e3.sdp) && void 0 !== t3 ? t3 : ""
              );
              return s5 = sendScreenModifer(s5), e3.sdp = s5, Promise.resolve(e3);
            }
          ],
          requestDelegate: {
            onAccept: (t3) => {
              this.setSessionMediaProperty(e2, t3.message.body), this.event.onShareAccept(
                e2,
                t3.message.from.uri.user,
                t3.message.to.uri.user
              ), i2();
            },
            onReject: (e3) => {
              o2(e3.message.reasonPhrase);
            }
          }
        });
      }).catch((e3) => {
        o2(new Error("replace track error: " + e3));
      }) : (null === (d = (null === (a2 = t2.session) || void 0 === a2 ? void 0 : a2.sessionDescriptionHandler).peerConnection) || void 0 === d || d.addTrack(s3), null === (c2 = t2.session) || void 0 === c2 || c2.invite({
        sessionDescriptionHandlerOptions: {
          disabledCodecs: {
            audio: this.disabledAudioCodecs,
            video: this.disabledVideoCodecs
          }
        },
        sessionDescriptionHandlerModifiers: [
          (e3) => {
            var t3;
            let s4 = addScreenMarkModifier(
              null !== (t3 = e3.sdp) && void 0 !== t3 ? t3 : ""
            );
            return e3.sdp = s4, Promise.resolve(e3);
          }
        ],
        requestDelegate: {
          onAccept: (t3) => {
            this.setSessionMediaProperty(e2, t3.message.body), this.event.onShareAccept(
              e2,
              t3.message.from.uri.user,
              t3.message.to.uri.user
            ), i2();
          },
          onReject: (e3) => {
            o2(e3.message.reasonPhrase);
          }
        }
      }).then(() => {
        v();
      }));
    });
    __classPrivateFieldGet(
      this,
      _PortSipSdk_localScreenVideoTrack,
      "f"
    ).addEventListener("ended", () => {
      this.event.onShareStop(e2), this.endShareScreen(e2);
    });
    try {
      return await s2(
        __classPrivateFieldGet(this, _PortSipSdk_localScreenVideoTrack, "f")
      ), true;
    } catch (e3) {
      return false;
    }
  }
  endShareScreen(e2) {
    var t2;
    try {
      const s2 = this.sessions.get(e2);
      if (!s2 || null === s2.session) throw new Error("session not find");
      const i2 = s2.session.sessionDescriptionHandler.peerConnection, o2 = null == i2 ? void 0 : i2.getSenders(), n2 = null == o2 ? void 0 : o2.find(
        (e3) => e3.track && e3.track.label.match(
          /(screen|window|web-contents-media-stream)/
        )
      );
      return n2 && (null === (t2 = n2.track) || void 0 === t2 || t2.stop(), null == i2 || i2.removeTrack(n2), s2.session.invite({
        sessionDescriptionHandlerOptions: {
          disabledCodecs: {
            audio: this.disabledAudioCodecs,
            video: this.disabledVideoCodecs
          }
        },
        sessionDescriptionHandlerModifiers: [
          (t3) => {
            var i3, o3;
            const n3 = null === (i3 = t3.sdp) || void 0 === i3 ? void 0 : i3.split("m=").reverse().find((e3) => e3.includes("stream_screen"));
            if ("offer" === t3.type) {
              (null == n3 ? void 0 : n3.includes("sendonly")) ? this.event.onRecieveShare(
                e2,
                s2.ext,
                __classPrivateFieldGet(this, _PortSipSdk_username, "f")
              ) : (null == n3 ? void 0 : n3.includes("inactive")) && this.switchScreenShareRenderInRemote(false, e2);
              const i4 = inactiveScreenModifer(
                null !== (o3 = t3.sdp) && void 0 !== o3 ? o3 : ""
              );
              t3.sdp = i4;
            }
            return Promise.resolve(t3);
          }
        ],
        requestDelegate: {
          onAccept: (t3) => {
            this.setSessionMediaProperty(e2, t3.message.body), this.event.onShareStopAccept(
              e2,
              t3.message.from.uri.user,
              t3.message.to.uri.user
            );
          }
        }
      })), true;
    } catch (e3) {
      return console.error("stop sharing fail", e3), false;
    }
  }
  sendOutOfDialogMessage(e2, t2, s2) {
    if (!this.userAgent) return Promise.reject();
    const i2 = UserAgent2.makeURI(t2);
    if (!i2) return Promise.reject("not valid targetURI");
    let o2;
    s2 && (o2 = "application/json");
    const n2 = new Messager2(this.userAgent, i2, e2, o2, {
      extraHeaders: [
        `X-Instance-Id:${__classPrivateFieldGet(this, _PortSipSdk_registererOption, "f").instanceId}`
      ]
    }), r2 = {
      requestDelegate: {
        onAccept: (i3) => {
          var o3;
          const n3 = null !== (o3 = i3.message.getHeader("X-Sender-Msg-Id")) && void 0 !== o3 ? o3 : "", r3 = t2.split(":")[1].split("@")[0];
          this.event.onSendOutOfDialogMessageSuccess(r3, {
            msgServerID: n3,
            msgRawString: e2,
            rawStringIsJSON: s2
          });
        },
        onReject(e3) {
          console.error("out dialog message is send, recieve fail :", e3);
        }
      }
    };
    return n2.message(r2);
  }
  sendMessage(e2, t2, s2) {
    const i2 = this.sessions.get(t2);
    if (!i2 || null === i2.session) return Promise.reject("session not exist");
    const o2 = {
      contentDisposition: "session",
      content: e2,
      contentType: s2 ? "application/x-conference-control+json" : "application/json"
    };
    return i2.session.message({
      requestOptions: {
        body: o2,
        extraHeaders: [
          `X-Instance-Id:${__classPrivateFieldGet(this, _PortSipSdk_registererOption, "f").instanceId}`
        ]
      }
    });
  }
  async sendSubscription(e2) {
    if (!this.userAgent) return Promise.reject();
    const t2 = UserAgent2.makeURI(e2);
    if (!t2) return Promise.reject(new Error("Not valid URI"));
    const s2 = new Subscriber(this.userAgent, t2, "presence");
    s2.delegate = {
      onNotify: (t3) => {
        t3.accept();
        const s3 = e2.split(":")[1].split("@")[0];
        this.event.onRecvNotifyOfSubscription(s3, t3.request.body);
      }
    }, await s2.subscribe(), this.subscribers.set(e2, s2);
  }
  async subscribeVoicemail(e2) {
    if (!this.userAgent) return Promise.reject();
    const t2 = UserAgent2.makeURI(e2);
    if (!t2) return Promise.reject(new Error("Not valid URI"));
    const s2 = new Subscriber(this.userAgent, t2, "message-summary");
    s2.delegate = {
      onNotify: (e3) => {
        if (e3.accept(), "" === e3.request.body) return;
        const t3 = new RegExp("^voice-message:.*$", "gm"), s3 = e3.request.body.match(t3);
        let i2;
        null === s3 ? i2 = "0" : (i2 = s3[0].slice(s3[0].indexOf(":") + 1, s3[0].indexOf("/")), Number(i2) >= 0 && this.event.onVoiceMailReceived(Number(i2)));
      }
    }, await s2.subscribe(), this.subscribers.set(e2, s2);
  }
  terminateSubscription(e2) {
    const t2 = this.subscribers.get(e2);
    return t2 ? t2.unsubscribe() : Promise.reject("subscriber not exist");
  }
  setMyStatus(e2, t2) {
    if (!this.userAgent) return Promise.reject("user agent not exist");
    const s2 = this.userAgent.configuration.uri;
    let i2 = "";
    return "Available" === e2 && (i2 = "open"), "Offline" === e2 && (i2 = "closed"), new Publisher(this.userAgent, s2, "presence", {
      contentType: "application/pidf+xml"
    }).publish(
      function(e3, t3, s3) {
        return `<?xml version="1.0" encoding="UTF-8"?>
        <presence xmlns="urn:ietf:params:xml:ns:pidf" entity="${s3}">
            <tuple id="${s3}">
              <status>
                <basic>${e3}</basic>
              </status>
              ${t3 ? `<note>${t3}</note>` : ""}
            <timestamp>${(/* @__PURE__ */ new Date()).toISOString()}</timestamp>
          </tuple>
        </presence>`;
      }(i2 || e2, t2, s2.toRaw())
    );
  }
  async getDeviceList() {
    const e2 = async ({ audio: e3, video: t2 } = { audio: true, video: true }) => {
      try {
        (await navigator.mediaDevices.getUserMedia({ audio: e3, video: t2 })).getTracks().forEach((e4) => e4.stop());
      } catch (e4) {
        throw e4;
      }
    };
    try {
      await e2();
    } catch (e3) {
      console.error("Initial permission request failed:", e3), __classPrivateFieldSet(this, _PortSipSdk_enumerateDevices, [], "f");
    }
    try {
      const t2 = await navigator.mediaDevices.enumerateDevices(), s2 = t2.some((e3) => "audioinput" === e3.kind && "" === e3.deviceId), i2 = t2.some((e3) => "videoinput" === e3.kind && "" === e3.deviceId);
      if (s2 || i2)
        try {
          await e2({ audio: s2, video: i2 });
        } catch (e3) {
          return console.error("Second permission request failed:", e3), void __classPrivateFieldSet(
            this,
            _PortSipSdk_enumerateDevices,
            [],
            "f"
          );
        }
      __classPrivateFieldSet(
        this,
        _PortSipSdk_enumerateDevices,
        await navigator.mediaDevices.enumerateDevices(),
        "f"
      );
    } catch (e3) {
      __classPrivateFieldSet(this, _PortSipSdk_enumerateDevices, [], "f"), console.error("Failed to obtain the device list:", e3);
    }
  }
  getSpeakDevList() {
    return __classPrivateFieldGet(
      this,
      _PortSipSdk_enumerateDevices,
      "f"
    ).filter((e2) => "audiooutput" === e2.kind);
  }
  setSpeakDev(e2) {
    __classPrivateFieldSet(this, _PortSipSdk_audioOutput, e2, "f");
  }
  getMicrophoneDevList() {
    return __classPrivateFieldGet(
      this,
      _PortSipSdk_enumerateDevices,
      "f"
    ).filter((e2) => "audioinput" === e2.kind);
  }
  setMicrophone(e2) {
    __classPrivateFieldSet(this, _PortSipSdk_audioSource, e2, "f");
  }
  getCameraDevList() {
    return __classPrivateFieldGet(
      this,
      _PortSipSdk_enumerateDevices,
      "f"
    ).filter((e2) => "videoinput" === e2.kind);
  }
  setCameraDev(e2) {
    __classPrivateFieldSet(this, _PortSipSdk_videoSource, e2, "f");
  }
  setDisabledAudioCodecs(e2) {
    this.disabledAudioCodecs = e2;
  }
  setDisabledVideoCodecs(e2) {
    this.disabledVideoCodecs = e2;
  }
  cleanupMedia(e2) {
    let t2 = null;
    const s2 = __classPrivateFieldGet(
      this,
      _PortSipSdk_instances,
      "m",
      _PortSipSdk_getPlayingAudiotID
    ).call(this, e2);
    try {
      t2 = document.querySelector(`#${s2}`);
    } catch (e3) {
      console.error(e3);
    }
    if (null === t2)
      return Promise.reject("cann't found the remote audio element");
    t2.pause(), this.setElementSrc(t2, null, e2);
    let i2 = null;
    const o2 = __classPrivateFieldGet(
      this,
      _PortSipSdk_instances,
      "m",
      _PortSipSdk_getPlayingVideotID
    ).call(this, e2);
    try {
      i2 = document.querySelector(`#${o2}`);
    } catch (e3) {
      console.error(e3);
    }
    if (null === i2)
      return Promise.reject("cann't found the remote video element");
    i2.pause(), this.setElementSrc(i2, null, e2);
    let n2 = null;
    try {
      n2 = document.querySelector(`#${this.localVideoID}`);
    } catch (e3) {
      console.error(e3);
    }
    return null === n2 ? Promise.reject("cann't found the local video element") : (n2.pause(), this.setElementSrc(n2, null, e2), Promise.resolve());
  }
  setupLocalMedia(e2) {
    var t2, s2;
    const i2 = this.sessions.get(e2);
    if (!i2 || null === i2.session) throw new Error("session not exist");
    let o2 = null;
    this.localVideoID = "local";
    try {
      o2 = document.querySelector(`#${this.localVideoID}`);
    } catch (e3) {
      console.error(e3);
    }
    const n2 = i2.session.sessionDescriptionHandler.localMediaStream;
    if (null === o2) throw new Error("cann't found the local media element");
    null === (s2 = null === (t2 = null == i2 ? void 0 : i2.session.sessionDescriptionHandler) || void 0 === t2 ? void 0 : t2.peerConnection) || void 0 === s2 || s2.getSenders().forEach((e3) => {
      if (e3.track && "video" === e3.track.kind) {
        const t3 = e3.getParameters();
        t3.encodings.forEach((e4) => {
          e4.maxBitrate = this.videoMaxBitrate, e4.priority = "high";
        }), e3.setParameters(t3);
      }
    }), this.setElementSrc(o2, n2, e2);
  }
  setupRemoteMedia(e2, t2 = false) {
    const s2 = this.sessions.get(e2);
    if (!s2 || null === s2.session) throw new Error("session not exist");
    const i2 = s2.session.sessionDescriptionHandler.remoteMediaStream;
    if (!i2.active) return;
    const o2 = s2.session.sessionDescriptionHandler.remoteScreenMediaStream;
    (() => {
      const t3 = __classPrivateFieldGet(
        this,
        _PortSipSdk_instances,
        "a",
        _PortSipSdk_pendingRemoteAudioID_get
      ), s3 = "string" == typeof t3 ? t3 : null == t3 ? void 0 : t3.id;
      let o3 = null;
      try {
        o3 = document.querySelector(`#${s3}`);
      } catch (e3) {
        console.error(e3);
      }
      if (null === o3) throw new Error("cann't found the remote audio element");
      const n2 = new MediaStream(), r2 = i2.getAudioTracks()[0];
      n2.addTrack(r2), this.setElementSrc(o3, n2, e2), __classPrivateFieldGet(this, _PortSipSdk_audioOutput, "f") && (null == o3 || o3.setSinkId(
        __classPrivateFieldGet(this, _PortSipSdk_audioOutput, "f")
      ).catch((e3) => console.error(e3)));
    })();
    (() => {
      var s3;
      const o3 = __classPrivateFieldGet(
        this,
        _PortSipSdk_instances,
        "a",
        _PortSipSdk_pendingRemoteVideoID_get
      ), n2 = "string" == typeof o3 ? o3 : null == o3 ? void 0 : o3.id;
      let r2 = null;
      try {
        r2 = document.querySelector(`#${n2}`);
      } catch (e3) {
        console.error(e3);
      }
      if (null === r2) throw new Error("cann't found the remote media element");
      const a2 = new MediaStream(), d = i2.getVideoTracks()[0];
      if (d) {
        if (a2.addTrack(d), t2 && __classPrivateFieldGet(
          this,
          _PortSipSdk_instances,
          "m",
          _PortSipSdk_compareTrackIsSame
        ).call(
          this,
          d,
          null === (s3 = r2.srcObject) || void 0 === s3 ? void 0 : s3.getVideoTracks()[0]
        ))
          return;
        this.setElementSrc(r2, a2, e2);
      } else this.setElementSrc(r2, null, e2);
    })();
    (() => {
      let t3 = null;
      try {
        t3 = document.querySelector(`#${this.remoteScreenID}`);
      } catch (e3) {
        console.error(e3);
      }
      if (null === t3) throw new Error("cann't find the remote screen element");
      t3.pause();
      const i3 = new MediaStream(), n2 = o2.getVideoTracks()[0];
      if (n2) {
        if ("sendonly" !== s2.mediaProperty.screen) return;
        i3.addTrack(n2), this.setElementSrc(t3, i3, e2);
      } else this.setElementSrc(t3, null, e2);
    })();
  }
  playLocalVideoInRemoteElement(e2, t2) {
    if ("string" != typeof this.remoteVideoID)
      throw new Error("remote video is array, cann't go on");
    const s2 = this.sessions.get(e2);
    if (!s2 || null === s2.session) throw new Error("session not exist");
    let i2 = null;
    try {
      i2 = document.querySelector(t2 ? "#local" : `#${this.remoteVideoID}`);
    } catch (e3) {
      console.error(e3);
    }
    if (null === i2) throw new Error("cann't found the remote media element");
    if (s2.constraints.video) {
      const t3 = s2.session.sessionDescriptionHandler.localMediaStream;
      this.setElementSrc(i2, t3, e2);
    }
  }
  async playMeetingLocalVideoInRemoteElement(e2) {
    const t2 = document.querySelector(e2);
    if (t2)
      try {
        if (t2.srcObject) {
          t2.srcObject.getTracks().forEach((e4) => e4.stop()), await new Promise((e4) => {
            t2.onemptied = e4, t2.srcObject = null;
          });
        }
        const e3 = this.initConstraints(true), s2 = await navigator.mediaDevices.getUserMedia(e3);
        t2.srcObject = s2, await new Promise((e4, s3) => {
          t2.onloadedmetadata = e4, t2.onerror = s3;
        }), await t2.play().catch(
          (e4) => (console.warn("Playback failed, trying fallback:", e4), t2.muted = true, t2.play())
        );
      } catch (e3) {
        console.error("Error accessing media devices:", e3);
      }
  }
  async stopLocalVideoPreview() {
    const e2 = document.querySelector("#meeting-video");
    if (e2 && e2.srcObject) {
      e2.srcObject.getTracks().forEach((e3) => e3.stop()), e2.srcObject = null;
    }
  }
  switchScreenShareRenderInRemote(e2, t2) {
    var s2, i2, o2;
    if (this.remoteVideoID = "remote", this.remoteScreenID = "remoteScreen", "string" != typeof this.remoteVideoID)
      throw new Error("remote video is array, cann't go on");
    const n2 = this.sessions.get(t2);
    if (!n2 || null === n2.session) throw new Error("session not exist");
    let r2 = null, a2 = null;
    try {
      r2 = document.querySelector(`#${this.remoteVideoID}`), a2 = document.querySelector(`#${this.remoteScreenID}`);
    } catch (e3) {
      console.error(e3);
    }
    if (null === r2 || null === a2)
      throw new Error("remote video or remote screen element not found");
    const d = (null === (s2 = null == n2 ? void 0 : n2.session) || void 0 === s2 ? void 0 : s2.sessionDescriptionHandler).remoteMediaStream, c2 = new MediaStream(), l2 = d.getVideoTracks();
    l2[0] && c2.addTrack(l2[0]);
    const u2 = (null === (i2 = null == n2 ? void 0 : n2.session) || void 0 === i2 ? void 0 : i2.sessionDescriptionHandler).remoteScreenMediaStream;
    if (e2) this.setElementSrc(r2, u2, t2), this.setElementSrc(a2, c2, t2);
    else {
      if (this.setElementSrc(a2, u2, t2), __classPrivateFieldGet(
        this,
        _PortSipSdk_instances,
        "m",
        _PortSipSdk_compareTrackIsSame
      ).call(
        this,
        null === (o2 = r2.srcObject) || void 0 === o2 ? void 0 : o2.getVideoTracks()[0],
        l2[0]
      ))
        return;
      this.setElementSrc(r2, c2, t2);
    }
  }
  setElementSrc(e2, t2, s2) {
    null === t2 && __classPrivateFieldGet(
      this,
      _PortSipSdk_instances,
      "m",
      _PortSipSdk_remoteMediaElementMarker
    ).call(this, e2.id, s2, false), "srcObject" in e2 ? (e2.srcObject = t2, e2.load(), e2.play().then(() => {
      __classPrivateFieldGet(
        this,
        _PortSipSdk_instances,
        "m",
        _PortSipSdk_remoteMediaElementMarker
      ).call(this, e2.id, s2, true);
    }).catch((t3) => {
      __classPrivateFieldGet(
        this,
        _PortSipSdk_instances,
        "m",
        _PortSipSdk_remoteMediaElementMarker
      ).call(this, e2.id, s2, false), console.warn(`${e2.id} play err: `, t3);
    })) : null === t2 ? e2.removeAttribute("src") : alert("Only browsers with the srcObject attribute are supported");
  }
}
_PortSipSdk_username = /* @__PURE__ */ new WeakMap(), _PortSipSdk_registererOption = /* @__PURE__ */ new WeakMap(), _PortSipSdk_enumerateDevices = /* @__PURE__ */ new WeakMap(), _PortSipSdk_audioSource = /* @__PURE__ */ new WeakMap(), _PortSipSdk_videoSource = /* @__PURE__ */ new WeakMap(), _PortSipSdk_audioOutput = /* @__PURE__ */ new WeakMap(), _PortSipSdk_localScreenVideoTrack = /* @__PURE__ */ new WeakMap(), _PortSipSdk_instances = /* @__PURE__ */ new WeakSet(), _PortSipSdk_getSupportAudioCodecs = function() {
  var e2;
  const t2 = null === (e2 = RTCRtpSender.getCapabilities("audio")) || void 0 === e2 ? void 0 : e2.codecs, s2 = [];
  if (!t2) return s2;
  const i2 = ["red", "telephone-event", "CN"];
  for (const e3 of t2) {
    const t3 = e3.mimeType.split("/")[1];
    i2.includes(t3) || s2.includes(t3) || s2.push(t3);
  }
  return s2;
}, _PortSipSdk_getSupportVideoCodecs = function() {
  var e2;
  const t2 = null === (e2 = RTCRtpSender.getCapabilities("video")) || void 0 === e2 ? void 0 : e2.codecs, s2 = [];
  if (!t2) return s2;
  const i2 = ["red", "rtx", "ulpfec"];
  for (const e3 of t2) {
    const t3 = e3.mimeType.split("/")[1];
    i2.includes(t3) || s2.includes(t3) || s2.push(t3);
  }
  return s2;
}, _PortSipSdk_getPlayingVideotID = function(e2) {
  var t2, s2;
  return void 0 === this.remoteVideoID ? void 0 : "string" == typeof this.remoteVideoID ? this.remoteVideoID : null === (s2 = null === (t2 = this.remoteVideoID) || void 0 === t2 ? void 0 : t2.find((t3) => t3.sessionID === e2)) || void 0 === s2 ? void 0 : s2.id;
}, _PortSipSdk_getPlayingAudiotID = function(e2) {
  var t2, s2;
  return void 0 === this.remoteAudioID ? void 0 : "string" == typeof this.remoteAudioID ? this.remoteAudioID : null === (s2 = null === (t2 = this.remoteAudioID) || void 0 === t2 ? void 0 : t2.find((t3) => t3.sessionID === e2)) || void 0 === s2 ? void 0 : s2.id;
}, _PortSipSdk_compareTrackIsSame = function(e2, t2) {
  return null != e2 && null != t2 && e2.id === t2.id && e2.kind === t2.kind && e2.readyState === t2.readyState;
}, _PortSipSdk_pendingRemoteAudioID_get = function() {
  if ("string" == typeof this.remoteAudioID) return this.remoteAudioID;
  return this.remoteAudioID.find((e2) => false === e2.isPlaying);
}, _PortSipSdk_pendingRemoteVideoID_get = function() {
  var e2;
  if ("string" == typeof this.remoteVideoID) return this.remoteVideoID;
  return null === (e2 = this.remoteVideoID) || void 0 === e2 ? void 0 : e2.find((e3) => false === e3.isPlaying);
}, _PortSipSdk_remoteMediaElementMarker = function(e2, t2, s2) {
  if (Array.isArray(this.remoteAudioID) && Array.isArray(this.remoteVideoID)) {
    let i2;
    if (s2) {
      if (i2 = this.remoteAudioID.concat(this.remoteVideoID).find((e3) => e3.sessionID === t2), !i2)
        return;
      i2.isPlaying = true, i2.sessionID = t2;
    } else {
      if (i2 = this.remoteAudioID.concat(this.remoteVideoID).find((t3) => t3.id === e2), !i2)
        return;
      i2.isPlaying = false, i2.sessionID = 0;
    }
  }
};
class Port_Sip {
  constructor() {
    __publicField(this, "port_sip_sdk");
    __publicField(this, "user_action", false);
    __publicField(this, "data", /* @__PURE__ */ new Map());
    __publicField(this, "main_id", "");
    __publicField(this, "pendingReinvite", /* @__PURE__ */ new Set());
    __publicField(this, "is_disconnect", true);
    __publicField(this, "reconnectionAttempts", 5);
    __publicField(this, "reconnectionDelay", 5);
    __publicField(this, "attemptingReconnection", false);
    __publicField(this, "shouldBeConnected", true);
    __publicField(this, "agent_info");
    __publicField(this, "attemptReconnection", (reconnectionAttempt = 1, agentId) => {
      var _a, _b;
      if (!this.shouldBeConnected) {
        return;
      }
      if (this.attemptingReconnection) {
        return;
      }
      if (reconnectionAttempt > this.reconnectionAttempts) {
        return;
      }
      this.attemptingReconnection = true;
      traceLog(
        "attemptReconnection pre",
        {},
        { isLogServer: true, agentId, tenantId: (_b = (_a = this.agent_info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id }
      );
      setTimeout(
        () => {
          var _a2, _b2;
          if (!this.shouldBeConnected) {
            this.attemptingReconnection = false;
            return;
          }
          (_b2 = (_a2 = this.port_sip_sdk) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b2.reconnect().then(() => {
            var _a3, _b3;
            this.attemptingReconnection = false;
            traceLog(
              "attemptReconnection success",
              {},
              {
                isLogServer: true,
                agentId,
                tenantId: (_b3 = (_a3 = this.agent_info) == null ? void 0 : _a3.tenant) == null ? void 0 : _b3.id
              }
            );
            this.data.forEach((value2) => {
              if (typeof value2 === "string") {
                this.hang_up_server(value2, agentId);
                this.deleteDataKey(value2);
              }
            });
          }).catch((error) => {
            var _a3, _b3;
            traceLog(
              "attemptReconnection error",
              { error },
              {
                isLogServer: true,
                agentId,
                tenantId: (_b3 = (_a3 = this.agent_info) == null ? void 0 : _a3.tenant) == null ? void 0 : _b3.id
              }
            );
            this.attemptingReconnection = false;
            this.attemptReconnection(++reconnectionAttempt, agentId);
          });
        },
        reconnectionAttempt === 1 ? 0 : this.reconnectionDelay * 1e3
      );
    });
  }
  set userAction(v) {
    this.user_action = v;
  }
  clearSessionIds() {
  }
  getDataCallId(key) {
    return Number(this.data.get(key));
  }
  getDataSessionId(key) {
    return String(this.data.get(key));
  }
  deleteDataKey(key) {
    if (typeof key === "string") {
      const callId = this.data.get(key);
      this.data.delete(key);
      if (callId) {
        this.data.delete(callId);
      }
    }
    if (typeof key === "number") {
      const sessionId = this.data.get(key);
      this.data.delete(key);
      if (sessionId) {
        this.data.delete(sessionId);
      }
    }
  }
  clearData() {
    this.data.clear();
  }
  disconnect_sdk() {
    var _a, _b, _c;
    if (this.port_sip_sdk) {
      (_b = (_a = this.port_sip_sdk) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.stop().then(() => {
        var _a2, _b2, _c2, _d;
        traceLog(
          "stop user agent success",
          {},
          {
            isLogServer: true,
            agentId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.user) == null ? void 0 : _b2.id,
            tenantId: (_d = (_c2 = this.agent_info) == null ? void 0 : _c2.tenant) == null ? void 0 : _d.id
          }
        );
      }).catch((error) => {
        var _a2, _b2, _c2, _d;
        traceLog(
          "stop user agent error",
          { error },
          {
            isLogServer: true,
            agentId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.user) == null ? void 0 : _b2.id,
            tenantId: (_d = (_c2 = this.agent_info) == null ? void 0 : _c2.tenant) == null ? void 0 : _d.id
          }
        );
      });
    }
    (_c = this.port_sip_sdk) == null ? void 0 : _c.unRegisterServer();
  }
  pushCallEventEmitter(type, object = {}) {
    client_socket.emit(Event_SDK.CallEvent, {
      type,
      ...object
    });
  }
  searchSessionEstablished(sessionId) {
    var _a, _b, _c;
    let established = false;
    if (sessionId) {
      const id = this.getDataCallId(sessionId);
      if (id) {
        const result = (_c = (_b = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(id)) == null ? void 0 : _b.session) == null ? void 0 : _c.state;
        if (result === SessionState$2.Established) {
          established = true;
        }
      }
      return established;
    }
    this.data.forEach((session2) => {
      var _a2, _b2, _c2, _d, _e, _f;
      if (typeof session2 === "string") {
        const id = this.getDataCallId(session2);
        const result = (_c2 = (_b2 = (_a2 = this.port_sip_sdk) == null ? void 0 : _a2.sessions.get(id)) == null ? void 0 : _b2.session) == null ? void 0 : _c2.state;
        if (result === SessionState$2.Established) {
          established = true;
        }
      } else if (typeof session2 === "number") {
        const result = (_f = (_e = (_d = this.port_sip_sdk) == null ? void 0 : _d.sessions.get(session2)) == null ? void 0 : _e.session) == null ? void 0 : _f.state;
        if (result === SessionState$2.Established) {
          established = true;
        }
      }
    });
    return established;
  }
  async connect_sip({
    server,
    info,
    remoteVideoId,
    localVideoId,
    remoteAudioId,
    cbInviteClosed,
    cbCheckTask
  }) {
    var _a, _b, _c, _d, _e;
    this.agent_info = info;
    const sipExtension = (_a = info == null ? void 0 : info.user) == null ? void 0 : _a.extension;
    const dynamicPassword = (_b = info == null ? void 0 : info.user) == null ? void 0 : _b.sipPassword;
    if (!Array.isArray(remoteAudioId) || (remoteAudioId == null ? void 0 : remoteAudioId.length) < 3) {
      alertSnackbar()({
        title: "Vui lòng tạo tối thiểu 3 thẻ audio",
        status: "error",
        duration: 6e3
      });
      client_socket.emit(Event_SDK.AppEvent, {
        type: AppEventType$1.DISCONNECTED,
        message: AppEventType$1.DISCONNECTED
      });
      traceLog(
        "element_audio",
        {
          server,
          info,
          remoteVideoId,
          localVideoId,
          remoteAudioId
        },
        { isLogClient: false, isLogServer: false }
      );
      return;
    }
    if (localVideoId) {
      const el = document.getElementById(localVideoId);
      if (!el) {
        const createVideo = document.createElement("video");
        createVideo.id = localVideoId;
        createVideo.autoplay = true;
        createVideo.muted = true;
        createVideo.setAttribute("playsinline", "true");
        document.body.appendChild(createVideo);
      }
    } else {
      const defaultLocalId = "local";
      const el = document.getElementById(defaultLocalId);
      if (!el) {
        const createVideo = document.createElement("video");
        createVideo.id = defaultLocalId;
        createVideo.autoplay = true;
        createVideo.muted = true;
        createVideo.setAttribute("playsinline", "true");
        document.body.appendChild(createVideo);
      }
    }
    if (remoteVideoId && remoteVideoId.length > 0) {
      remoteVideoId.forEach((elId) => {
        const el = document.getElementById(elId);
        if (!el) {
          const createVideo = document.createElement("video");
          createVideo.id = elId;
          createVideo.autoplay = true;
          createVideo.muted = true;
          createVideo.setAttribute("playsinline", "true");
          document.body.appendChild(createVideo);
        }
      });
    } else {
      const defaultRemoteVideoId = "video1";
      const el = document.getElementById(defaultRemoteVideoId);
      if (!el) {
        const createVideo = document.createElement("video");
        createVideo.id = defaultRemoteVideoId;
        createVideo.autoplay = true;
        createVideo.muted = true;
        createVideo.setAttribute("playsinline", "true");
        document.body.appendChild(createVideo);
      }
    }
    if (remoteAudioId) {
      remoteAudioId.forEach((elId) => {
        const el = document.getElementById(elId);
        if (!el) {
          const createAudio = document.createElement("audio");
          createAudio.id = elId;
          document.body.appendChild(createAudio);
        }
      });
    }
    const sdk = new PortSipSdk(
      {
        onRegisterSuccess: () => {
          setTimeout(() => {
            var _a2, _b2, _c2, _d2, _e2;
            client_socket.emit(Event_SDK.AppEvent, {
              type: AppEventType$1.CONNECTED,
              message: AppEventType$1.CONNECTED
            });
            traceLog(
              "onRegisterSuccess",
              {
                type: AppEventType$1.CONNECTED,
                message: AppEventType$1.CONNECTED,
                event: Event_SDK.AppEvent
              },
              {
                tenantId: (_a2 = info == null ? void 0 : info.tenant) == null ? void 0 : _a2.id,
                agentId: (_b2 = info == null ? void 0 : info.user) == null ? void 0 : _b2.id,
                isLogServer: true,
                isLogClient: false
              }
            );
            getCurrentAgentStatus({
              cloudAgentId: (_c2 = info == null ? void 0 : info.user) == null ? void 0 : _c2.id,
              cloudTenantId: (_d2 = info == null ? void 0 : info.tenant) == null ? void 0 : _d2.id,
              cloudAgentName: (_e2 = info == null ? void 0 : info.user) == null ? void 0 : _e2.fullName
            }).then((res) => {
              var _a3, _b3, _c3, _d3, _e3, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
              if ((_a3 = res.data) == null ? void 0 : _a3.success) {
                client_socket.emit(Event_SDK.AgentStatusEvent, {
                  agentId: (_c3 = (_b3 = res.data) == null ? void 0 : _b3.data) == null ? void 0 : _c3.cloudAgentId,
                  tenantId: (_e3 = (_d3 = res.data) == null ? void 0 : _d3.data) == null ? void 0 : _e3.cloudTenantId,
                  agentName: (_g = (_f = res.data) == null ? void 0 : _f.data) == null ? void 0 : _g.cloudAgentName,
                  statusName: (_i = (_h = res.data) == null ? void 0 : _h.data) == null ? void 0 : _i.statusName,
                  changeTime: (_k = (_j = res.data) == null ? void 0 : _j.data) == null ? void 0 : _k.changeTime,
                  reasonCode: (_m = (_l = res.data) == null ? void 0 : _l.data) == null ? void 0 : _m.reasonCode,
                  reasonCodeId: (_o = (_n = res.data) == null ? void 0 : _n.data) == null ? void 0 : _o.reasonCodeId,
                  reasonName: (_q = (_p = res.data) == null ? void 0 : _p.data) == null ? void 0 : _q.reasonName
                });
              }
            });
            this.attemptingReconnection = false;
            this.shouldBeConnected = true;
          }, 2e3);
          this.is_disconnect = false;
        },
        onRegisterFailure: (reason) => {
          var _a2, _b2;
          client_socket.emit(Event_SDK.AppEvent, {
            type: AppEventType$1.DISCONNECTED,
            message: AppEventType$1.DISCONNECTED
          });
          traceLog(
            "onRegisterFailure",
            {
              type: "onRegisterFailure",
              message: "onRegisterFailure",
              reason
            },
            {
              tenantId: (_a2 = info == null ? void 0 : info.tenant) == null ? void 0 : _a2.id,
              agentId: (_b2 = info == null ? void 0 : info.user) == null ? void 0 : _b2.id,
              isLogServer: true,
              isLogClient: false
            }
          );
        },
        onConnect: () => {
        },
        onDisconnect: (reason) => {
          var _a2, _b2, _c2;
          if (!window.navigator.onLine) {
            client_socket.emit(Event_SDK.AppEvent, {
              type: AppEventType$1.NETWORK_ERROR,
              message: AppEventType$1.NETWORK_ERROR
            });
          } else {
            client_socket.emit(Event_SDK.AppEvent, {
              type: AppEventType$1.DISCONNECTED,
              message: reason
            });
            traceLog(
              "onDisconnect",
              {
                type: AppEventType$1.DISCONNECTED,
                message: AppEventType$1.DISCONNECTED,
                reason
              },
              {
                tenantId: (_a2 = info == null ? void 0 : info.tenant) == null ? void 0 : _a2.id,
                agentId: (_b2 = info == null ? void 0 : info.user) == null ? void 0 : _b2.id,
                isLogServer: true,
                isLogClient: false
              }
            );
          }
          this.main_id = "";
          SIP_SDK.sessionIds = [];
          this.attemptReconnection(1, (_c2 = info == null ? void 0 : info.user) == null ? void 0 : _c2.id);
        },
        onReconnectFailure: () => {
        },
        onInviteStart: (id, ext, existsVideo) => {
          console.log("onInviteStart", id, ext, existsVideo);
        },
        onInviteIncoming: (id, ext, displayname, isMeeting, existsAudio, existsVideo, autoAnswer) => {
          var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j;
          const result = (_a2 = this.port_sip_sdk) == null ? void 0 : _a2.sessions.get(id);
          console.log("ext", ext);
          if (result) {
            const sessionId = (_c2 = (_b2 = result.session) == null ? void 0 : _b2.request) == null ? void 0 : _c2.getHeader(
              "X-Session-Id"
            );
            const auto_call = (_e2 = (_d2 = result.session) == null ? void 0 : _d2.request) == null ? void 0 : _e2.getHeader(
              "Answer-Mode"
            );
            client_socket.emit(Event_SDK.CallEvent, {
              type: CallEventType.CALL_CONNECTED,
              name: CallEventType.CALL_CONNECTED,
              applicationId: "",
              senderId: "",
              sessionId
            });
            traceLog(
              CallEventType.CALL_CONNECTED,
              {
                sessionId,
                data_session: this.getDataStringify(),
                autoAnswer: auto_call,
                user_action: this.user_action,
                type: CallEventType.CALL_CONNECTED,
                name: CallEventType.CALL_CONNECTED
              },
              {
                isLogClient: false,
                isLogServer: true,
                sessionId,
                tenantId: (_g = (_f = this.agent_info) == null ? void 0 : _f.tenant) == null ? void 0 : _g.id,
                agentId: (_i = (_h = this.agent_info) == null ? void 0 : _h.user) == null ? void 0 : _i.id
              }
            );
            if (!this.main_id) {
              this.main_id = sessionId;
            }
            this.data.set(sessionId, id);
            this.data.set(id, sessionId);
            if (!SIP_SDK.sessionIds.includes(sessionId)) {
              SIP_SDK.sessionIds.push(sessionId);
            }
            if (auto_call === "Auto;require" && this.user_action) {
              this.userAction = false;
              (_j = this.port_sip_sdk) == null ? void 0 : _j.answerCall(id, existsVideo).then(() => {
                var _a3, _b3;
                traceLog(
                  "auto answer call",
                  { sessionId, data_session: this.getDataStringify() },
                  {
                    isLogClient: false,
                    isLogServer: true,
                    sessionId,
                    tenantId: (_a3 = info == null ? void 0 : info.tenant) == null ? void 0 : _a3.id,
                    agentId: (_b3 = info == null ? void 0 : info.user) == null ? void 0 : _b3.id
                  }
                );
                if (this.main_id === sessionId) {
                  cbCheckTask && cbCheckTask(sessionId, "TALKING");
                }
              }).catch((error) => {
                var _a3, _b3;
                traceLog(
                  "auto answer call error",
                  { sessionId, error },
                  {
                    isLogClient: false,
                    isLogServer: true,
                    sessionId,
                    tenantId: (_a3 = info == null ? void 0 : info.tenant) == null ? void 0 : _a3.id,
                    agentId: (_b3 = info == null ? void 0 : info.user) == null ? void 0 : _b3.id
                  }
                );
              });
            }
          }
        },
        onInviteTrying: (id, existsVideo) => {
          console.log("onInviteTrying", id);
        },
        onInviteSessionProgress: (id) => {
          console.log("onInviteSessionProgress", id);
        },
        onInviteRinging: (id) => {
          console.log("onInviteRinging", id);
        },
        onInviteAnswered: (id, isMeeting, withVideo, meetingWithPin) => {
          console.log("onInviteAnswered", id);
        },
        onInviteFailure: (id, reason) => {
          var _a2, _b2;
          const sessionId = this.getDataSessionId(id);
          traceLog(
            `inviteFailure-${sessionId}`,
            { id, reason, data: this.getDataStringify() },
            {
              isLogServer: true,
              isLogClient: true,
              tenantId: (_a2 = info == null ? void 0 : info.tenant) == null ? void 0 : _a2.id,
              agentId: (_b2 = info == null ? void 0 : info.user) == null ? void 0 : _b2.id,
              sessionId
            }
          );
          if (sessionId === this.main_id) {
            cbCheckTask && cbCheckTask(sessionId, "IDLE");
            this.main_id = "";
          }
          this.deleteDataKey(id);
        },
        onRecvOutOfDialogMessage: (from, message2, contentType) => {
        },
        onRecvNotifyOfSubscription: (id, message2) => {
        },
        onInviteConnected: (id, hasVideo) => {
          console.log("onInviteConnected", id, hasVideo);
        },
        onRecvInfo: (ext, message2) => {
        },
        onInviteClosed: async (id) => {
          var _a2, _b2, _c2, _d2, _e2;
          const sessionId = this.getDataSessionId(id);
          traceLog(
            `inviteClosed-${sessionId}`,
            {
              id,
              state: (_c2 = (_b2 = (_a2 = this.port_sip_sdk) == null ? void 0 : _a2.sessions.get(id)) == null ? void 0 : _b2.session) == null ? void 0 : _c2.state,
              sessionId,
              mainId: this.main_id,
              data: this.getDataStringify()
            },
            {
              isLogServer: true,
              isLogClient: false,
              tenantId: (_d2 = info == null ? void 0 : info.tenant) == null ? void 0 : _d2.id,
              agentId: (_e2 = info == null ? void 0 : info.user) == null ? void 0 : _e2.id,
              sessionId
            }
          );
          if (sessionId === this.main_id) {
            cbCheckTask && cbCheckTask(sessionId, "IDLE");
            cbInviteClosed && cbInviteClosed(() => {
              this.pushCallEventEmitter(CallEventType.CALL_HANGUP, {
                sessionId,
                hangupBy: this.is_disconnect ? MessengerForm.AGENT : MessengerForm.CUSTOMER,
                statusCode: "0"
              });
            });
            this.main_id = "";
          }
          this.deleteDataKey(id);
        },
        onInviteUpdated: (id, existsAudio, existsVideo, existsScreen) => {
          var _a2, _b2;
          console.log(
            "onInviteUpdated",
            id,
            existsAudio,
            existsVideo,
            existsScreen
          );
          traceLog(
            "onInviteUpdate",
            {
              id,
              existsAudio,
              existsVideo,
              existsScreen
            },
            {
              isLogClient: false,
              isLogServer: true,
              agentId: (_a2 = info == null ? void 0 : info.user) == null ? void 0 : _a2.id,
              tenantId: (_b2 = info == null ? void 0 : info.tenant) == null ? void 0 : _b2.id
            }
          );
          if (existsVideo) {
            this.getDataSessionId(id);
          }
        },
        onRemoteHold: (id) => {
          var _a2, _b2;
          traceLog(
            "onRemoteHold",
            { id, data: this.getDataStringify() },
            {
              isLogServer: true,
              isLogClient: true,
              tenantId: (_a2 = info == null ? void 0 : info.tenant) == null ? void 0 : _a2.id,
              agentId: (_b2 = info == null ? void 0 : info.user) == null ? void 0 : _b2.id
            }
          );
        },
        onRemoteUnHold: (id) => {
          var _a2, _b2;
          traceLog(
            "onRemoteUnHold",
            { id, data: this.getDataStringify() },
            { tenantId: (_a2 = info == null ? void 0 : info.tenant) == null ? void 0 : _a2.id, agentId: (_b2 = info == null ? void 0 : info.user) == null ? void 0 : _b2.id }
          );
        },
        onTransferTrying: (id) => {
        },
        onTransferRinging: (id) => {
        },
        onACTVTransferSuccess: (id) => {
        },
        onRecvOutOfDialogNotify: () => {
        },
        onACTVTransferFailure: (id) => {
        },
        onRecvDtmfTone: (id, tone) => {
        },
        onRecvMessage: (id, message2, contentType) => {
          console.log("onRecvMessage", message2, contentType);
        },
        onShareAccept: (from, to) => {
        },
        onShareStopAccept: (from, to) => {
        },
        onShareStop: () => {
        },
        onRecieveShare: (id, to) => {
        },
        onRecieveStopShare: (id, to) => {
        },
        onVoiceMailReceived: (count) => {
        },
        onSendOutOfDialogMessageSuccess: (ext, { msgServerID, msgRawString, rawStringIsJSON }) => {
          console.log("onSendOutOfDialogMessageSuccess", ext, {
            msgServerID,
            msgRawString,
            rawStringIsJSON
          });
        },
        onAudioDeviceChanged: (deviceName, newState) => {
          console.log("onAudioDeviceChanged", deviceName, newState);
        }
      },
      {
        localVideoID: localVideoId || "local",
        remoteScreenID: "mpt-body",
        remoteAudioID: remoteAudioId ?? [],
        remoteVideoID: remoteVideoId ?? []
      }
    );
    try {
      await sdk.createUserAgent(
        sipExtension ?? "",
        dynamicPassword ?? "",
        ((_c = info == null ? void 0 : info.tenant) == null ? void 0 : _c.domainContext) ?? "",
        server,
        void 0,
        void 0,
        void 0,
        void 0,
        50
      );
      this.port_sip_sdk = sdk;
      window.addEventListener("beforeunload", () => {
        var _a2, _b2;
        if (this.port_sip_sdk) {
          traceLog(
            "beforeunload",
            {
              server,
              info,
              remoteVideoId,
              localVideoId,
              remoteAudioId
            },
            {
              isLogClient: false,
              isLogServer: true,
              agentId: (_a2 = info == null ? void 0 : info.user) == null ? void 0 : _a2.id,
              tenantId: (_b2 = info == null ? void 0 : info.tenant) == null ? void 0 : _b2.id,
              sendBeacon: true
            }
          );
          sdk.unRegisterServer();
        }
      });
      window.addEventListener("pagehide", () => {
        var _a2, _b2;
        if (this.port_sip_sdk) {
          traceLog(
            "pagehide",
            {
              server,
              info,
              remoteVideoId,
              localVideoId,
              remoteAudioId
            },
            {
              isLogClient: false,
              isLogServer: true,
              agentId: (_a2 = info == null ? void 0 : info.user) == null ? void 0 : _a2.id,
              tenantId: (_b2 = info == null ? void 0 : info.tenant) == null ? void 0 : _b2.id,
              sendBeacon: true
            }
          );
        }
        sdk.unRegisterServer();
      });
      window.addEventListener("unload", () => {
        var _a2, _b2;
        if (this.port_sip_sdk) {
          traceLog(
            "unload_agent_user_sip",
            {
              server,
              info,
              remoteVideoId,
              localVideoId,
              remoteAudioId
            },
            {
              isLogClient: false,
              isLogServer: true,
              agentId: (_a2 = info == null ? void 0 : info.user) == null ? void 0 : _a2.id,
              tenantId: (_b2 = info == null ? void 0 : info.tenant) == null ? void 0 : _b2.id,
              sendBeacon: true
            }
          );
          sdk.unRegisterServer();
        }
      });
    } catch (error) {
      if (!window.navigator.onLine) {
        client_socket.emit(Event_SDK.AppEvent, {
          type: AppEventType$1.NETWORK_ERROR,
          message: AppEventType$1.NETWORK_ERROR
        });
      } else {
        client_socket.emit(Event_SDK.AppEvent, {
          type: AppEventType$1.DISCONNECTED,
          message: AppEventType$1.DISCONNECTED
        });
      }
      traceLog(
        "not_create_agent_user_sip_error",
        {
          server,
          info,
          remoteVideoId,
          localVideoId,
          remoteAudioId,
          error
        },
        {
          isLogClient: true,
          isLogServer: true,
          agentId: (_d = info == null ? void 0 : info.user) == null ? void 0 : _d.id,
          tenantId: (_e = info == null ? void 0 : info.tenant) == null ? void 0 : _e.id
        }
      );
    }
  }
  async answer(session2, cbCheckTask, cbFails, isVideo = false, isQueue = false) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    this.userAction = false;
    const _callId = this.getDataCallId(session2);
    traceLog(
      "answer sip function",
      {
        sessionId: session2,
        data: this.getDataStringify()
      },
      {
        isLogClient: false,
        isLogServer: true,
        tenantId: (_b = (_a = this.agent_info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.agent_info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
        sessionId: session2
      }
    );
    if (_callId) {
      try {
        await this.port_sip_sdk.answerCall(_callId, true);
        cbCheckTask && cbCheckTask(session2, "TALKING", _callId);
      } catch (error) {
        const s2 = (_f = (_e = this.port_sip_sdk.sessions.get(_callId)) == null ? void 0 : _e.session) == null ? void 0 : _f.state;
        const text = s2 === SessionState$2.Established ? "Vui lòng không nhấc máy nhiều lần!" : "Cuộc gọi đã kết thúc, không tồn tại hoặc đã vào IVR nhỡ.";
        alertSnackbar()({
          status: "error",
          duration: 3e3,
          title: text
        });
        if (s2 !== SessionState$2.Established) {
          cbFails && cbFails();
        }
        traceLog(
          "answer sip function error",
          {
            sessionId: session2,
            error
          },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_h = (_g = this.agent_info) == null ? void 0 : _g.tenant) == null ? void 0 : _h.id,
            agentId: (_j = (_i = this.agent_info) == null ? void 0 : _i.user) == null ? void 0 : _j.id,
            sessionId: session2
          }
        );
      }
    } else {
      alertSnackbar()({
        status: "error",
        duration: 3e3,
        title: "Cuộc gọi đã kết thúc, không tồn tại hoặc đã vào IVR nhỡ."
      });
      cbFails && cbFails();
    }
  }
  async rejectCall(session2) {
    var _a, _b, _c, _d, _e;
    const _callId = this.getDataCallId(session2);
    traceLog(
      "reject call function",
      {
        sessionId: session2
      },
      {
        isLogClient: false,
        isLogServer: true,
        tenantId: (_b = (_a = this.agent_info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.agent_info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
        sessionId: session2
      }
    );
    if (_callId) {
      try {
        (_e = this.port_sip_sdk) == null ? void 0 : _e.hangUp(_callId).then(() => {
          if (this.main_id === session2) {
            this.main_id = "";
          }
          this.deleteDataKey(session2);
        }).catch((e2) => {
          var _a2, _b2, _c2, _d2;
          traceLog(
            "reject_error",
            {
              sessionId: session2,
              error: e2
            },
            {
              isLogClient: false,
              isLogServer: true,
              tenantId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
              agentId: (_d2 = (_c2 = this.agent_info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id,
              sessionId: session2
            }
          );
        });
      } catch (error) {
      }
    }
  }
  async hang_up(session2, agentId, cbCheckTab) {
    var _a, _b, _c, _d, _e;
    const _callId = this.getDataCallId(session2);
    try {
      await ((_a = this.port_sip_sdk) == null ? void 0 : _a.hangUp(_callId));
      if (this.main_id === session2) {
        this.main_id = "";
      }
      this.deleteDataKey(session2);
      cbCheckTab && cbCheckTab(session2, "IDLE");
      postEndCall({ sessionId: session2, agentId }).then(() => {
      }).catch(() => {
      });
    } catch (error) {
      postEndCall({ sessionId: session2, agentId }).then(() => {
        cbCheckTab && cbCheckTab(session2, "IDLE");
      }).catch(() => {
      });
      traceLog(
        "hang_up_error",
        {
          sessionId: session2,
          error
        },
        {
          isLogClient: false,
          isLogServer: true,
          tenantId: (_c = (_b = this.agent_info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
          agentId: (_e = (_d = this.agent_info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
          sessionId: session2
        }
      );
    }
  }
  async hang_up_server(session2, agentId) {
    var _a, _b, _c, _d;
    try {
      await postEndCall({ sessionId: session2, agentId });
      if (this.main_id === session2) {
        this.main_id = "";
      }
      this.deleteDataKey(session2);
    } catch (error) {
      traceLog(
        "hang_up_error_hang_up_server",
        {
          sessionId: session2,
          error
        },
        {
          isLogClient: false,
          isLogServer: true,
          tenantId: (_b = (_a = this.agent_info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
          agentId: (_d = (_c = this.agent_info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
          sessionId: session2
        }
      );
    }
  }
  async hold_call_client(session2, agentId) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const _callId = this.getDataCallId(session2);
    if (_callId) {
      traceLog(
        "hold_call_client",
        { id: _callId },
        {
          isLogClient: false,
          isLogServer: true,
          tenantId: (_b = (_a = this.agent_info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
          agentId: (_d = (_c = this.agent_info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
          sessionId: session2
        }
      );
      try {
        await ((_e = this.port_sip_sdk) == null ? void 0 : _e.hold(_callId));
        this.pushCallEventEmitter(CallEventType.CALL_HOLD, {
          sessionId: session2,
          hangupBy: null
          // applicationId: body?.applicationId,
          // senderId: body?.senderId,
        });
        postHoldCall({
          sessionId: session2,
          agentId,
          timestamp: Date.now(),
          remoteHold: false
        }).then((res) => {
          var _a2, _b2, _c2, _d2;
          traceLog("postHoldCall_res", res, {
            isLogClient: true,
            isLogServer: false,
            tenantId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
            agentId: (_d2 = (_c2 = this.agent_info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id,
            sessionId: session2
          });
        }).catch((error) => {
          var _a2, _b2, _c2, _d2;
          traceLog(
            "error_postHoldCall",
            { error },
            {
              isLogClient: true,
              isLogServer: false,
              tenantId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
              agentId: (_d2 = (_c2 = this.agent_info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id,
              sessionId: session2
            }
          );
        });
      } catch (error) {
        traceLog(
          "hold_call_client _ error",
          { error },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_g = (_f = this.agent_info) == null ? void 0 : _f.tenant) == null ? void 0 : _g.id,
            agentId: (_i = (_h = this.agent_info) == null ? void 0 : _h.user) == null ? void 0 : _i.id,
            sessionId: session2
          }
        );
      }
    }
  }
  async un_hold_call_client(session2, agentId) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const _callId = this.getDataCallId(session2);
    if (_callId) {
      try {
        await ((_a = this.port_sip_sdk) == null ? void 0 : _a.unhold(_callId));
        this.pushCallEventEmitter(CallEventType.CALL_UNHOLD, {
          sessionId: session2,
          hangupBy: null
          // applicationId: body?.applicationId,
          // senderId: body?.senderId,
        });
        postUnHoldCall({
          sessionId: session2,
          agentId,
          timestamp: Date.now(),
          remoteHold: false
        }).then((res) => {
          var _a2, _b2, _c2, _d2;
          traceLog("postUnHoldCall_res", res, {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
            agentId: (_d2 = (_c2 = this.agent_info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id,
            sessionId: session2
          });
        }).catch((error) => {
          var _a2, _b2, _c2, _d2;
          traceLog(
            "error_postUnHoldCall",
            { error },
            {
              isLogClient: false,
              isLogServer: true,
              tenantId: (_b2 = (_a2 = this.agent_info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
              agentId: (_d2 = (_c2 = this.agent_info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id,
              sessionId: session2
            }
          );
        });
        traceLog("un_hold_call_client success", {
          isLogClient: false,
          isLogServer: true,
          tenantId: (_c = (_b = this.agent_info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
          agentId: (_e = (_d = this.agent_info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
          sessionId: session2
        });
      } catch (error) {
        traceLog(
          "un_hold_call_client error",
          { error },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_g = (_f = this.agent_info) == null ? void 0 : _f.tenant) == null ? void 0 : _g.id,
            agentId: (_i = (_h = this.agent_info) == null ? void 0 : _h.user) == null ? void 0 : _i.id,
            sessionId: session2
          }
        );
      }
    }
  }
  async hold_call(session2, agentId) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const _callId = this.getDataCallId(session2);
    if (_callId) {
      traceLog("hold_call server", _callId, {
        isLogClient: false,
        isLogServer: true,
        tenantId: (_b = (_a = this.agent_info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.agent_info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
        sessionId: session2
      });
      try {
        const response = await postHoldCall({
          sessionId: session2,
          agentId,
          timestamp: Date.now(),
          remoteHold: true
        });
        if ((_e = response == null ? void 0 : response.data) == null ? void 0 : _e.success) {
          this.pushCallEventEmitter(CallEventType.CALL_HOLD, {
            sessionId: session2,
            hangupBy: null
            // applicationId: body?.applicationId,
            // senderId: body?.senderId,
          });
        }
      } catch (error) {
        traceLog(
          "error",
          { error },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_g = (_f = this.agent_info) == null ? void 0 : _f.tenant) == null ? void 0 : _g.id,
            agentId: (_i = (_h = this.agent_info) == null ? void 0 : _h.user) == null ? void 0 : _i.id,
            sessionId: session2
          }
        );
      }
    }
  }
  async unHold_call(session2, agentId) {
    var _a, _b, _c, _d, _e;
    const _callId = this.getDataCallId(session2);
    if (_callId) {
      try {
        const response = await postUnHoldCall({
          sessionId: session2,
          agentId,
          timestamp: Date.now(),
          remoteHold: true
        });
        if ((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.success) {
          this.pushCallEventEmitter(CallEventType.CALL_UNHOLD, {
            sessionId: session2,
            hangupBy: null
            // applicationId: body?.applicationId,
            // senderId: body?.senderId,
          });
        }
      } catch (error) {
        traceLog(
          "error unHold_call",
          { error },
          {
            isLogClient: true,
            isLogServer: false,
            tenantId: (_c = (_b = this.agent_info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
            agentId: (_e = (_d = this.agent_info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
            sessionId: session2
          }
        );
      }
    }
  }
  async mute_call(session2, enableMute) {
    var _a, _b, _c, _d, _e;
    const _callId = this.getDataCallId(session2);
    if (_callId) {
      try {
        await ((_a = this.port_sip_sdk) == null ? void 0 : _a.mute(_callId, enableMute));
        this.pushCallEventEmitter(
          enableMute ? CallEventType.CALL_MUTE : CallEventType.CALL_UNMUTE,
          {
            sessionId: session2,
            hangupBy: null
          }
        );
      } catch (error) {
        traceLog(
          "error mute_call",
          { error },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_c = (_b = this.agent_info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
            agentId: (_e = (_d = this.agent_info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
            sessionId: session2
          }
        );
      }
    }
  }
  async sendCamera(session2, enableMute) {
    var _a, _b;
    const _callId = this.getDataCallId(session2);
    if (_callId) {
      try {
        if (enableMute) {
          const s2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(_callId);
          if (s2) s2.constraints.video = true;
        }
        await ((_b = this.port_sip_sdk) == null ? void 0 : _b.sendVideo(_callId, enableMute));
      } catch (error) {
        console.log("error sendCamera", error);
      }
    }
  }
  async update(session2, enableVideo) {
    var _a, _b, _c, _d, _e, _f;
    const _callId = this.getDataCallId(session2) ?? 0;
    console.log("updateCall", session2, _callId);
    if (!_callId) return;
    if (this.pendingReinvite.has(_callId)) {
      console.log("updateCall skipped due to pending re-INVITE", _callId);
      return;
    }
    ((_b = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(_callId)) == null ? void 0 : _b.ext) ?? ((_d = (_c = this.agent_info) == null ? void 0 : _c.user) == null ? void 0 : _d.extension) ?? "";
    try {
      const s2 = (_e = this.port_sip_sdk) == null ? void 0 : _e.sessions.get(_callId);
      if (s2) {
        s2.constraints.video = true;
      }
      await ((_f = this.port_sip_sdk) == null ? void 0 : _f.updateCall(_callId, true, true));
    } catch (error) {
      console.log("error updateCall", error);
      this.pendingReinvite.delete(_callId);
    }
  }
  getLastEntry(map) {
    let last;
    for (const entry of map) {
      last = entry;
    }
    return last;
  }
  getSessionMain() {
    const value2 = this.getLastEntry(this.data);
    const _id = value2 == null ? void 0 : value2[0];
    if (typeof _id === "string") {
      return _id ?? "";
    } else if (typeof _id === "number") {
      return this.getDataSessionId(_id) ?? "";
    }
    return this.main_id;
  }
  sip_Accept_Transfer(body, cb) {
    traceLog(
      "sip_Accept_Transfer",
      {},
      {
        isLogClient: false,
        isLogServer: true,
        tenantId: body == null ? void 0 : body.agentId,
        agentId: body == null ? void 0 : body.agentId,
        sessionId: this.main_id
      }
    );
    if (this.main_id) {
      postAcceptTransfer({ ...body, sessionId: this.main_id }).then((response) => {
        var _a, _b, _c;
        if ((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.success) {
          traceLog(
            "sip_Accept_Transfer success",
            {},
            {
              isLogClient: false,
              isLogServer: true,
              tenantId: body == null ? void 0 : body.tenantId,
              agentId: body == null ? void 0 : body.agentId,
              sessionId: this.main_id
            }
          );
          const id = this.getDataCallId(this.main_id);
          const value2 = this.getLastEntry(this.data);
          const _id = value2 == null ? void 0 : value2[0];
          if (typeof _id === "string") {
            const sessionId = this.getDataCallId(_id);
            (_b = this.port_sip_sdk) == null ? void 0 : _b.attendedRefer(sessionId, id).then((value22) => {
            }).catch((e2) => {
              traceLog(
                "attendedRefer error",
                { error: e2 },
                {
                  isLogClient: false,
                  isLogServer: true,
                  tenantId: body == null ? void 0 : body.tenantId,
                  agentId: body == null ? void 0 : body.agentId
                }
              );
            });
          } else if (typeof _id === "number") {
            (_c = this.port_sip_sdk) == null ? void 0 : _c.attendedRefer(_id, id).then((value22) => {
            }).catch((e2) => {
              traceLog(
                "attendedRefer error",
                { error: e2 },
                {
                  isLogClient: false,
                  isLogServer: true,
                  tenantId: body == null ? void 0 : body.tenantId,
                  agentId: body == null ? void 0 : body.agentId
                }
              );
            });
          }
          cb && cb({
            sessionId: this.main_id,
            applicationId: body == null ? void 0 : body.applicationId,
            senderId: body == null ? void 0 : body.senderId
          });
          this.main_id = "";
          SIP_SDK.sessionIds = [];
        }
      }).catch((err) => {
        alertSnackbar()({
          title: "Không thể chuyển cho agent",
          status: "error"
        });
        traceLog("sip_Accept_Transfer_error", err, {
          isLogClient: false,
          isLogServer: true,
          tenantId: body == null ? void 0 : body.tenantId,
          agentId: body == null ? void 0 : body.agentId
        });
      });
    }
  }
  sip_refuse_transfer(body, cb) {
    traceLog(
      "refuse_transfer_main_id",
      { id: this.main_id, body },
      {
        isLogClient: false,
        isLogServer: true,
        tenantId: body == null ? void 0 : body.agentId,
        agentId: body == null ? void 0 : body.agentId,
        sessionId: this.main_id
      }
    );
    if (this.main_id) {
      postRefuseTransfer({ ...body, sessionId: this.main_id }).then((response) => {
        var _a;
        if ((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.success) {
          cb && cb(this.main_id);
          this.loopDeleteData();
          client_socket.emit(Event_SDK.CallEvent, {
            type: CallEventType.CALL_REFUSE_TRANSFER,
            name: CallEventType.CALL_REFUSE_TRANSFER,
            senderId: body == null ? void 0 : body.senderId,
            applicationId: body == null ? void 0 : body.applicationId,
            sessionId: this.main_id
          });
          traceLog(
            "refuse_transfer_main_id_success",
            {
              type: CallEventType.CALL_REFUSE_TRANSFER,
              name: CallEventType.CALL_REFUSE_TRANSFER,
              senderId: body == null ? void 0 : body.senderId,
              applicationId: body == null ? void 0 : body.applicationId,
              sessionId: this.main_id
            },
            {
              tenantId: body == null ? void 0 : body.agentId,
              agentId: body == null ? void 0 : body.agentId,
              isLogClient: false,
              isLogServer: true,
              sessionId: this.main_id
            }
          );
        } else {
          this.loopDeleteData();
        }
      }).catch(() => {
        traceLog(
          "refuse_transfer_main_id_error",
          {},
          {
            tenantId: body == null ? void 0 : body.agentId,
            agentId: body == null ? void 0 : body.agentId,
            isLogClient: false,
            isLogServer: true,
            sessionId: this.main_id
          }
        );
        alertSnackbar()({
          title: "Không thể quay lại cuộc gọi với khách hàng hoặc khách hàng đã tắt máy",
          status: "error"
        });
        this.loopDeleteData();
      });
    } else {
      this.loopDeleteData();
      traceLog(
        "refuse_transfer_main_id_not_found",
        {},
        {
          tenantId: body == null ? void 0 : body.agentId,
          agentId: body == null ? void 0 : body.agentId,
          isLogClient: false,
          isLogServer: true
        }
      );
    }
  }
  loopDeleteData() {
    this.data.forEach((value2) => {
      var _a, _b;
      if (typeof value2 === "number") {
        const session2 = (_a = this.port_sip_sdk.sessions) == null ? void 0 : _a.get(value2);
        const sessionId = this.getDataSessionId(value2);
        if (sessionId !== this.main_id && ((_b = session2 == null ? void 0 : session2.session) == null ? void 0 : _b.state) !== SessionState$2.Terminated) {
          this.hang_up(sessionId);
          this.deleteDataKey(sessionId);
        }
      }
    });
  }
  getDataStringify() {
    let data = {};
    this.data.forEach((value2, key) => {
      if (typeof value2 === "string") {
        const id = this.getDataCallId(value2);
        data[value2] = id;
      } else if (typeof value2 === "number") {
        const sessionId = this.getDataSessionId(value2);
        if (sessionId) {
          data[value2] = sessionId;
        }
      }
    });
    return JSON.stringify(data);
  }
  async switchVideoCall(sessionId, ext) {
    var _a, _b;
    const callId = this.getDataCallId(sessionId);
    try {
      const s2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(callId);
      if (s2) {
        s2.constraints.video = true;
      }
      await ((_b = this.port_sip_sdk) == null ? void 0 : _b.updateCall(callId, true, true));
    } catch (error) {
      console.log("error updateCall", error);
    }
  }
  async blurBackground(sessionId, enable = false, localVideoId) {
    var _a, _b, _c;
    const callId = this.getDataCallId(sessionId);
    const canvas = document.getElementById("outputCanvas");
    const localVideo = document.getElementById(
      localVideoId ?? ""
    );
    const processedStream = canvas.captureStream(60);
    try {
      const session2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(callId);
      if (!session2) throw new Error("session does not exti");
      const pc = (_c = (_b = session2.session) == null ? void 0 : _b.sessionDescriptionHandler) == null ? void 0 : _c.peerConnection;
      const newTrack = processedStream.getVideoTracks()[0];
      session2.constraints.video = true;
      const sender = pc.getSenders().find((sender2) => {
        var _a2;
        return ((_a2 = sender2.track) == null ? void 0 : _a2.kind) === "video";
      });
      if (sender) {
        if (enable && newTrack) {
          await sender.replaceTrack(newTrack);
        } else {
          const remoteLocalStream = localVideo.srcObject;
          const originalTrack = remoteLocalStream.getVideoTracks()[0];
          await (sender == null ? void 0 : sender.replaceTrack(originalTrack));
        }
        console.log("✅ Replaced video track with blurred stream");
      }
    } catch (error) {
      console.log("error blurBackground", error);
    }
  }
  async replaceTrack(sessionId, localVideoId, enable = false) {
    var _a, _b, _c;
    const callId = this.getDataCallId(sessionId);
    document.getElementById("outputCanvas");
    const localVideo = document.getElementById(
      localVideoId ?? ""
    );
    const processedStream = localVideo.srcObject;
    try {
      const session2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(callId);
      if (!session2) throw new Error("session does not exti");
      const pc = (_c = (_b = session2.session) == null ? void 0 : _b.sessionDescriptionHandler) == null ? void 0 : _c.peerConnection;
      const newTrack = processedStream.getVideoTracks()[0];
      session2.constraints.video = true;
      const sender = pc.getSenders().find((sender2) => {
        var _a2;
        return ((_a2 = sender2.track) == null ? void 0 : _a2.kind) === "video";
      });
      if (sender) {
        if (enable && newTrack) {
          await sender.replaceTrack(newTrack);
        } else {
          const remoteLocalStream = localVideo.srcObject;
          const originalTrack = remoteLocalStream.getVideoTracks()[0];
          await (sender == null ? void 0 : sender.replaceTrack(originalTrack));
        }
        console.log("✅ Replaced video track with blurred stream");
      }
    } catch (error) {
      console.log("error blurBackground", error);
    }
  }
  async enableVideo(sessionId, enable, localVideoId) {
    var _a, _b, _c;
    const callId = this.getDataCallId(sessionId);
    const localVideo = document.getElementById(
      localVideoId ?? ""
    );
    const session2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(callId);
    if (!session2) throw new Error("session does not exti");
    const pc = (_c = (_b = session2.session) == null ? void 0 : _b.sessionDescriptionHandler) == null ? void 0 : _c.peerConnection;
    try {
      if (enable) {
        session2.constraints.video = true;
        localVideo.play();
        this.replaceTrack(sessionId, localVideoId, true);
      } else {
        localVideo.pause();
        pc.getSenders().forEach((sender) => {
          var _a2;
          if (((_a2 = sender.track) == null ? void 0 : _a2.kind) === "video") {
            sender.track.enabled = enable;
          }
        });
        session2.constraints.video = false;
      }
    } catch (error) {
      console.log("error pauseVideo", error);
    }
  }
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content2 = fileReader.result.split(",")[1];
    callback("b" + (content2 || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup$1[chars.charCodeAt(i2)] = i2;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i2)];
    encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i2 = 0; i2 < size; i2++) {
    buffer[i2] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n2 = view.getUint32(0);
          if (n2 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length = 0;
  for (let i2 = 0, l2 = str.length; i2 < l2; i2++) {
    c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      length += 1;
    } else if (c2 < 2048) {
      length += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length += 3;
    } else {
      i2++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l2 = pairs.length; i2 < l2; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError3 extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport3 extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError3(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
class Polling extends Transport3 {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close2 = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close2();
    } else {
      this.once("open", close2);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
let Request$1 = class Request2 extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this._opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e2) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e2) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e2) {
      }
      (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e2) {
      this.setTimeoutFn(() => {
        this._onError(e2);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request2.requestsCount++;
      Request2.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e2) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request2.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request$1.requestsCount = 0;
Request$1.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request$1.requests) {
    if (Request$1.requests.hasOwnProperty(i2)) {
      Request$1.requests[i2].abort();
    }
  }
}
const hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request$1(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e2) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e2) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport3 {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e2) => this.onError("websocket error", e2);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e2) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport3 {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done: done2, value: value2 }) => {
            if (done2) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e2 = str.indexOf("]");
  if (b != -1 && e2 != -1) {
    str = str.substring(0, b) + str.substring(b, e2).replace(/:/g, ";") + str.substring(e2, str.length);
  }
  let m2 = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m2[i2] || "";
  }
  if (b != -1 && e2 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names2 = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names2.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names2.splice(names2.length - 1, 1);
  }
  return names2;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t2) => {
      const transportName = t2.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t2;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name2) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name2;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name2]);
    return new this._transportsByName[name2](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close2 = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close2();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close2();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close2();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i2 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i2 !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i2, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i2 = 0; i2 < this._upgrades.length; i2++) {
        this._probe(this._upgrades[i2]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name2) {
    let transport = this.createTransport(name2);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name2 !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i2 = 0; i2 < upgrades.length; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o2 = typeof uri === "object" ? uri : opts;
    if (!o2.transports || o2.transports && typeof o2.transports[0] === "string") {
      o2.transports = (o2.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t2) => !!t2);
    }
    super(uri, o2);
  }
};
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString3 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString3.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString3.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON2) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i2 = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if ("," === c2)
          break;
        if (i2 === str.length)
          break;
      }
      p2.nsp = str.substring(start, i2);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if (null == c2 || Number(c2) != c2) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e2) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a, _b, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) ;
    else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout2 = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout2 === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout2);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout2) {
    this.flags.timeout = timeout2;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    if (!v) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout2 = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout2);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e2) {
      this.onclose("parse error", e2);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a;
    this.cleanup();
    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
const participantType = "SUPERVISOR";
const chanels = [fb_message, zl_message, phoneContact, "LIVE_CHAT"];
class Socket_SDK extends Port_Sip {
  constructor({
    info,
    getMsg,
    mode = true,
    options,
    cb,
    token = "",
    config = {
      url: "",
      options: {
        path: "",
        autoConnect: true,
        reconnection: true,
        transports: ["websocket", "polling"],
        reconnectionAttempts: 5,
        reconnectionDelay: 1e3,
        timeout: 5e3,
        closeOnBeforeunload: true,
        forceNew: true
      }
    },
    cbUserAction
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    super();
    __publicField(this, "info");
    __publicField(this, "getMsg");
    __publicField(this, "msg_channel", null);
    __publicField(this, "msgs", []);
    __publicField(this, "SesId", "");
    __publicField(this, "push_hang_up", []);
    __publicField(this, "socket");
    __publicField(this, "is_disconnect_socket", false);
    __publicField(this, "isVideoCall", false);
    this.info = info;
    this.getMsg = getMsg;
    const rooms = (_b = (_a = this.info.user) == null ? void 0 : _a.supportApplicationIds) == null ? void 0 : _b.map(
      (item) => {
        var _a2, _b2;
        return `${(_a2 = this.info.tenant) == null ? void 0 : _a2.id}_${(_b2 = this.info.user) == null ? void 0 : _b2.id}_${item}`;
      }
    );
    rooms.push(`call_event_${(_c = this.info.tenant) == null ? void 0 : _c.id}`);
    rooms.push(`${(_d = this.info.tenant) == null ? void 0 : _d.id}_${(_e = this.info.user) == null ? void 0 : _e.id}`);
    rooms.push(`agent_status_${(_f = this.info.tenant) == null ? void 0 : _f.id}_${(_g = this.info.user) == null ? void 0 : _g.id}`);
    rooms.push(`private_${(_h = this.info.tenant) == null ? void 0 : _h.id}_${(_i = this.info.user) == null ? void 0 : _i.id}`);
    const socket = lookup(config.url, {
      ...config.options,
      auth: {
        token
      },
      query: {
        participantType,
        participantId: (_j = this.info.user) == null ? void 0 : _j.id,
        tenantId: (_k = this.info.tenant) == null ? void 0 : _k.id,
        channels: chanels.join(","),
        fullName: `${(_l = this.info.user) == null ? void 0 : _l.fullName} (${(_m = this.info.user) == null ? void 0 : _m.userName})`,
        applicationId: (_n = this.info.user) == null ? void 0 : _n.supportApplicationIds,
        forceNew: false
      }
      // transports: ["websocket", "polling"],
      // reconnectionAttempts: 5,
      // reconnectionDelay: 1000,
      // timeout: 5000,
      // closeOnBeforeunload: true,
      // forceNew: true,
    });
    this.socket = socket;
    socket.on("connect", () => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      this.is_disconnect_socket = false;
      client_socket.emit(Event_SDK.AppEvent, {
        type: AppEventType$1.CONNECTED_WEB_SOCKET,
        message: AppEventType$1.CONNECTED_WEB_SOCKET
      });
      if (!mode) {
        client_socket.emit(Event_SDK.AppEvent, {
          type: AppEventType$1.READY,
          message: AppEventType$1.READY
        });
      }
      cb && cb();
      if (this.is_disconnect) {
        this.connect_sip({
          server: config_url.sip_url ?? fakeInternetCall.url,
          info: this.info,
          remoteVideoId: (options == null ? void 0 : options.remoteVideoId) || [],
          localVideoId: (options == null ? void 0 : options.localVideoId) || "",
          remoteAudioId: (options == null ? void 0 : options.elRemoteAudio) || [],
          cbInviteClosed: (cb2) => {
            if (this.is_disconnect_socket) {
              cb2 && cb2();
            }
          },
          cbCheckTask: (sessionId, state) => {
            this.checkTabSession(sessionId, state);
          }
        });
      }
      this.socket.emit(
        "agent_initialize",
        {
          cloudTenantId: (_a2 = this.info.tenant) == null ? void 0 : _a2.id,
          cloudAgentId: (_b2 = this.info.user) == null ? void 0 : _b2.id,
          agentName: `${(_c2 = this.info.user) == null ? void 0 : _c2.fullName} (${(_d2 = this.info.user) == null ? void 0 : _d2.userName})`,
          applicationIds: (_e2 = this.info.user) == null ? void 0 : _e2.supportApplicationIds,
          fsAgentId: (_f2 = this.info.user) == null ? void 0 : _f2.fsAgentId,
          domainContext: (_g2 = this.info.tenant) == null ? void 0 : _g2.domainId,
          isEnableEmail: true,
          isEnableChat: true
        },
        (response) => {
          this.socket.emit(
            "agent_join_rooms",
            {
              rooms
            },
            (response2) => {
            }
          );
        }
      );
    });
    this.socket.on("disconnect", () => {
      var _a2, _b2, _c2, _d2;
      this.is_disconnect_socket = true;
      if (!window.navigator.onLine) {
        client_socket.emit(Event_SDK.AppEvent, {
          type: AppEventType$1.NETWORK_ERROR,
          message: AppEventType$1.NETWORK_ERROR
        });
        this.is_disconnect = true;
        this.disconnect_sdk();
        this.main_id = "";
      } else {
        client_socket.emit(Event_SDK.AppEvent, {
          type: AppEventType$1.DISCONNECTED_WEB_SOCKET,
          message: AppEventType$1.DISCONNECTED_WEB_SOCKET
        });
        traceLog(
          "disconnect_web_socket",
          {
            event: AppEventType$1.DISCONNECTED_WEB_SOCKET
          },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_b2 = (_a2 = this.info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
            agentId: (_d2 = (_c2 = this == null ? void 0 : this.info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id
          }
        );
      }
    });
    socket.on(
      `private_transfer_accepted_${(_o = info == null ? void 0 : info.tenant) == null ? void 0 : _o.id}_${(_p = info == null ? void 0 : info.user) == null ? void 0 : _p.id}`,
      (msg) => {
        this.pushCallEventEmitter(CallEventType.CALL_TRANSFER_ACCEPTED, msg);
        this.main_id = "";
        SIP_SDK.sessionIds = [];
        this.SesId = "";
        this.push_hang_up.push(msg == null ? void 0 : msg.sessionId);
      }
    );
    socket.on(
      `private_answer_terminated_${(_q = info == null ? void 0 : info.tenant) == null ? void 0 : _q.id}_${(_r = info == null ? void 0 : info.user) == null ? void 0 : _r.id}`,
      () => {
        this.pushCallEventEmitter(
          CallEventType.CALL_TERMINATED_OR_IVR_MISSED,
          {}
        );
      }
    );
    socket.on(
      `private_agent_${(_s = info == null ? void 0 : info.tenant) == null ? void 0 : _s.id}_${(_t = info == null ? void 0 : info.user) == null ? void 0 : _t.id}`,
      (msg) => {
        cbUserAction && cbUserAction(msg);
      }
    );
    socket.on(
      `private_agent_call_event_${(_u = info == null ? void 0 : info.tenant) == null ? void 0 : _u.id}_${(_v = info == null ? void 0 : info.user) == null ? void 0 : _v.id}`,
      (msg) => {
        if (!this.searchSessionEstablished()) {
          client_socket.emit(Event_SDK.CallEvent, msg);
        }
      }
    );
    socket.on(
      `private_platform_${(_w = info == null ? void 0 : info.tenant) == null ? void 0 : _w.id}_${(_x = info == null ? void 0 : info.user) == null ? void 0 : _x.id}`,
      (msg) => {
        this.pushCallEventEmitter(CallEventType.CALL_CROSS_PLATFORM, {
          platform: msg.platform,
          sessionId: msg.sessionId
        });
      }
    );
    socket.on(`CALL_EVENT`, (msg) => {
      this.getChannelCallEvent(msg);
      return {
        status: "success"
      };
    });
    socket.on(`AGENT_STATUS_CHANGED`, (msg) => {
      client_socket.emit(Event_SDK.AgentStatusEvent, {
        agentId: msg == null ? void 0 : msg.cloudAgentId,
        tenantId: msg == null ? void 0 : msg.cloudTenantId,
        agentName: msg == null ? void 0 : msg.cloudAgentName,
        statusName: msg == null ? void 0 : msg.statusName,
        changeTime: msg == null ? void 0 : msg.changeTime,
        reasonCode: msg == null ? void 0 : msg.reasonCode,
        reasonCodeId: msg == null ? void 0 : msg.reasonCodeId,
        reasonName: msg == null ? void 0 : msg.reasonName
      });
      if (agentStatusStore == null ? void 0 : agentStatusStore.dispatch) {
        agentStatusStore.dispatch({
          type: "AGENT_CHANGE_STATUS",
          message: msg
        });
      }
      return {
        status: "success"
      };
    });
    socket.on(`test`, (msg) => {
      console.log("event test", msg);
    });
  }
  checkTabSession(sessionId, state) {
    if (this.socket) {
      this.socket.emit("agent_state", {
        sessionId,
        state
      });
    }
  }
  /**
   * Refuse transfer conversation
   */
  socketAnswerTerminated() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    (_i = this.socket) == null ? void 0 : _i.emit(
      send_message,
      {
        rooms: [`private_${(_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id}_${(_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id}`],
        event: `private_answer_terminated_${(_f = (_e = this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id}_${(_h = (_g = this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id}`,
        data: {}
      },
      () => {
      }
    );
  }
  accept_ably(requests) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const sessionId = this.getSessionMain();
    traceLog(
      "answer sdk_sip",
      { sessionId, data_session: this.getDataStringify() },
      {
        isLogClient: false,
        isLogServer: true,
        sessionId,
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      }
    );
    if (sessionId) {
      traceLog(
        "answer sessionId",
        { sessionId },
        {
          isLogClient: false,
          isLogServer: true,
          sessionId,
          tenantId: (_f = (_e = this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id,
          agentId: (_h = (_g = this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id
        }
      );
      const record = (this.msgs ?? []).find((r2) => (r2 == null ? void 0 : r2.sessionId) === sessionId);
      this.answer(
        sessionId,
        (sessionId2, state, callId) => {
          var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m, _n, _o, _p;
          if (requests == null ? void 0 : requests.enableVideo) {
            this.sendCamera(sessionId2, true);
            (_e2 = this.port_sip_sdk) == null ? void 0 : _e2.sendMessage(
              JSON.stringify({
                sessionId: sessionId2,
                payload: {
                  answered: true,
                  extension: (_b2 = (_a2 = this.info) == null ? void 0 : _a2.user) == null ? void 0 : _b2.extension,
                  type: "call_state",
                  isInternal: (record == null ? void 0 : record.dnis) === ((_d2 = (_c2 = this.info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.extension) ? true : false
                }
              }),
              callId,
              true
            );
          }
          this.checkTabSession(sessionId2, state);
          const find = (this.msgs ?? []).find(
            (r2) => (r2 == null ? void 0 : r2.sessionId) === sessionId2
          );
          (_n = this.socket) == null ? void 0 : _n.emit(
            send_message,
            {
              rooms: [
                `private_${(_g2 = (_f2 = this.info) == null ? void 0 : _f2.tenant) == null ? void 0 : _g2.id}_${(_i2 = (_h2 = this.info) == null ? void 0 : _h2.user) == null ? void 0 : _i2.id}`
              ],
              event: `private_platform_${(_k2 = (_j2 = this.info) == null ? void 0 : _j2.tenant) == null ? void 0 : _k2.id}_${(_m = (_l2 = this.info) == null ? void 0 : _l2.user) == null ? void 0 : _m.id}`,
              data: {
                platform: PlatformType.WEB,
                sessionId: sessionId2
              }
            },
            () => {
            }
          );
          ((_o = requests == null ? void 0 : requests.requestDelegate) == null ? void 0 : _o.onAccept) && ((_p = requests == null ? void 0 : requests.requestDelegate) == null ? void 0 : _p.onAccept(sessionId2, {
            senderId: find == null ? void 0 : find.ani,
            applicationId: find == null ? void 0 : find.dnis,
            sessionId: find == null ? void 0 : find.sessionId,
            channel: find == null ? void 0 : find.channel,
            direction: find == null ? void 0 : find.direction,
            extraInfo: (find == null ? void 0 : find.extraInfo) ?? ""
          }));
        },
        () => {
          this.socketAnswerTerminated();
        },
        (requests == null ? void 0 : requests.enableVideo) ?? false
      );
    } else {
      alertSnackbar()({
        status: "error",
        duration: 3e3,
        title: "Cuộc gọi đã kết thúc, không tồn tại hoặc đã vào IVR nhỡ."
      });
      this.socketAnswerTerminated();
      traceLog("answer error session not found", sessionId, {
        isLogServer: true,
        sessionId,
        tenantId: (_j = (_i = this.info) == null ? void 0 : _i.tenant) == null ? void 0 : _j.id,
        agentId: (_l = (_k = this.info) == null ? void 0 : _k.user) == null ? void 0 : _l.id
      });
    }
  }
  reject_sip() {
    var _a, _b, _c, _d;
    const sessionId = this.getSessionMain();
    traceLog(
      "reject_sip",
      { sessionId, data_session: this.getDataStringify() },
      {
        isLogClient: false,
        isLogServer: true,
        sessionId,
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      }
    );
    if (this.msg_channel && sessionId) this.rejectCall(sessionId);
  }
  clearMainId(sessionId) {
    if (sessionId === this.main_id) {
      this.main_id = "";
    }
  }
  parseExtraInfo(values) {
    const parse2 = JSON.parse(values);
    if (parse2 == null ? void 0 : parse2.type) {
      return {
        type: parse2 == null ? void 0 : parse2.type,
        extraInfo: parse2 == null ? void 0 : parse2.extraInfo
      };
    }
    return {
      type: CALL_TYPE.VOICE,
      extraInfo: values
    };
  }
  pushCallEventEmitter(type, object = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    if (object == null ? void 0 : object.sessionId) {
      const find = this.msgs.find((i2) => (i2 == null ? void 0 : i2.sessionId) === (object == null ? void 0 : object.sessionId));
      if (find) {
        this.msg_channel = find;
      }
    }
    const obj_event = {
      type,
      name: type,
      senderId: (_a = this.msg_channel) == null ? void 0 : _a.ani,
      applicationId: (_b = this.msg_channel) == null ? void 0 : _b.dnis,
      sessionId: (_c = this.msg_channel) == null ? void 0 : _c.sessionId,
      channel: (_d = this.msg_channel) == null ? void 0 : _d.channel,
      direction: (_e = this.msg_channel) == null ? void 0 : _e.direction,
      extraInfo: ((_f = this.msg_channel) == null ? void 0 : _f.extraInfo) ?? "",
      ...object || {}
    };
    if (obj_event == null ? void 0 : obj_event.extraInfo) {
      const extInfo = this.parseExtraInfo((obj_event == null ? void 0 : obj_event.extraInfo) ?? "");
      if (extInfo == null ? void 0 : extInfo.extraInfo) {
        obj_event.extraInfo = extInfo == null ? void 0 : extInfo.extraInfo;
        obj_event.callType = extInfo == null ? void 0 : extInfo.type;
      }
    }
    client_socket.emit(Event_SDK.CallEvent, obj_event);
    traceLog(
      "pushCallEventEmitter",
      {
        event: Event_SDK.CallEvent,
        data: obj_event
      },
      {
        isLogClient: false,
        isLogServer: true,
        tenantId: (_h = (_g = this.info) == null ? void 0 : _g.tenant) == null ? void 0 : _h.id,
        agentId: (_j = (_i = this == null ? void 0 : this.info) == null ? void 0 : _i.user) == null ? void 0 : _j.id,
        sessionId: obj_event == null ? void 0 : obj_event.sessionId
      }
    );
    if (type === CallEventType.CALL_HOLD || type === CallEventType.CALL_UNHOLD || type === CallEventType.CALL_MUTE || type === CallEventType.CALL_UNMUTE) {
      this.socket.emit(
        send_message,
        {
          rooms: [`private_${(_l = (_k = this.info) == null ? void 0 : _k.tenant) == null ? void 0 : _l.id}_${(_n = (_m = this.info) == null ? void 0 : _m.user) == null ? void 0 : _n.id}`],
          event: `private_agent_call_event_${(_p = (_o = this.info) == null ? void 0 : _o.tenant) == null ? void 0 : _p.id}_${(_r = (_q = this.info) == null ? void 0 : _q.user) == null ? void 0 : _r.id}`,
          data: obj_event
        },
        () => {
        }
      );
    }
  }
  checkEvent(event) {
    const list_event = [
      EVENT_ABLY_NAME.OFFER_CALL,
      EVENT_ABLY_NAME.ANSWER_CALL,
      EVENT_ABLY_NAME.END_CALL,
      EVENT_ABLY_NAME.CLOSE,
      EVENT_ABLY_NAME.REJECT_CALL,
      EVENT_ABLY_NAME.START_CONVERSATION,
      EVENT_ABLY_NAME.TRANSFER_CONVERSATION,
      EVENT_ABLY_NAME.TRANSFER_ACCEPTED,
      EVENT_ABLY_NAME.TRANSFER_ANSWER,
      EVENT_ABLY_NAME.TRANSFER_RINGING,
      EVENT_ABLY_NAME.ASSIGN_CONVERSATION
    ];
    return list_event.some((i2) => i2 === event);
  }
  pickCall(message2) {
    var _a, _b, _c, _d;
    if (message2.state === EVENT_ABLY_NAME.MESSAGE_TRANSFERED || message2.state === EVENT_ABLY_NAME.NEW_CONVERSATION || message2.state === EVENT_ABLY_NAME.ASSIGN_CONVERSATION || message2.state === EVENT_ABLY_NAME.TRANSFER_CONVERSATION || message2.state === EVENT_ABLY_NAME.START_CONVERSATION) {
      if (!SIP_SDK.sessionIds.includes(message2 == null ? void 0 : message2.sessionId) && ((_b = (_a = this.info) == null ? void 0 : _a.user) == null ? void 0 : _b.id) === message2.agentId && existChannelCall(message2.channel)) {
        SIP_SDK.sessionIds.push(message2.sessionId);
      }
    }
    if (message2.state === EVENT_ABLY_NAME.TRANSFER_RINGING) {
      if (SIP_SDK.sessionIds.includes(message2.sessionId)) {
        this.pushCallEventEmitter(CallEventType.CALL_TRANSFER_RINGING, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
    }
    if (message2.state === EVENT_ABLY_NAME.TRANSFER_ANSWER) {
      if (SIP_SDK.sessionIds.includes(message2.sessionId)) {
        this.pushCallEventEmitter(CallEventType.CALL_TRANSFER_ANSWER, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
    }
    if (((_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id) === message2.agentId) {
      if (message2.state === EVENT_ABLY_NAME.INBOUND_CALL && (message2.direction === DIRECTION.OUTBOUND || message2.direction === DIRECTION.INTERNAL) && existChannelCall(message2.channel)) {
        this.pushCallEventEmitter(CallEventType.CALL_OUTGOING, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: null,
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
      if (message2.state === EVENT_ABLY_NAME.ANSWER_CALL) {
        this.pushCallEventEmitter(CallEventType.CALL_ANSWERED, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: null,
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
      if (message2.state === EVENT_ABLY_NAME.TRANSFER_CONVERSATION && existChannelCall(message2.channel)) {
        this.pushCallEventEmitter(CallEventType.CALL_TRANSFER, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
      if (message2.state === EVENT_ABLY_NAME.REJECT_CALL) {
        console.log("REJECT_CALL", message2);
        this.pushCallEventEmitter(CallEventType.CALL_REJECTED, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
      if (message2.state === EVENT_ABLY_NAME.TRANSFER_FAILED) {
        this.main_id = message2.sessionId;
        this.pushCallEventEmitter(CallEventType.CALL_TRANSFER_FAILED, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
      if (message2.state === EVENT_ABLY_NAME.CLOSE) {
        this.pushCallEventEmitter(CallEventType.CALL_CLOSE_CONVERSATION, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
    }
  }
  getLastEntry(map) {
    let last;
    for (const entry of map) {
      last = entry;
    }
    return last;
  }
  getChannelCallEvent(message2) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I;
    this.pickCall(message2);
    if (message2.state && this.checkEvent(message2.state) && existChannelCall(message2.channel)) {
      if (message2.agentId === ((_b = (_a = this.info) == null ? void 0 : _a.user) == null ? void 0 : _b.id)) {
        const check = (_c = this.msgs) == null ? void 0 : _c.findIndex(
          (i2) => (i2 == null ? void 0 : i2.sessionId) === message2.sessionId
        );
        if (check >= 0) {
          this.msgs[check] = message2;
        } else {
          this.msgs = [...this.msgs, message2];
        }
      }
      if (((_d = SIP_SDK.sessionIds) == null ? void 0 : _d.length) && SIP_SDK.sessionIds.includes(message2.sessionId)) {
        if (message2.state in Map_event_name) {
          emitInteractionEvent(
            Map_event_name[message2.state],
            {
              type: Map_event_name[message2.state] ?? "",
              senderId: message2.ani ?? "",
              applicationId: message2.dnis ?? "",
              conversationId: "",
              message: message2.text ?? ""
            }
          );
        }
        this.getMsg(message2);
        this.msg_channel = message2;
      }
      if (message2.state === EVENT_ABLY_NAME.CLOSE) {
        this.msgs = (this.msgs ?? []).filter(
          (i2) => (i2 == null ? void 0 : i2.sessionId) !== message2.sessionId
        );
      }
    }
    if (message2.state === EVENT_ABLY_NAME.OFFER_CALL) {
      if (((_f = (_e = this.info) == null ? void 0 : _e.user) == null ? void 0 : _f.id) === message2.agentId) {
        this.main_id = message2.sessionId;
        this.pushCallEventEmitter(CallEventType.CALL_INCOMING, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: null,
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
        this.SesId = message2.sessionId;
      }
    }
    if (message2.state === EVENT_ABLY_NAME.REJECT_CALL) {
      if (((_h = (_g = this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id) === message2.agentId) {
        this.clearMainId(message2.sessionId ?? "");
        SIP_SDK.sessionIds = [];
        this.SesId = "";
      } else if (((_j = (_i = this.info) == null ? void 0 : _i.user) == null ? void 0 : _j.id) !== message2.agentId && SIP_SDK.sessionIds.includes(message2.sessionId) && (message2.direction === DIRECTION.INTERNAL || message2.direction === DIRECTION.ATTENDED_TRANSFER)) {
        this.clearMainId(message2.sessionId ?? "");
        this.pushCallEventEmitter(CallEventType.CALL_REJECTED, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
    }
    if (message2.state === EVENT_ABLY_NAME.TRANSFER_ACCEPTED) {
      if (message2.agentId === ((_l = (_k = this.info) == null ? void 0 : _k.user) == null ? void 0 : _l.id)) {
        this.main_id = message2.sessionId;
      }
      if (message2.agentId === ((_n = (_m = this.info) == null ? void 0 : _m.user) == null ? void 0 : _n.id) && !SIP_SDK.sessionIds.includes(message2.sessionId)) {
        SIP_SDK.sessionIds.push(message2.sessionId);
        this.SesId = "";
      }
      if (SIP_SDK.sessionIds.includes(message2.sessionId)) {
        this.SesId = message2 == null ? void 0 : message2.sessionId;
        this.pushCallEventEmitter(CallEventType.CALL_TRANSFER_ACCEPTED, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: MessengerForm.AGENT,
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
        if (message2.agentId === ((_p = (_o = this.info) == null ? void 0 : _o.user) == null ? void 0 : _p.id)) {
          const check = (_q = this.msgs) == null ? void 0 : _q.findIndex(
            (i2) => (i2 == null ? void 0 : i2.sessionId) === message2.sessionId
          );
          if (check >= 0) {
            this.msgs[check] = message2;
          } else {
            this.msgs = [...this.msgs, message2];
          }
          const sessionIds = SIP_SDK.sessionIds.filter(
            (s2) => s2 !== message2.sessionId
          );
          const filters = (this.msgs ?? []).filter(
            (i2) => sessionIds.includes(i2 == null ? void 0 : i2.sessionId)
          );
          if (filters && filters.length) {
            filters.forEach((f) => {
              var _a2, _b2, _c2, _d2;
              SIP_SDK.sessionIds = SIP_SDK.sessionIds.filter(
                (s2) => s2 !== (f == null ? void 0 : f.sessionId)
              );
              this.push_hang_up.push(f == null ? void 0 : f.sessionId);
              traceLog(
                "hangup_transfer_accepted",
                {
                  senderId: f == null ? void 0 : f.ani,
                  applicationId: f == null ? void 0 : f.dnis,
                  sessionId: f == null ? void 0 : f.sessionId,
                  hangupBy: render_hang_up(message2),
                  channel: f == null ? void 0 : f.channel,
                  direction: f == null ? void 0 : f.direction,
                  extraInfo: (f == null ? void 0 : f.extraInfo) ?? "",
                  statusCode: "0"
                },
                {
                  isLogClient: false,
                  isLogServer: true,
                  tenantId: (_b2 = (_a2 = this == null ? void 0 : this.info) == null ? void 0 : _a2.tenant) == null ? void 0 : _b2.id,
                  agentId: (_d2 = (_c2 = this == null ? void 0 : this.info) == null ? void 0 : _c2.user) == null ? void 0 : _d2.id,
                  sessionId: f == null ? void 0 : f.sessionId
                }
              );
              this.pushCallEventEmitter(CallEventType.CALL_HANGUP, {
                senderId: f == null ? void 0 : f.ani,
                applicationId: f == null ? void 0 : f.dnis,
                sessionId: f == null ? void 0 : f.sessionId,
                hangupBy: render_hang_up(message2),
                channel: f == null ? void 0 : f.channel,
                direction: f == null ? void 0 : f.direction,
                extraInfo: (f == null ? void 0 : f.extraInfo) ?? "",
                statusCode: "0"
              });
            });
          }
          if (this.main_id) {
            const value2 = this.getLastEntry(this.data);
            const _id = value2 == null ? void 0 : value2[0];
            this.SesId = this.main_id;
            if (typeof _id === "string") {
              const sessionId = this.getDataCallId(_id);
              this.clearData();
              this.data.set(this.main_id, sessionId);
              this.data.set(sessionId, this.main_id);
            } else if (typeof _id === "number") {
              this.clearData();
              this.data.set(this.main_id, _id);
              this.data.set(_id, this.main_id);
            }
            SIP_SDK.sessionIds = [message2.sessionId];
            if (_id) {
              this.msgs = this.msgs.filter(
                (m2) => m2.sessionId === message2.sessionId
              );
            }
          }
        } else {
          this.msgs = [];
          SIP_SDK.sessionIds = [];
          this.clearData();
        }
      }
    }
    if (message2.state === EVENT_ABLY_NAME.ANSWER_CALL) {
      if (message2.agentId !== ((_s = (_r = this.info) == null ? void 0 : _r.user) == null ? void 0 : _s.id) && message2.sessionId === this.main_id && message2.direction === DIRECTION.INTERNAL) {
        this.SesId = message2.sessionId;
        const existDirection = this.msgs.some(
          (i2) => (i2 == null ? void 0 : i2.sessionId) === message2.sessionId
        );
        if (!existDirection) {
          this.msgs = [...this.msgs, message2];
        }
        this.pushCallEventEmitter(CallEventType.CALL_ANSWERED, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: null,
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? ""
        });
      }
    }
    if (message2.state === EVENT_ABLY_NAME.TRANSFER_FAILED) {
      if (((_u = (_t = this.info) == null ? void 0 : _t.user) == null ? void 0 : _u.id) !== message2.agentId && SIP_SDK.sessionIds.includes(message2.sessionId)) {
        SIP_SDK.sessionIds = SIP_SDK.sessionIds.filter(
          (s2) => s2 !== message2.sessionId
        );
        if (message2.sessionId === this.SesId) {
          this.SesId = "";
        }
      }
    }
    if (message2.state === EVENT_ABLY_NAME.END_CALL) {
      this.clearMainId(message2.sessionId ?? "");
      if (SIP_SDK.sessionIds.includes(message2.sessionId)) {
        this.msgs = this.msgs.filter((i2) => i2.sessionId !== message2.sessionId);
        if (message2.sessionId === this.SesId) {
          this.SesId = "";
        }
        traceLog(
          "hangup_1",
          {},
          {
            isLogClient: false,
            tenantId: (_w = (_v = this == null ? void 0 : this.info) == null ? void 0 : _v.tenant) == null ? void 0 : _w.id,
            agentId: (_y = (_x = this == null ? void 0 : this.info) == null ? void 0 : _x.user) == null ? void 0 : _y.id,
            sessionId: message2 == null ? void 0 : message2.sessionId
          }
        );
        this.pushCallEventEmitter(CallEventType.CALL_HANGUP, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? "",
          statusCode: message2 == null ? void 0 : message2.statusCode
        });
        SIP_SDK.sessionIds = SIP_SDK.sessionIds.filter(
          (s2) => s2 !== message2.sessionId
        );
      } else if (message2.sessionId === this.SesId && !SIP_SDK.sessionIds.includes(message2.sessionId)) {
        traceLog(
          "hangup_2",
          {},
          {
            isLogClient: false,
            tenantId: (_A = (_z = this == null ? void 0 : this.info) == null ? void 0 : _z.tenant) == null ? void 0 : _A.id,
            agentId: (_C = (_B = this == null ? void 0 : this.info) == null ? void 0 : _B.user) == null ? void 0 : _C.id,
            sessionId: message2 == null ? void 0 : message2.sessionId
          }
        );
        this.pushCallEventEmitter(CallEventType.CALL_HANGUP, {
          senderId: message2 == null ? void 0 : message2.ani,
          applicationId: message2 == null ? void 0 : message2.dnis,
          sessionId: message2 == null ? void 0 : message2.sessionId,
          hangupBy: render_hang_up(message2),
          channel: message2 == null ? void 0 : message2.channel,
          direction: message2 == null ? void 0 : message2.direction,
          extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? "",
          statusCode: message2 == null ? void 0 : message2.statusCode
        });
        this.SesId = "";
      } else if (message2.agentId === ((_E = (_D = this.info) == null ? void 0 : _D.user) == null ? void 0 : _E.id) && this.SesId !== message2.sessionId) {
        if (!this.push_hang_up.includes(message2.sessionId)) {
          traceLog(
            "hangup_3",
            {},
            {
              isLogClient: false,
              tenantId: (_G = (_F = this == null ? void 0 : this.info) == null ? void 0 : _F.tenant) == null ? void 0 : _G.id,
              agentId: (_I = (_H = this == null ? void 0 : this.info) == null ? void 0 : _H.user) == null ? void 0 : _I.id,
              sessionId: message2 == null ? void 0 : message2.sessionId
            }
          );
          this.pushCallEventEmitter(CallEventType.CALL_HANGUP, {
            senderId: message2 == null ? void 0 : message2.ani,
            applicationId: message2 == null ? void 0 : message2.dnis,
            sessionId: message2 == null ? void 0 : message2.sessionId,
            hangupBy: render_hang_up(message2),
            channel: message2 == null ? void 0 : message2.channel,
            direction: message2 == null ? void 0 : message2.direction,
            extraInfo: (message2 == null ? void 0 : message2.extraInfo) ?? "",
            statusCode: message2 == null ? void 0 : message2.statusCode
          });
        }
        this.push_hang_up = this.push_hang_up.filter(
          (i2) => i2 !== (message2 == null ? void 0 : message2.sessionId)
        );
        this.SesId = "";
      }
    }
  }
  checkVideoCall(id, sessionId) {
    var _a, _b, _c;
    if (this.isVideoCall) {
      (_c = this.port_sip_sdk) == null ? void 0 : _c.sendMessage(
        JSON.stringify({
          sessionId,
          payload: {
            answered: true,
            extension: (_b = (_a = this.info) == null ? void 0 : _a.user) == null ? void 0 : _b.extension,
            type: "call_state"
          }
        }),
        id,
        true
      );
    }
  }
}
const deleteRegisterCall = (body) => {
  return axiosNotAuth.delete(`/contact-center/agent/registration`, {
    data: body
  });
};
var selfie_segmentation = {};
(function() {
  var x;
  function aa(a2) {
    var b = 0;
    return function() {
      return b < a2.length ? { done: false, value: a2[b++] } : { done: true };
    };
  }
  var ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a2, b, c2) {
    if (a2 == Array.prototype || a2 == Object.prototype) return a2;
    a2[b] = c2.value;
    return a2;
  };
  function ca(a2) {
    a2 = ["object" == typeof globalThis && globalThis, a2, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof commonjsGlobal && commonjsGlobal];
    for (var b = 0; b < a2.length; ++b) {
      var c2 = a2[b];
      if (c2 && c2.Math == Math) return c2;
    }
    throw Error("Cannot find global object");
  }
  var y = ca(this);
  function z(a2, b) {
    if (b) a: {
      var c2 = y;
      a2 = a2.split(".");
      for (var d = 0; d < a2.length - 1; d++) {
        var e2 = a2[d];
        if (!(e2 in c2)) break a;
        c2 = c2[e2];
      }
      a2 = a2[a2.length - 1];
      d = c2[a2];
      b = b(d);
      b != d && null != b && ba(c2, a2, { configurable: true, writable: true, value: b });
    }
  }
  z("Symbol", function(a2) {
    function b(g) {
      if (this instanceof b) throw new TypeError("Symbol is not a constructor");
      return new c2(d + (g || "") + "_" + e2++, g);
    }
    function c2(g, f) {
      this.h = g;
      ba(this, "description", { configurable: true, writable: true, value: f });
    }
    if (a2) return a2;
    c2.prototype.toString = function() {
      return this.h;
    };
    var d = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e2 = 0;
    return b;
  });
  z("Symbol.iterator", function(a2) {
    if (a2) return a2;
    a2 = Symbol("Symbol.iterator");
    for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c2 = 0; c2 < b.length; c2++) {
      var d = y[b[c2]];
      "function" === typeof d && "function" != typeof d.prototype[a2] && ba(d.prototype, a2, { configurable: true, writable: true, value: function() {
        return da(aa(this));
      } });
    }
    return a2;
  });
  function da(a2) {
    a2 = { next: a2 };
    a2[Symbol.iterator] = function() {
      return this;
    };
    return a2;
  }
  function A(a2) {
    var b = "undefined" != typeof Symbol && Symbol.iterator && a2[Symbol.iterator];
    return b ? b.call(a2) : { next: aa(a2) };
  }
  function ea(a2) {
    if (!(a2 instanceof Array)) {
      a2 = A(a2);
      for (var b, c2 = []; !(b = a2.next()).done; ) c2.push(b.value);
      a2 = c2;
    }
    return a2;
  }
  var fa = "function" == typeof Object.assign ? Object.assign : function(a2, b) {
    for (var c2 = 1; c2 < arguments.length; c2++) {
      var d = arguments[c2];
      if (d) for (var e2 in d) Object.prototype.hasOwnProperty.call(d, e2) && (a2[e2] = d[e2]);
    }
    return a2;
  };
  z("Object.assign", function(a2) {
    return a2 || fa;
  });
  var ha = "function" == typeof Object.create ? Object.create : function(a2) {
    function b() {
    }
    b.prototype = a2;
    return new b();
  }, ia;
  if ("function" == typeof Object.setPrototypeOf) ia = Object.setPrototypeOf;
  else {
    var ja;
    a: {
      var ka = { a: true }, la = {};
      try {
        la.__proto__ = ka;
        ja = la.a;
        break a;
      } catch (a2) {
      }
      ja = false;
    }
    ia = ja ? function(a2, b) {
      a2.__proto__ = b;
      if (a2.__proto__ !== b) throw new TypeError(a2 + " is not extensible");
      return a2;
    } : null;
  }
  var ma = ia;
  function na(a2, b) {
    a2.prototype = ha(b.prototype);
    a2.prototype.constructor = a2;
    if (ma) ma(a2, b);
    else for (var c2 in b) if ("prototype" != c2) if (Object.defineProperties) {
      var d = Object.getOwnPropertyDescriptor(b, c2);
      d && Object.defineProperty(a2, c2, d);
    } else a2[c2] = b[c2];
    a2.za = b.prototype;
  }
  function oa() {
    this.m = false;
    this.j = null;
    this.i = void 0;
    this.h = 1;
    this.v = this.s = 0;
    this.l = null;
  }
  function pa(a2) {
    if (a2.m) throw new TypeError("Generator is already running");
    a2.m = true;
  }
  oa.prototype.u = function(a2) {
    this.i = a2;
  };
  function qa(a2, b) {
    a2.l = { ma: b, na: true };
    a2.h = a2.s || a2.v;
  }
  oa.prototype.return = function(a2) {
    this.l = { return: a2 };
    this.h = this.v;
  };
  function D(a2, b, c2) {
    a2.h = c2;
    return { value: b };
  }
  function ra(a2) {
    this.h = new oa();
    this.i = a2;
  }
  function sa(a2, b) {
    pa(a2.h);
    var c2 = a2.h.j;
    if (c2) return ta(a2, "return" in c2 ? c2["return"] : function(d) {
      return { value: d, done: true };
    }, b, a2.h.return);
    a2.h.return(b);
    return ua2(a2);
  }
  function ta(a2, b, c2, d) {
    try {
      var e2 = b.call(a2.h.j, c2);
      if (!(e2 instanceof Object)) throw new TypeError("Iterator result " + e2 + " is not an object");
      if (!e2.done) return a2.h.m = false, e2;
      var g = e2.value;
    } catch (f) {
      return a2.h.j = null, qa(a2.h, f), ua2(a2);
    }
    a2.h.j = null;
    d.call(a2.h, g);
    return ua2(a2);
  }
  function ua2(a2) {
    for (; a2.h.h; ) try {
      var b = a2.i(a2.h);
      if (b) return a2.h.m = false, { value: b.value, done: false };
    } catch (c2) {
      a2.h.i = void 0, qa(a2.h, c2);
    }
    a2.h.m = false;
    if (a2.h.l) {
      b = a2.h.l;
      a2.h.l = null;
      if (b.na) throw b.ma;
      return { value: b.return, done: true };
    }
    return { value: void 0, done: true };
  }
  function va(a2) {
    this.next = function(b) {
      pa(a2.h);
      a2.h.j ? b = ta(a2, a2.h.j.next, b, a2.h.u) : (a2.h.u(b), b = ua2(a2));
      return b;
    };
    this.throw = function(b) {
      pa(a2.h);
      a2.h.j ? b = ta(a2, a2.h.j["throw"], b, a2.h.u) : (qa(a2.h, b), b = ua2(a2));
      return b;
    };
    this.return = function(b) {
      return sa(a2, b);
    };
    this[Symbol.iterator] = function() {
      return this;
    };
  }
  function wa(a2) {
    function b(d) {
      return a2.next(d);
    }
    function c2(d) {
      return a2.throw(d);
    }
    return new Promise(function(d, e2) {
      function g(f) {
        f.done ? d(f.value) : Promise.resolve(f.value).then(b, c2).then(g, e2);
      }
      g(a2.next());
    });
  }
  function E(a2) {
    return wa(new va(new ra(a2)));
  }
  z("Promise", function(a2) {
    function b(f) {
      this.i = 0;
      this.j = void 0;
      this.h = [];
      this.u = false;
      var h = this.l();
      try {
        f(h.resolve, h.reject);
      } catch (k) {
        h.reject(k);
      }
    }
    function c2() {
      this.h = null;
    }
    function d(f) {
      return f instanceof b ? f : new b(function(h) {
        h(f);
      });
    }
    if (a2) return a2;
    c2.prototype.i = function(f) {
      if (null == this.h) {
        this.h = [];
        var h = this;
        this.j(function() {
          h.m();
        });
      }
      this.h.push(f);
    };
    var e2 = y.setTimeout;
    c2.prototype.j = function(f) {
      e2(f, 0);
    };
    c2.prototype.m = function() {
      for (; this.h && this.h.length; ) {
        var f = this.h;
        this.h = [];
        for (var h = 0; h < f.length; ++h) {
          var k = f[h];
          f[h] = null;
          try {
            k();
          } catch (l2) {
            this.l(l2);
          }
        }
      }
      this.h = null;
    };
    c2.prototype.l = function(f) {
      this.j(function() {
        throw f;
      });
    };
    b.prototype.l = function() {
      function f(l2) {
        return function(m2) {
          k || (k = true, l2.call(h, m2));
        };
      }
      var h = this, k = false;
      return { resolve: f(this.I), reject: f(this.m) };
    };
    b.prototype.I = function(f) {
      if (f === this) this.m(new TypeError("A Promise cannot resolve to itself"));
      else if (f instanceof b) this.L(f);
      else {
        a: switch (typeof f) {
          case "object":
            var h = null != f;
            break a;
          case "function":
            h = true;
            break a;
          default:
            h = false;
        }
        h ? this.F(f) : this.s(f);
      }
    };
    b.prototype.F = function(f) {
      var h = void 0;
      try {
        h = f.then;
      } catch (k) {
        this.m(k);
        return;
      }
      "function" == typeof h ? this.M(h, f) : this.s(f);
    };
    b.prototype.m = function(f) {
      this.v(2, f);
    };
    b.prototype.s = function(f) {
      this.v(1, f);
    };
    b.prototype.v = function(f, h) {
      if (0 != this.i) throw Error("Cannot settle(" + f + ", " + h + "): Promise already settled in state" + this.i);
      this.i = f;
      this.j = h;
      2 === this.i && this.K();
      this.H();
    };
    b.prototype.K = function() {
      var f = this;
      e2(function() {
        if (f.D()) {
          var h = y.console;
          "undefined" !== typeof h && h.error(f.j);
        }
      }, 1);
    };
    b.prototype.D = function() {
      if (this.u) return false;
      var f = y.CustomEvent, h = y.Event, k = y.dispatchEvent;
      if ("undefined" === typeof k) return true;
      "function" === typeof f ? f = new f("unhandledrejection", { cancelable: true }) : "function" === typeof h ? f = new h("unhandledrejection", { cancelable: true }) : (f = y.document.createEvent("CustomEvent"), f.initCustomEvent("unhandledrejection", false, true, f));
      f.promise = this;
      f.reason = this.j;
      return k(f);
    };
    b.prototype.H = function() {
      if (null != this.h) {
        for (var f = 0; f < this.h.length; ++f) g.i(this.h[f]);
        this.h = null;
      }
    };
    var g = new c2();
    b.prototype.L = function(f) {
      var h = this.l();
      f.T(h.resolve, h.reject);
    };
    b.prototype.M = function(f, h) {
      var k = this.l();
      try {
        f.call(h, k.resolve, k.reject);
      } catch (l2) {
        k.reject(l2);
      }
    };
    b.prototype.then = function(f, h) {
      function k(p2, n2) {
        return "function" == typeof p2 ? function(q) {
          try {
            l2(p2(q));
          } catch (t2) {
            m2(t2);
          }
        } : n2;
      }
      var l2, m2, r2 = new b(function(p2, n2) {
        l2 = p2;
        m2 = n2;
      });
      this.T(k(f, l2), k(h, m2));
      return r2;
    };
    b.prototype.catch = function(f) {
      return this.then(void 0, f);
    };
    b.prototype.T = function(f, h) {
      function k() {
        switch (l2.i) {
          case 1:
            f(l2.j);
            break;
          case 2:
            h(l2.j);
            break;
          default:
            throw Error("Unexpected state: " + l2.i);
        }
      }
      var l2 = this;
      null == this.h ? g.i(k) : this.h.push(k);
      this.u = true;
    };
    b.resolve = d;
    b.reject = function(f) {
      return new b(function(h, k) {
        k(f);
      });
    };
    b.race = function(f) {
      return new b(function(h, k) {
        for (var l2 = A(f), m2 = l2.next(); !m2.done; m2 = l2.next()) d(m2.value).T(h, k);
      });
    };
    b.all = function(f) {
      var h = A(f), k = h.next();
      return k.done ? d([]) : new b(function(l2, m2) {
        function r2(q) {
          return function(t2) {
            p2[q] = t2;
            n2--;
            0 == n2 && l2(p2);
          };
        }
        var p2 = [], n2 = 0;
        do
          p2.push(void 0), n2++, d(k.value).T(r2(p2.length - 1), m2), k = h.next();
        while (!k.done);
      });
    };
    return b;
  });
  function xa(a2, b) {
    a2 instanceof String && (a2 += "");
    var c2 = 0, d = false, e2 = { next: function() {
      if (!d && c2 < a2.length) {
        var g = c2++;
        return { value: b(g, a2[g]), done: false };
      }
      d = true;
      return { done: true, value: void 0 };
    } };
    e2[Symbol.iterator] = function() {
      return e2;
    };
    return e2;
  }
  z("Array.prototype.keys", function(a2) {
    return a2 ? a2 : function() {
      return xa(this, function(b) {
        return b;
      });
    };
  });
  z("Array.prototype.fill", function(a2) {
    return a2 ? a2 : function(b, c2, d) {
      var e2 = this.length || 0;
      0 > c2 && (c2 = Math.max(0, e2 + c2));
      if (null == d || d > e2) d = e2;
      d = Number(d);
      0 > d && (d = Math.max(0, e2 + d));
      for (c2 = Number(c2 || 0); c2 < d; c2++) this[c2] = b;
      return this;
    };
  });
  function F(a2) {
    return a2 ? a2 : Array.prototype.fill;
  }
  z("Int8Array.prototype.fill", F);
  z("Uint8Array.prototype.fill", F);
  z("Uint8ClampedArray.prototype.fill", F);
  z("Int16Array.prototype.fill", F);
  z("Uint16Array.prototype.fill", F);
  z("Int32Array.prototype.fill", F);
  z("Uint32Array.prototype.fill", F);
  z("Float32Array.prototype.fill", F);
  z("Float64Array.prototype.fill", F);
  z("Object.is", function(a2) {
    return a2 ? a2 : function(b, c2) {
      return b === c2 ? 0 !== b || 1 / b === 1 / c2 : b !== b && c2 !== c2;
    };
  });
  z("Array.prototype.includes", function(a2) {
    return a2 ? a2 : function(b, c2) {
      var d = this;
      d instanceof String && (d = String(d));
      var e2 = d.length;
      c2 = c2 || 0;
      for (0 > c2 && (c2 = Math.max(c2 + e2, 0)); c2 < e2; c2++) {
        var g = d[c2];
        if (g === b || Object.is(g, b)) return true;
      }
      return false;
    };
  });
  z("String.prototype.includes", function(a2) {
    return a2 ? a2 : function(b, c2) {
      if (null == this) throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
      if (b instanceof RegExp) throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
      return -1 !== this.indexOf(b, c2 || 0);
    };
  });
  var ya = this || self;
  function Aa(a2, b) {
    a2 = a2.split(".");
    var c2 = ya;
    a2[0] in c2 || "undefined" == typeof c2.execScript || c2.execScript("var " + a2[0]);
    for (var d; a2.length && (d = a2.shift()); ) a2.length || void 0 === b ? c2[d] && c2[d] !== Object.prototype[d] ? c2 = c2[d] : c2 = c2[d] = {} : c2[d] = b;
  }
  function Ba(a2) {
    var b;
    a: {
      if (b = ya.navigator) {
        if (b = b.userAgent) break a;
      }
      b = "";
    }
    return -1 != b.indexOf(a2);
  }
  var Ca = Array.prototype.map ? function(a2, b) {
    return Array.prototype.map.call(a2, b, void 0);
  } : function(a2, b) {
    for (var c2 = a2.length, d = Array(c2), e2 = "string" === typeof a2 ? a2.split("") : a2, g = 0; g < c2; g++) g in e2 && (d[g] = b.call(void 0, e2[g], g, a2));
    return d;
  };
  var Da = {}, Ea = null;
  function Fa(a2) {
    var b = a2.length, c2 = 3 * b / 4;
    c2 % 3 ? c2 = Math.floor(c2) : -1 != "=.".indexOf(a2[b - 1]) && (c2 = -1 != "=.".indexOf(a2[b - 2]) ? c2 - 2 : c2 - 1);
    var d = new Uint8Array(c2), e2 = 0;
    Ga(a2, function(g) {
      d[e2++] = g;
    });
    return e2 !== c2 ? d.subarray(0, e2) : d;
  }
  function Ga(a2, b) {
    function c2(k) {
      for (; d < a2.length; ) {
        var l2 = a2.charAt(d++), m2 = Ea[l2];
        if (null != m2) return m2;
        if (!/^[\s\xa0]*$/.test(l2)) throw Error("Unknown base64 encoding at char: " + l2);
      }
      return k;
    }
    Ha();
    for (var d = 0; ; ) {
      var e2 = c2(-1), g = c2(0), f = c2(64), h = c2(64);
      if (64 === h && -1 === e2) break;
      b(e2 << 2 | g >> 4);
      64 != f && (b(g << 4 & 240 | f >> 2), 64 != h && b(f << 6 & 192 | h));
    }
  }
  function Ha() {
    if (!Ea) {
      Ea = {};
      for (var a2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c2 = 0; 5 > c2; c2++) {
        var d = a2.concat(b[c2].split(""));
        Da[c2] = d;
        for (var e2 = 0; e2 < d.length; e2++) {
          var g = d[e2];
          void 0 === Ea[g] && (Ea[g] = e2);
        }
      }
    }
  }
  var Ia = "undefined" !== typeof Uint8Array, Ja = !(Ba("Trident") || Ba("MSIE")) && "function" === typeof ya.btoa;
  function Ka(a2) {
    if (!Ja) {
      var b;
      void 0 === b && (b = 0);
      Ha();
      b = Da[b];
      for (var c2 = Array(Math.floor(a2.length / 3)), d = b[64] || "", e2 = 0, g = 0; e2 < a2.length - 2; e2 += 3) {
        var f = a2[e2], h = a2[e2 + 1], k = a2[e2 + 2], l2 = b[f >> 2];
        f = b[(f & 3) << 4 | h >> 4];
        h = b[(h & 15) << 2 | k >> 6];
        k = b[k & 63];
        c2[g++] = l2 + f + h + k;
      }
      l2 = 0;
      k = d;
      switch (a2.length - e2) {
        case 2:
          l2 = a2[e2 + 1], k = b[(l2 & 15) << 2] || d;
        case 1:
          a2 = a2[e2], c2[g] = b[a2 >> 2] + b[(a2 & 3) << 4 | l2 >> 4] + k + d;
      }
      return c2.join("");
    }
    for (b = ""; 10240 < a2.length; ) b += String.fromCharCode.apply(null, a2.subarray(0, 10240)), a2 = a2.subarray(10240);
    b += String.fromCharCode.apply(
      null,
      a2
    );
    return btoa(b);
  }
  var La = RegExp("[-_.]", "g");
  function Ma(a2) {
    switch (a2) {
      case "-":
        return "+";
      case "_":
        return "/";
      case ".":
        return "=";
      default:
        return "";
    }
  }
  function Na(a2) {
    if (!Ja) return Fa(a2);
    La.test(a2) && (a2 = a2.replace(La, Ma));
    a2 = atob(a2);
    for (var b = new Uint8Array(a2.length), c2 = 0; c2 < a2.length; c2++) b[c2] = a2.charCodeAt(c2);
    return b;
  }
  var Oa;
  function Pa() {
    return Oa || (Oa = new Uint8Array(0));
  }
  var Qa = {};
  var Ra = "function" === typeof Uint8Array.prototype.slice, G = 0, H = 0;
  function Sa(a2) {
    var b = 0 > a2;
    a2 = Math.abs(a2);
    var c2 = a2 >>> 0;
    a2 = Math.floor((a2 - c2) / 4294967296);
    b && (c2 = A(Ta(c2, a2)), b = c2.next().value, a2 = c2.next().value, c2 = b);
    G = c2 >>> 0;
    H = a2 >>> 0;
  }
  var Ua = "function" === typeof BigInt;
  function Ta(a2, b) {
    b = ~b;
    a2 ? a2 = ~a2 + 1 : b += 1;
    return [a2, b];
  }
  function Va(a2, b) {
    this.i = a2 >>> 0;
    this.h = b >>> 0;
  }
  function Wa(a2) {
    if (!a2) return Xa || (Xa = new Va(0, 0));
    if (!/^-?\d+$/.test(a2)) return null;
    if (16 > a2.length) Sa(Number(a2));
    else if (Ua) a2 = BigInt(a2), G = Number(a2 & BigInt(4294967295)) >>> 0, H = Number(a2 >> BigInt(32) & BigInt(4294967295));
    else {
      var b = +("-" === a2[0]);
      H = G = 0;
      for (var c2 = a2.length, d = b, e2 = (c2 - b) % 6 + b; e2 <= c2; d = e2, e2 += 6) d = Number(a2.slice(d, e2)), H *= 1e6, G = 1e6 * G + d, 4294967296 <= G && (H += G / 4294967296 | 0, G %= 4294967296);
      b && (b = A(Ta(G, H)), a2 = b.next().value, b = b.next().value, G = a2, H = b);
    }
    return new Va(G, H);
  }
  var Xa;
  function Ya(a2, b) {
    return Error("Invalid wire type: " + a2 + " (at position " + b + ")");
  }
  function Za() {
    return Error("Failed to read varint, encoding is invalid.");
  }
  function $a(a2, b) {
    return Error("Tried to read past the end of the data " + b + " > " + a2);
  }
  function K() {
    throw Error("Invalid UTF8");
  }
  function ab(a2, b) {
    b = String.fromCharCode.apply(null, b);
    return null == a2 ? b : a2 + b;
  }
  var bb = void 0, cb, db = "undefined" !== typeof TextDecoder, eb, fb = "undefined" !== typeof TextEncoder;
  var gb;
  function hb(a2) {
    if (a2 !== Qa) throw Error("illegal external caller");
  }
  function ib(a2, b) {
    hb(b);
    this.V = a2;
    if (null != a2 && 0 === a2.length) throw Error("ByteString should be constructed with non-empty values");
  }
  function jb() {
    return gb || (gb = new ib(null, Qa));
  }
  function kb(a2) {
    hb(Qa);
    var b = a2.V;
    b = null == b || Ia && null != b && b instanceof Uint8Array ? b : "string" === typeof b ? Na(b) : null;
    return null == b ? b : a2.V = b;
  }
  function lb(a2) {
    if ("string" === typeof a2) return { buffer: Na(a2), C: false };
    if (Array.isArray(a2)) return { buffer: new Uint8Array(a2), C: false };
    if (a2.constructor === Uint8Array) return { buffer: a2, C: false };
    if (a2.constructor === ArrayBuffer) return { buffer: new Uint8Array(a2), C: false };
    if (a2.constructor === ib) return { buffer: kb(a2) || Pa(), C: true };
    if (a2 instanceof Uint8Array) return { buffer: new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), C: false };
    throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
  }
  function mb(a2, b) {
    this.i = null;
    this.m = false;
    this.h = this.j = this.l = 0;
    nb(this, a2, b);
  }
  function nb(a2, b, c2) {
    c2 = void 0 === c2 ? {} : c2;
    a2.S = void 0 === c2.S ? false : c2.S;
    b && (b = lb(b), a2.i = b.buffer, a2.m = b.C, a2.l = 0, a2.j = a2.i.length, a2.h = a2.l);
  }
  mb.prototype.reset = function() {
    this.h = this.l;
  };
  function L(a2, b) {
    a2.h = b;
    if (b > a2.j) throw $a(a2.j, b);
  }
  function ob(a2) {
    var b = a2.i, c2 = a2.h, d = b[c2++], e2 = d & 127;
    if (d & 128 && (d = b[c2++], e2 |= (d & 127) << 7, d & 128 && (d = b[c2++], e2 |= (d & 127) << 14, d & 128 && (d = b[c2++], e2 |= (d & 127) << 21, d & 128 && (d = b[c2++], e2 |= d << 28, d & 128 && b[c2++] & 128 && b[c2++] & 128 && b[c2++] & 128 && b[c2++] & 128 && b[c2++] & 128))))) throw Za();
    L(a2, c2);
    return e2;
  }
  function pb(a2, b) {
    if (0 > b) throw Error("Tried to read a negative byte length: " + b);
    var c2 = a2.h, d = c2 + b;
    if (d > a2.j) throw $a(b, a2.j - c2);
    a2.h = d;
    return c2;
  }
  var qb = [];
  function rb() {
    this.h = [];
  }
  rb.prototype.length = function() {
    return this.h.length;
  };
  rb.prototype.end = function() {
    var a2 = this.h;
    this.h = [];
    return a2;
  };
  function sb(a2, b, c2) {
    for (; 0 < c2 || 127 < b; ) a2.h.push(b & 127 | 128), b = (b >>> 7 | c2 << 25) >>> 0, c2 >>>= 7;
    a2.h.push(b);
  }
  function M(a2, b) {
    for (; 127 < b; ) a2.h.push(b & 127 | 128), b >>>= 7;
    a2.h.push(b);
  }
  function tb(a2, b) {
    if (qb.length) {
      var c2 = qb.pop();
      nb(c2, a2, b);
      a2 = c2;
    } else a2 = new mb(a2, b);
    this.h = a2;
    this.j = this.h.h;
    this.i = this.l = -1;
    this.setOptions(b);
  }
  tb.prototype.setOptions = function(a2) {
    a2 = void 0 === a2 ? {} : a2;
    this.ca = void 0 === a2.ca ? false : a2.ca;
  };
  tb.prototype.reset = function() {
    this.h.reset();
    this.j = this.h.h;
    this.i = this.l = -1;
  };
  function ub(a2) {
    var b = a2.h;
    if (b.h == b.j) return false;
    a2.j = a2.h.h;
    var c2 = ob(a2.h) >>> 0;
    b = c2 >>> 3;
    c2 &= 7;
    if (!(0 <= c2 && 5 >= c2)) throw Ya(c2, a2.j);
    if (1 > b) throw Error("Invalid field number: " + b + " (at position " + a2.j + ")");
    a2.l = b;
    a2.i = c2;
    return true;
  }
  function vb(a2) {
    switch (a2.i) {
      case 0:
        if (0 != a2.i) vb(a2);
        else a: {
          a2 = a2.h;
          for (var b = a2.h, c2 = b + 10, d = a2.i; b < c2; ) if (0 === (d[b++] & 128)) {
            L(a2, b);
            break a;
          }
          throw Za();
        }
        break;
      case 1:
        a2 = a2.h;
        L(a2, a2.h + 8);
        break;
      case 2:
        2 != a2.i ? vb(a2) : (b = ob(a2.h) >>> 0, a2 = a2.h, L(a2, a2.h + b));
        break;
      case 5:
        a2 = a2.h;
        L(a2, a2.h + 4);
        break;
      case 3:
        b = a2.l;
        do {
          if (!ub(a2)) throw Error("Unmatched start-group tag: stream EOF");
          if (4 == a2.i) {
            if (a2.l != b) throw Error("Unmatched end-group tag");
            break;
          }
          vb(a2);
        } while (1);
        break;
      default:
        throw Ya(a2.i, a2.j);
    }
  }
  var wb = [];
  function xb() {
    this.j = [];
    this.i = 0;
    this.h = new rb();
  }
  function N(a2, b) {
    0 !== b.length && (a2.j.push(b), a2.i += b.length);
  }
  function yb(a2, b) {
    if (b = b.R) {
      N(a2, a2.h.end());
      for (var c2 = 0; c2 < b.length; c2++) N(a2, kb(b[c2]) || Pa());
    }
  }
  var O = "function" === typeof Symbol && "symbol" === typeof Symbol() ? Symbol() : void 0;
  function P(a2, b) {
    if (O) return a2[O] |= b;
    if (void 0 !== a2.A) return a2.A |= b;
    Object.defineProperties(a2, { A: { value: b, configurable: true, writable: true, enumerable: false } });
    return b;
  }
  function zb(a2, b) {
    O ? a2[O] && (a2[O] &= ~b) : void 0 !== a2.A && (a2.A &= ~b);
  }
  function Q(a2) {
    var b;
    O ? b = a2[O] : b = a2.A;
    return null == b ? 0 : b;
  }
  function R(a2, b) {
    O ? a2[O] = b : void 0 !== a2.A ? a2.A = b : Object.defineProperties(a2, { A: { value: b, configurable: true, writable: true, enumerable: false } });
  }
  function Ab(a2) {
    P(a2, 1);
    return a2;
  }
  function Bb(a2, b) {
    R(b, (a2 | 0) & -51);
  }
  function Cb(a2, b) {
    R(b, (a2 | 18) & -41);
  }
  var Db = {};
  function Eb(a2) {
    return null !== a2 && "object" === typeof a2 && !Array.isArray(a2) && a2.constructor === Object;
  }
  var Fb, Gb = [];
  R(Gb, 23);
  Fb = Object.freeze(Gb);
  function Hb(a2) {
    if (Q(a2.o) & 2) throw Error("Cannot mutate an immutable Message");
  }
  function Ib(a2) {
    var b = a2.length;
    (b = b ? a2[b - 1] : void 0) && Eb(b) ? b.g = 1 : (b = {}, a2.push((b.g = 1, b)));
  }
  function Jb(a2) {
    var b = a2.i + a2.G;
    return a2.B || (a2.B = a2.o[b] = {});
  }
  function S(a2, b) {
    return -1 === b ? null : b >= a2.i ? a2.B ? a2.B[b] : void 0 : a2.o[b + a2.G];
  }
  function U(a2, b, c2, d) {
    Hb(a2);
    Kb(a2, b, c2, d);
  }
  function Kb(a2, b, c2, d) {
    a2.j && (a2.j = void 0);
    b >= a2.i || d ? Jb(a2)[b] = c2 : (a2.o[b + a2.G] = c2, (a2 = a2.B) && b in a2 && delete a2[b]);
  }
  function Lb(a2, b, c2, d) {
    var e2 = S(a2, b);
    Array.isArray(e2) || (e2 = Fb);
    var g = Q(e2);
    g & 1 || Ab(e2);
    if (d) g & 2 || P(e2, 2), c2 & 1 || Object.freeze(e2);
    else {
      d = !(c2 & 2);
      var f = g & 2;
      c2 & 1 || !f ? d && g & 16 && !f && zb(e2, 16) : (e2 = Ab(Array.prototype.slice.call(e2)), Kb(a2, b, e2));
    }
    return e2;
  }
  function Mb(a2, b) {
    var c2 = S(a2, b);
    var d = null == c2 ? c2 : "number" === typeof c2 || "NaN" === c2 || "Infinity" === c2 || "-Infinity" === c2 ? Number(c2) : void 0;
    null != d && d !== c2 && Kb(a2, b, d);
    return d;
  }
  function Nb(a2, b, c2, d, e2) {
    a2.h || (a2.h = {});
    var g = a2.h[c2], f = Lb(a2, c2, 3, e2);
    if (!g) {
      var h = f;
      g = [];
      var k = !!(Q(a2.o) & 16);
      f = !!(Q(h) & 2);
      var l2 = h;
      !e2 && f && (h = Array.prototype.slice.call(h));
      for (var m2 = f, r2 = 0; r2 < h.length; r2++) {
        var p2 = h[r2];
        var n2 = b, q = false;
        q = void 0 === q ? false : q;
        p2 = Array.isArray(p2) ? new n2(p2) : q ? new n2() : void 0;
        if (void 0 !== p2) {
          n2 = p2.o;
          var t2 = q = Q(n2);
          f && (t2 |= 2);
          k && (t2 |= 16);
          t2 != q && R(n2, t2);
          n2 = t2;
          m2 = m2 || !!(2 & n2);
          g.push(p2);
        }
      }
      a2.h[c2] = g;
      k = Q(h);
      b = k | 33;
      b = m2 ? b & -9 : b | 8;
      k != b && (m2 = h, Object.isFrozen(m2) && (m2 = Array.prototype.slice.call(m2)), R(m2, b), h = m2);
      l2 !== h && Kb(
        a2,
        c2,
        h
      );
      (e2 || d && f) && P(g, 2);
      d && Object.freeze(g);
      return g;
    }
    e2 || (e2 = Object.isFrozen(g), d && !e2 ? Object.freeze(g) : !d && e2 && (g = Array.prototype.slice.call(g), a2.h[c2] = g));
    return g;
  }
  function Ob(a2, b, c2) {
    var d = !!(Q(a2.o) & 2);
    b = Nb(a2, b, c2, d, d);
    a2 = Lb(a2, c2, 3, d);
    if (!(d || Q(a2) & 8)) {
      for (d = 0; d < b.length; d++) {
        c2 = b[d];
        if (Q(c2.o) & 2) {
          var e2 = Pb(c2, false);
          e2.j = c2;
        } else e2 = c2;
        c2 !== e2 && (b[d] = e2, a2[d] = e2.o);
      }
      P(a2, 8);
    }
    return b;
  }
  function V(a2, b, c2) {
    if (null != c2 && "number" !== typeof c2) throw Error("Value of float/double field must be a number|null|undefined, found " + typeof c2 + ": " + c2);
    U(a2, b, c2);
  }
  function Qb(a2, b, c2, d, e2) {
    Hb(a2);
    var g = Nb(a2, c2, b, false, false);
    c2 = null != d ? d : new c2();
    a2 = Lb(a2, b, 2, false);
    void 0 != e2 ? (g.splice(e2, 0, c2), a2.splice(e2, 0, c2.o)) : (g.push(c2), a2.push(c2.o));
    c2.C() && zb(a2, 8);
    return c2;
  }
  function Rb(a2, b) {
    return null == a2 ? b : a2;
  }
  function W(a2, b, c2) {
    c2 = void 0 === c2 ? 0 : c2;
    return Rb(Mb(a2, b), c2);
  }
  var Sb;
  function Tb(a2) {
    switch (typeof a2) {
      case "number":
        return isFinite(a2) ? a2 : String(a2);
      case "object":
        if (a2) if (Array.isArray(a2)) {
          if (0 !== (Q(a2) & 128)) return a2 = Array.prototype.slice.call(a2), Ib(a2), a2;
        } else {
          if (Ia && null != a2 && a2 instanceof Uint8Array) return Ka(a2);
          if (a2 instanceof ib) {
            var b = a2.V;
            return null == b ? "" : "string" === typeof b ? b : a2.V = Ka(b);
          }
        }
    }
    return a2;
  }
  function Ub(a2, b, c2, d) {
    if (null != a2) {
      if (Array.isArray(a2)) a2 = Vb(a2, b, c2, void 0 !== d);
      else if (Eb(a2)) {
        var e2 = {}, g;
        for (g in a2) e2[g] = Ub(a2[g], b, c2, d);
        a2 = e2;
      } else a2 = b(a2, d);
      return a2;
    }
  }
  function Vb(a2, b, c2, d) {
    var e2 = Q(a2);
    d = d ? !!(e2 & 16) : void 0;
    a2 = Array.prototype.slice.call(a2);
    for (var g = 0; g < a2.length; g++) a2[g] = Ub(a2[g], b, c2, d);
    c2(e2, a2);
    return a2;
  }
  function Wb(a2) {
    return a2.ja === Db ? a2.toJSON() : Tb(a2);
  }
  function Xb(a2, b) {
    a2 & 128 && Ib(b);
  }
  function Yb(a2, b, c2) {
    c2 = void 0 === c2 ? Cb : c2;
    if (null != a2) {
      if (Ia && a2 instanceof Uint8Array) return a2.length ? new ib(new Uint8Array(a2), Qa) : jb();
      if (Array.isArray(a2)) {
        var d = Q(a2);
        if (d & 2) return a2;
        if (b && !(d & 32) && (d & 16 || 0 === d)) return R(a2, d | 2), a2;
        a2 = Vb(a2, Yb, d & 4 ? Cb : c2, true);
        b = Q(a2);
        b & 4 && b & 2 && Object.freeze(a2);
        return a2;
      }
      return a2.ja === Db ? Zb(a2) : a2;
    }
  }
  function $b(a2, b, c2, d, e2, g, f) {
    if (a2 = a2.h && a2.h[c2]) {
      d = Q(a2);
      d & 2 ? d = a2 : (g = Ca(a2, Zb), Cb(d, g), Object.freeze(g), d = g);
      Hb(b);
      f = null == d ? Fb : Ab([]);
      if (null != d) {
        g = !!d.length;
        for (a2 = 0; a2 < d.length; a2++) {
          var h = d[a2];
          g = g && !(Q(h.o) & 2);
          f[a2] = h.o;
        }
        g = (g ? 8 : 0) | 1;
        a2 = Q(f);
        (a2 & g) !== g && (Object.isFrozen(f) && (f = Array.prototype.slice.call(f)), R(f, a2 | g));
        b.h || (b.h = {});
        b.h[c2] = d;
      } else b.h && (b.h[c2] = void 0);
      Kb(b, c2, f, e2);
    } else U(b, c2, Yb(d, g, f), e2);
  }
  function Zb(a2) {
    if (Q(a2.o) & 2) return a2;
    a2 = Pb(a2, true);
    P(a2.o, 2);
    return a2;
  }
  function Pb(a2, b) {
    var c2 = a2.o, d = [];
    P(d, 16);
    var e2 = a2.constructor.h;
    e2 && d.push(e2);
    e2 = a2.B;
    if (e2) {
      d.length = c2.length;
      d.fill(void 0, d.length, c2.length);
      var g = {};
      d[d.length - 1] = g;
    }
    0 !== (Q(c2) & 128) && Ib(d);
    b = b || a2.C() ? Cb : Bb;
    g = a2.constructor;
    Sb = d;
    d = new g(d);
    Sb = void 0;
    a2.R && (d.R = a2.R.slice());
    g = !!(Q(c2) & 16);
    for (var f = e2 ? c2.length - 1 : c2.length, h = 0; h < f; h++) $b(a2, d, h - a2.G, c2[h], false, g, b);
    if (e2) for (var k in e2) $b(a2, d, +k, e2[k], true, g, b);
    return d;
  }
  function X(a2, b, c2) {
    null == a2 && (a2 = Sb);
    Sb = void 0;
    var d = this.constructor.i || 0, e2 = 0 < d, g = this.constructor.h, f = false;
    if (null == a2) {
      a2 = g ? [g] : [];
      var h = 48;
      var k = true;
      e2 && (d = 0, h |= 128);
      R(a2, h);
    } else {
      if (!Array.isArray(a2)) throw Error();
      if (g && g !== a2[0]) throw Error();
      var l2 = h = P(a2, 0);
      if (k = 0 !== (16 & l2)) (f = 0 !== (32 & l2)) || (l2 |= 32);
      if (e2) if (128 & l2) d = 0;
      else {
        if (0 < a2.length) {
          var m2 = a2[a2.length - 1];
          if (Eb(m2) && "g" in m2) {
            d = 0;
            l2 |= 128;
            delete m2.g;
            var r2 = true, p2;
            for (p2 in m2) {
              r2 = false;
              break;
            }
            r2 && a2.pop();
          }
        }
      }
      else if (128 & l2) throw Error();
      h !== l2 && R(a2, l2);
    }
    this.G = (g ? 0 : -1) - d;
    this.h = void 0;
    this.o = a2;
    a: {
      g = this.o.length;
      d = g - 1;
      if (g && (g = this.o[d], Eb(g))) {
        this.B = g;
        this.i = d - this.G;
        break a;
      }
      void 0 !== b && -1 < b ? (this.i = Math.max(b, d + 1 - this.G), this.B = void 0) : this.i = Number.MAX_VALUE;
    }
    if (!e2 && this.B && "g" in this.B) throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');
    if (c2) {
      b = k && !f && true;
      e2 = this.i;
      var n2;
      for (k = 0; k < c2.length; k++) f = c2[k], f < e2 ? (f += this.G, (d = a2[f]) ? ac(d, b) : a2[f] = Fb) : (n2 || (n2 = Jb(this)), (d = n2[f]) ? ac(d, b) : n2[f] = Fb);
    }
  }
  X.prototype.toJSON = function() {
    return Vb(this.o, Wb, Xb);
  };
  X.prototype.C = function() {
    return !!(Q(this.o) & 2);
  };
  function ac(a2, b) {
    if (Array.isArray(a2)) {
      var c2 = Q(a2), d = 1;
      !b || c2 & 2 || (d |= 16);
      (c2 & d) !== d && R(a2, c2 | d);
    }
  }
  X.prototype.ja = Db;
  X.prototype.toString = function() {
    return this.o.toString();
  };
  function bc(a2, b, c2) {
    if (c2) {
      var d = {}, e2;
      for (e2 in c2) {
        var g = c2[e2], f = g.ra;
        f || (d.J = g.xa || g.oa.W, g.ia ? (d.aa = cc(g.ia), f = /* @__PURE__ */ function(h) {
          return function(k, l2, m2) {
            return h.J(k, l2, m2, h.aa);
          };
        }(d)) : g.ka ? (d.Z = dc(g.da.P, g.ka), f = /* @__PURE__ */ function(h) {
          return function(k, l2, m2) {
            return h.J(k, l2, m2, h.Z);
          };
        }(d)) : f = d.J, g.ra = f);
        f(b, a2, g.da);
        d = { J: d.J, aa: d.aa, Z: d.Z };
      }
    }
    yb(b, a2);
  }
  var ec = Symbol();
  function fc(a2, b, c2) {
    return a2[ec] || (a2[ec] = function(d, e2) {
      return b(d, e2, c2);
    });
  }
  function gc(a2) {
    var b = a2[ec];
    if (!b) {
      var c2 = hc(a2);
      b = function(d, e2) {
        return ic(d, e2, c2);
      };
      a2[ec] = b;
    }
    return b;
  }
  function jc(a2) {
    var b = a2.ia;
    if (b) return gc(b);
    if (b = a2.wa) return fc(a2.da.P, b, a2.ka);
  }
  function kc(a2) {
    var b = jc(a2), c2 = a2.da, d = a2.oa.U;
    return b ? function(e2, g) {
      return d(e2, g, c2, b);
    } : function(e2, g) {
      return d(e2, g, c2);
    };
  }
  function lc(a2, b) {
    var c2 = a2[b];
    "function" == typeof c2 && 0 === c2.length && (c2 = c2(), a2[b] = c2);
    return Array.isArray(c2) && (mc in c2 || nc in c2 || 0 < c2.length && "function" == typeof c2[0]) ? c2 : void 0;
  }
  function oc(a2, b, c2, d, e2, g) {
    b.P = a2[0];
    var f = 1;
    if (a2.length > f && "number" !== typeof a2[f]) {
      var h = a2[f++];
      c2(b, h);
    }
    for (; f < a2.length; ) {
      c2 = a2[f++];
      for (var k = f + 1; k < a2.length && "number" !== typeof a2[k]; ) k++;
      h = a2[f++];
      k -= f;
      switch (k) {
        case 0:
          d(b, c2, h);
          break;
        case 1:
          (k = lc(a2, f)) ? (f++, e2(b, c2, h, k)) : d(b, c2, h, a2[f++]);
          break;
        case 2:
          k = f++;
          k = lc(a2, k);
          e2(b, c2, h, k, a2[f++]);
          break;
        case 3:
          g(b, c2, h, a2[f++], a2[f++], a2[f++]);
          break;
        case 4:
          g(b, c2, h, a2[f++], a2[f++], a2[f++], a2[f++]);
          break;
        default:
          throw Error("unexpected number of binary field arguments: " + k);
      }
    }
    return b;
  }
  var pc = Symbol();
  function cc(a2) {
    var b = a2[pc];
    if (!b) {
      var c2 = qc(a2);
      b = function(d, e2) {
        return rc(d, e2, c2);
      };
      a2[pc] = b;
    }
    return b;
  }
  function dc(a2, b) {
    var c2 = a2[pc];
    c2 || (c2 = function(d, e2) {
      return bc(d, e2, b);
    }, a2[pc] = c2);
    return c2;
  }
  var nc = Symbol();
  function sc(a2, b) {
    a2.push(b);
  }
  function tc(a2, b, c2) {
    a2.push(b, c2.W);
  }
  function uc(a2, b, c2, d) {
    var e2 = cc(d), g = qc(d).P, f = c2.W;
    a2.push(b, function(h, k, l2) {
      return f(h, k, l2, g, e2);
    });
  }
  function vc(a2, b, c2, d, e2, g) {
    var f = dc(d, g), h = c2.W;
    a2.push(b, function(k, l2, m2) {
      return h(k, l2, m2, d, f);
    });
  }
  function qc(a2) {
    var b = a2[nc];
    if (b) return b;
    b = oc(a2, a2[nc] = [], sc, tc, uc, vc);
    mc in a2 && nc in a2 && (a2.length = 0);
    return b;
  }
  var mc = Symbol();
  function wc(a2, b) {
    a2[0] = b;
  }
  function xc(a2, b, c2, d) {
    var e2 = c2.U;
    a2[b] = d ? function(g, f, h) {
      return e2(g, f, h, d);
    } : e2;
  }
  function yc(a2, b, c2, d, e2) {
    var g = c2.U, f = gc(d), h = hc(d).P;
    a2[b] = function(k, l2, m2) {
      return g(k, l2, m2, h, f, e2);
    };
  }
  function zc(a2, b, c2, d, e2, g, f) {
    var h = c2.U, k = fc(d, e2, g);
    a2[b] = function(l2, m2, r2) {
      return h(l2, m2, r2, d, k, f);
    };
  }
  function hc(a2) {
    var b = a2[mc];
    if (b) return b;
    b = oc(a2, a2[mc] = {}, wc, xc, yc, zc);
    mc in a2 && nc in a2 && (a2.length = 0);
    return b;
  }
  function ic(a2, b, c2) {
    for (; ub(b) && 4 != b.i; ) {
      var d = b.l, e2 = c2[d];
      if (!e2) {
        var g = c2[0];
        g && (g = g[d]) && (e2 = c2[d] = kc(g));
      }
      if (!e2 || !e2(b, a2, d)) {
        e2 = b;
        d = a2;
        g = e2.j;
        vb(e2);
        var f = e2;
        if (!f.ca) {
          e2 = f.h.h - g;
          f.h.h = g;
          f = f.h;
          if (0 == e2) e2 = jb();
          else {
            g = pb(f, e2);
            if (f.S && f.m) e2 = f.i.subarray(g, g + e2);
            else {
              f = f.i;
              var h = g;
              e2 = g + e2;
              e2 = h === e2 ? Pa() : Ra ? f.slice(h, e2) : new Uint8Array(f.subarray(h, e2));
            }
            e2 = 0 == e2.length ? jb() : new ib(e2, Qa);
          }
          (g = d.R) ? g.push(e2) : d.R = [e2];
        }
      }
    }
    return a2;
  }
  function rc(a2, b, c2) {
    for (var d = c2.length, e2 = 1 == d % 2, g = e2 ? 1 : 0; g < d; g += 2) (0, c2[g + 1])(b, a2, c2[g]);
    bc(a2, b, e2 ? c2[0] : void 0);
  }
  function Ac(a2, b) {
    return { U: a2, W: b };
  }
  var Y = Ac(function(a2, b, c2) {
    if (5 !== a2.i) return false;
    a2 = a2.h;
    var d = a2.i, e2 = a2.h, g = d[e2];
    var f = d[e2 + 1];
    var h = d[e2 + 2];
    d = d[e2 + 3];
    L(a2, a2.h + 4);
    f = (g << 0 | f << 8 | h << 16 | d << 24) >>> 0;
    a2 = 2 * (f >> 31) + 1;
    g = f >>> 23 & 255;
    f &= 8388607;
    U(b, c2, 255 == g ? f ? NaN : Infinity * a2 : 0 == g ? a2 * Math.pow(2, -149) * f : a2 * Math.pow(2, g - 150) * (f + Math.pow(2, 23)));
    return true;
  }, function(a2, b, c2) {
    b = Mb(b, c2);
    if (null != b) {
      M(a2.h, 8 * c2 + 5);
      a2 = a2.h;
      var d = +b;
      0 === d ? 0 < 1 / d ? G = H = 0 : (H = 0, G = 2147483648) : isNaN(d) ? (H = 0, G = 2147483647) : (d = (c2 = 0 > d ? -2147483648 : 0) ? -d : d, 34028234663852886e22 < d ? (H = 0, G = (c2 | 2139095040) >>> 0) : 11754943508222875e-54 > d ? (d = Math.round(d / Math.pow(2, -149)), H = 0, G = (c2 | d) >>> 0) : (b = Math.floor(Math.log(d) / Math.LN2), d *= Math.pow(2, -b), d = Math.round(8388608 * d), 16777216 <= d && ++b, H = 0, G = (c2 | b + 127 << 23 | d & 8388607) >>> 0));
      c2 = G;
      a2.h.push(c2 >>> 0 & 255);
      a2.h.push(c2 >>> 8 & 255);
      a2.h.push(c2 >>> 16 & 255);
      a2.h.push(c2 >>> 24 & 255);
    }
  }), Bc = Ac(function(a2, b, c2) {
    if (0 !== a2.i) return false;
    var d = a2.h, e2 = 0, g = a2 = 0, f = d.i, h = d.h;
    do {
      var k = f[h++];
      e2 |= (k & 127) << g;
      g += 7;
    } while (32 > g && k & 128);
    32 < g && (a2 |= (k & 127) >> 4);
    for (g = 3; 32 > g && k & 128; g += 7) k = f[h++], a2 |= (k & 127) << g;
    L(
      d,
      h
    );
    if (128 > k) {
      d = e2 >>> 0;
      k = a2 >>> 0;
      if (a2 = k & 2147483648) d = ~d + 1 >>> 0, k = ~k >>> 0, 0 == d && (k = k + 1 >>> 0);
      d = 4294967296 * k + (d >>> 0);
    } else throw Za();
    U(b, c2, a2 ? -d : d);
    return true;
  }, function(a2, b, c2) {
    b = S(b, c2);
    null != b && ("string" === typeof b && Wa(b), null != b && (M(a2.h, 8 * c2), "number" === typeof b ? (a2 = a2.h, Sa(b), sb(a2, G, H)) : (c2 = Wa(b), sb(a2.h, c2.i, c2.h))));
  }), Cc = Ac(function(a2, b, c2) {
    if (0 !== a2.i) return false;
    U(b, c2, ob(a2.h));
    return true;
  }, function(a2, b, c2) {
    b = S(b, c2);
    if (null != b && null != b) if (M(a2.h, 8 * c2), a2 = a2.h, c2 = b, 0 <= c2) M(a2, c2);
    else {
      for (b = 0; 9 > b; b++) a2.h.push(c2 & 127 | 128), c2 >>= 7;
      a2.h.push(1);
    }
  }), Dc = Ac(function(a2, b, c2) {
    if (2 !== a2.i) return false;
    var d = ob(a2.h) >>> 0;
    a2 = a2.h;
    var e2 = pb(a2, d);
    a2 = a2.i;
    if (db) {
      var g = a2, f;
      (f = cb) || (f = cb = new TextDecoder("utf-8", { fatal: true }));
      a2 = e2 + d;
      g = 0 === e2 && a2 === g.length ? g : g.subarray(e2, a2);
      try {
        var h = f.decode(g);
      } catch (r2) {
        if (void 0 === bb) {
          try {
            f.decode(new Uint8Array([128]));
          } catch (p2) {
          }
          try {
            f.decode(new Uint8Array([97])), bb = true;
          } catch (p2) {
            bb = false;
          }
        }
        !bb && (cb = void 0);
        throw r2;
      }
    } else {
      h = e2;
      d = h + d;
      e2 = [];
      for (var k = null, l2, m2; h < d; ) l2 = a2[h++], 128 > l2 ? e2.push(l2) : 224 > l2 ? h >= d ? K() : (m2 = a2[h++], 194 > l2 || 128 !== (m2 & 192) ? (h--, K()) : e2.push((l2 & 31) << 6 | m2 & 63)) : 240 > l2 ? h >= d - 1 ? K() : (m2 = a2[h++], 128 !== (m2 & 192) || 224 === l2 && 160 > m2 || 237 === l2 && 160 <= m2 || 128 !== ((g = a2[h++]) & 192) ? (h--, K()) : e2.push((l2 & 15) << 12 | (m2 & 63) << 6 | g & 63)) : 244 >= l2 ? h >= d - 2 ? K() : (m2 = a2[h++], 128 !== (m2 & 192) || 0 !== (l2 << 28) + (m2 - 144) >> 30 || 128 !== ((g = a2[h++]) & 192) || 128 !== ((f = a2[h++]) & 192) ? (h--, K()) : (l2 = (l2 & 7) << 18 | (m2 & 63) << 12 | (g & 63) << 6 | f & 63, l2 -= 65536, e2.push((l2 >> 10 & 1023) + 55296, (l2 & 1023) + 56320))) : K(), 8192 <= e2.length && (k = ab(k, e2), e2.length = 0);
      h = ab(k, e2);
    }
    U(b, c2, h);
    return true;
  }, function(a2, b, c2) {
    b = S(b, c2);
    if (null != b) {
      var d = false;
      d = void 0 === d ? false : d;
      if (fb) {
        if (d && /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(b)) throw Error("Found an unpaired surrogate");
        b = (eb || (eb = new TextEncoder())).encode(b);
      } else {
        for (var e2 = 0, g = new Uint8Array(3 * b.length), f = 0; f < b.length; f++) {
          var h = b.charCodeAt(f);
          if (128 > h) g[e2++] = h;
          else {
            if (2048 > h) g[e2++] = h >> 6 | 192;
            else {
              if (55296 <= h && 57343 >= h) {
                if (56319 >= h && f < b.length) {
                  var k = b.charCodeAt(++f);
                  if (56320 <= k && 57343 >= k) {
                    h = 1024 * (h - 55296) + k - 56320 + 65536;
                    g[e2++] = h >> 18 | 240;
                    g[e2++] = h >> 12 & 63 | 128;
                    g[e2++] = h >> 6 & 63 | 128;
                    g[e2++] = h & 63 | 128;
                    continue;
                  } else f--;
                }
                if (d) throw Error("Found an unpaired surrogate");
                h = 65533;
              }
              g[e2++] = h >> 12 | 224;
              g[e2++] = h >> 6 & 63 | 128;
            }
            g[e2++] = h & 63 | 128;
          }
        }
        b = e2 === g.length ? g : g.subarray(0, e2);
      }
      M(a2.h, 8 * c2 + 2);
      M(a2.h, b.length);
      N(a2, a2.h.end());
      N(a2, b);
    }
  }), Ec = Ac(function(a2, b, c2, d, e2) {
    if (2 !== a2.i) return false;
    b = Qb(b, c2, d);
    c2 = a2.h.j;
    d = ob(a2.h) >>> 0;
    var g = a2.h.h + d, f = g - c2;
    0 >= f && (a2.h.j = g, e2(b, a2, void 0, void 0, void 0), f = g - a2.h.h);
    if (f) throw Error("Message parsing ended unexpectedly. Expected to read " + (d + " bytes, instead read " + (d - f) + " bytes, either the data ended unexpectedly or the message misreported its own length"));
    a2.h.h = g;
    a2.h.j = c2;
    return true;
  }, function(a2, b, c2, d, e2) {
    b = Ob(b, d, c2);
    if (null != b) for (d = 0; d < b.length; d++) {
      var g = a2;
      M(g.h, 8 * c2 + 2);
      var f = g.h.end();
      N(g, f);
      f.push(g.i);
      g = f;
      e2(b[d], a2);
      f = a2;
      var h = g.pop();
      for (h = f.i + f.h.length() - h; 127 < h; ) g.push(h & 127 | 128), h >>>= 7, f.i++;
      g.push(h);
      f.i++;
    }
  });
  function Fc(a2) {
    return function(b, c2) {
      a: {
        if (wb.length) {
          var d = wb.pop();
          d.setOptions(c2);
          nb(d.h, b, c2);
          b = d;
        } else b = new tb(b, c2);
        try {
          var e2 = hc(a2);
          var g = ic(new e2.P(), b, e2);
          break a;
        } finally {
          e2 = b.h, e2.i = null, e2.m = false, e2.l = 0, e2.j = 0, e2.h = 0, e2.S = false, b.l = -1, b.i = -1, 100 > wb.length && wb.push(b);
        }
        g = void 0;
      }
      return g;
    };
  }
  function Gc(a2) {
    return function() {
      var b = new xb();
      rc(this, b, qc(a2));
      N(b, b.h.end());
      for (var c2 = new Uint8Array(b.i), d = b.j, e2 = d.length, g = 0, f = 0; f < e2; f++) {
        var h = d[f];
        c2.set(h, g);
        g += h.length;
      }
      b.j = [c2];
      return c2;
    };
  }
  function Z(a2) {
    X.call(this, a2);
  }
  na(Z, X);
  var Hc = [Z, 1, Cc, 2, Y, 3, Dc, 4, Dc];
  Z.prototype.l = Gc(Hc);
  function Ic(a2) {
    X.call(this, a2, -1, Jc);
  }
  na(Ic, X);
  Ic.prototype.addClassification = function(a2, b) {
    Qb(this, 1, Z, a2, b);
    return this;
  };
  var Jc = [1], Kc = Fc([Ic, 1, Ec, Hc]);
  function Lc(a2) {
    X.call(this, a2);
  }
  na(Lc, X);
  var Mc = [Lc, 1, Y, 2, Y, 3, Y, 4, Y, 5, Y];
  Lc.prototype.l = Gc(Mc);
  function Nc(a2) {
    X.call(this, a2, -1, Oc);
  }
  na(Nc, X);
  var Oc = [1], Pc = Fc([Nc, 1, Ec, Mc]);
  function Qc(a2) {
    X.call(this, a2);
  }
  na(Qc, X);
  var Rc = [Qc, 1, Y, 2, Y, 3, Y, 4, Y, 5, Y, 6, Bc], Sc = Fc(Rc);
  Qc.prototype.l = Gc(Rc);
  function Tc(a2, b, c2) {
    c2 = a2.createShader(0 === c2 ? a2.VERTEX_SHADER : a2.FRAGMENT_SHADER);
    a2.shaderSource(c2, b);
    a2.compileShader(c2);
    if (!a2.getShaderParameter(c2, a2.COMPILE_STATUS)) throw Error("Could not compile WebGL shader.\n\n" + a2.getShaderInfoLog(c2));
    return c2;
  }
  function Uc(a2) {
    return Ob(a2, Z, 1).map(function(b) {
      var c2 = S(b, 1);
      return { index: null == c2 ? 0 : c2, qa: W(b, 2), label: null != S(b, 3) ? Rb(S(b, 3), "") : void 0, displayName: null != S(b, 4) ? Rb(S(b, 4), "") : void 0 };
    });
  }
  function Vc(a2) {
    return { x: W(a2, 1), y: W(a2, 2), z: W(a2, 3), visibility: null != Mb(a2, 4) ? W(a2, 4) : void 0 };
  }
  function Wc(a2, b) {
    this.i = a2;
    this.h = b;
    this.m = 0;
  }
  function Xc(a2, b, c2) {
    Yc(a2, b);
    if ("function" === typeof a2.h.canvas.transferToImageBitmap) return Promise.resolve(a2.h.canvas.transferToImageBitmap());
    if (c2) return Promise.resolve(a2.h.canvas);
    if ("function" === typeof createImageBitmap) return createImageBitmap(a2.h.canvas);
    void 0 === a2.j && (a2.j = document.createElement("canvas"));
    return new Promise(function(d) {
      a2.j.height = a2.h.canvas.height;
      a2.j.width = a2.h.canvas.width;
      a2.j.getContext("2d", {}).drawImage(a2.h.canvas, 0, 0, a2.h.canvas.width, a2.h.canvas.height);
      d(a2.j);
    });
  }
  function Yc(a2, b) {
    var c2 = a2.h;
    if (void 0 === a2.s) {
      var d = Tc(c2, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), e2 = Tc(c2, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), g = c2.createProgram();
      c2.attachShader(g, d);
      c2.attachShader(g, e2);
      c2.linkProgram(g);
      if (!c2.getProgramParameter(g, c2.LINK_STATUS)) throw Error("Could not compile WebGL program.\n\n" + c2.getProgramInfoLog(g));
      d = a2.s = g;
      c2.useProgram(d);
      e2 = c2.getUniformLocation(d, "sampler0");
      a2.l = { O: c2.getAttribLocation(d, "aVertex"), N: c2.getAttribLocation(d, "aTex"), ya: e2 };
      a2.v = c2.createBuffer();
      c2.bindBuffer(c2.ARRAY_BUFFER, a2.v);
      c2.enableVertexAttribArray(a2.l.O);
      c2.vertexAttribPointer(a2.l.O, 2, c2.FLOAT, false, 0, 0);
      c2.bufferData(c2.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c2.STATIC_DRAW);
      c2.bindBuffer(c2.ARRAY_BUFFER, null);
      a2.u = c2.createBuffer();
      c2.bindBuffer(c2.ARRAY_BUFFER, a2.u);
      c2.enableVertexAttribArray(a2.l.N);
      c2.vertexAttribPointer(
        a2.l.N,
        2,
        c2.FLOAT,
        false,
        0,
        0
      );
      c2.bufferData(c2.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), c2.STATIC_DRAW);
      c2.bindBuffer(c2.ARRAY_BUFFER, null);
      c2.uniform1i(e2, 0);
    }
    d = a2.l;
    c2.useProgram(a2.s);
    c2.canvas.width = b.width;
    c2.canvas.height = b.height;
    c2.viewport(0, 0, b.width, b.height);
    c2.activeTexture(c2.TEXTURE0);
    a2.i.bindTexture2d(b.glName);
    c2.enableVertexAttribArray(d.O);
    c2.bindBuffer(c2.ARRAY_BUFFER, a2.v);
    c2.vertexAttribPointer(d.O, 2, c2.FLOAT, false, 0, 0);
    c2.enableVertexAttribArray(d.N);
    c2.bindBuffer(c2.ARRAY_BUFFER, a2.u);
    c2.vertexAttribPointer(
      d.N,
      2,
      c2.FLOAT,
      false,
      0,
      0
    );
    c2.bindFramebuffer(c2.DRAW_FRAMEBUFFER ? c2.DRAW_FRAMEBUFFER : c2.FRAMEBUFFER, null);
    c2.clearColor(0, 0, 0, 0);
    c2.clear(c2.COLOR_BUFFER_BIT);
    c2.colorMask(true, true, true, true);
    c2.drawArrays(c2.TRIANGLE_FAN, 0, 4);
    c2.disableVertexAttribArray(d.O);
    c2.disableVertexAttribArray(d.N);
    c2.bindBuffer(c2.ARRAY_BUFFER, null);
    a2.i.bindTexture2d(0);
  }
  function Zc(a2) {
    this.h = a2;
  }
  var $c = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
  function ad(a2, b) {
    return b + a2;
  }
  function bd(a2, b) {
    window[a2] = b;
  }
  function cd(a2) {
    var b = document.createElement("script");
    b.setAttribute("src", a2);
    b.setAttribute("crossorigin", "anonymous");
    return new Promise(function(c2) {
      b.addEventListener("load", function() {
        c2();
      }, false);
      b.addEventListener("error", function() {
        c2();
      }, false);
      document.body.appendChild(b);
    });
  }
  function dd() {
    return E(function(a2) {
      switch (a2.h) {
        case 1:
          return a2.s = 2, D(a2, WebAssembly.instantiate($c), 4);
        case 4:
          a2.h = 3;
          a2.s = 0;
          break;
        case 2:
          return a2.s = 0, a2.l = null, a2.return(false);
        case 3:
          return a2.return(true);
      }
    });
  }
  function ed(a2) {
    this.h = a2;
    this.listeners = {};
    this.l = {};
    this.L = {};
    this.s = {};
    this.v = {};
    this.M = this.u = this.ga = true;
    this.I = Promise.resolve();
    this.fa = "";
    this.D = {};
    this.locateFile = a2 && a2.locateFile || ad;
    if ("object" === typeof window) var b = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
    else if ("undefined" !== typeof location) b = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
    else throw Error("solutions can only be loaded on a web page or in a web worker");
    this.ha = b;
    if (a2.options) {
      b = A(Object.keys(a2.options));
      for (var c2 = b.next(); !c2.done; c2 = b.next()) {
        c2 = c2.value;
        var d = a2.options[c2].default;
        void 0 !== d && (this.l[c2] = "function" === typeof d ? d() : d);
      }
    }
  }
  x = ed.prototype;
  x.close = function() {
    this.j && this.j.delete();
    return Promise.resolve();
  };
  function fd(a2) {
    var b, c2, d, e2, g, f, h, k, l2, m2, r2;
    return E(function(p2) {
      switch (p2.h) {
        case 1:
          if (!a2.ga) return p2.return();
          b = void 0 === a2.h.files ? [] : "function" === typeof a2.h.files ? a2.h.files(a2.l) : a2.h.files;
          return D(p2, dd(), 2);
        case 2:
          c2 = p2.i;
          if ("object" === typeof window) return bd("createMediapipeSolutionsWasm", { locateFile: a2.locateFile }), bd("createMediapipeSolutionsPackedAssets", { locateFile: a2.locateFile }), f = b.filter(function(n2) {
            return void 0 !== n2.data;
          }), h = b.filter(function(n2) {
            return void 0 === n2.data;
          }), k = Promise.all(f.map(function(n2) {
            var q = gd(a2, n2.url);
            if (void 0 !== n2.path) {
              var t2 = n2.path;
              q = q.then(function(w) {
                a2.overrideFile(t2, w);
                return Promise.resolve(w);
              });
            }
            return q;
          })), l2 = Promise.all(h.map(function(n2) {
            return void 0 === n2.simd || n2.simd && c2 || !n2.simd && !c2 ? cd(a2.locateFile(n2.url, a2.ha)) : Promise.resolve();
          })).then(function() {
            var n2, q, t2;
            return E(function(w) {
              if (1 == w.h) return n2 = window.createMediapipeSolutionsWasm, q = window.createMediapipeSolutionsPackedAssets, t2 = a2, D(w, n2(q), 2);
              t2.i = w.i;
              w.h = 0;
            });
          }), m2 = function() {
            return E(function(n2) {
              a2.h.graph && a2.h.graph.url ? n2 = D(
                n2,
                gd(a2, a2.h.graph.url),
                0
              ) : (n2.h = 0, n2 = void 0);
              return n2;
            });
          }(), D(p2, Promise.all([l2, k, m2]), 7);
          if ("function" !== typeof importScripts) throw Error("solutions can only be loaded on a web page or in a web worker");
          d = b.filter(function(n2) {
            return void 0 === n2.simd || n2.simd && c2 || !n2.simd && !c2;
          }).map(function(n2) {
            return a2.locateFile(n2.url, a2.ha);
          });
          importScripts.apply(null, ea(d));
          e2 = a2;
          return D(p2, createMediapipeSolutionsWasm(Module), 6);
        case 6:
          e2.i = p2.i;
          a2.m = new OffscreenCanvas(1, 1);
          a2.i.canvas = a2.m;
          g = a2.i.GL.createContext(a2.m, {
            antialias: false,
            alpha: false,
            va: "undefined" !== typeof WebGL2RenderingContext ? 2 : 1
          });
          a2.i.GL.makeContextCurrent(g);
          p2.h = 4;
          break;
        case 7:
          a2.m = document.createElement("canvas");
          r2 = a2.m.getContext("webgl2", {});
          if (!r2 && (r2 = a2.m.getContext("webgl", {}), !r2)) return alert("Failed to create WebGL canvas context when passing video frame."), p2.return();
          a2.K = r2;
          a2.i.canvas = a2.m;
          a2.i.createContext(a2.m, true, true, {});
        case 4:
          a2.j = new a2.i.SolutionWasm(), a2.ga = false, p2.h = 0;
      }
    });
  }
  function hd(a2) {
    var b, c2, d, e2, g, f, h, k;
    return E(function(l2) {
      if (1 == l2.h) {
        if (a2.h.graph && a2.h.graph.url && a2.fa === a2.h.graph.url) return l2.return();
        a2.u = true;
        if (!a2.h.graph || !a2.h.graph.url) {
          l2.h = 2;
          return;
        }
        a2.fa = a2.h.graph.url;
        return D(l2, gd(a2, a2.h.graph.url), 3);
      }
      2 != l2.h && (b = l2.i, a2.j.loadGraph(b));
      c2 = A(Object.keys(a2.D));
      for (d = c2.next(); !d.done; d = c2.next()) e2 = d.value, a2.j.overrideFile(e2, a2.D[e2]);
      a2.D = {};
      if (a2.h.listeners) for (g = A(a2.h.listeners), f = g.next(); !f.done; f = g.next()) h = f.value, id(a2, h);
      k = a2.l;
      a2.l = {};
      a2.setOptions(k);
      l2.h = 0;
    });
  }
  x.reset = function() {
    var a2 = this;
    return E(function(b) {
      a2.j && (a2.j.reset(), a2.s = {}, a2.v = {});
      b.h = 0;
    });
  };
  x.setOptions = function(a2, b) {
    var c2 = this;
    if (b = b || this.h.options) {
      for (var d = [], e2 = [], g = {}, f = A(Object.keys(a2)), h = f.next(); !h.done; g = { X: g.X, Y: g.Y }, h = f.next()) if (h = h.value, !(h in this.l && this.l[h] === a2[h])) {
        this.l[h] = a2[h];
        var k = b[h];
        void 0 !== k && (k.onChange && (g.X = k.onChange, g.Y = a2[h], d.push(/* @__PURE__ */ function(l2) {
          return function() {
            var m2;
            return E(function(r2) {
              if (1 == r2.h) return D(r2, l2.X(l2.Y), 2);
              m2 = r2.i;
              true === m2 && (c2.u = true);
              r2.h = 0;
            });
          };
        }(g))), k.graphOptionXref && (h = Object.assign(
          {},
          { calculatorName: "", calculatorIndex: 0 },
          k.graphOptionXref,
          { valueNumber: 1 === k.type ? a2[h] : 0, valueBoolean: 0 === k.type ? a2[h] : false, valueString: 2 === k.type ? a2[h] : "" }
        ), e2.push(h)));
      }
      if (0 !== d.length || 0 !== e2.length) this.u = true, this.H = (void 0 === this.H ? [] : this.H).concat(e2), this.F = (void 0 === this.F ? [] : this.F).concat(d);
    }
  };
  function jd(a2) {
    var b, c2, d, e2, g, f, h;
    return E(function(k) {
      switch (k.h) {
        case 1:
          if (!a2.u) return k.return();
          if (!a2.F) {
            k.h = 2;
            break;
          }
          b = A(a2.F);
          c2 = b.next();
        case 3:
          if (c2.done) {
            k.h = 5;
            break;
          }
          d = c2.value;
          return D(k, d(), 4);
        case 4:
          c2 = b.next();
          k.h = 3;
          break;
        case 5:
          a2.F = void 0;
        case 2:
          if (a2.H) {
            e2 = new a2.i.GraphOptionChangeRequestList();
            g = A(a2.H);
            for (f = g.next(); !f.done; f = g.next()) h = f.value, e2.push_back(h);
            a2.j.changeOptions(e2);
            e2.delete();
            a2.H = void 0;
          }
          a2.u = false;
          k.h = 0;
      }
    });
  }
  x.initialize = function() {
    var a2 = this;
    return E(function(b) {
      return 1 == b.h ? D(b, fd(a2), 2) : 3 != b.h ? D(b, hd(a2), 3) : D(b, jd(a2), 0);
    });
  };
  function gd(a2, b) {
    var c2, d;
    return E(function(e2) {
      if (b in a2.L) return e2.return(a2.L[b]);
      c2 = a2.locateFile(b, "");
      d = fetch(c2).then(function(g) {
        return g.arrayBuffer();
      });
      a2.L[b] = d;
      return e2.return(d);
    });
  }
  x.overrideFile = function(a2, b) {
    this.j ? this.j.overrideFile(a2, b) : this.D[a2] = b;
  };
  x.clearOverriddenFiles = function() {
    this.D = {};
    this.j && this.j.clearOverriddenFiles();
  };
  x.send = function(a2, b) {
    var c2 = this, d, e2, g, f, h, k, l2, m2, r2;
    return E(function(p2) {
      switch (p2.h) {
        case 1:
          if (!c2.h.inputs) return p2.return();
          d = 1e3 * (void 0 === b || null === b ? performance.now() : b);
          return D(p2, c2.I, 2);
        case 2:
          return D(p2, c2.initialize(), 3);
        case 3:
          e2 = new c2.i.PacketDataList();
          g = A(Object.keys(a2));
          for (f = g.next(); !f.done; f = g.next()) if (h = f.value, k = c2.h.inputs[h]) {
            a: {
              var n2 = a2[h];
              switch (k.type) {
                case "video":
                  var q = c2.s[k.stream];
                  q || (q = new Wc(c2.i, c2.K), c2.s[k.stream] = q);
                  0 === q.m && (q.m = q.i.createTexture());
                  if ("undefined" !== typeof HTMLVideoElement && n2 instanceof HTMLVideoElement) {
                    var t2 = n2.videoWidth;
                    var w = n2.videoHeight;
                  } else "undefined" !== typeof HTMLImageElement && n2 instanceof HTMLImageElement ? (t2 = n2.naturalWidth, w = n2.naturalHeight) : (t2 = n2.width, w = n2.height);
                  w = { glName: q.m, width: t2, height: w };
                  t2 = q.h;
                  t2.canvas.width = w.width;
                  t2.canvas.height = w.height;
                  t2.activeTexture(t2.TEXTURE0);
                  q.i.bindTexture2d(q.m);
                  t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, n2);
                  q.i.bindTexture2d(0);
                  q = w;
                  break a;
                case "detections":
                  q = c2.s[k.stream];
                  q || (q = new Zc(c2.i), c2.s[k.stream] = q);
                  q.data || (q.data = new q.h.DetectionListData());
                  q.data.reset(n2.length);
                  for (w = 0; w < n2.length; ++w) {
                    t2 = n2[w];
                    var v = q.data, B = v.setBoundingBox, J = w;
                    var I = t2.la;
                    var u2 = new Qc();
                    V(u2, 1, I.sa);
                    V(u2, 2, I.ta);
                    V(u2, 3, I.height);
                    V(u2, 4, I.width);
                    V(u2, 5, I.rotation);
                    U(u2, 6, I.pa);
                    I = u2.l();
                    B.call(v, J, I);
                    if (t2.ea) for (v = 0; v < t2.ea.length; ++v) {
                      u2 = t2.ea[v];
                      B = q.data;
                      J = B.addNormalizedLandmark;
                      I = w;
                      u2 = Object.assign({}, u2, { visibility: u2.visibility ? u2.visibility : 0 });
                      var C2 = new Lc();
                      V(C2, 1, u2.x);
                      V(C2, 2, u2.y);
                      V(C2, 3, u2.z);
                      u2.visibility && V(C2, 4, u2.visibility);
                      u2 = C2.l();
                      J.call(
                        B,
                        I,
                        u2
                      );
                    }
                    if (t2.ba) for (v = 0; v < t2.ba.length; ++v) B = q.data, J = B.addClassification, I = w, u2 = t2.ba[v], C2 = new Z(), V(C2, 2, u2.qa), u2.index && U(C2, 1, u2.index), u2.label && U(C2, 3, u2.label), u2.displayName && U(C2, 4, u2.displayName), u2 = C2.l(), J.call(B, I, u2);
                  }
                  q = q.data;
                  break a;
                default:
                  q = {};
              }
            }
            l2 = q;
            m2 = k.stream;
            switch (k.type) {
              case "video":
                e2.pushTexture2d(Object.assign({}, l2, { stream: m2, timestamp: d }));
                break;
              case "detections":
                r2 = l2;
                r2.stream = m2;
                r2.timestamp = d;
                e2.pushDetectionList(r2);
                break;
              default:
                throw Error("Unknown input config type: '" + k.type + "'");
            }
          }
          c2.j.send(e2);
          return D(p2, c2.I, 4);
        case 4:
          e2.delete(), p2.h = 0;
      }
    });
  };
  function kd(a2, b, c2) {
    var d, e2, g, f, h, k, l2, m2, r2, p2, n2, q, t2, w;
    return E(function(v) {
      switch (v.h) {
        case 1:
          if (!c2) return v.return(b);
          d = {};
          e2 = 0;
          g = A(Object.keys(c2));
          for (f = g.next(); !f.done; f = g.next()) h = f.value, k = c2[h], "string" !== typeof k && "texture" === k.type && void 0 !== b[k.stream] && ++e2;
          1 < e2 && (a2.M = false);
          l2 = A(Object.keys(c2));
          f = l2.next();
        case 2:
          if (f.done) {
            v.h = 4;
            break;
          }
          m2 = f.value;
          r2 = c2[m2];
          if ("string" === typeof r2) return t2 = d, w = m2, D(v, ld(a2, m2, b[r2]), 14);
          p2 = b[r2.stream];
          if ("detection_list" === r2.type) {
            if (p2) {
              var B = p2.getRectList();
              for (var J = p2.getLandmarksList(), I = p2.getClassificationsList(), u2 = [], C2 = 0; C2 < B.size(); ++C2) {
                var T = Sc(B.get(C2)), od = W(T, 1), pd = W(T, 2), qd = W(T, 3), rd = W(T, 4), sd = W(T, 5, 0), za = void 0;
                za = void 0 === za ? 0 : za;
                T = { la: { sa: od, ta: pd, height: qd, width: rd, rotation: sd, pa: Rb(S(T, 6), za) }, ea: Ob(Pc(J.get(C2)), Lc, 1).map(Vc), ba: Uc(Kc(I.get(C2))) };
                u2.push(T);
              }
              B = u2;
            } else B = [];
            d[m2] = B;
            v.h = 7;
            break;
          }
          if ("proto_list" === r2.type) {
            if (p2) {
              B = Array(p2.size());
              for (J = 0; J < p2.size(); J++) B[J] = p2.get(J);
              p2.delete();
            } else B = [];
            d[m2] = B;
            v.h = 7;
            break;
          }
          if (void 0 === p2) {
            v.h = 3;
            break;
          }
          if ("float_list" === r2.type) {
            d[m2] = p2;
            v.h = 7;
            break;
          }
          if ("proto" === r2.type) {
            d[m2] = p2;
            v.h = 7;
            break;
          }
          if ("texture" !== r2.type) throw Error("Unknown output config type: '" + r2.type + "'");
          n2 = a2.v[m2];
          n2 || (n2 = new Wc(a2.i, a2.K), a2.v[m2] = n2);
          return D(v, Xc(n2, p2, a2.M), 13);
        case 13:
          q = v.i, d[m2] = q;
        case 7:
          r2.transform && d[m2] && (d[m2] = r2.transform(d[m2]));
          v.h = 3;
          break;
        case 14:
          t2[w] = v.i;
        case 3:
          f = l2.next();
          v.h = 2;
          break;
        case 4:
          return v.return(d);
      }
    });
  }
  function ld(a2, b, c2) {
    var d;
    return E(function(e2) {
      return "number" === typeof c2 || c2 instanceof Uint8Array || c2 instanceof a2.i.Uint8BlobList ? e2.return(c2) : c2 instanceof a2.i.Texture2dDataOut ? (d = a2.v[b], d || (d = new Wc(a2.i, a2.K), a2.v[b] = d), e2.return(Xc(d, c2, a2.M))) : e2.return(void 0);
    });
  }
  function id(a2, b) {
    for (var c2 = b.name || "$", d = [].concat(ea(b.wants)), e2 = new a2.i.StringList(), g = A(b.wants), f = g.next(); !f.done; f = g.next()) e2.push_back(f.value);
    g = a2.i.PacketListener.implement({ onResults: function(h) {
      for (var k = {}, l2 = 0; l2 < b.wants.length; ++l2) k[d[l2]] = h.get(l2);
      var m2 = a2.listeners[c2];
      m2 && (a2.I = kd(a2, k, b.outs).then(function(r2) {
        r2 = m2(r2);
        for (var p2 = 0; p2 < b.wants.length; ++p2) {
          var n2 = k[d[p2]];
          "object" === typeof n2 && n2.hasOwnProperty && n2.hasOwnProperty("delete") && n2.delete();
        }
        r2 && (a2.I = r2);
      }));
    } });
    a2.j.attachMultiListener(e2, g);
    e2.delete();
  }
  x.onResults = function(a2, b) {
    this.listeners[b || "$"] = a2;
  };
  Aa("Solution", ed);
  Aa("OptionType", { BOOL: 0, NUMBER: 1, ua: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
  function md(a2) {
    void 0 === a2 && (a2 = 0);
    switch (a2) {
      case 1:
        return "selfie_segmentation_landscape.tflite";
      default:
        return "selfie_segmentation.tflite";
    }
  }
  function nd(a2) {
    var b = this;
    a2 = a2 || {};
    this.h = new ed({ locateFile: a2.locateFile, files: function(c2) {
      return [{ simd: true, url: "selfie_segmentation_solution_simd_wasm_bin.js" }, { simd: false, url: "selfie_segmentation_solution_wasm_bin.js" }, { data: true, url: md(c2.modelSelection) }];
    }, graph: { url: "selfie_segmentation.binarypb" }, listeners: [{ wants: ["segmentation_mask", "image_transformed"], outs: { image: { type: "texture", stream: "image_transformed" }, segmentationMask: { type: "texture", stream: "segmentation_mask" } } }], inputs: { image: {
      type: "video",
      stream: "input_frames_gpu"
    } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "object" !== typeof window || void 0 === window.navigator ? false : "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, modelSelection: {
      type: 1,
      graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorModelSelection", fieldName: "int_value" },
      onChange: function(c2) {
        var d, e2, g;
        return E(function(f) {
          if (1 == f.h) return d = md(c2), e2 = "third_party/mediapipe/modules/selfie_segmentation/" + d, D(f, gd(b.h, d), 2);
          g = f.i;
          b.h.overrideFile(e2, g);
          return f.return(true);
        });
      }
    } } });
  }
  x = nd.prototype;
  x.close = function() {
    this.h.close();
    return Promise.resolve();
  };
  x.onResults = function(a2) {
    this.h.onResults(a2);
  };
  x.initialize = function() {
    var a2 = this;
    return E(function(b) {
      return D(b, a2.h.initialize(), 0);
    });
  };
  x.reset = function() {
    this.h.reset();
  };
  x.send = function(a2) {
    var b = this;
    return E(function(c2) {
      return D(c2, b.h.send(a2), 0);
    });
  };
  x.setOptions = function(a2) {
    this.h.setOptions(a2);
  };
  Aa("SelfieSegmentation", nd);
  Aa("VERSION", "0.1.1675465747");
}).call(commonjsGlobal);
class Mediapipe {
  constructor() {
    __publicField(this, "segmenter");
    __publicField(this, "canvasId", "");
    __publicField(this, "titleVideo", "");
    __publicField(this, "mode", "none");
    __publicField(this, "urlImage", "");
    __publicField(this, "animationId", null);
    __publicField(this, "loop", async () => {
      const video = document.getElementById("local");
      if (!video) {
        this.animationId = requestAnimationFrame(this.loop);
        return;
      }
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        this.animationId = requestAnimationFrame(this.loop);
        return;
      }
      await this.segmenter.send({ image: video });
      this.animationId = requestAnimationFrame(this.loop);
    });
  }
  getElement() {
    return this.segmenter;
  }
  initMediapipe({
    canvasId,
    titleVideo = "Khách hàng",
    mode = "blur"
  }) {
    const SelfieSegmentationCtor = (
      // Prefer module export when available
      selfie_segmentation.SelfieSegmentation || // Fallback to global attached by the UMD build
      (globalThis == null ? void 0 : globalThis.SelfieSegmentation)
    );
    if (!SelfieSegmentationCtor) {
      throw new Error(
        "SelfieSegmentation constructor not found. Ensure @mediapipe/selfie_segmentation is loaded."
      );
    }
    this.segmenter = new SelfieSegmentationCtor({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
    });
    this.segmenter.setOptions({ modelSelection: 1 });
    this.titleVideo = titleVideo;
    this.canvasId = canvasId;
    this.mode = mode;
  }
  async start() {
    const video = document.getElementById("local");
    let canvas = document.getElementById("outputCanvas");
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = "outputCanvas";
      canvas.width = 640;
      canvas.height = 480;
      canvas.style.display = "none";
      document.body.appendChild(canvas);
    }
    this.sendBackgroundBlur({
      name: "Khách hàng",
      mode: "none",
      urlImage: "",
      position: { x: 10, y: 470 }
    });
    const stream = await navigator.mediaDevices.getUserMedia({
      video: true
    });
    video.srcObject = stream;
    video.onloadedmetadata = () => {
      const c2 = document.getElementById("outputCanvas");
      if (c2) {
        const vw = video.videoWidth || 640;
        const vh = video.videoHeight || 480;
        c2.width = vw;
        c2.height = vh;
      }
      video.play();
      this.loop();
    };
  }
  async stop() {
    this.segmenter.close();
  }
  async resetMediapipe() {
    cancelAnimationFrame(this.animationId);
    this.animationId = null;
  }
  async sendUnBlurBackground(userName = "Chưa có tên", position) {
    const canvas = document.getElementById("outputCanvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    this.segmenter.onResults((results) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = "source-over";
      ctx.font = "20px Arial";
      ctx.fillStyle = "white";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 3;
      const textMetrics = ctx.measureText(userName);
      const textWidth = textMetrics.width;
      const x = (position == null ? void 0 : position.x) || (canvas.width - textWidth) / 2;
      const y = (position == null ? void 0 : position.y) || 20;
      ctx.strokeText(userName, x, y);
      ctx.fillText(userName, x, y);
      ctx.restore();
    });
  }
  async sendBackgroundBlur({
    name: name2 = "Chưa có tên",
    position = { x: 0, y: 0 },
    mode = "none",
    urlImage = ""
  }, callback) {
    const canvas = document.getElementById("outputCanvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    this.segmenter.onResults((results) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      switch (mode) {
        case "blur":
          ctx.drawImage(
            results.segmentationMask,
            0,
            0,
            canvas.width,
            canvas.height
          );
          ctx.globalCompositeOperation = "source-out";
          ctx.filter = "blur(8px)";
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          ctx.globalCompositeOperation = "destination-over";
          ctx.filter = "none";
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          break;
        case "image":
          if (!urlImage) {
            ctx.globalCompositeOperation = "source-out";
            ctx.filter = "blur(8px)";
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            this.mode = "blur";
          }
          const image2 = new Image();
          image2.src = urlImage;
          ctx.globalCompositeOperation = "source-out";
          ctx.filter = "none";
          ctx.drawImage(image2, 0, 0, canvas.width, canvas.height);
          this.urlImage = urlImage;
          this.mode = "image";
          break;
        case "none":
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          ctx.globalCompositeOperation = "destination-over";
          ctx.filter = "none";
          this.mode = "none";
          break;
      }
      ctx.globalCompositeOperation = "source-over";
      ctx.font = "20px Arial";
      ctx.fillStyle = "white";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 3;
      const text = name2;
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;
      const x = (position == null ? void 0 : position.x) || (canvas.width - textWidth) / 2;
      const y = (position == null ? void 0 : position.y) || 20;
      ctx.strokeText(text, x, y);
      ctx.fillText(text, x, y);
      ctx.restore();
    });
    setTimeout(() => {
      callback && callback();
    }, 1e3);
  }
  async mediaPipeReset() {
    var _a;
    const video = document.getElementById("local");
    const canvas = document.getElementById("outputCanvas");
    if (video || canvas) {
      video.srcObject = null;
      video == null ? void 0 : video.pause();
      mediaPipe.resetMediapipe();
      (_a = canvas.getContext("2d")) == null ? void 0 : _a.clearRect(0, 0, canvas.width, canvas.height);
      canvas.captureStream(30).getVideoTracks()[0].stop();
      this.stopUserMedia();
    }
  }
  async stopUserMedia() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      stream.getTracks().forEach((track) => track.stop());
    } catch (error) {
      console.log("error stopUserMedia", error);
    }
  }
}
const mediaPipe = new Mediapipe();
class BubbleSDK {
  constructor() {
    // private _container: HTMLElement | null = null;
    __publicField(this, "info", null);
    __publicField(this, "msg", null);
    __publicField(this, "socket");
    __publicField(this, "mode", false);
    __publicField(this, "token", "");
    __publicField(this, "list_agent", []);
    __publicField(this, "remoteAudioId");
    __publicField(this, "localVideoId");
    __publicField(this, "remoteVideoId");
    __publicField(this, "attempt_transfer", 0);
    __publicField(this, "attempt_max", 3);
    __publicField(this, "attempt_refuse", 0);
    __publicField(this, "attempt_accept", 0);
    __publicField(this, "request");
  }
  /**
   * Initialize the bubble with a custom container
   * @param containerId - The ID of the container element
   */
  initialize(_containerId, mode) {
    this.mode = mode;
  }
  getElId(remoteAudioId, localVideoId, remoteVideoId) {
    this.remoteAudioId = remoteAudioId ?? this.remoteAudioId;
    this.localVideoId = localVideoId ?? this.localVideoId;
    this.remoteVideoId = remoteVideoId ?? this.remoteVideoId;
  }
  clear_sdk() {
    var _a;
    if (this.socket) {
      this.socket.socket.disconnect();
      (_a = this.socket) == null ? void 0 : _a.disconnect_sdk();
    }
    this.msg = null;
    this.token = "";
    this.info = null;
    localStorage.removeItem("prevStatus");
    store.dispatch(agent_logout());
  }
  info_user_push_notification() {
    alertSnackbar()({
      title: "Không có thông tin người dùng vui lòng đăng nhập lại!",
      status: "error",
      duration: 5e3
    });
    this.clear_sdk();
    emitAppEvent(AppEventType.LOGGED_OUT);
    return Promise.reject({
      success: false,
      message: "Không có thông tin user",
      data: null
    });
  }
  /**
   * Clear access token (logout)
   */
  async logout_sdk() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    traceLog(
      "agent logout_sdk",
      {},
      {
        isLogServer: true,
        isLogClient: false,
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      }
    );
    try {
      const res = await logout$1({
        cloudAgentId: ((_f = (_e = this.info) == null ? void 0 : _e.user) == null ? void 0 : _f.id) ?? 0,
        cloudTenantId: ((_h = (_g = this.info) == null ? void 0 : _g.tenant) == null ? void 0 : _h.id) ?? 0,
        cloudAgentName: ((_j = (_i = this.info) == null ? void 0 : _i.user) == null ? void 0 : _j.userName) ?? ""
      });
      if (res == null ? void 0 : res.status) {
        this.unRegisterCall_sdk();
        pushEventCurrentStatus({
          cloudAgentId: (_l = (_k = this == null ? void 0 : this.info) == null ? void 0 : _k.user) == null ? void 0 : _l.id,
          cloudTenantId: (_n = (_m = this == null ? void 0 : this.info) == null ? void 0 : _m.tenant) == null ? void 0 : _n.id,
          cloudAgentName: (_p = (_o = this == null ? void 0 : this.info) == null ? void 0 : _o.user) == null ? void 0 : _p.userName
        });
        this.clear_sdk();
        client_socket.emit(EVT_EMITTER.LOGOUT_SDK);
        emitAppEvent(AppEventType.LOGGED_OUT);
        store.dispatch(agent_logout());
        removeStorage("token");
        removeStorage("tenantId");
        traceLog(
          "agent logout_sdk success",
          {},
          {
            isLogServer: true,
            isLogClient: false,
            tenantId: (_r = (_q = this.info) == null ? void 0 : _q.tenant) == null ? void 0 : _r.id,
            agentId: (_t = (_s = this.info) == null ? void 0 : _s.user) == null ? void 0 : _t.id
          }
        );
        return Promise.resolve({ success: true, message: "Logged out" });
      } else {
        return Promise.reject({ success: false, message: "Logged out failed" });
      }
    } catch (error) {
      return Promise.reject({ success: false, message: "Logged out failed" });
    }
  }
  async syncLoginSdk(accessToken) {
    var _a, _b;
    try {
      const res_info = await getInfoAgent(accessToken ?? "");
      const info = JSON.parse(decryptData(res_info.data.result));
      this.info = info;
      if (((_a = info.user) == null ? void 0 : _a.id) && ((_b = info.tenant) == null ? void 0 : _b.id)) {
        const res_config = await getConfigBaseUrl(accessToken ?? "");
        const config = JSON.parse(
          decryptData(res_config.data.result)
        );
        config_url.base_url = config.BASE_URL;
        config_url.sip_url = config.SIP_URL;
        config_key.ably = config.ABLY_KEY;
        config_port.sip = (config.SIP_PORT ?? 0).toString();
        this.getListAgent();
        this.socket = new Socket_SDK({
          info,
          getMsg: (msg) => this.getMsgAbly(msg),
          mode: this.mode,
          options: {
            localVideoId: this.localVideoId,
            remoteVideoId: this.remoteVideoId,
            elRemoteAudio: this.remoteAudioId
          },
          cb: () => {
            emitAppEvent(AppEventType.LOGGED_IN);
          },
          token: accessToken,
          config: config.socketIoCallConfig,
          cbUserAction: (msg) => this.user_action_sdk(msg)
        });
      } else {
        emitAppEvent(AppEventType.TOKEN_EXPIRED);
        store.dispatch(agent_logout());
        removeStorage("token");
        removeStorage("tenantId");
        removeStorage("mpt-auth");
      }
    } catch (error) {
      store.dispatch(agent_logout());
      removeStorage("token");
      removeStorage("tenantId");
      removeStorage("mpt-auth");
    }
  }
  async get_info_setting(token, skipLogin = false) {
    var _a, _b, _c, _d, _e;
    try {
      const res_info = await getInfoAgent(token ?? "");
      const info = JSON.parse(decryptData(res_info.data.result));
      this.info = info;
      if (((_a = info.user) == null ? void 0 : _a.id) && ((_b = info.tenant) == null ? void 0 : _b.id)) {
        this.token = token;
        store.dispatch(setInfo(info));
        store.dispatch(syncLogin(token));
        const res_config = await getConfigBaseUrl(token ?? "");
        const config = JSON.parse(
          decryptData(res_config.data.result)
        );
        config_url.base_url = config.BASE_URL;
        config_url.sip_url = config.SIP_URL;
        config_key.ably = config.ABLY_KEY;
        config_port.sip = (config.SIP_PORT ?? 0).toString();
        this.getListAgent();
        if (skipLogin) {
          traceLog(
            "login_With_Token success",
            {},
            {
              isLogServer: true,
              tenantId: (_c = info == null ? void 0 : info.tenant) == null ? void 0 : _c.id,
              agentId: (_d = info == null ? void 0 : info.user) == null ? void 0 : _d.id
            }
          );
        }
        client_socket.emit(EVT_EMITTER.LOGIN_SDK, {
          token: this.token ?? "",
          tenantId: (_e = info == null ? void 0 : info.tenant) == null ? void 0 : _e.id
        });
        emitAppEvent(AppEventType.LOGGED_IN);
        return Promise.resolve({
          success: true,
          message: "login success",
          data: {
            accessToken: "login success"
          }
        });
      } else {
        removeStorage("token");
        emitAppEvent(AppEventType.TOKEN_EXPIRED);
        store.dispatch(agent_logout());
        return Promise.reject({
          success: false,
          message: "token expired",
          data: null
        });
      }
    } catch (error) {
      store.dispatch(agent_logout());
      removeStorage("token");
      return Promise.reject({
        success: false,
        message: "get info agent failed",
        data: null
      });
    }
  }
  async login_sdk(values) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    try {
      const response = await postLogin(values);
      if (!((_b = (_a = response.data) == null ? void 0 : _a.result) == null ? void 0 : _b.status)) {
        alertSnackbar()({
          title: (_d = (_c = response.data) == null ? void 0 : _c.result) == null ? void 0 : _d.message,
          status: "error"
        });
        traceLog(
          "login_sdk error",
          {
            message: (_f = (_e = response.data) == null ? void 0 : _e.result) == null ? void 0 : _f.message
          },
          {
            isLogServer: true
          }
        );
        return Promise.reject({
          success: false,
          message: "Login failed",
          data: (_h = (_g = response.data) == null ? void 0 : _g.result) == null ? void 0 : _h.message
        });
      }
      this.token = ((_j = (_i = response.data) == null ? void 0 : _i.result) == null ? void 0 : _j.accessToken) ?? "";
      setStorage("token", (_l = (_k = response.data) == null ? void 0 : _k.result) == null ? void 0 : _l.accessToken);
      traceLog(
        "login_sdk success",
        {},
        {
          isLogServer: true,
          tenantId: (_n = (_m = response.data) == null ? void 0 : _m.result) == null ? void 0 : _n.tenantId,
          agentId: (_p = (_o = response.data) == null ? void 0 : _o.result) == null ? void 0 : _p.userId
        }
      );
      return this.get_info_setting(((_r = (_q = response.data) == null ? void 0 : _q.result) == null ? void 0 : _r.accessToken) ?? "");
    } catch (error) {
      return Promise.reject({
        success: false,
        message: "Login failed",
        data: error
      });
    }
  }
  async loginSSO_sdk(values) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
    try {
      const response = await postLoginSSO({
        partner_session: values.ssoToken ?? "",
        partner_tenant: values.organization ?? ""
      });
      if (!((_b = (_a = response.data) == null ? void 0 : _a.result) == null ? void 0 : _b.status)) {
        alertSnackbar()({
          title: (_d = (_c = response.data) == null ? void 0 : _c.result) == null ? void 0 : _d.message,
          status: "error"
        });
        traceLog(
          "loginSSO_sdk error",
          {
            message: (_f = (_e = response.data) == null ? void 0 : _e.result) == null ? void 0 : _f.message
          },
          {
            isLogServer: true,
            tenantId: (_h = (_g = response.data) == null ? void 0 : _g.result) == null ? void 0 : _h.tenantId,
            agentId: (_j = (_i = response.data) == null ? void 0 : _i.result) == null ? void 0 : _j.userId
          }
        );
        return Promise.reject({
          success: false,
          message: "Login failed",
          data: (_l = (_k = response.data) == null ? void 0 : _k.result) == null ? void 0 : _l.message
        });
      }
      this.token = ((_n = (_m = response.data) == null ? void 0 : _m.result) == null ? void 0 : _n.accessToken) ?? "";
      setStorage("token", (_p = (_o = response.data) == null ? void 0 : _o.result) == null ? void 0 : _p.accessToken);
      traceLog(
        "loginSSO_sdk success",
        {},
        {
          isLogServer: true,
          tenantId: (_r = (_q = response.data) == null ? void 0 : _q.result) == null ? void 0 : _r.tenantId,
          agentId: (_t = (_s = response.data) == null ? void 0 : _s.result) == null ? void 0 : _t.userId
        }
      );
      return this.get_info_setting(((_v = (_u = response.data) == null ? void 0 : _u.result) == null ? void 0 : _v.accessToken) ?? "");
    } catch (error) {
      return Promise.reject({ success: false, message: "Logged failed" });
    }
  }
  async makeCall_sdk(phone, option) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    traceLog(
      "makeCall_sdk",
      {
        phone,
        option
      },
      {
        isLogServer: true,
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      }
    );
    if (!(phone == null ? void 0 : phone.trim())) {
      return Promise.reject({
        success: false,
        message: "Please enter phone number"
      });
    }
    if (!((_f = (_e = this == null ? void 0 : this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id) || !((_h = (_g = this == null ? void 0 : this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id)) {
      return this.info_user_push_notification();
    }
    this.attempt_transfer = 0;
    this.attempt_refuse = 0;
    this.attempt_accept = 0;
    try {
      await navigator.mediaDevices.getUserMedia({ audio: true });
      try {
        if (this.socket) {
          this.socket.msgs = [];
          this.socket.clearData();
          this.socket.userAction = true;
          this.socket.SesId = "";
          this.socket.main_id = "";
        }
        SIP_SDK.sessionIds = [];
        const values = {
          type: (option == null ? void 0 : option.enableVideo) ? CALL_TYPE.VIDEO : CALL_TYPE.VOICE,
          extraInfo: option == null ? void 0 : option.extraInfo
        };
        const res = await openTakeCareConversation({
          tenantId: (_j = (_i = this.info) == null ? void 0 : _i.tenant) == null ? void 0 : _j.id,
          channel: channelCall,
          agentId: ((_l = (_k = this.info) == null ? void 0 : _k.user) == null ? void 0 : _l.id) ?? 0,
          applicationId: option == null ? void 0 : option.did,
          senderId: phone,
          extraInfo: JSON.stringify(values)
        });
        traceLog(
          "makeCall_sdk call api",
          {
            phone,
            option,
            response: res == null ? void 0 : res.data
          },
          {
            isLogServer: true,
            tenantId: (_n = (_m = this.info) == null ? void 0 : _m.tenant) == null ? void 0 : _n.id,
            agentId: (_p = (_o = this.info) == null ? void 0 : _o.user) == null ? void 0 : _p.id
          }
        );
        if ((_q = res == null ? void 0 : res.data) == null ? void 0 : _q.success) {
          return Promise.resolve({
            success: true,
            message: "make call success"
          });
        } else {
          if (this.socket) this.socket.userAction = false;
          return Promise.reject({
            success: false,
            message: "make call failed"
          });
        }
      } catch (error) {
        traceLog(
          "makeCall_sdk call api failed",
          {
            phone,
            option,
            error
          },
          {
            isLogServer: true,
            tenantId: (_s = (_r = this.info) == null ? void 0 : _r.tenant) == null ? void 0 : _s.id,
            agentId: (_u = (_t = this.info) == null ? void 0 : _t.user) == null ? void 0 : _u.id
          }
        );
        if (this.socket) this.socket.userAction = false;
        return Promise.reject({
          success: false,
          message: error
        });
      }
    } catch (error) {
      traceLog(
        "makeCall_sdk call api failed",
        {
          phone,
          option,
          error
        },
        {
          isLogServer: true,
          tenantId: (_w = (_v = this.info) == null ? void 0 : _v.tenant) == null ? void 0 : _w.id,
          agentId: (_y = (_x = this.info) == null ? void 0 : _x.user) == null ? void 0 : _y.id
        }
      );
      emitAppEvent(AppEventType.PERMISSION_DENIED);
      switchErrorAudio(error);
      return Promise.reject({
        success: false,
        message: "Permission denied"
      });
    }
  }
  answer_sdk(options) {
    traceLog("answer_sdk", options, { isLogServer: true, isLogClient: false });
    this.attempt_transfer = 0;
    this.attempt_refuse = 0;
    this.attempt_accept = 0;
    navigator.mediaDevices.getUserMedia({ audio: true }).then(() => {
      if (this.socket) this.socket.accept_ably(options);
    }).catch((error) => {
      emitAppEvent(AppEventType.PERMISSION_DENIED);
      switchErrorAudio(error);
    });
  }
  userActionType(type, params = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (!this.socket) return;
    (_i = this.socket) == null ? void 0 : _i.socket.emit(
      send_message,
      {
        rooms: [`private_${(_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id}_${(_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id}`],
        event: `private_agent_${(_f = (_e = this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id}_${(_h = (_g = this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id}`,
        data: {
          type,
          ...params
        }
      },
      () => {
      }
    );
  }
  getRecord(sessionId) {
    var _a, _b;
    const find = (((_a = this.socket) == null ? void 0 : _a.msgs) ?? []).find(
      (r2) => (r2 == null ? void 0 : r2.sessionId) === sessionId
    );
    if (find == null ? void 0 : find.extraInfo) {
      const extInfo = (_b = this.socket) == null ? void 0 : _b.parseExtraInfo((find == null ? void 0 : find.extraInfo) ?? "");
      if (extInfo == null ? void 0 : extInfo.extraInfo) {
        find.extraInfo = extInfo == null ? void 0 : extInfo.extraInfo;
      }
    }
    return {
      senderId: find == null ? void 0 : find.ani,
      applicationId: find == null ? void 0 : find.dnis,
      sessionId: find == null ? void 0 : find.sessionId,
      channel: find == null ? void 0 : find.channel,
      direction: find == null ? void 0 : find.direction,
      extraInfo: (find == null ? void 0 : find.extraInfo) ?? ""
    };
  }
  hangup_sdk() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    if (this.socket) {
      const sessionId = (_a = this.socket) == null ? void 0 : _a.getSessionMain();
      traceLog(
        "click hangup_sdk",
        { sessionId, data: (_b = this.socket) == null ? void 0 : _b.getDataStringify() },
        {
          isLogServer: true,
          isLogClient: false,
          tenantId: (_d = (_c = this.info) == null ? void 0 : _c.tenant) == null ? void 0 : _d.id,
          agentId: (_f = (_e = this.info) == null ? void 0 : _e.user) == null ? void 0 : _f.id
        }
      );
      if (sessionId && this.socket.searchSessionEstablished(sessionId)) {
        traceLog(
          "hangup_sdk",
          { sessionId, data: (_g = this.socket) == null ? void 0 : _g.getDataStringify() },
          {
            isLogServer: true,
            isLogClient: false,
            tenantId: (_i = (_h = this.info) == null ? void 0 : _h.tenant) == null ? void 0 : _i.id,
            agentId: (_k = (_j = this.info) == null ? void 0 : _j.user) == null ? void 0 : _k.id,
            sessionId
          }
        );
        (_o = this.socket) == null ? void 0 : _o.hang_up(
          sessionId,
          (_n = (_m = (_l = this.socket) == null ? void 0 : _l.info) == null ? void 0 : _m.user) == null ? void 0 : _n.id,
          (sessionId2, state) => {
            var _a2, _b2, _c2;
            (_a2 = this.socket) == null ? void 0 : _a2.checkTabSession(sessionId2, state);
            ((_b2 = this.request) == null ? void 0 : _b2.onHangup) && ((_c2 = this.request) == null ? void 0 : _c2.onHangup(sessionId2, this.getRecord(sessionId2)));
          }
        );
        if (this.socket) this.socket.SesId = "";
      } else {
        this.userActionType(USER_ACTION.HANGUP);
        traceLog(
          "hangup_sdk tab",
          {},
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_q = (_p = this.info) == null ? void 0 : _p.tenant) == null ? void 0 : _q.id,
            agentId: (_s = (_r = this.info) == null ? void 0 : _r.user) == null ? void 0 : _s.id
          }
        );
      }
    }
  }
  customHangup_sdk(sessionId) {
    var _a, _b, _c, _d;
    (_d = this.socket) == null ? void 0 : _d.hang_up(
      sessionId,
      (_c = (_b = (_a = this.socket) == null ? void 0 : _a.info) == null ? void 0 : _b.user) == null ? void 0 : _c.id,
      (callId, state) => {
        var _a2, _b2, _c2;
        (_a2 = this.socket) == null ? void 0 : _a2.checkTabSession(sessionId, state);
        ((_b2 = this == null ? void 0 : this.request) == null ? void 0 : _b2.onHangup) && ((_c2 = this == null ? void 0 : this.request) == null ? void 0 : _c2.onHangup(callId, this.getRecord(callId)));
      }
    );
  }
  hold_sdk() {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this.socket) {
      const sessionId = this.socket.main_id ?? (SIP_SDK.sessionIds.length ? SIP_SDK.sessionIds[0] : "");
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) {
        traceLog(
          "hold_sdk",
          { sessionId, data: (_a = this.socket) == null ? void 0 : _a.getDataStringify() },
          {
            isLogClient: false,
            isLogServer: true,
            tenantId: (_c = (_b = this.info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
            agentId: (_e = (_d = this.info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
            sessionId
          }
        );
        this.socket.hold_call_client(sessionId, (_g = (_f = this.info) == null ? void 0 : _f.user) == null ? void 0 : _g.id);
      } else {
        traceLog(
          "hold_sdk tab",
          { find },
          { isLogClient: false, isLogServer: true }
        );
        this.userActionType(USER_ACTION.HOLD);
      }
    }
  }
  unhold_sdk() {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this.socket) {
      const sessionId = this.socket.main_id ?? (SIP_SDK.sessionIds.length ? SIP_SDK.sessionIds[0] : "");
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) {
        traceLog(
          "unhold_sdk",
          { sessionId, data: (_a = this.socket) == null ? void 0 : _a.getDataStringify() },
          {
            isLogClient: true,
            isLogServer: true,
            tenantId: (_c = (_b = this.info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
            agentId: (_e = (_d = this.info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
            sessionId
          }
        );
        this.socket.un_hold_call_client(sessionId, (_g = (_f = this.info) == null ? void 0 : _f.user) == null ? void 0 : _g.id);
      } else {
        traceLog(
          "unhold_sdk tab",
          { find, sessionId },
          { isLogClient: true, isLogServer: false, sessionId }
        );
        this.userActionType(USER_ACTION.UNHOLD);
      }
    }
  }
  mute_sdk() {
    var _a, _b, _c, _d, _e;
    if (this.socket) {
      const sessionId = this.socket.main_id ?? (SIP_SDK.sessionIds.length ? SIP_SDK.sessionIds[0] : "");
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) {
        traceLog(
          "mute_sdk",
          { sessionId, data: (_a = this.socket) == null ? void 0 : _a.getDataStringify() },
          {
            isLogClient: true,
            isLogServer: true,
            tenantId: (_c = (_b = this.info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
            agentId: (_e = (_d = this.info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
            sessionId
          }
        );
        this.socket.mute_call(sessionId, true);
      } else {
        traceLog("mute_sdk tab", {}, { isLogClient: true, isLogServer: false });
        this.userActionType(USER_ACTION.MUTE);
      }
    }
  }
  unmute_sdk() {
    var _a, _b, _c, _d, _e;
    if (this.socket) {
      const sessionId = this.socket.main_id ?? (SIP_SDK.sessionIds.length ? SIP_SDK.sessionIds[0] : "");
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) {
        traceLog(
          "unmute_sdk",
          { sessionId, data: (_a = this.socket) == null ? void 0 : _a.getDataStringify() },
          {
            isLogClient: true,
            isLogServer: true,
            tenantId: (_c = (_b = this.info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id,
            agentId: (_e = (_d = this.info) == null ? void 0 : _d.user) == null ? void 0 : _e.id,
            sessionId
          }
        );
        this.socket.mute_call(sessionId, false);
      } else {
        traceLog(
          "unmute_sdk tab",
          {},
          { isLogClient: true, isLogServer: false }
        );
        this.userActionType(USER_ACTION.UNMUTE);
      }
    }
  }
  getMsgAbly(msg) {
    this.msg = msg;
  }
  cameraOn_sdk() {
    if (this.socket) {
      const sessionId = this.socket.getSessionMain();
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) this.socket.sendCamera(sessionId, true);
    }
  }
  cameraOff_sdk() {
    if (this.socket) {
      const sessionId = this.socket.getSessionMain();
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) this.socket.sendCamera(sessionId, false);
    }
  }
  updateVideo_sdk() {
    if (this.socket) {
      const sessionId = this.socket.getSessionMain();
      const find = this.socket.searchSessionEstablished(sessionId);
      if (find) this.socket.update(sessionId, true);
    }
  }
  rejectCall_sdk() {
    var _a, _b, _c, _d;
    traceLog(
      "click rejectCall_sdk",
      {},
      {
        isLogServer: true,
        isLogClient: false,
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      }
    );
    if (this.socket) this.socket.reject_sip();
  }
  showBubble_sdk() {
    client_socket.emit(EVT_EMITTER.BUBBLE, true);
  }
  hideBubble_sdk() {
    client_socket.emit(EVT_EMITTER.BUBBLE, false);
  }
  async getListAgent() {
    var _a, _b, _c, _d;
    try {
      const res = await getAgentStatusAcd({
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id
      });
      this.list_agent = ((_c = res.data) == null ? void 0 : _c.data) ?? [];
      return Promise.resolve({
        data: ((_d = res.data) == null ? void 0 : _d.data) ?? [],
        success: true,
        message: "get list agent success"
      });
    } catch (error) {
      return Promise.reject({
        data: [],
        success: false,
        message: error
      });
    }
  }
  async changeStatusAgent(reasonCodeId) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    traceLog(
      "changeStatusAgent",
      { reasonCodeId },
      {
        isLogServer: true,
        isLogClient: false,
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      }
    );
    if (!((_f = (_e = this == null ? void 0 : this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id) || !((_h = (_g = this == null ? void 0 : this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id)) {
      return this.info_user_push_notification();
    }
    try {
      const find = (this.list_agent ?? []).find(
        (i2) => i2.reasonCodeId === reasonCodeId
      );
      if (!find) {
        return Promise.reject({
          data: {},
          success: true,
          message: "reasonCodeId not found"
        });
      }
      const res = await postStatusAgent({
        cloudAgentId: (_i = this.info) == null ? void 0 : _i.user.id,
        cloudTenantId: (_j = this.info) == null ? void 0 : _j.tenant.id,
        cloudAgentName: `${(_k = this.info) == null ? void 0 : _k.user.fullName} (${(_l = this.info) == null ? void 0 : _l.user.userName})`,
        reasonCodeId: find.reasonCodeId,
        statusName: find.reasonCode
      });
      traceLog(
        "error_api_change_stataus",
        {
          reasonCodeId,
          response: res.data.data
        },
        {
          isLogServer: true,
          isLogClient: false,
          tenantId: (_n = (_m = this.info) == null ? void 0 : _m.tenant) == null ? void 0 : _n.id,
          agentId: (_p = (_o = this.info) == null ? void 0 : _o.user) == null ? void 0 : _p.id
        }
      );
      return Promise.resolve({
        data: ((_q = res.data) == null ? void 0 : _q.data) ?? [],
        success: true,
        message: "change status agent success"
      });
    } catch (error) {
      traceLog(
        "error_api_change_stataus",
        {
          reasonCodeId,
          message: error == null ? void 0 : error.message,
          responseError: (_s = (_r = error == null ? void 0 : error.response) == null ? void 0 : _r.data) == null ? void 0 : _s.errors
        },
        {
          isLogServer: true,
          isLogClient: false,
          tenantId: (_u = (_t = this.info) == null ? void 0 : _t.tenant) == null ? void 0 : _u.id,
          agentId: (_w = (_v = this.info) == null ? void 0 : _v.user) == null ? void 0 : _w.id
        }
      );
      return Promise.reject({
        data: null,
        success: false,
        message: error
      });
    }
  }
  async getAgentQueues_sdk() {
    var _a, _b, _c, _d, _e;
    try {
      const response = await getAgentQueues({
        tenantId: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
      });
      return Promise.resolve({
        data: ((_e = response.data) == null ? void 0 : _e.data) ?? [],
        success: true,
        message: "get list agent queues success"
      });
    } catch (error) {
      return Promise.reject({
        data: null,
        success: false,
        message: "error get agent queues"
      });
    }
  }
  async getGroupAgents_sdk() {
    var _a, _b, _c;
    try {
      const response = await getGroupsAgents({
        tenantId: (_b = (_a = this == null ? void 0 : this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id
      });
      return Promise.resolve({
        data: ((_c = response.data) == null ? void 0 : _c.data) ?? [],
        success: true,
        message: "get list agent queues success"
      });
    } catch (error) {
      return Promise.reject({
        data: [],
        success: false,
        message: "error get agent queues"
      });
    }
  }
  async getAgentQueuesById_sdk(queueId) {
    var _a, _b;
    try {
      const response = await getQueueAgent(queueId);
      return Promise.resolve({
        data: ((_a = response.data) == null ? void 0 : _a.data) ?? [],
        success: ((_b = response.data) == null ? void 0 : _b.success) ?? false,
        message: "get list agent queues success"
      });
    } catch (error) {
      return Promise.reject({
        data: [],
        success: false,
        message: "error get agent queues"
      });
    }
  }
  async getAgentByExtension_sdk(queueExtension) {
    var _a, _b, _c, _d;
    try {
      const response = await getAgentsByExtension({
        tenantId: (_b = (_a = this == null ? void 0 : this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        queueExtension
      });
      return Promise.resolve({
        data: ((_c = response.data) == null ? void 0 : _c.data) ?? [],
        success: ((_d = response.data) == null ? void 0 : _d.success) ?? false,
        message: "get agent by extension success"
      });
    } catch (error) {
      return Promise.reject({
        data: [],
        success: false,
        message: "error get agent queues"
      });
    }
  }
  async putAgentQueues_sdk(queueId, enable) {
    var _a, _b, _c, _d, _e;
    try {
      const response = await putAgentQueues({
        tenant_id: (_b = (_a = this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agent_id: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
        queue_id: queueId,
        enabled: enable
      });
      return Promise.resolve({
        data: ((_e = response.data) == null ? void 0 : _e.data) ?? [],
        success: true,
        message: `Agent is ${enable ? "added" : "removed"} to queue ${queueId}`
      });
    } catch (error) {
      return Promise.reject({
        data: null,
        success: false,
        message: "error get agent queues"
      });
    }
  }
  /**
   * Transfer conversation to another agent or queue
   * @param destination - The destination to transfer the conversation to
   * @param destinationType - The type of destination (AGENT, QUEUE, EXTERNAL)
   * @param transferType - The type of transfer (ATTENDED_TRANSFER, BLIND_TRANSFER)
   */
  async transferAgent(destination, destinationType, transferType) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G;
    traceLog(
      "transferAgent",
      {
        destination,
        destinationType,
        transferType,
        sessionId: (_a = this.socket) == null ? void 0 : _a.main_id,
        tenantId: (_c = (_b = this.info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id
      },
      {
        sessionId: (_d = this.socket) == null ? void 0 : _d.main_id,
        tenantId: (_f = (_e = this == null ? void 0 : this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id,
        agentId: (_h = (_g = this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id,
        isLogServer: true,
        isLogClient: false
      }
    );
    if (((_j = this.socket) == null ? void 0 : _j.searchSessionEstablished((_i = this.socket) == null ? void 0 : _i.main_id)) && ((_k = this.socket) == null ? void 0 : _k.main_id)) {
      try {
        if (this.socket) this.socket.userAction = true;
        const res = await postTransferConversation({
          currentAgentId: ((_m = (_l = this == null ? void 0 : this.info) == null ? void 0 : _l.user) == null ? void 0 : _m.id) || 0,
          // conversationId: find?.data?._id ?? (this.msg?.data?._id || ""),
          destination,
          transferType,
          destinationType,
          sessionId: (_n = this.socket) == null ? void 0 : _n.main_id,
          tenantId: (_p = (_o = this.info) == null ? void 0 : _o.tenant) == null ? void 0 : _p.id
        });
        traceLog(
          "transferAgent call api",
          {
            destination,
            destinationType,
            transferType,
            sessionId: (_q = this.socket) == null ? void 0 : _q.main_id,
            tenantId: (_s = (_r = this.info) == null ? void 0 : _r.tenant) == null ? void 0 : _s.id,
            response: res == null ? void 0 : res.data
          },
          {
            sessionId: (_t = this.socket) == null ? void 0 : _t.main_id,
            tenantId: (_v = (_u = this == null ? void 0 : this.info) == null ? void 0 : _u.tenant) == null ? void 0 : _v.id,
            agentId: (_x = (_w = this.info) == null ? void 0 : _w.user) == null ? void 0 : _x.id,
            isLogServer: true,
            isLogClient: false
          }
        );
        if ((_y = res == null ? void 0 : res.data) == null ? void 0 : _y.success) {
          if (transferType === TransferType.ATTENDED_TRANSFER) this.hold_sdk();
        } else {
          if (this.socket) this.socket.userAction = false;
          alertSnackbar()({
            title: "Không thể chuyển cho agent",
            status: "error"
          });
        }
      } catch (error) {
        if (this.socket) this.socket.userAction = false;
        traceLog(
          "transferAgent error call api",
          {
            destination,
            destinationType,
            transferType,
            sessionId: (_z = this.socket) == null ? void 0 : _z.main_id,
            tenantId: (_B = (_A = this.info) == null ? void 0 : _A.tenant) == null ? void 0 : _B.id,
            response: error
          },
          {
            sessionId: (_C = this.socket) == null ? void 0 : _C.main_id,
            tenantId: (_E = (_D = this == null ? void 0 : this.info) == null ? void 0 : _D.tenant) == null ? void 0 : _E.id,
            agentId: (_G = (_F = this.info) == null ? void 0 : _F.user) == null ? void 0 : _G.id,
            isLogServer: true,
            isLogClient: false
          }
        );
        alertSnackbar()({
          title: "Không thể chuyển cho agent",
          status: "error"
        });
      }
    } else {
      traceLog(
        "transferAgent_sdk tab",
        { destination, destinationType, transferType },
        { isLogClient: true, isLogServer: false }
      );
      this.attempt_transfer++;
      if (this.attempt_transfer < this.attempt_max) {
        this.userActionType(USER_ACTION.TRANSFER, {
          destination,
          destinationType,
          transferType
        });
      }
    }
  }
  async closeSession_sdk() {
    var _a, _b, _c, _d, _e;
    try {
      const find = (((_a = this.socket) == null ? void 0 : _a.msgs) ?? []).find(
        (i2) => {
          var _a2;
          return (i2 == null ? void 0 : i2.sessionId) === ((_a2 = SIP_SDK.sessionIds) == null ? void 0 : _a2[0]);
        }
      );
      const res = await poseEndSession({
        closeMode: CLOSE_MODE.MANUAL,
        cloudAgentId: (_c = (_b = this.info) == null ? void 0 : _b.user) == null ? void 0 : _c.id,
        // conversationId: find?.data?._id ?? (this.msg?.data?._id || ""),
        applicationId: (find == null ? void 0 : find.dnis) ?? ((_d = this.msg) == null ? void 0 : _d.dnis),
        senderId: (find == null ? void 0 : find.ani) ?? ((_e = this.msg) == null ? void 0 : _e.ani)
      });
      if (res.data.success) {
      }
    } catch (error) {
    }
  }
  async getCurrentStatus_sdk() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    try {
      const response = await getCurrentAgentStatus({
        cloudAgentId: (_b = (_a = this.info) == null ? void 0 : _a.user) == null ? void 0 : _b.id,
        cloudTenantId: (_d = (_c = this.info) == null ? void 0 : _c.tenant) == null ? void 0 : _d.id,
        cloudAgentName: (_f = (_e = this.info) == null ? void 0 : _e.user) == null ? void 0 : _f.fullName
      });
      if ((_g = response.data) == null ? void 0 : _g.success) {
        client_socket.emit(Event_SDK.AgentStatusEvent, {
          agentId: (_i = (_h = response.data) == null ? void 0 : _h.data) == null ? void 0 : _i.cloudAgentId,
          tenantId: (_k = (_j = response.data) == null ? void 0 : _j.data) == null ? void 0 : _k.cloudTenantId,
          agentName: (_m = (_l = response.data) == null ? void 0 : _l.data) == null ? void 0 : _m.cloudAgentName,
          statusName: (_o = (_n = response.data) == null ? void 0 : _n.data) == null ? void 0 : _o.statusName,
          changeTime: (_q = (_p = response.data) == null ? void 0 : _p.data) == null ? void 0 : _q.changeTime,
          reasonCode: (_s = (_r = response.data) == null ? void 0 : _r.data) == null ? void 0 : _s.reasonCode,
          reasonCodeId: (_u = (_t = response.data) == null ? void 0 : _t.data) == null ? void 0 : _u.reasonCodeId,
          reasonName: (_w = (_v = response.data) == null ? void 0 : _v.data) == null ? void 0 : _w.reasonName
        });
      }
      return Promise.resolve({
        data: ((_x = response == null ? void 0 : response.data) == null ? void 0 : _x.data) ?? {},
        success: (_y = response == null ? void 0 : response.data) == null ? void 0 : _y.success,
        message: "Get current status success"
      });
    } catch (error) {
      return Promise.reject({
        data: {},
        success: false
      });
    }
  }
  async makeCallInternal_sdk(destination, extraInfo, enableVideo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A;
    traceLog(
      "makeCallInternal_sdk",
      {
        destination
      },
      {
        tenantId: (_b = (_a = this == null ? void 0 : this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
        agentId: (_d = (_c = this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id,
        isLogServer: true,
        isLogClient: false
      }
    );
    if (!((_f = (_e = this == null ? void 0 : this.info) == null ? void 0 : _e.tenant) == null ? void 0 : _f.id) || !((_h = (_g = this == null ? void 0 : this.info) == null ? void 0 : _g.user) == null ? void 0 : _h.id)) {
      return this.info_user_push_notification();
    }
    try {
      await navigator.mediaDevices.getUserMedia({ audio: true });
      try {
        if (this.socket) {
          this.socket.userAction = true;
          this.socket.SesId = "";
          this.socket.main_id = "";
        }
        this.attempt_transfer = 0;
        this.attempt_refuse = 0;
        this.attempt_accept = 0;
        const values = {
          type: enableVideo ? CALL_TYPE.VIDEO : CALL_TYPE.VOICE,
          extraInfo
        };
        const res = await openTakeCareConversation({
          tenantId: (_j = (_i = this.info) == null ? void 0 : _i.tenant) == null ? void 0 : _j.id,
          channel: channelCall,
          agentId: ((_l = (_k = this.info) == null ? void 0 : _k.user) == null ? void 0 : _l.id) ?? 0,
          applicationId: destination,
          direction: DIRECTION.INTERNAL,
          senderId: ((_n = (_m = this.info) == null ? void 0 : _m.user) == null ? void 0 : _n.extension) ?? "",
          extraInfo: JSON.stringify(values)
        });
        traceLog(
          "makeCallInternal_sdk call api",
          {
            destination,
            response: res == null ? void 0 : res.data
          },
          {
            tenantId: (_p = (_o = this == null ? void 0 : this.info) == null ? void 0 : _o.tenant) == null ? void 0 : _p.id,
            agentId: (_r = (_q = this.info) == null ? void 0 : _q.user) == null ? void 0 : _r.id,
            isLogServer: true,
            isLogClient: false
          }
        );
        if ((_s = res == null ? void 0 : res.data) == null ? void 0 : _s.success) {
          return Promise.resolve({
            success: true,
            message: "make call internal success"
          });
        } else {
          if (this.socket) this.socket.userAction = false;
          return Promise.reject({
            success: false,
            message: "make call internal failed"
          });
        }
      } catch (error) {
        if (this.socket) this.socket.userAction = false;
        traceLog(
          "makeCallInternal_sdk call error",
          {
            destination,
            error
          },
          {
            tenantId: (_u = (_t = this == null ? void 0 : this.info) == null ? void 0 : _t.tenant) == null ? void 0 : _u.id,
            agentId: (_w = (_v = this.info) == null ? void 0 : _v.user) == null ? void 0 : _w.id,
            isLogServer: true,
            isLogClient: false
          }
        );
        return Promise.reject({
          success: false,
          message: error
        });
      }
    } catch (error) {
      emitAppEvent(AppEventType.PERMISSION_DENIED);
      switchErrorAudio(error);
      traceLog(
        "makeCallInternal_sdk permission error",
        {
          destination,
          error
        },
        {
          tenantId: (_y = (_x = this == null ? void 0 : this.info) == null ? void 0 : _x.tenant) == null ? void 0 : _y.id,
          agentId: (_A = (_z = this.info) == null ? void 0 : _z.user) == null ? void 0 : _A.id,
          isLogServer: true,
          isLogClient: false
        }
      );
      return Promise.reject({
        success: false,
        message: "Permission denied"
      });
    }
  }
  acceptTransfer_sdk() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    traceLog(
      "acceptTransfer_sdk",
      { sessionId: (_a = this.socket) == null ? void 0 : _a.main_id },
      {
        sessionId: (_b = this.socket) == null ? void 0 : _b.main_id,
        tenantId: (_d = (_c = this == null ? void 0 : this.info) == null ? void 0 : _c.tenant) == null ? void 0 : _d.id,
        agentId: (_f = (_e = this.info) == null ? void 0 : _e.user) == null ? void 0 : _f.id,
        isLogServer: true,
        isLogClient: false
      }
    );
    if (this.socket) {
      if (((_h = this.socket) == null ? void 0 : _h.searchSessionEstablished((_g = this.socket) == null ? void 0 : _g.main_id)) && ((_i = this.socket) == null ? void 0 : _i.main_id)) {
        const find = (((_j = this.socket) == null ? void 0 : _j.msgs) ?? []).find(
          (i2) => {
            var _a2;
            return (i2 == null ? void 0 : i2.sessionId) === ((_a2 = this.socket) == null ? void 0 : _a2.main_id);
          }
        );
        this.socket.sip_Accept_Transfer(
          {
            agentId: (_l = (_k = this.info) == null ? void 0 : _k.user) == null ? void 0 : _l.id,
            tenantId: (_n = (_m = this.info) == null ? void 0 : _m.tenant) == null ? void 0 : _n.id,
            applicationId: find == null ? void 0 : find.dnis,
            senderId: find == null ? void 0 : find.ani
          },
          (data) => {
            var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
            if (this.socket) {
              this.socket.SesId = "";
              this.socket.push_hang_up.push(((_a2 = this.socket) == null ? void 0 : _a2.main_id) ?? "");
              this.socket.socket.emit(
                send_message,
                {
                  rooms: [
                    `private_${(_c2 = (_b2 = this.info) == null ? void 0 : _b2.tenant) == null ? void 0 : _c2.id}_${(_e2 = (_d2 = this.info) == null ? void 0 : _d2.user) == null ? void 0 : _e2.id}`
                  ],
                  event: `private_transfer_accepted_${(_g2 = (_f2 = this.info) == null ? void 0 : _f2.tenant) == null ? void 0 : _g2.id}_${(_i2 = (_h2 = this.info) == null ? void 0 : _h2.user) == null ? void 0 : _i2.id}`,
                  data
                },
                () => {
                }
              );
            }
          }
        );
      } else {
        this.attempt_accept++;
        if (this.attempt_accept < this.attempt_max) {
          this.userActionType(USER_ACTION.TRANSFER_ACCEPTED);
        }
      }
    }
  }
  refuseTransfer_sdk() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    traceLog(
      "agent refuseTransfer_sdk",
      { sessionId: (_a = this.socket) == null ? void 0 : _a.main_id },
      {
        sessionId: (_b = this.socket) == null ? void 0 : _b.main_id,
        tenantId: (_d = (_c = this == null ? void 0 : this.info) == null ? void 0 : _c.tenant) == null ? void 0 : _d.id,
        agentId: (_f = (_e = this.info) == null ? void 0 : _e.user) == null ? void 0 : _f.id,
        isLogServer: true,
        isLogClient: false
      }
    );
    if (this.socket) {
      if ((_g = this.socket) == null ? void 0 : _g.searchSessionEstablished()) {
        const find = (((_h = this.socket) == null ? void 0 : _h.msgs) ?? []).find(
          (i2) => {
            var _a2;
            return (i2 == null ? void 0 : i2.sessionId) === ((_a2 = this.socket) == null ? void 0 : _a2.main_id);
          }
        );
        this.socket.sip_refuse_transfer(
          {
            agentId: (_j = (_i = this.info) == null ? void 0 : _i.user) == null ? void 0 : _j.id,
            tenantId: (_l = (_k = this.info) == null ? void 0 : _k.tenant) == null ? void 0 : _l.id,
            applicationId: find == null ? void 0 : find.dnis,
            senderId: find == null ? void 0 : find.ani
          },
          (id) => {
            if (this.socket) this.socket.SesId = id ?? "";
          }
        );
      } else {
        this.attempt_refuse++;
        if (this.attempt_refuse < this.attempt_max) {
          this.userActionType(USER_ACTION.TRANSFER_REFUSE);
        }
      }
    }
  }
  user_action_sdk(msg) {
    var _a, _b, _c, _d, _e;
    if (!this.socket || !((_a = this.socket) == null ? void 0 : _a.searchSessionEstablished())) {
      return;
    }
    switch (msg.type) {
      case USER_ACTION.HANGUP:
        this.hangup_sdk();
        break;
      case USER_ACTION.HOLD:
        this.hold_sdk();
        break;
      case USER_ACTION.UNHOLD:
        this.unhold_sdk();
        break;
      case USER_ACTION.MUTE:
        this.mute_sdk();
        break;
      case USER_ACTION.UNMUTE:
        this.unmute_sdk();
        break;
      case USER_ACTION.TRANSFER:
        if (((_c = this.socket) == null ? void 0 : _c.searchSessionEstablished((_b = this.socket) == null ? void 0 : _b.main_id)) && (msg == null ? void 0 : msg.destination) && (msg == null ? void 0 : msg.transferType) && (msg == null ? void 0 : msg.destinationType)) {
          this.transferAgent(
            msg.destination,
            msg.destinationType,
            msg.transferType
          );
        }
        break;
      case USER_ACTION.TRANSFER_ACCEPTED:
        if ((_e = this.socket) == null ? void 0 : _e.searchSessionEstablished((_d = this.socket) == null ? void 0 : _d.main_id)) {
          this.acceptTransfer_sdk();
        }
        break;
      case USER_ACTION.TRANSFER_REFUSE:
        this.refuseTransfer_sdk();
        break;
    }
  }
  updateCall_sdk() {
    if (this.socket) {
      const sessionId = this.socket.getSessionMain();
      if (sessionId) {
        this.socket.update(sessionId, true);
      }
    }
  }
  unRegisterCall_sdk() {
    var _a, _b, _c, _d;
    return deleteRegisterCall({
      tenant_id: (_b = (_a = this == null ? void 0 : this.info) == null ? void 0 : _a.tenant) == null ? void 0 : _b.id,
      agent_id: (_d = (_c = this == null ? void 0 : this.info) == null ? void 0 : _c.user) == null ? void 0 : _d.id
    }).then((res) => {
      var _a2;
      if ((_a2 = res == null ? void 0 : res.data) == null ? void 0 : _a2.success) {
        return Promise.resolve({
          success: true,
          message: "unRegisterCall_sdk success"
        });
      } else {
        return Promise.reject({
          success: false,
          message: "unRegisterCall_sdk failed"
        });
      }
    }).catch((error) => {
      console.log("unRegisterCall_sdk error", error);
      return Promise.reject({
        success: false,
        message: "unRegisterCall_sdk error"
      });
    });
  }
  sendBackgroundBlur_sdk(options, enable = false) {
    mediaPipe.sendBackgroundBlur(options, () => {
      var _a, _b;
      (_b = this.socket) == null ? void 0 : _b.blurBackground(
        (_a = this.socket) == null ? void 0 : _a.main_id,
        enable,
        this.localVideoId
      );
    });
  }
}
var config_url = {
  base_url: CONFIG_URL,
  sip_url: ""
};
var config_key = {
  ably: "",
  sip: ""
};
var config_port = {
  sip: ""
};
const DEFAULT_OPTIONS = {
  targetElementId: "omi-sdk-container",
  mode: "bubble",
  debug: false,
  baseUrl: config_url.base_url
};
const SDK_NAMESPACE = "OmiSDK";
const SDK_VERSION = "1.0.10";
class OmiSDK extends BubbleSDK {
  /**
   * Creates a new SDK instance
   * @param options SDK options
   */
  constructor(options) {
    super();
    __publicField(this, "options");
    __publicField(this, "container", null);
    __publicField(this, "logger");
    __publicField(this, "initialized", false);
    __publicField(this, "styleElement", null);
    __publicField(this, "eventEmitter");
    __publicField(this, "bubbleUI", null);
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.logger = new Logger$3({
      enabled: !!this.options.debug,
      prefix: "[OmiSDK]",
      level: LogLevel.DEBUG
    });
    this.eventEmitter = new SimpleEventEmitter();
    config_url = {
      ...config_url,
      base_url: (options == null ? void 0 : options.baseUrl) || (config_url == null ? void 0 : config_url.base_url) || CONFIG_URL
    };
    this.getElId(
      options == null ? void 0 : options.remoteAudioId,
      options == null ? void 0 : options.localVideoId,
      options == null ? void 0 : options.remoteVideoId
    );
    if (options == null ? void 0 : options.forceNew) {
      store.dispatch(agent_logout());
    }
    if (options == null ? void 0 : options.requestDelegate) this.request = options.requestDelegate;
  }
  login(values) {
    return this.login_sdk(values);
  }
  loginSSO(values) {
    return this.loginSSO_sdk(values);
  }
  loginWithToken(token) {
    return this.get_info_setting(token, true);
  }
  logout() {
    return this.logout_sdk();
  }
  makeCall(phone, option) {
    return this.makeCall_sdk(phone, option);
  }
  hangup() {
    this.hangup_sdk();
    return Promise.resolve({ success: true, message: "Call hung up" });
  }
  customHangup(sessionId) {
    this.customHangup_sdk(sessionId);
  }
  answerCall(options) {
    this.answer_sdk(options);
    return Promise.resolve({ success: true, message: "Call answered" });
  }
  rejectCall() {
    this.rejectCall_sdk();
    return Promise.resolve({ success: true, message: "Call rejected" });
  }
  hold() {
    this.hold_sdk();
    return Promise.resolve({ success: true, message: "Held" });
  }
  unhold() {
    this.unhold_sdk();
    return Promise.resolve({ success: true, message: "Unheld" });
  }
  mute() {
    this.mute_sdk();
    return Promise.resolve({ success: true, message: "Muted" });
  }
  unmute() {
    this.unmute_sdk();
    return Promise.resolve({ success: true, message: "Unmuted" });
  }
  cameraOn() {
    this.cameraOn_sdk();
    return Promise.resolve({ success: true, message: "Camera on" });
  }
  cameraOff() {
    this.cameraOff_sdk();
    return Promise.resolve({ success: true, message: "Camera off" });
  }
  transfer(destination, destinationType, transferType) {
    this.transferAgent(destination, destinationType, transferType);
  }
  closeSession() {
    this.closeSession_sdk();
  }
  getCurrentStatus() {
    return this.getCurrentStatus_sdk();
  }
  changeAgentStatus(reasonCodeId) {
    return this.changeStatusAgent(reasonCodeId);
  }
  getAgentStatus() {
    return this.getListAgent();
  }
  getAgentQueues() {
    return this.getAgentQueues_sdk();
  }
  toggleAgentQueue(queueId, enable) {
    return this.putAgentQueues_sdk(queueId, enable);
  }
  hideBubble() {
    this.hideBubble_sdk();
    return Promise.resolve({ success: true, message: "Bubble hidden" });
  }
  showBubble() {
    this.showBubble_sdk();
    return Promise.resolve({ success: true, message: "Bubble shown" });
  }
  on(eventName, callback) {
    this.eventEmitter.on(eventName, callback);
  }
  off(eventName, callback) {
    this.eventEmitter.off(eventName, callback);
  }
  acceptTransfer() {
    this.acceptTransfer_sdk();
  }
  makeCallInternal(destination, extraInfo, enableVideo) {
    return this.makeCallInternal_sdk(destination, extraInfo, enableVideo);
  }
  refuseTransfer() {
    this.refuseTransfer_sdk();
  }
  getInfo() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    return {
      tenantId: ((_c = (_b = (_a = this.socket) == null ? void 0 : _a.info) == null ? void 0 : _b.tenant) == null ? void 0 : _c.id) ?? 0,
      userId: ((_f = (_e = (_d = this.socket) == null ? void 0 : _d.info) == null ? void 0 : _e.user) == null ? void 0 : _f.id) ?? 0,
      userName: ((_i = (_h = (_g = this.socket) == null ? void 0 : _g.info) == null ? void 0 : _h.user) == null ? void 0 : _i.userName) ?? "",
      fullName: ((_l = (_k = (_j = this.socket) == null ? void 0 : _j.info) == null ? void 0 : _k.user) == null ? void 0 : _l.fullName) ?? "",
      extension: ((_o = (_n = (_m = this.socket) == null ? void 0 : _m.info) == null ? void 0 : _n.user) == null ? void 0 : _o.extension) ?? ""
    };
  }
  getGroupAgents() {
    return this.getGroupAgents_sdk();
  }
  getAgentByExtension(queueExtension) {
    return this.getAgentByExtension_sdk(queueExtension);
  }
  getAgentQueuesById(queueId) {
    return this.getAgentQueuesById_sdk(queueId);
  }
  switchVideo() {
    this.updateCall_sdk();
  }
  sendBackgroundBlur(options, enable = false) {
    this.sendBackgroundBlur_sdk(options, enable);
  }
  startBackgroundBlur() {
    mediaPipe.start();
  }
  /**
   * Initializes the SDK
   * @param options SDK options
   */
  init(options) {
    if (options == null ? void 0 : options.forceNew) {
      store.dispatch(agent_logout());
    }
    config_url = {
      ...config_url,
      base_url: (options == null ? void 0 : options.baseUrl) || (config_url == null ? void 0 : config_url.base_url) || CONFIG_URL
    };
    this.getElId(
      options == null ? void 0 : options.remoteAudioId,
      options == null ? void 0 : options.localVideoId,
      options == null ? void 0 : options.remoteVideoId
    );
    if (options == null ? void 0 : options.requestDelegate) this.request = options.requestDelegate;
    if (this.initialized) {
      this.logger.warn("SDK is already initialized");
      return;
    }
    client_socket.on(EVT_EMITTER.LOGIN_CRM, (data) => {
      this.syncLoginSdk(data);
    });
    client_socket.on(EVT_EMITTER.LOGOUT_CRM, () => {
      this.clear_sdk();
    });
    client_socket.on(EVT_EMITTER.UN_REGISTER, () => {
      var _a, _b, _c;
      (_a = this.socket) == null ? void 0 : _a.disconnect_sdk();
      (_c = (_b = this.socket) == null ? void 0 : _b.socket) == null ? void 0 : _c.disconnect();
    });
    this.updateOptions(options);
    this.logger.debug("Initializing SDK with options:", this.options);
    try {
      const targetId = this.options.targetElementId || DEFAULT_OPTIONS.targetElementId;
      let targetElement = getElementById(targetId);
      if (!targetElement) {
        this.logger.debug(
          `Target element with ID "${targetId}" not found, creating it`
        );
        targetElement = createElement("div", { id: targetId });
        document.body.appendChild(targetElement);
      }
      setTimeout(() => {
      }, 1e3);
      this.container = createElement("div", {
        class: SDK_NAMESPACE,
        "data-version": SDK_VERSION,
        "data-mode": this.options.mode || DEFAULT_OPTIONS.mode
      });
      targetElement.appendChild(this.container);
      if (this.options.theme) {
        this.styleElement = applyTheme(this.options.theme, SDK_NAMESPACE);
      }
      this.initializeUI();
      this.initialized = true;
      this.logger.info("SDK initialized successfully");
      setTimeout(() => {
        var _a, _b, _c, _d;
        this.eventEmitter.emit("AppEvent", {
          name: "ready",
          type: AppEventType$1.READY,
          message: "SDK initialized successfully",
          timestamp: Date.now()
        });
        if (!(options == null ? void 0 : options.forceNew) && ((_b = (_a = store == null ? void 0 : store.getState()) == null ? void 0 : _a.auth) == null ? void 0 : _b.accessToken)) {
          this.eventEmitter.emit(Event_SDK.AppEvent, {
            type: AppEventType$1.AUTO_CONNECT,
            message: AppEventType$1.AUTO_CONNECT
          });
        } else if (!(options == null ? void 0 : options.forceNew) && !((_d = (_c = store == null ? void 0 : store.getState()) == null ? void 0 : _c.auth) == null ? void 0 : _d.accessToken)) {
          this.eventEmitter.emit(Event_SDK.AppEvent, {
            type: AppEventType$1.NOT_AUTO_CONNECT,
            message: AppEventType$1.NOT_AUTO_CONNECT
          });
        }
      }, 0);
    } catch (error) {
      this.logger.error("Failed to initialize SDK:", error);
      this.eventEmitter.emit("AppEvent", {
        name: "error",
        type: AppEventType$1.ERROR,
        message: "Failed to initialize SDK",
        error,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Destroys the SDK instance
   */
  destroy() {
    if (!this.initialized) {
      this.logger.warn("SDK is not initialized");
      return;
    }
    this.logger.debug("Destroying SDK");
    try {
      if (this.bubbleUI) {
        this.bubbleUI.destroy();
        this.bubbleUI = null;
      }
      if (this.container) {
        removeElement(this.container);
        this.container = null;
      }
      if (this.styleElement) {
        removeElement(this.styleElement);
        this.styleElement = null;
      }
      this.initialized = false;
      this.logger.info("SDK destroyed successfully");
    } catch (error) {
      this.logger.error("Failed to destroy SDK:", error);
      this.eventEmitter.emit("AppEvent", {
        name: "error",
        type: AppEventType$1.ERROR,
        message: "Failed to destroy SDK",
        error,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Updates SDK options
   * @param options New options
   */
  updateOptions(options) {
    const previousMode = this.options.mode;
    this.options = { ...this.options, ...options };
    this.logger.updateConfig({
      enabled: !!this.options.debug
    });
    this.logger.debug("Options updated:", this.options);
    if (this.initialized && this.options.theme) {
      this.styleElement = applyTheme(this.options.theme, SDK_NAMESPACE);
    }
    if (this.initialized && previousMode !== this.options.mode) {
      this.initializeUI();
    }
  }
  /**
   * Gets the SDK version
   * @returns SDK version
   */
  getVersion() {
    return SDK_VERSION;
  }
  /**
   * Gets the current SDK options
   * @returns SDK options
   */
  getOptions() {
    return { ...this.options };
  }
  /**
   * Initializes the UI based on the mode
   */
  initializeUI() {
    if (!this.container) return;
    this.container.innerHTML = "";
    if (this.bubbleUI) {
      this.bubbleUI.destroy();
      this.bubbleUI = null;
    }
    this.bubbleUI = new BubbleUI(this.container, this.options.theme);
    if (this.options.mode === "bubble") {
      const bubbleCSS = BubbleUI.getCSS();
      addStyleToDocument(bubbleCSS, `${SDK_NAMESPACE}-bubble-style`);
      this.bubbleUI.render(this.options.mode);
      this.bubbleUI.updateContent("SDK", "Connected and ready to use.");
    } else {
      this.bubbleUI.render(this.options.mode ?? "none");
      this.logger.debug("SDK initialized in headless mode");
      const existingStyle = document.getElementById(
        `${SDK_NAMESPACE}-bubble-style`
      );
      if (existingStyle && existingStyle.parentNode) {
        existingStyle.parentNode.removeChild(existingStyle);
      }
    }
  }
}
class GuestSocket {
  constructor() {
    __publicField(this, "socket_config");
    __publicField(this, "port_sip_sdk");
    __publicField(this, "base_url", "");
    __publicField(this, "data", /* @__PURE__ */ new Map());
  }
  getDataCallId(key) {
    return Number(this.data.get(key));
  }
  disconnectSwitchBoard_sdk() {
    var _a, _b;
    (_b = (_a = this.port_sip_sdk) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.stop().then((res) => {
      console.log("res", res);
    }).catch((e2) => {
      console.log("e", e2);
    });
    this.clearData();
  }
  getDataSessionId(key) {
    return String(this.data.get(key));
  }
  deleteDataKey(key) {
    if (typeof key === "string") {
      const callId = this.data.get(key);
      this.data.delete(key);
      if (callId) {
        this.data.delete(callId);
      }
    }
    if (typeof key === "number") {
      const sessionId = this.data.get(key);
      this.data.delete(key);
      if (sessionId) {
        this.data.delete(sessionId);
      }
    }
  }
  clearData() {
    this.data.clear();
  }
  connectSocket(token = "", url2 = "") {
    if (!token || !url2) {
      alertSnackbar()({
        title: "Token is missing or URL is missing",
        status: "error"
      });
      return;
    }
    this.socket_config = lookup(`${this.base_url}/`, {
      path: "/live-connect",
      reconnection: true,
      autoConnect: false,
      reconnectionDelay: 1e3,
      transports: ["websocket"],
      auth: {
        token
      },
      query: {
        env: "widget",
        type: "guest"
      }
    });
    this.socket_config.on("connect", () => {
      var _a;
      console.log("Socket connected:", (_a = this.socket_config) == null ? void 0 : _a.id);
    });
    this.socket_config.connect();
  }
  Socket_Emit(event, value2) {
    var _a;
    (_a = this.socket_config) == null ? void 0 : _a.emit(event, value2);
  }
  disconnectSocket() {
    var _a;
    (_a = this.socket_config) == null ? void 0 : _a.disconnect();
  }
  Socket_On(event, cb) {
    var _a;
    (_a = this.socket_config) == null ? void 0 : _a.on(event, (msg) => {
      cb && cb(msg);
    });
  }
}
const postGuestToken = (body) => {
  return apiConfig.callApi({
    method: ENUM_METHOD.POST,
    url: "/integration/security/guest-token",
    body
  });
};
const postExtMakeCall = (body) => {
  return apiConfig.callApi({
    method: ENUM_METHOD.POST,
    body,
    url: "/integration/extension/request"
  });
};
const postReleaseExtension = (body) => {
  return apiConfig.callApi({
    method: ENUM_METHOD.POST,
    url: "/integration/extension/release",
    body
  });
};
const postMakeCall = (body) => {
  return apiConfig.callApi({
    method: ENUM_METHOD.POST,
    url: "/integration/make-call",
    body
  });
};
class GuestSwitchBoard {
  constructor({
    server,
    ext,
    password,
    domainContext,
    appId,
    isVideo = false,
    extraInfo,
    mediaElement,
    requestDelegate,
    phone
  }) {
    __publicField(this, "port_sip_sdk");
    __publicField(this, "ext", "");
    __publicField(this, "ext_agent", "");
    __publicField(this, "data", /* @__PURE__ */ new Map());
    __publicField(this, "mediaElement");
    __publicField(this, "usingFront", false);
    __publicField(this, "count", 0);
    this.count = 0;
    this.connectSwitchboard({
      server,
      ext,
      password,
      domainContext,
      appId,
      isVideo,
      extraInfo,
      mediaElement,
      requestDelegate,
      phone
    });
  }
  async releaseExtension(ext) {
    try {
      await postReleaseExtension({ extension: ext });
    } catch (error) {
      console.log("Release extension error:", error);
    }
  }
  deleteDataKey(key) {
    if (typeof key === "string") {
      const callId = this.data.get(key);
      this.data.delete(key);
      if (callId) {
        this.data.delete(callId);
      }
    }
    if (typeof key === "number") {
      const sessionId = this.data.get(key);
      this.data.delete(key);
      if (sessionId) {
        this.data.delete(sessionId);
      }
    }
  }
  async startLocalVideo() {
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      });
      const video = document.getElementById("localVideo");
      video.srcObject = stream;
    } catch (err) {
      console.error("Không lấy được camera/mic:", err);
    }
  }
  addLog(logText) {
    const container = document.getElementById("log");
    const p2 = document.createElement("p");
    p2.textContent = JSON.stringify(logText);
    container.appendChild(p2);
  }
  randomPhone10Starting0() {
    let s2 = "0";
    for (let i2 = 1; i2 < 10; i2++) {
      s2 += Math.floor(Math.random() * 10);
    }
    return s2;
  }
  async connectSwitchboard({
    server,
    ext,
    password,
    domainContext,
    appId,
    isVideo = false,
    extraInfo,
    mediaElement,
    requestDelegate,
    phone
  }) {
    this.mediaElement = mediaElement;
    this.ext = ext;
    this.addLog(
      "Connect switchboard with ext " + ext + " - " + domainContext + " - " + server + " - " + appId + " - " + password
    );
    const sdk = new PortSipSdk(
      {
        onRegisterSuccess: () => {
          client_socket.emit(Event_SDK.AppEvent, {
            type: AppEventType$1.CONNECTED,
            message: AppEventType$1.CONNECTED
          });
          this.addLog("onRegisterSuccess");
          if (!this.count) {
            postMakeCall({
              extraInfo: JSON.stringify({
                type: isVideo ? CALL_TYPE.VIDEO : CALL_TYPE.VOICE,
                extraInfo
              }),
              destination: appId,
              extension: ext,
              phoneNumber: phone ?? this.randomPhone10Starting0()
            }).then((res) => {
              var _a;
              console.log("Open conversation success", res.data);
              (_a = requestDelegate == null ? void 0 : requestDelegate.onConnection) == null ? void 0 : _a.call(requestDelegate);
              this.count += 1;
            }).catch((error) => {
              console.log("Open conversation error", error);
            });
          }
        },
        onRegisterFailure: (reason) => {
          client_socket.emit(Event_SDK.GuestEvent, {
            type: AppEventType$1.DISCONNECTED,
            message: reason
          });
          this.releaseExtension(ext ?? "");
        },
        onConnect: () => {
        },
        onDisconnect: (reason) => {
          if (!window.navigator.onLine) {
            client_socket.emit(Event_SDK.GuestEvent, {
              type: AppEventType$1.NETWORK_ERROR,
              message: AppEventType$1.NETWORK_ERROR
            });
          } else {
            client_socket.emit(Event_SDK.GuestEvent, {
              type: AppEventType$1.DISCONNECTED,
              message: reason
            });
          }
        },
        onReconnectFailure: () => {
        },
        onInviteStart: (id, ext2, existsVideo) => {
          console.log("onInviteStart", id, ext2, existsVideo);
        },
        onInviteIncoming: (id, extension, displayname, isMeeting, existsAudio, existsVideo, autoAnswer) => {
          var _a, _b, _c, _d, _e, _f;
          const result = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(id);
          this.addLog(
            "onInviteIncoming" + id + " - " + extension + " - " + autoAnswer + " - " + existsVideo + " - " + existsAudio
          );
          if (result) {
            const sessionId = (_c = (_b = result.session) == null ? void 0 : _b.request) == null ? void 0 : _c.getHeader(
              "X-Session-Id"
            );
            const auto_call = (_e = (_d = result.session) == null ? void 0 : _d.request) == null ? void 0 : _e.getHeader(
              "Answer-Mode"
            );
            this.addLog("Answer-Mode" + sessionId + " - " + auto_call);
            this.data.set(sessionId, id);
            this.data.set(id, sessionId);
            if (auto_call === "Auto;require") {
              (_f = this.port_sip_sdk) == null ? void 0 : _f.answerCall(id, false).then(() => {
                var _a2, _b2;
                (_a2 = this.port_sip_sdk) == null ? void 0 : _a2.sendMessage(
                  JSON.stringify({
                    sessionId,
                    payload: {
                      answered: true,
                      extension: ext,
                      type: "call_state"
                    }
                  }),
                  id,
                  true
                );
                (_b2 = requestDelegate == null ? void 0 : requestDelegate.onConnectedSuccessfully) == null ? void 0 : _b2.call(requestDelegate, sessionId);
                this.addLog("Answer-Mode" + sessionId);
              }).catch((error) => {
                var _a2;
                (_a2 = requestDelegate == null ? void 0 : requestDelegate.onHangup) == null ? void 0 : _a2.call(requestDelegate, sessionId, {});
                alert(
                  "Không thể trả lời cuộc gọi tự động" + JSON.stringify(error)
                );
                this.addLog("AUTO ANSWER" + JSON.stringify(error));
              });
            }
          }
        },
        onInviteTrying: (id, existsVideo) => {
          console.log("onInviteTrying", id);
        },
        onInviteSessionProgress: (id) => {
          console.log("onInviteSessionProgress", id);
        },
        onInviteRinging: (id) => {
          console.log("onInviteRinging", id);
        },
        onInviteAnswered: (id, isMeeting, withVideo, meetingWithPin) => {
          console.log("onInviteAnswered", id);
        },
        onInviteFailure: (id, reason) => {
          console.log("onInviteFailure", id, reason);
          this.deleteDataKey(id);
          this.releaseExtension(ext ?? "");
        },
        onRecvOutOfDialogMessage: (from, message2, contentType) => {
          console.log("onRecvOutOfDialogMessage", from, message2, contentType);
        },
        onRecvNotifyOfSubscription: (id, message2) => {
          console.log("onRecvNotifyOfSubscription", id, message2);
        },
        onInviteConnected: (id, hasVideo) => {
          var _a;
          console.log("onInviteConnected", id, hasVideo);
          const session2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(id);
          if (!session2) return;
          session2.session.stateChange.addListener((state) => {
            if (state === SessionState$2.Established) {
              console.log("✅ Call established (queue answered by agent)");
            }
          });
        },
        onRecvInfo: (ext2, message2) => {
          console.log("onRecvInfo", ext2, message2);
        },
        onInviteClosed: async (id) => {
          var _a;
          const sessionId = this.getDataSessionId(id);
          this.deleteDataKey(id);
          this.releaseExtension(ext ?? "");
          this.disconnectSwitchBoard_sdk();
          console.log("onInviteClosed", id);
          (_a = requestDelegate == null ? void 0 : requestDelegate.onHangup) == null ? void 0 : _a.call(requestDelegate, sessionId, {});
          this.addLog("onInviteClosed " + sessionId + " - " + id);
        },
        onInviteUpdated: (id, existsAudio, existsVideo, existsScreen) => {
          console.log(
            "onInviteUpdated",
            id,
            existsAudio,
            existsVideo,
            existsScreen
          );
        },
        onRemoteHold: (id) => {
          const sessionId = this.getDataSessionId(id);
          this.addLog("onRemoteHold " + sessionId + " - " + id);
        },
        onRemoteUnHold: (id) => {
        },
        onTransferTrying: (id) => {
        },
        onTransferRinging: (id) => {
        },
        onACTVTransferSuccess: (id) => {
        },
        onRecvOutOfDialogNotify: () => {
        },
        onACTVTransferFailure: (id) => {
        },
        onRecvDtmfTone: (id, tone) => {
        },
        onRecvMessage: async (id, message2, contentType) => {
          var _a, _b, _c, _d, _e;
          const values = JSON.parse(message2);
          console.log("onRecvMessage", values);
          this.addLog("onRecvMessage " + message2);
          if (((_a = values == null ? void 0 : values.payload) == null ? void 0 : _a.answered) && isVideo) {
            const sessionId = this.getDataSessionId(id);
            const session2 = (_b = this.port_sip_sdk) == null ? void 0 : _b.sessions.get(id);
            if (session2) {
              session2.constraints.video = true;
            }
            try {
              if ((_c = values == null ? void 0 : values.payload) == null ? void 0 : _c.isInternal)
                await this.waitUntilStable(session2 == null ? void 0 : session2.session);
              this.addLog(
                "✅ PeerConnection is stable, upgrading to video call"
              );
              console.log(
                "✅ PeerConnection is stable, upgrading to video call"
              );
              await this.port_sip_sdk.updateCall(id, true, true);
              await ((_d = this.port_sip_sdk) == null ? void 0 : _d.sendVideo(id, true));
              this.ext_agent = values == null ? void 0 : values.extension;
              (_e = requestDelegate == null ? void 0 : requestDelegate.onAccept) == null ? void 0 : _e.call(requestDelegate, sessionId, {});
            } catch (error) {
              console.log("error enableVideo", error);
              this.addLog("error enableVideo " + JSON.stringify(error));
            }
          }
        },
        onShareAccept: (from, to) => {
        },
        onShareStopAccept: (from, to) => {
        },
        onShareStop: () => {
        },
        onRecieveShare: (id, to) => {
        },
        onRecieveStopShare: (id, to) => {
        },
        onVoiceMailReceived: (count) => {
        },
        onSendOutOfDialogMessageSuccess: (ext2, { msgServerID, msgRawString, rawStringIsJSON }) => {
          console.log("Out-of-dialog message sent", ext2, {
            msgServerID,
            msgRawString,
            rawStringIsJSON
          });
        },
        onAudioDeviceChanged: (deviceId) => {
          console.log("Audio device changed", deviceId);
        }
      },
      mediaElement
    );
    try {
      await sdk.createUserAgent(
        ext ?? "",
        password ?? "",
        domainContext ?? "",
        server,
        void 0,
        void 0,
        void 0,
        void 0,
        50
      );
      this.port_sip_sdk = sdk;
      this.addLog("Connect switchboard success");
      window.addEventListener("unload", () => {
        if (this.port_sip_sdk) {
          sdk.unRegisterServer();
          this.releaseExtension(ext ?? "");
        }
      });
      navigator.connection.addEventListener("change", () => {
        var _a, _b, _c;
        let type = navigator.connection.effectiveType;
        if (this.data.size > 0) {
          const callId = this.getSessionMain();
          const session2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(callId);
          if (session2) {
            const pc = (_c = (_b = session2.session) == null ? void 0 : _b.sessionDescriptionHandler) == null ? void 0 : _c.peerConnection;
            pc.oniceconnectionstatechange = () => {
              if (pc.iceConnectionState === "failed" || pc.iceConnectionState === "disconnected") {
                console.warn("ICE disconnected, try ICE restart");
                this.restartIce(pc, session2.session);
              }
            };
          }
        }
      });
    } catch (error) {
      console.log("erorr", error);
      this.addLog("Connect switchboard error" + JSON.stringify(error));
      this.releaseExtension(ext ?? "");
      if (!window.navigator.onLine) {
        client_socket.emit(Event_SDK.GuestEvent, {
          type: AppEventType$1.NETWORK_ERROR,
          message: AppEventType$1.NETWORK_ERROR
        });
      } else {
        client_socket.emit(Event_SDK.GuestEvent, {
          type: AppEventType$1.DISCONNECTED,
          message: error
        });
      }
    }
  }
  getLastEntry(map) {
    let last;
    for (const entry of map) {
      last = entry;
    }
    return last;
  }
  getDataCallId(key) {
    return Number(this.data.get(key));
  }
  clearData() {
    this.data.clear();
  }
  disconnectSwitchBoard_sdk() {
    var _a, _b;
    (_b = (_a = this.port_sip_sdk) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.stop().then((res) => {
      console.log("res", res);
    }).catch((e2) => {
      console.log("e", e2);
    });
    this.clearData();
    this.port_sip_sdk = void 0;
  }
  getDataSessionId(key) {
    return String(this.data.get(key));
  }
  getSessionMain() {
    const value2 = this.getLastEntry(this.data);
    const _id = value2 == null ? void 0 : value2[0];
    if (typeof _id === "string") {
      return this.getDataCallId(_id);
    } else if (typeof _id === "number") {
      return _id ?? 0;
    }
    return 0;
  }
  async hangupSDK() {
    var _a;
    try {
      const callId = this.getSessionMain();
      await ((_a = this.port_sip_sdk) == null ? void 0 : _a.hangUp(callId));
      this.releaseExtension(this.ext ?? "");
      this.disconnectSwitchBoard_sdk();
      this.deleteDataKey(callId);
      return Promise.resolve({ success: true, message: "hang up success" });
    } catch (error) {
      console.log("Hangup error:", error);
      return Promise.reject({
        success: false,
        message: "Hangup error",
        description: error
      });
    }
  }
  async muteSip(enableMute) {
    var _a;
    try {
      const callId = this.getSessionMain();
      await ((_a = this.port_sip_sdk) == null ? void 0 : _a.mute(callId, enableMute));
      return Promise.resolve({ success: true, message: "Muted" });
    } catch (error) {
      console.log("Mute error:", error);
      return Promise.reject({
        success: false,
        message: "Mute error",
        description: error
      });
    }
  }
  async holdSip() {
    var _a;
    try {
      const callId = this.getSessionMain();
      await ((_a = this.port_sip_sdk) == null ? void 0 : _a.hold(callId));
      return Promise.resolve({ success: true, message: "Holded" });
    } catch (error) {
      console.log("Hold error:", error);
      return Promise.reject({
        success: true,
        message: "Hoded",
        description: error
      });
    }
  }
  async unHoldSip() {
    var _a;
    try {
      const callId = this.getSessionMain();
      const response = await ((_a = this.port_sip_sdk) == null ? void 0 : _a.unhold(callId));
      console.log("UnHold response:", response);
      return Promise.resolve({ success: true, message: "unholded" });
    } catch (error) {
      console.log("UnHold error:", error);
      return Promise.reject({
        success: true,
        message: "Hoded",
        description: error
      });
    }
  }
  getElement(id) {
    const element = document.querySelector("#" + id);
    return element;
  }
  async sendCamera(enableVideo) {
    var _a, _b, _c, _d;
    const el = this.getElement(
      ((_a = this.mediaElement) == null ? void 0 : _a.localVideoID) ?? ""
    );
    const stream = el.srcObject;
    stream.getTracks().forEach((track) => {
      if (track.kind === "video") {
        track.enabled = enableVideo;
      }
    });
    try {
      const callId = this.getSessionMain();
      const session2 = (_b = this.port_sip_sdk) == null ? void 0 : _b.sessions.get(callId);
      if (!session2) throw new Error("session does not exti");
      const pc = (_d = (_c = session2.session) == null ? void 0 : _c.sessionDescriptionHandler) == null ? void 0 : _d.peerConnection;
      if (enableVideo) {
        session2.constraints.video = true;
        pc.getSenders().forEach((sender) => {
          var _a2;
          if (((_a2 = sender.track) == null ? void 0 : _a2.kind) === "video") {
            sender.track.enabled = enableVideo;
          }
        });
      } else {
        pc.getSenders().forEach((sender) => {
          var _a2;
          if (((_a2 = sender.track) == null ? void 0 : _a2.kind) === "video") {
            sender.track.enabled = enableVideo;
          }
        });
        session2.constraints.video = false;
      }
    } catch (error) {
      console.log("erro sendCaemera", error);
    }
  }
  async switchVideoCall() {
    var _a, _b;
    const callId = this.getSessionMain();
    try {
      const s2 = (_a = this.port_sip_sdk) == null ? void 0 : _a.sessions.get(callId);
      if (s2) {
        s2.constraints.video = true;
      }
      await ((_b = this.port_sip_sdk) == null ? void 0 : _b.updateCall(callId, true, true));
      return Promise.resolve({
        success: true,
        message: "Video switched successfully"
      });
    } catch (error) {
      console.log("error updateCall", error);
      return Promise.reject({
        success: false,
        message: "Failed to switch video",
        description: error
      });
    }
  }
  async pip() {
    var _a;
    const callId = this.getSessionMain();
    try {
      await ((_a = this.port_sip_sdk) == null ? void 0 : _a.playLocalVideoInRemoteElement(callId, true));
    } catch (error) {
      console.log("error", error);
    }
  }
  videoResolution(width = 1280, height = 720) {
    try {
      this.port_sip_sdk.setVideoResolution(width, height);
      console.log("setVideoResolution success", width, height);
    } catch (error) {
      console.log("error setVideoResolution", error);
    }
  }
  async blurBackground(enable = false) {
    var _a, _b, _c, _d;
    const callId = this.getSessionMain();
    const localVideo = document.getElementById(
      ((_a = this.mediaElement) == null ? void 0 : _a.localVideoID) ?? ""
    );
    try {
      const session2 = (_b = this.port_sip_sdk) == null ? void 0 : _b.sessions.get(callId);
      if (!session2) throw new Error("session does not exti");
      const pc = (_d = (_c = session2.session) == null ? void 0 : _c.sessionDescriptionHandler) == null ? void 0 : _d.peerConnection;
      const newTrack = localVideo.srcObject;
      session2.constraints.video = true;
      const sender = pc.getSenders().find((sender2) => {
        var _a2;
        return ((_a2 = sender2.track) == null ? void 0 : _a2.kind) === "video";
      });
      if (sender) {
        if (enable && newTrack) {
          await sender.replaceTrack(newTrack.getVideoTracks()[0]);
        } else {
          const remoteLocalStream = localVideo.srcObject;
          const originalTrack = remoteLocalStream.getVideoTracks()[0];
          await (sender == null ? void 0 : sender.replaceTrack(originalTrack));
        }
        console.log("✅ Replaced video track with blurred stream");
      }
    } catch (error) {
      console.log("error blurBackground", error);
    }
  }
  async switchCamera(facingMode2 = "user") {
    var _a, _b, _c, _d;
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter((d) => d.kind === "videoinput");
      if (videoDevices.length > 1) {
        const video = document.getElementById(
          ((_a = this.mediaElement) == null ? void 0 : _a.localVideoID) ?? ""
        );
        if (video.srcObject) {
          video.srcObject.getTracks().forEach((t2) => t2.stop());
        }
        const callId = this.getSessionMain();
        const session2 = (_b = this.port_sip_sdk) == null ? void 0 : _b.sessions.get(callId);
        if (!session2) throw new Error("session does not exist");
        const pc = (_d = (_c = session2.session) == null ? void 0 : _c.sessionDescriptionHandler) == null ? void 0 : _d.peerConnection;
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: facingMode2,
            height: { ideal: 1080 },
            width: { ideal: 1920 }
          },
          audio: true
        });
        video.srcObject = newStream;
        this.usingFront = !this.usingFront;
        const newTrack = newStream.getVideoTracks()[0];
        const sender = pc.getSenders().find((s2) => {
          var _a2;
          return ((_a2 = s2.track) == null ? void 0 : _a2.kind) === "video";
        });
        if (sender && newTrack) {
          await sender.replaceTrack(newTrack);
          return Promise.resolve({
            success: true,
            message: "switchCamera success"
          });
        }
        return Promise.resolve({
          success: true,
          message: "switchCamera success"
        });
      } else {
        throw new Error("Không có camera phụ");
      }
    } catch (error) {
      alert(`${error} error switchCamera`);
      return Promise.reject({
        success: false,
        message: "Lỗi switchCamera",
        description: error
      });
    }
  }
  async restartIce(pc, session2) {
    try {
      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);
      session2.invite({
        sessionDescriptionHandlerOptions: {
          constraints: {
            video: true,
            audio: true
          }
        },
        requestDelegate: {
          onAccept: async (response) => {
            const answer = response.message.body;
            await pc.setRemoteDescription({
              type: "answer",
              sdp: answer
            });
            console.log("ICE restart successful");
          },
          onReject: (response) => {
            console.warn("ICE restart rejected by remote:", response);
          }
        }
      });
    } catch (err) {
      console.error("ICE restart failed:", err);
    }
  }
  async waitUntilStable(session2) {
    const pc = session2.sessionDescriptionHandler.peerConnection;
    console.log("Initial signaling state:", pc.signalingState);
    return new Promise((resolve) => {
      const check = () => {
        console.log("Current signaling state:", pc.signalingState);
        if (pc.signalingState === "stable") {
          pc.removeEventListener("signalingstatechange", check);
          resolve();
        }
      };
      pc.addEventListener("signalingstatechange", check);
    });
  }
}
class GuestService extends GuestSocket {
  constructor(options) {
    super();
    __publicField(this, "instance", {
      base_url: "",
      api_key: "",
      token: ""
    });
    __publicField(this, "appId", "");
    __publicField(this, "ref_size", 0);
    __publicField(this, "mediaId", {
      localVideoID: "",
      remoteAudioID: "",
      remoteVideoID: "",
      remoteScreenID: ""
    });
    __publicField(this, "eventEmitter");
    __publicField(this, "sip");
    this.instance.base_url = options.baseUrl;
    this.instance.api_key = options.apiKey;
    this.appId = options.appId;
    this.mediaId = options.mediaIds;
    apiConfig.init({ base_url: options.baseUrl, api_key: options.apiKey });
    this.eventEmitter = new SimpleEventEmitter();
  }
  /** 
    Listener event socket
  */
  on(eventName, callback) {
    this.eventEmitter.on(eventName, callback);
  }
  off(eventName, callback) {
    this.eventEmitter.off(eventName, callback);
  }
  setBaseUrl(url2) {
    this.instance.base_url = url2;
  }
  get getBaseUrl() {
    return this.instance.base_url;
  }
  set AppId(id) {
    this.appId = id;
  }
  /**
   * Initializes the GuestService
   * @param options Service options
   */
  async init(options) {
    var _a;
    console.log("GuestService init called with options:", this.instance);
    if (!this.instance.base_url || !this.instance.api_key) {
      return Promise.reject(new Error("Base URL or API key is missing"));
    }
    if (!options.phone || !options.name) {
      return Promise.reject(new Error("Phone or name is missing"));
    }
    try {
      const response = await postGuestToken({
        phone: options.phone,
        name: options.name,
        email: (options == null ? void 0 : options.email) ?? "",
        appId: this.appId
      });
      if ((_a = response.data) == null ? void 0 : _a.data.token) {
        this.instance.token = response.data.data.token;
        this.connectSocket(response.data.data.token, this.instance.base_url);
        return Promise.resolve({
          success: true,
          message: "Guest token successfully"
        });
      } else {
        return Promise.reject(new Error("Failed to retrieve guest token"));
      }
    } catch (error) {
      return Promise.reject(new Error("Failed to fetch guest token"));
    }
  }
  /**
   * Cleans up resources used by the GuestService
   */
  destroy() {
    var _a;
    (_a = this.sip) == null ? void 0 : _a.disconnectSwitchBoard_sdk();
    this.sip = void 0;
    this.disconnectSocket();
  }
  /**
   * Gets the version of the GuestService
   * @returns {string} The version of the service
   */
  getVersion() {
    return SDK_VERSION;
  }
  /**
   *
   * @param phone
   * @param option
   * @returns {SdkResponse}
   */
  async makeCall(phone, option) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    if (!this.appId) {
      return Promise.reject({
        success: false,
        message: "AppId is not available"
      });
    }
    try {
      await navigator.permissions.query({ name: "microphone" });
      const response = await postExtMakeCall({ phone_number: phone });
      if (!((_a = response.data) == null ? void 0 : _a.data)) {
        return Promise.reject({
          success: false,
          message: "Các tổng đài viên đang bận quý khách vui lòng gọi lại sau!"
        });
      }
      this.sip = new GuestSwitchBoard({
        server: `wss://${(_c = (_b = response.data) == null ? void 0 : _b.data) == null ? void 0 : _c.sipServer}:${(_e = (_d = response.data) == null ? void 0 : _d.data) == null ? void 0 : _e.wssPort}`,
        password: ((_g = (_f = response.data) == null ? void 0 : _f.data) == null ? void 0 : _g.password) ?? "",
        ext: ((_i = (_h = response.data) == null ? void 0 : _h.data) == null ? void 0 : _i.username) ?? "",
        domainContext: ((_k = (_j = response.data) == null ? void 0 : _j.data) == null ? void 0 : _k.domain) ?? "",
        appId: this.appId,
        isVideo: (option == null ? void 0 : option.enableVideo) || false,
        extraInfo: (option == null ? void 0 : option.extraInfo) ?? "",
        mediaElement: this.mediaId,
        requestDelegate: {
          onHangup: (_l = option == null ? void 0 : option.requestDelegate) == null ? void 0 : _l.onHangup,
          onConnection: (_m = option == null ? void 0 : option.requestDelegate) == null ? void 0 : _m.onConnection,
          onConnectedSuccessfully: (_n = option == null ? void 0 : option.requestDelegate) == null ? void 0 : _n.onConnectedSuccessfully,
          onAccept: (_o = option == null ? void 0 : option.requestDelegate) == null ? void 0 : _o.onAccept
        },
        phone
      });
      return Promise.resolve({ success: true, message: "Calling" });
    } catch (error) {
      console.log("Make call error:", error);
      return Promise.reject({
        success: false,
        message: "Not permission or device mic, camera"
      });
    }
  }
  notConnected() {
    return Promise.reject({
      success: true,
      message: "Not connected"
    });
  }
  /**
   * Call control methods
   */
  hangup() {
    var _a;
    (_a = this.sip) == null ? void 0 : _a.hangupSDK();
  }
  hold() {
    var _a;
    if (!this.sip) return this.notConnected();
    return (_a = this.sip) == null ? void 0 : _a.holdSip();
  }
  unhold() {
    var _a;
    if (!this.sip) return this.notConnected();
    return (_a = this.sip) == null ? void 0 : _a.unHoldSip();
  }
  async switchVideo() {
    if (!this.sip) return this.notConnected();
    try {
      return await this.sip.switchVideoCall();
    } catch (error) {
      return Promise.reject({
        success: false,
        message: "Failed to switch video",
        description: error
      });
    }
  }
  mute() {
    var _a;
    console.log("mute clicked", this.sip);
    if (!this.sip) return this.notConnected();
    return (_a = this.sip) == null ? void 0 : _a.muteSip(true);
  }
  unmute() {
    var _a;
    if (!this.sip) return this.notConnected();
    return (_a = this.sip) == null ? void 0 : _a.muteSip(false);
  }
  cameraOn() {
    var _a;
    if (!this.sip) return;
    (_a = this.sip) == null ? void 0 : _a.sendCamera(true);
  }
  cameraOff() {
    var _a;
    if (!this.sip) return;
    (_a = this.sip) == null ? void 0 : _a.sendCamera(false);
  }
  pip() {
    var _a;
    (_a = this.sip) == null ? void 0 : _a.pip();
  }
  videoResolution(width, height) {
    var _a;
    if (!this.sip) return this.notConnected();
    (_a = this.sip) == null ? void 0 : _a.videoResolution(width, height);
  }
  blurBackground(enable = false) {
    var _a;
    if (!this.sip) return this.notConnected();
    (_a = this.sip) == null ? void 0 : _a.blurBackground(enable);
  }
  switchCamera(facingMode2) {
    var _a;
    if (!this.sip) return this.notConnected();
    return (_a = this.sip) == null ? void 0 : _a.switchCamera(facingMode2);
  }
  resetRegistration() {
    var _a, _b;
    if (!this.sip) return this.notConnected();
    (_b = (_a = this.sip) == null ? void 0 : _a.port_sip_sdk) == null ? void 0 : _b.refreshRegistration().then(() => {
      console.log("refreshRegistration success");
    }).catch((error) => {
      console.log("refreshRegistration error", error);
    });
  }
  /**
   *
   * handle user
   *
   */
  arrayBufferToBase64(buffer, type) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    bytes.forEach((byte) => {
      binary += String.fromCharCode(byte);
    });
    return `data:${type};base64,${window.btoa(binary)}`;
  }
  upLoadFile(files) {
    let fileList = [];
    if (!this.instance.base_url || !this.instance.api_key) {
      return Promise.reject(new Error("Base URL or API key is missing"));
    }
    if (!this.appId) {
      return Promise.reject(new Error("AppID is missing"));
    }
    Array.from(files).forEach((v, i2) => {
      let reader = new FileReader();
      this.ref_size += v.size;
      if (calculatorSizeFile(v.size, {}) >= 5 || calculatorSizeFile(this.ref_size, {}) >= 15) {
        this.ref_size -= v.size;
        return;
      }
      reader.readAsArrayBuffer(v);
      const outerThis = this;
      reader.onloadend = function() {
        if (reader.result instanceof ArrayBuffer) {
          const buffer = reader.result;
          const base64 = outerThis.arrayBufferToBase64(buffer, v.type);
          fileList.push({
            id: i2,
            buffer: reader.result,
            originalname: v.name,
            fileName: v.name,
            type: get_key_file(v.name),
            url: base64,
            size: (v == null ? void 0 : v.size) ?? 0
          });
        }
      };
    });
  }
}
class OmiGuestSDK extends GuestService {
}
const sdkInstance = new OmiSDK();
document.addEventListener("DOMContentLoaded", () => {
  const scriptTag = document.querySelector("script[data-auto-init]");
  if (scriptTag) {
    const options = {};
    const targetElementId = scriptTag.getAttribute("data-target-element-id");
    if (targetElementId) {
      options.targetElementId = targetElementId;
    }
    const mode = scriptTag.getAttribute("data-mode");
    if (mode && (mode === "none" || mode === "bubble")) {
      options.mode = mode;
    }
    const baseUrl = scriptTag.getAttribute("data-base-url");
    if (baseUrl) {
      options.baseUrl = baseUrl;
    }
    const debug = scriptTag.getAttribute("data-debug") === "true";
    if (debug) {
      options.debug = debug;
    }
    sdkInstance.init(options);
  }
});
export {
  OmiGuestSDK,
  OmiSDK,
  sdkInstance as default
};
//# sourceMappingURL=omisdk.es.js.map
